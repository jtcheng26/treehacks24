[
    {
        "query": "Could you create a 3D animated video using ManimCE where a cylinder appears and then fades out, followed by a drawing of a 3D coordinate system, and finally my name \"Kiron\" appears above the coordinate system? The camera should give us an angled aerial view of the scene. The appearance of the cylinder should take 3 seconds.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Find the area under x^2 from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integrating the function\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3} x^3\\right]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for solving the integral\n        explanation2 = Text(\"Plug in the upper and lower limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing the evaluation of the bounds\n        evaluation_step = MathTex(r\"= \\frac{1}{3} (3^3) - \\frac{1}{3} (1^3)\")\n        self.play(ReplacementTransform(integration_step, evaluation_step))\n        self.wait(1)\n\n        # Convert into numbers\n        final_solution = MathTex(r\"= \\frac{1}{3} (27) - \\frac{1}{3} (1)\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(evaluation_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and present the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video where two names, \"Kiron\" and \"Tisha,\" appear on screen in different locations, with Kiron at the top left and Tisha at the bottom right. Could you make an arrow appear that points from Kiron to Tisha? After the arrow appears, I want all the elements to enlarge together, and then Tisha's name to move up closer to Kiron's, with the arrow adjusting accordingly to continue pointing from one to the other. I'd like the animation to look smooth and for these events to take place over a comfortable duration of time, with some pauses in between so that viewers can follow along.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.flip\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(triangle.animate.flip())\n            self.remove(triangle)"
    },
    {
        "query": "Could you create a simple animation that starts with a calming multi-colored gradient background, then displays the text \"Hello Kiron.\" in blue and makes the text stand out or be highlighted somehow?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        curve_graph = self.get_graph()\n        area = self.get_area_under_curve(curve_graph)\n\n        # Show curve and shaded area as area under the curve\n        self.play(Create(curve_graph), Create(area))\n        self.wait(2)\n\n        # Show the label of the curve\n        label = self.get_curve_label(curve_graph)\n        self.play(Write(label))\n        self.wait(2)\n\n        # Explain the area under the curve\n        explanation = Text(\"Area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene and show just the explanation\n        self.clear()\n        self.play(Write(explanation))\n        self.wait(2)\n\n    def get_graph(self):\n        return FunctionGraph(lambda x: x**2, color=BLUE, x_range=[0,2])\n\n    def get_area_under_curve(self, graph):\n        return area := graph.get_riemann_rectangles(x_range=[0,2], dx=0.1, stroke_width=0.1)\n\n    def get_curve_label(self, graph):\n        return MathTex(\"y = x^2\").next_to(graph, UP + RIGHT)"
    },
    {
        "query": "Could you create an animated bar chart that has 5 bars with the following heights: two negative values at -5 and -10, and three positive values at 40, 20, and -3? Please include the labels \"one\", \"two\", \"three\", \"four\", and \"five\" for each respective bar. Can you also set the vertical range of the chart to go from -20 to 50, with markers every 10 units, and make the chart's height 6 units and width 10 units on the screen? Lastly, could you increase the size of the labels on the x-axis to 36 and the labels on the bars to 48 for better readability?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi/2} \\int_{0}^{1} r dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}\\theta]_{0}^{\\pi/2}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Display final answer\n        answer = MathTex(r\"= \\frac{\\pi}{4}\")\n        self.play(Transform(final_solution, answer))\n        self.wait(2)"
    },
    {
        "query": "I'd like to see an animated video where two geometric shapes are presented on the screen: an isosceles triangle and a unique polygon composed of a square with two triangles on adjacent sides. The isosceles triangle is located on the left side and the polygon on the right side. Both shapes should be stationary and simply displayed in the scene. Can you also start creating a circle but not add it to the scene?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} \\left[\\frac{1}{2}xyz^2\\right]_{0}^{3} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{9}{2}xy^2\\right]_{0}^{2} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n        \n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{9}{2}x^2\\right]_{0}^{1}\", r\"= \\frac{9}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation where a colored array appears on the screen with names listed. Each name should be inside its own box, and each box should have an index number starting from 2 and increasing by 1 for each subsequent box. The indices should be positioned to the right of each box. I need the animation to slowly build up this array on-screen, taking about 8 seconds to fully display. Can you create such an animation for me, including the names \"Kiron\", \"Nirob\", and \"Israt\"? The boxes should be distinctly colored from the text and the indices.",
        "answer": "\\n from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        rows, cols = 5, 5\n        grid = VGroup()\n        for i in range(rows):\n            row = VGroup()\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom = carbon() if (j % 3 == 0) else oxygen()\n                else:\n                    atom = metal() if (i % 3 == 0) else electron()\n                atom.shift(RIGHT * j + UP * i)\n                row.add(atom)\n            grid.add(row)\n        grid.center()\n\n        self.play(FadeIn(grid))\n        self.wait(2)\n\n        electron_particle = electron()\n        self.play(FadeIn(electron_particle))\n\n        path = VMobject()\n        path_points = [\n            UP * 2 + LEFT * 2, UP * 2, UP * 2 + RIGHT * 2, RIGHT * 2,\n            DOWN * 2 + RIGHT * 2, DOWN * 2, DOWN * 2 + LEFT * 2, LEFT * 2, ORIGIN\n        ]\n        path.set_points_as_corners(path_points)\n\n        self.play(MoveAlongPath(electron_particle, path, run_time=5, rate_func=linear))\n\n        self.wait(2)\n        self.play(FadeOut(grid), FadeOut(electron_particle))"
    },
    {
        "query": "I want to create a series of educational animations for my presentation that display various graphical elements with dynamic effects. Can you show:\n\n1. A custom-styled text box that appears with a transitioning effect, perhaps like a box being drawn and then filled, and make sure the box looks like it's dynamically updating itself.\n\n2. A simple animation of an apple SVG image that grows into the scene, then shrinks after a moment, on a white background.\n\n3. An engaging introduction of three technology logos \u2013 React, Angular, and Vue \u2013 that grow into the scene one by one with a subtle sound effect accompanying their appearance, and then have the Angular and Vue logos fade out, leaving the React logo which then moves, enlarges, and gets highlighted.\n\n4. A quotation about REST APIs displayed on-screen followed by the author\u2019s name, with the text and author appearing in sequence, and then have both elements disappear from the screen after a short pause. \n\nCould you design these animations for me using a tool that would allow me to include them in my video presentation?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Displaying the area problem\n        area_problem = MathTex(r\"\\int_1^3 f(x) \\,dx\")\n        self.play(Transform(function, area_problem))\n        self.wait(1)\n\n        # Graphing the function\n        axes = Axes(x_range=[0, 4], y_range=[0, 10], axis_config={\"color\": BLUE})\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(1,3), color=[BLUE, GREEN], opacity=0.3)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        self.play(Create(axes), Create(graph), FadeIn(area), Write(graph_label))\n        self.wait(2)\n\n        # Showing the calculation\n        calculation = MathTex(r\"= \\left[ \\frac{1}{3}x^3 \\right]_1^3\")\n        self.play(Transform(area_problem, calculation))\n        self.wait(1)\n\n        # Showing the evaluation at bounds\n        evaluation = MathTex(r\"= \\frac{1}{3}\\left(3^3\\right) - \\frac{1}{3}\\left(1^3\\right)\", r\"= \\frac{1}{3}(27 - 1)\", r\"= \\frac{1}{3}(26)\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(calculation, evaluation))\n        self.wait(2)\n\n        # Clear the scene and highlight the result\n        self.clear()\n        result = MathTex(r\"\\text{Area} = \\frac{26}{3}\")\n        self.play(Write(result))\n        self.wait(2)"
    },
    {
        "query": "I would like an animation that demonstrates the physics of gravity. Can you create a scene with a red circle and a yellow square falling towards the ground, with the square starting above the circle? Both the circle and square should fall from different heights and collide with the ground, but not pass through it. Also, please include visible walls on the sides of the screen to give the effect of a contained space. The square should initially be positioned at an angle. Both objects need to fall and land realistically, obeying the laws of physics, as if they were rigid bodies. The animation should last long enough for me to observe the motion of the objects as they fall and settle after hitting the ground.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r \\, dr \\, d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now, integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}\\theta]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Simplified solution\n        simplified_solution = MathTex(r\"= \\frac{\\pi}{2}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(2)"
    },
    {
        "query": "\"Can you create an educational animation video that starts with the sound of a VHS tape starting up, followed by the dynamic appearance of a teal to green gradient background? After the background appears, I'd like a short pause and then an introduction where a voiceover explains the number pi, showing the symbol for pi and text saying 'PI, which is an interesting irrational constant' below the symbol. Have the symbol and text appear on-screen along with the voiceover. Then, after the explanation, can you show the numerical value of pi appearing in a dramatic way while the background fades out and the voiceover mentions that pi has a 'robust value'? Make sure to end the animation with a period of stillness before it finishes.\"",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Set up axes\n        axes = Axes(\n            x_range=[0, 4],\n            y_range=[0, 4],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Define and draw the curve y = x^2\n        curve = axes.plot(lambda x: x**2, color=GREEN)\n        curve_label = axes.get_graph_label(curve, label='y = x^2')\n        self.play(Create(axes), Create(curve), Write(curve_label))\n        self.wait(1)\n\n        # Shade the area under the curve y = x^2 between x = 1 and x = 3\n        shaded_area = axes.get_riemann_rectangles(curve, x_range=[1, 3], dx=0.05, color=BLUE, fill_opacity=0.5)\n        self.play(Create(shaded_area))\n        self.wait(2)\n\n        # Display the area value\n        area_text = MathTex(r\"A = \\int_1^3 x^2 dx = \\left.\\frac{x^3}{3}\\right|_1^3 = \\frac{26}{3}\")\n        area_text.next_to(shaded_area, DOWN)\n        self.play(Write(area_text))\n        self.wait(2)\n\n        # Clear the scene and show only the final area value\n        self.play(FadeOut(axes), FadeOut(curve), FadeOut(curve_label), FadeOut(shaded_area))\n        self.play(area_text.animate.move_to(ORIGIN))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video showing a sequence of shapes transforming into one another. The shapes should be regular polygons starting with a decagon (10-sided polygon) in blue, then transforming into a hendecagon (11-sided polygon) in yellow, followed by a dodecagon (12-sided polygon) in white. After this sequence, I would like to show a separate polycontagon (30-sided polygon) in green, positioned to the right of the dodecagon. The transformation should be clear and well animated, resulting in a visually appealing educational math video. Could you generate an animation using a tool that could make the elements appear one after the other, with the first three polygons arranged side by side with some space between them, and then clear the screen to introduce the final green polycontagon?",
        "answer": "\\n from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sqrt{1 - x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for trigonometric substitution\n        explanation1 = Text(\n            \"Use trigonometric substitution: \",\n            font_size=24\n        ).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Choosing substitution\n        substitution = MathTex(r\"x = \\sin(\\theta), \\quad dx = \\cos(\\theta)d\\theta\")\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Rewriting the integral\n        rewritten_integral = MathTex(r\"= \\int \\sqrt{1 - \\sin^2(\\theta)} \\cos(\\theta) d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), rewritten_integral))\n        self.wait(1)\n\n        # Simplifying the integral\n        simplified_integral = MathTex(r\"= \\int \\cos^2(\\theta) d\\theta\")\n        self.play(ReplacementTransform(rewritten_integral, simplified_integral))\n        self.wait(1)\n\n        # Explanation for solving the integral\n        explanation2 = Text(\n            \"Solve the integral using a trigonometric identity\",\n            font_size=24\n        ).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Using the identity for cos^2(theta)\n        identity_substitution = MathTex(r\"= \\frac{1}{2} \\int (1 + \\cos(2\\theta)) d\\theta\")\n        self.play(ReplacementTransform(simplified_integral, identity_substitution))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{\\theta}{2} + \\frac{\\sin(2\\theta)}{4} + C\")\n        self.play(ReplacementTransform(identity_substitution, final_solution))\n        self.wait(1)\n\n        # Rewriting theta in terms of x\n        back_substitution = MathTex(r\"x = \\sin(\\theta) \\Rightarrow \\theta = \\arcsin(x)\")\n        final_solution_with_x = MathTex(r\"= \\frac{\\arcsin(x)}{2} + \\frac{\\sin(2\\arcsin(x))}{4} + C\")\n        self.play(Write(back_substitution))\n        self.wait(1)\n        self.play(ReplacementTransform(final_solution, final_solution_with_x))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution_with_x))\n        self.wait(1)"
    },
    {
        "query": "I'd like to see an animation where a dot moves in a straight line from the center of the screen to the upper left corner and then straight down. As it moves, I want a label above the dot that displays a number which increments by one every frame. The label should always be positioned right above the moving dot. Can you create this using a simple animation tool?",
        "answer": "\\n from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create objects\n        co_ = self.create_co_molecule()\n        h2o = self.create_h2o_molecule()\n\n        # Position objects on the screen\n        co_.to_edge(LEFT, buff=1)\n        h2o.to_edge(RIGHT, buff=1)\n\n        # Display the molecules\n        self.play(FadeIn(co_), FadeIn(h2o))\n        self.wait(2)\n\n        # Animate movements and interactions\n        self.play(co_.animate.shift(RIGHT * 2), h2o.animate.shift(LEFT * 2))\n        self.wait(1)\n\n        # Create a reaction product\n        product = self.create_reaction_product()\n        product.move_to(ORIGIN)\n\n        # Transform molecules into the reaction product\n        self.play(Transform(VGroup(co_, h2o), product))\n        self.wait(2)\n\n    def create_co_molecule(self) -> Mobject:\n        c = Circle(radius=0.3, color=GRAY, fill_opacity=1).set_fill(GRAY)\n        c_text = Tex(r\"C\", color=WHITE).scale(0.7)\n        o = Circle(radius=0.35, color=BLUE_E, fill_opacity=1).set_fill(BLUE_E)\n        o_text = Tex(r\"O\", color=WHITE).scale(0.8)\n        o.shift(RIGHT * 0.7)\n        o_text.move_to(o.get_center())\n\n        co_molecule = VGroup(c, c_text, o, o_text)\n        return co_molecule\n\n    def create_h2o_molecule(self) -> Mobject:\n        o = Circle(radius=0.35, color=BLUE_E, fill_opacity=1).set_fill(BLUE_E)\n        o_text = Tex(r\"O\", color=WHITE).scale(0.8)\n        h_left = Circle(radius=0.2, color=WHITE, fill_opacity=1).set_fill(WHITE)\n        h_left_text = Tex(r\"H\", color=BLACK).scale(0.5)\n        h_left.shift(LEFT * 0.5 + UP * 0.3)\n        h_left_text.move_to(h_left.get_center())\n\n        h_right = Circle(radius=0.2, color=WHITE, fill_opacity=1).set_fill(WHITE)\n        h_right_text = Tex(r\"H\", color=BLACK).scale(0.5)\n        h_right.shift(RIGHT * 0.5 + UP * 0.3)\n        h_right_text.move_to(h_right.get_center())\n\n        h2o_molecule = VGroup(o, o_text, h_left, h_left_text, h_right, h_right_text)\n        return h2o_molecule\n\n    def create_reaction_product(self) -> Mobject:\n        h2co3 = Tex(r\"H$_2$CO$_3$\")\n        return h2co3"
    },
    {
        "query": "I would like to create an educational math animation that explains the concept of Fourier Series with voiceover using a simple and elegantly animated whiteboard style presentation. The animation should start by stating \"We know that the basic trigonometric series is...\", followed by the appearance of the corresponding mathematical equation. Then, it should explain that this becomes a Fourier Series when specific terms are substituted with particular integral expressions, and it should display these integrals clearly.\n\nThe important elements of the animation include:\n- High-quality text and equations that are clear and easy to read.\n- The use of engaging voiceover with a natural English accent, preferable male, that fluidly narrates the information as it appears on screen.\n- The voiceover should have a style that resembles a casual but authoritative newscasting tone.\n- Smooth transitions should be present as different parts of the equations appear.\n- At the end of each section of explanation, the corresponding text and mathematical expressions should appropriately scale and move to make room for the next part of the lesson.\n- The term \"Fourier Series\" should be highlighted when it is described.\n- The function f(x), as it is introduced, should be emphasized as a single-valided function defined in the interval \\(-\\pi, \\pi\\).\n- The animation should end with a \"Thank you for watching.\" message the voiceover narrates, and should be accompanied by an animation that interacts with the last shown expression or piece of text.\n\nAlso, I want a concluding gesture that signals the end of the presentation. The animation should be clear and engaging, aiming to make the concept of Fourier Series understandable for students with at least some pre-calculus knowledge. Can you do this using a math animation tool like ManimCE?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r e^{r\\theta} dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[e^{r\\theta}\\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left(e^{\\theta} - 1\\right) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for evaluating at bounds\n        explanation3 = Text(\"Evaluate the integral at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[e^{\\theta} - \\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral.copy(), final_solution))\n        self.wait(1)\n\n        # Display final answer\n        final_answer = MathTex(r\"= e^{\\pi} - \\pi - 1\")\n        self.play(Transform(final_solution, final_answer))\n        self.wait(2)"
    },
    {
        "query": "Could you create a simple animation where a square rotates to align with its corners on the x and y axes, then morphs into a circle over the course of 5 seconds, and finally fades away from the screen?",
        "answer": "\\n from manim import *\n\nclass Hydrogen(Mobject):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.circle = Circle(radius=0.2, color=WHITE)\n        self.text = Tex(\"H\", color=BLACK, font_size=36)\n        self.add(self.circle, self.text)\n\n\nclass WaterScene(Scene):\n    def construct(self):\n        oxygen = Circle(radius=0.3, color=BLUE)\n        oxygen_text = Tex(r\"O\", color=WHITE, font_size=36)\n        oxygen_group = VGroup(oxygen, oxygen_text)\n\n        hydrogen1 = Hydrogen()\n        hydrogen1.shift(UP + LEFT)\n\n        hydrogen2 = Hydrogen()\n        hydrogen2.shift(UP + RIGHT)\n\n        molecule = VGroup(oxygen_group, hydrogen1, hydrogen2)\n\n        self.play(FadeIn(molecule))\n        self.wait(1)\n\n        self.play(molecule.animate.scale(2))\n        self.wait(1)\n\n        self.play(molecule.animate.scale(0.5))\n        self.wait(1)\n\n        self.play(FadeOut(molecule))"
    },
    {
        "query": "Can you create a simple animation where a text changes from \"Create\" to \"Uncreate\" while moving upwards, and simultaneously show a star appearing and then disappearing?",
        "answer": "\\n from manim import *\n\nclass PythagoreanProof(Scene):\n    def construct(self):\n        # Display the statement of the theorem\n        theorem = MathTex(\"a^2 + b^2 = c^2\")\n        self.play(Write(theorem))\n        self.wait(2)\n\n        # Show a right-angled triangle\n        triangle = Triangle().scale(2)\n        triangle.to_edge(DOWN)\n        self.play(Create(triangle))\n        self.wait(1)\n\n        # Annotate the sides of the triangle\n        a_label = MathTex(\"a\").next_to(triangle, LEFT, buff=0.1)\n        b_label = MathTex(\"b\").next_to(triangle, RIGHT, buff=0.1)\n        c_label = MathTex(\"c\").next_to(triangle, UP, buff=0.2)\n        \n        self.play(Write(a_label), Write(b_label), Write(c_label))\n        self.wait(1)\n\n        # Show squares of each side\n        square_a = Square().scale(0.5).next_to(triangle, LEFT, buff=0).align_to(triangle, DOWN)\n        square_b = Square().scale(0.5).next_to(triangle, RIGHT, buff=0).align_to(triangle, DOWN)\n        square_c = Square().scale(0.5).move_to(triangle.get_top())\n\n        self.play(Create(square_a), Create(square_b), Create(square_c))\n        self.wait(2)\n\n        # Show that the area of the square on the hypotenuse equals the area of the other two squares combined\n        area_equation = MathTex(\"c^2\", \"=\", \"a^2\", \"+\", \"b^2\").to_edge(UP)\n        self.play(Transform(c_label.copy(), area_equation[0]),\n                  Transform(a_label.copy(), area_equation[2]),\n                  Transform(b_label.copy(), area_equation[4]))\n        self.wait(1)\n\n        # Highlight the areas\n        self.play(c_label.animate.set_color(YELLOW), \n                  a_label.animate.set_color(RED),\n                  b_label.animate.set_color(GREEN))\n        self.wait(1)\n\n        self.play(Indicate(square_c), Indicate(square_a), Indicate(square_b))\n        self.wait(1)\n\n        # Conclude by restating the theorem\n        conclusion = Text(\"Pythagorean theorem demonstrated\", font_size=36).to_edge(UP)\n        self.play(Transform(area_equation, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation where a piece of text transforms into the words \"AnimatedBoundary\" and moves towards the top of the screen, followed by a circle appearing with a colorful boundary that cycles through red, green, and blue colors quickly, and then both the circle and its animated boundary disappear after a short display?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        problem = MathTex(r\"\\int_{0}^{2} x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Integral limits explanation\n        limits_explanation = Text(\"We evaluate from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(limits_explanation))\n        self.wait(2)\n\n        # Explain the integration rule\n        rule_explanation = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} \\Bigg|_a^b\")\n        self.play(Write(rule_explanation))\n        self.wait(2)\n\n        # Applying the integration rule to the problem\n        integral_step = MathTex(r\"= \\frac{x^{3+1}}{3+1} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integral_step))\n        self.wait(1)\n\n        # Showing the simplification\n        simplification = Text(\"Simplify the power expression\", font_size=24).to_edge(UP)\n        self.play(Transform(limits_explanation, simplification))\n        self.wait(2)\n\n        # Simplified expression\n        simplified_expr = MathTex(r\"= \\frac{x^4}{4} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(integral_step, simplified_expr))\n        self.wait(1)\n\n        # Evaluating the definite integral at the boundaries\n        evaluation = Text(\"Evaluate at the boundaries\", font_size=24).to_edge(UP)\n        self.play(Transform(limits_explanation, evaluation))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left. \\frac{x^4}{4} \\right|_0^2\")\n        final_solution_next = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        final_solution_final = MathTex(r\"= \\frac{16}{4} - 0\")\n        final_answer = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(simplified_expr, final_solution))\n        self.wait(1)\n        self.play(Transform(final_solution, final_solution_next))\n        self.wait(1)\n        self.play(Transform(final_solution, final_solution_final))\n        self.wait(1)\n        self.play(Transform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final answer\n        final_answer_static = final_answer.copy().to_edge(UP)\n        self.play(Write(final_answer_static))\n        self.wait(1)"
    },
    {
        "query": "Can you create a short animation where a text label morphs into a different label and moves upward, followed by a red dot tracing a path by moving up, then left, and finally diagonally down and right, before both the dot and its path disappear?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2}xyz^2]_{0}^{2} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy(2^2 - 0^2)]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} 2x \\,dx\", r\"= [x^2]_{0}^{1}\", r\"= 1\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation where a piece of text appears at the top of the screen and changes to say \"AddTextLetterByLetter\" over a short time, followed by another piece of text that appears letter by letter in the center of the screen? After that, can you change the text at the top to read \"RemoveTextLetterByLetter\" and then make the central text disappear one letter at a time?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass NeuralNetworkScene(Scene):\n    \"\"\"Test Scene for the Neural Network\"\"\"\n\n    def construct(self):\n        # Make the Layer object\n        layers = [FeedForwardLayer(3), FeedForwardLayer(5), FeedForwardLayer(3)]\n        nn = NeuralNetwork(layers)\n        nn.scale(2)\n        nn.move_to(ORIGIN)\n        # Make Animation\n        self.add(nn)\n        # self.play(Create(nn))\n        forward_propagation_animation = nn.make_forward_pass_animation(\n            run_time=5, passing_flash=True\n        )\n\n        self.play(forward_propagation_animation)"
    },
    {
        "query": "I would like to create an animation using Python where a word at the center of the screen transforms into the word \"Write\" and moves to the top of the screen quickly. Then, I want another piece of text that says \"Here is more text\" to appear as if it's being written out normally. Afterwards, the \"Write\" text should change to \"Unwrite\" and move back to the top. Following that, I want the \"Here is more text\" to appear as if it's being erased from the screen. Lastly, once the text is gone, I want it to be removed from the scene entirely. Can you create a script to do this, preferably with each step having a smooth animation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_height\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().scale(2)\n            square = Square()\n            self.add(circle,square)\n            self.play(square.animate.match_height(circle))\n            self.remove(square,circle)"
    },
    {
        "query": "How can I create an animation sequence where first a text transforms into another text that reads \"DrawBorderThenFill\" and moves upward, followed by a square that's drawn on-screen by first animating its border in blue, then filling it in yellow, finally all of these disappearing after being displayed briefly?",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass WhyPrime(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        numbers = VGroup(\n            Tex(\"2 \u00e9 primo\", color=LIGHT_RED_COLOR),\n            Tex(\"3 \u00e9 primo\", color=LIGHT_RED_COLOR),\n            Tex(\"4 = 2 x 2\", color=LIGHT_BLUE_COLOR),\n            Tex(\"5 \u00e9 primo\", color=LIGHT_RED_COLOR),\n            Tex(\"6 = 2 x 3\", color=LIGHT_BLUE_COLOR),\n            Tex(\"7 \u00e9 primo\", color=LIGHT_RED_COLOR),\n            Tex(\"8 = 2 x 2 x 2\", color=LIGHT_BLUE_COLOR),\n            Tex(\"9 = 3 x 3\", color=LIGHT_BLUE_COLOR),\n            Tex(\"10 = 2 x 5\", color=LIGHT_BLUE_COLOR),\n            Tex(\"11 \u00e9 primo\", color=LIGHT_RED_COLOR)\n        )\n        numbers.scale(1.5)\n        numbers.arrange(DOWN, buff=0.7)\n\n        self.play(Write(numbers), run_time=3)\n        self.wait(2)\n        self.play(Unwrite(numbers, reverse=False))"
    },
    {
        "query": "I want to create an animation where a piece of text transforms into the words \"ShowSubmobjectsOneByOne\" and moves to the top of the screen. After that transformation, I'd like to sequentially display three circles: one at the top center, and the other two placed diagonally below it to the left and right respectively. Once all the circles are displayed, they should all disappear at once. Can you describe how this animation would be created step-by-step or provide a script to produce it?",
        "answer": "\\n from manim import *\n\nclass PythagoreanTheoremScene(Scene):\n    def construct(self):\n        # Define a right triangle\n        right_triangle = Polygon(ORIGIN, 2*RIGHT, 2*RIGHT+3*UP)\n        squares = VGroup()\n        # Square for the hypotenuse\n        squares.add(Square(side_length=5).move_to(right_triangle.get_corner(UR)+0.5*UL+0.5*LEFT))\n        # Square for the vertical side\n        squares.add(Square(side_length=3).move_to(right_triangle.get_corner(DR)+1.5*LEFT+0.5*DOWN))\n        # Square for the horizontal side\n        squares.add(Square(side_length=2).move_to(right_triangle.get_corner(UR)+1*RIGHT+0.5*UP))\n\n        # Draw right triangle and squares\n        self.play(Create(right_triangle))\n        self.play(Create(squares))\n        self.wait(1)\n\n        # Label lengths of sides of the triangle and squares\n        triangle_leg_a = Tex(\"a\").move_to(2*RIGHT+1.5*UP)\n        triangle_leg_b = Tex(\"b\").move_to(1*RIGHT+3*UP)\n        hypotenuse_label = Tex(\"c\").move_to(3.5*RIGHT+1.5*UP)\n\n        square_label_a = Tex(\"a^2\").move_to(right_triangle.get_corner(DR)+1.5*LEFT+1.5*DOWN)\n        square_label_b = Tex(\"b^2\").move_to(right_triangle.get_corner(UR)+1*RIGHT+2.5*UP)\n        square_label_c= Tex(\"c^2\").move_to(right_triangle.get_corner(UR)+2.5*LEFT+1*UP)\n\n        # Play the side labels animation\n        self.play(Write(triangle_leg_a), Write(triangle_leg_b), Write(hypotenuse_label))\n        self.play(Write(square_label_a), Write(square_label_b), Write(square_label_c))\n        self.wait(2)\n\n        # Display Pythagorean theorem equation\n        theorem_text = Tex(\"a^2 + b^2 = c^2\").to_edge(DOWN)\n        self.play(Write(theorem_text))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(right_triangle), FadeOut(squares), FadeOut(triangle_leg_a), FadeOut(triangle_leg_b), FadeOut(hypotenuse_label), FadeOut(square_label_a), FadeOut(square_label_b), FadeOut(square_label_c), FadeOut(theorem_text))\n        self.wait(1)"
    },
    {
        "query": "Can you create a simple animation where text appears on the screen saying \"FadeIn\", followed by a square that fades in, then the text changes to \"FadeOut\" before the square fades out and finally is removed from the screen? The text should also move upwards slightly and the transformations should happen quickly, with each action taking half a second.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the definite integral problem\n        problem = MathTex(r\"\\int_{0}^{2} x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(2)\n\n        # Explanation for the integration rule\n        explanation = Text(\"Calculate the definite integral using limits:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(3)\n\n        # Performing the integration step\n        integral_step = MathTex(r\"= \\left[ \\frac{x^{3+1}}{3+1} \\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integral_step))\n        self.wait(2)\n\n        # Showing the limits substituted\n        limits_substituted = MathTex(r\"= \\left[ \\frac{x^4}{4} \\right]_{0}^{2}\")\n        self.play(ReplacementTransform(integral_step, limits_substituted))\n        self.wait(2)\n\n        # Evaluating at upper and lower limits\n        evaluation = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(limits_substituted, evaluation))\n        self.wait(2)\n\n        # Showing the final answer\n        final_answer = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluation, final_answer))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(explanation), FadeOut(final_answer))\n        self.wait(1)\n\n        # Final scene showing the result\n        result = Text(\"Integral result is 4.\", font_size=36)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)"
    },
    {
        "query": "How can I create a brief animation where text transforms into the word \"GrowArrow\" and shifts upwards, followed by an arrow that appears as if it's growing and then suddenly disappears?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the function and the area to be shaded\n        function = lambda x: 0.1 * x**2\n        area = 4  # Area from x = 0 to x = 4\n\n        # Display the function graph\n        graph = FunctionGraph(function, x_range=[-1, 5])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Show the area under the curve\n        shaded_area = area_between_curves(\n            graph,\n            x_range=[0, area],\n            fill_opacity=0.3,\n            fill_color=BLUE\n        )\n        self.play(FadeIn(shaded_area))\n        self.wait(2)\n\n        # Present the calculation of the area\n        calculation = MathTex(r\"A = \\int_0^4 0.1x^2 \\,dx\")\n        self.play(Write(calculation))\n        self.wait(2)\n\n        # Display the result of the integration\n        result = MathTex(r\"A = \\left[ \\frac{0.1x^3}{3} \\right]_0^4\")\n        self.play(ReplacementTransform(calculation, result))\n        self.wait(2)\n\n        # Result simplification\n        final_result = MathTex(r\"A = \\frac{64}{30} - 0\")\n        self.play(ReplacementTransform(result, final_result))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(graph), FadeOut(shaded_area), FadeOut(final_result))\n        self.wait(1)"
    },
    {
        "query": "How do I animate a text changing to another text that says \"GrowFromCenter\" and moving it upwards, followed by a triangle appearing as if it's growing from the center and then have the triangle disappear in Manim?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} \\Bigg|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{4} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Evaluate the integral from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Simplified solution\n        solution2 = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, solution2))\n        self.wait(1)\n\n        # Calculate the final result\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(solution2, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        conclusion = Text(\"The area under the curve is 4\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where a piece of text initially appears and then transforms to say \"GrowFromEdge - DOWN\" and moves upwards on the screen. Following the text change, a square should appear from the bottom edge of the screen, as if it is growing upwards from that edge. Next, the text changes again to read \"GrowFromEdge - RIGHT\" and maintains its elevated position. Afterward, another square should materialize from the right edge, appearing to expand from there. The process continues with the text changing to \"GrowFromEdge - UP\" and a new square appearing from the top edge, and concludes with \"GrowFromEdge - LEFT\" and the final square growing into view from the left edge. At the end of the sequence, all squares should disappear from the screen. Each text transformation and square growth should happen quickly, in half a second. Can you animate this sequence for me?",
        "answer": "\\n class UpdaterAndAnimation(Scene):\n    def construct(self):\n        red_dot = Dot(color=RED).shift(LEFT)\n        rotating_square = Square()\n        rotating_square.add_updater(lambda mob, dt: mob.rotate(dt*PI))\n        \n        def shifter(mob, dt): # make dot move 2 units RIGHT/sec\n            mob.shift(2*dt*RIGHT)\n        red_dot.add_updater(shifter)\n        \n        self.add(red_dot, rotating_square)\n        self.wait(1)\n        red_dot.suspend_updating()\n        self.wait(1)\n        self.play(\n            red_dot.animate.shift(UP),\n            rotating_square.animate.move_to([-2, -2, 0])\n        )\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation where a text element first transforms into the words \"GrowFromPoint\" and moves upwards on the screen, then a dot appears in the upper right area, followed by a star that appears to grow from the exact position of that dot, after which both the dot and the star disappear? The entire sequence should be quick and dynamic.",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^\\pi \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of the definite integral\n        explanation1 = Text(\"Evaluate the definite integral of sine from 0 to \u03c0\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^\\pi\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for the antiderivative of sine\n        explanation2 = Text(\"Antiderivative of sine is -cosine\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the antiderivative at bounds\n        evaluation_step = MathTex(r\"= -\\cos(\\pi) - (-\\cos(0))\")\n        self.play(ReplacementTransform(integration_step, evaluation_step))\n        self.wait(1)\n\n        # Explanation for evaluating the bounds\n        explanation3 = Text(\"Evaluate -cosine at \u03c0 and 0\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(evaluation_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an animation where text appears to spin in from nothing and moves upwards, followed by a triangle that also spins in from nothing and then disappears. Can this be done in a way that the text change happens quickly, say in half a second?",
        "answer": "\\n from manim import *\n\nclass FallingObjects(Scene):\n    def construct(self):\n        balls = VGroup(*[Circle(radius=0.2, color=random_color()) for _ in range(5)])\n        balls.arrange(RIGHT, buff=0.5)\n        balls.move_to(UP * 2)\n        \n        floor = Line(LEFT, RIGHT).scale(2).next_to(DOWN * 2, DOWN)\n        \n        self.add(balls, floor)\n        for ball in balls:\n            self.play(FallDown(ball, floor))\n        \n        self.wait(10)"
    },
    {
        "query": "How can I create a two-part animation sequence where the first part quickly transforms a piece of text to display \"ApplyWave\" and then shifts it upwards, and the second part introduces new text saying \"Mathematical Animations\" that experiences a wave-like animation from the bottom to the top and then a second wave from left to right, with the text disappearing at the end?",
        "answer": "\\n from manim import *\n\nclass ParametricCurveExample(Scene):\n    def construct(self):\n        # Title for the scene\n        title = Text(\"Parametric Curve Representation\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Moving the title to the top of the frame\n        self.play(ApplyMethod(title.to_edge, UP))\n        self.wait(1)\n\n        # Parametric Curve equation\n        curve_eq = MathTex(r\"\\vec{r}(t) = \\begin{bmatrix} \\cos(t) \\\\ \\sin(t) \\\\ t \\end{bmatrix}\", font_size=36)\n        self.play(Write(curve_eq))\n        self.wait(2)\n\n        # Explanation for parametric curves\n        explanation = Text(\"This represents a 3D helix\", font_size=24).next_to(curve_eq, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Plot the parametric curve\n        curve = ParametricFunction(\n            lambda t: np.array([np.cos(t), np.sin(t), t]),\n            t_range = np.array([0, 2*PI]),\n            color = BLUE\n        )\n        self.play(Create(curve))\n        self.wait(2)\n\n        # Axes for the curve\n        axes = ThreeDAxes()\n        self.play(Create(axes))\n        self.wait(1)\n\n        # Transform the 2D curve Eq to 3D\n        self.play(Transform(curve_eq, curve_eq.copy().set_z(1)))\n        self.wait(1)\n\n        # Rotate to show 3D\n        self.move_camera(phi=65 * DEGREES, theta=-45 * DEGREES)\n        self.wait(2)\n\n        # Clear the scene and show only the 3D plot\n        self.clear()\n        self.play(Create(axes), Create(curve))\n        self.wait(2)\n\n        # Conclude the animation\n        self.play(FadeOut(curve), FadeOut(axes))\n        self.wait(1)"
    },
    {
        "query": "How can I create an animation where text changes to the word \"Circumscribe\" and moves upwards, followed by new text appearing saying \"Look Here\" which then gets highlighted with animation, first with the default shape and then with a circle, and finally have the text disappear?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and area we're integrating over\n        func_graph = FunctionGraph(lambda x: 0.1*x**2, x_range=[-3, 3])\n        area = Integral(func_graph, x_range=[-3, 0], color=YELLOW)\n        self.play(Create(func_graph))\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Show the integral formula\n        integral = MathTex(r\"\\int_{-3}^{0} 0.1x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Explanation of the antiderivative\n        explanation1 = Text(\"Find the antiderivative\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the antiderivative\n        antiderivative = MathTex(r\"F(x) = \\frac{0.1}{3}x^3\")\n        self.play(Transform(integral, antiderivative))\n        self.wait(2)\n\n        # Explanation of the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(1)\n\n        # Evaluating the integral\n        integral_value = MathTex(r\"F(0) - F(-3)\")\n        self.play(ReplacementTransform(antiderivative, integral_value))\n        self.wait(1)\n\n        # Calculate the actual area\n        area_solution = MathTex(r\"= 0 - \\left(-\\frac{0.1}{3}(-3)^3\\right)\")\n        self.play(ReplacementTransform(integral_value, area_solution))\n        self.wait(2)\n\n        # Simplify the solution\n        simplified_solution = MathTex(r\"= 0.9\")\n        self.play(Transform(area_solution, simplified_solution))\n        self.wait(2)\n\n        # Clear the scene and show the simplified solution\n        self.clear()\n        self.play(Write(simplified_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create a short animation where a piece of text saying \"Flash\" quickly moves upwards and then, in the same position, another text that says \"Ta Da\" appears in yellow, flashes brightly, and then disappears?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import NeuralNetworkMobject\n\n\nclass NeuralNetworkMobjectScene(Scene):\n    \"\"\"Scene for demonstrating a Neural Network Mobject\"\"\"\n\n    def construct(self):\n        # Define the number of neurons in each layer\n        layers_sizes = [4, 7, 4, 2]\n\n        # Create the Neural network object\n        neural_network = NeuralNetworkMobject(layers_sizes)\n        neural_network.scale(1.5)\n        neural_network.to_edge(UP)\n\n        # Add neural network to the scene\n        self.add(neural_network)\n\n        # Animate the neural network with forward propagation\n        self.play(neural_network.forward_propagate())\n\n        # Show the initial state and the propagation\n        self.wait(2)"
    },
    {
        "query": "I would like to have an educational animation that showcases a wide variety of mathematical and geometrical objects along with text and tables, first displaying each of them in 2D with their names and then showcasing some in 3D while rotating the camera to give a more immersive experience. Can the animation start with a slide showing the title \"Manim Objects\" and then proceed to individually introduce each object with a corresponding label fade in, and after showing all 2D objects, move on to 3D objects with a transitional text saying \"Looking at 3D Mobjects...\"? Also, could it have a smooth transition between objects and a fade out at the end?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, Neuron\nfrom manim_ml.neural_network.layers import RecurrentLayer, FeedForwardLayer\n\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 8.0\nconfig.frame_width = 14.0\n\nclass RNNVisualization(Scene):\n    def construct(self):\n        neurons_per_layer = [6, 8, 4]\n        layers = []\n        for i, num_neurons in enumerate(neurons_per_layer):\n            if i == 1:  # adding a RecurrentLayer\n                layers.append(RecurrentLayer(num_neurons, radius=0.15))\n            else:\n                layers.append(FeedForwardLayer(num_neurons))\n        rnn = NeuralNetwork(layers, layer_spacing=0.5)\n        \n        rnn.to_edge(LEFT, buff=1)\n        \n        # Decorate neurons with a specific color\n        for neuron in rnn.layers[1].neurons:\n            neuron.set_color(RED)\n            neuron.set_fill(BLUE, opacity=0.5)\n        \n        # Create an RNN label\n        rnn_title = Text(\"Recurrent Neural Network\", font_size=36)\n        rnn_title.to_edge(UP)\n\n        # Adding arrow annotations\n        for layer in rnn.layers:\n            if isinstance(layer, RecurrentLayer):\n                input_arrow = Arrow(ORIGIN, LEFT)\n                input_arrow.next_to(layer.neurons[0], LEFT)\n                output_arrow = Arrow(ORIGIN, RIGHT)\n                output_arrow.next_to(layer.neurons[-1], RIGHT)\n                self.add(input_arrow, output_arrow)\n\n        # Play the scene\n        self.play(FadeIn(rnn_title))\n        self.play(DrawBorderThenFill(rnn))\n        self.wait(2)\n\n        # Animate signal through network\n        self.play(rnn.make_forward_pass_animation(), run_time=3)\n        self.wait(1)"
    },
    {
        "query": "I would like to create a simple animation where a translucent blue circle appears on the screen, and shortly after, a slightly more opaque green square appears next to it on the right. Can you create an animation like this and describe how it would be realized step by step?",
        "answer": "\\n from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef positive() -> Mobject:\n    return circle_with_text(0.25, \"+\", RED_A, 32, BLACK, 4, RED_A)\n\n\ndef negative() -> Mobject:\n    return circle_with_text(0.25, \"-\", BLUE_A, 32, BLACK, 4, BLUE_A)"
    },
    {
        "query": "Could you create an educational animation that visually demonstrates the area under a curve from -2 to 0 for the cubic function f(x) = (x+2)x(x-2)/2 on a simple x-y axis graph, with the function curve colored red and the area shaded, using a tool that can help me explain math concepts in my videos?",
        "answer": "\\n from manim import *\n\nclass AnimatedBoundaryExample(Scene):\n    def construct(self):\n        square = Square()\n        animated_boundary = AnimatedBoundary(square, colors=[PURPLE, TEAL, YELLOW], cycle_rate=2)\n        self.add(square, animated_boundary)\n        self.play(ScaleInPlace(square, 1.5), run_time=2)\n        self.wait(1)\n        self.play(Rotate(square, PI/2), run_time=2)\n        self.wait(1)\n        self.remove(animated_boundary) # Remove only boundary to freeze on last color\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation using a Python-based library that graphically demonstrates the following mathematical concepts? I would like a two-dimensional graph with axes ranging from -3 to 3 on both the x and y-axes. On this graph, please plot the cubic function f(x) = (x+2)x(x-2)/2 where x is between -3 and 3, and have the function's line shown in red. Afterward, I'd like to highlight the area under the curve between x = -2 and x = 0. The axes should appear first, and then the curve should be drawn gradually. Once the curve is fully drawn, the area under the curve should fade into view. Please ensure that the entire animation is smooth and has a reasonable duration for each step to enhance the educational value.",
        "answer": "\\n from manim import *\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3], y_range=[-4, 4])\n        curve = axes.plot(lambda x: x**3 - 3*x, color=GREEN)\n        line = axes.plot(lambda x: 3*x - 3, color=RED)\n        dot = Dot(color=ORANGE).move_to(axes.c2p(1, -2))\n\n        tangent = always_redraw(lambda: TangentLine(curve, alpha=dot.get_center()[0], length=4, color=ORANGE))\n        \n        self.play(Create(axes), Create(curve))\n        self.play(Create(line))\n        self.add(dot, tangent)\n        self.play(MoveAlongPath(dot, curve), run_time=4, rate_func=linear)\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an animation where a green square appears on the screen by first drawing its border and then filling in its color. Once the square is visible, it should transform into a blue circle. After the transformation, I want the blue circle to be highlighted or indicated in some way. Lastly, the blue circle should fade away, leaving a blank screen. Can you design this animation sequence for me, keeping the color intensity of the shapes semi-transparent?",
        "answer": "\\n from manim import *\n\nclass PieChartScene(Scene):\n    def construct(self):\n        pie_chart = PieChart(\n            values=[30, 45, 25],\n            colors=[RED, GREEN, BLUE],\n            radius=2,\n            labels=[\"Red\", \"Green\", \"Blue\"],\n            pie_slice_colors=[RED, GREEN, BLUE],\n            start_angle=90,\n            slice_spacing=0.02\n        )\n\n        percentages = pie_chart.get_percentages()\n\n        for percent, label in zip(percentages, pie_chart.labels):\n            label.next_to(percent, UP)\n\n        self.add(pie_chart)\n        self.play(\n            AnimationGroup(\n                *[Write(label) for label in pie_chart.labels],\n                lag_ratio=0.5\n            )\n        )"
    },
    {
        "query": "I would like to create an educational animation to help visualize complex exponential functions, particularly focusing on the function z = e^(t\u03c0i) where t ranges from 0 to 2. Can you depict a helix in a 3D space that represents this, along with the function's equation displayed nearby? Additionally, I'd like the animation to extend the helix by continuing the pattern as if t were to range from 2 to 4, and update the displayed equation accordingly to reflect the new range of t. Lastly, I want several different views and angles of the 3D curve to be shown during the animation to enhance the understanding of its 3-dimensional structure, and then have everything fade out at the end. Can you make this animation engaging with smooth transitions and camera movements?",
        "answer": "\\n from manim import *\n\nclass DefiniteIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2} x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        definite_integral_rule = MathTex(r\"\\int_{a}^{b} x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_{a}^{b}\")\n        self.play(Write(definite_integral_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left. \\frac{x^{3+1}}{4} \\right|_{0}^{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Evaluation of the definite integral\n        explanation2 = Text(\"Evaluate at the bounds 0 and 2:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left. \\frac{x^4}{4} \\right|_{0}^{2} = \\frac{2^4}{4} - \\frac{0^4}{4} = 4\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that illustrates several positioning techniques on a 2D plane. Firstly, can you show a red dot and then place a green dot to its upper right side? Next, I would like to see an orange square slide up and rightward into a specific position on the plane. After that, can we have a purple circle that moves directly to a chosen location, somewhere towards the bottom left of the plane? Finally, let's introduce three semi-transparent circles\u2014one red, one yellow, and one orange\u2014and have each one line up with the orange square in a different way: the red one aligns to its top, the yellow one to its right side, and the orange one to its top right corner. For the background, I would love to see all of this happening on a grid, like a mathematical coordinate plane.",
        "answer": "\\n from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\ndef electron() -> Mobject:\n    return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)"
    },
    {
        "query": "Could you create an educational animation using basic shapes where a green semi-transparent circle is placed at the center of the screen, and then small crosses appear at the center and along the circle at cardinal directions and diagonals? After that, can you add a semi-transparent red square to the right of the circle, with its left edge lined up with the circle's right edge?",
        "answer": "\\n from manim import *\n\nclass SimpleGenerator(Scene):\n    def construct(self):\n        # Create base parts of the generator\n        base_circle = Circle(radius=1.5, color=GREY_B).set_fill(GREY_A, 1)\n        coils = VGroup(*[\n            Arc(radius=1.5, angle=PI / 2, start_angle=PI / 2 * i, color=BLUE)\n            for i in range(4)\n        ]).set_z_index(1)\n\n        # Create the armature\n        armature = VGroup(\n            Line(ORIGIN, UP * 1.5, color=RED),\n            Line(ORIGIN, DOWN * 1.5, color=RED)\n        ).set_z_index(2)\n\n        # Combine into a single VGroup for the generator\n        generator = VGroup(base_circle, coils, armature)\n\n        # Generate labels and arrows for \"Magnetic Field\" and \"Current\"\n        magnetic_field_text = Text(\"Magnetic Field\", color=BLUE).shift(LEFT * 3.5)\n        magnetic_field_arrow = Arrow(\n            magnetic_field_text.get_right(), coils[0].get_center(),\n            color=BLUE, buff=0.2\n        )\n\n        current_text = Text(\"Current\", color=RED).shift(RIGHT * 3.5 + DOWN * 0.5)\n        current_arrow = Arrow(\n            current_text.get_left(), armature.get_top(),\n            color=RED, buff=0.2\n        )\n\n        # Set the background color, add all objects to the scene\n        self.camera.background_color = WHITE\n        self.add(generator, magnetic_field_text, magnetic_field_arrow, current_text, current_arrow)"
    },
    {
        "query": "Can you create an animation where a sequence of circles and squares of varying sizes are displayed, increasing in size incrementally, with the circles' radii and the squares' side lengths based on a percentage of the screen width and height respectively? Also, can you place a dot that is offset from the center by a fixed number of screen pixels to the right? For the circles, start at 5% of the screen width and increase by 5% increments up to 50% of the screen width. For the squares, use double the percentage value for each side length compared to the circles, and color them yellow. The dot should be 100 pixels to the right of the center.",
        "answer": "\\n from manim import *\n\nclass CosineSquaredIntegrationExample(Scene):\n    def construct(self):\n        # Display the integration problem\n        problem = MathTex(r\"\\int \\cos^2(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Using a trigonometric identity for cosine squared\n        explanation1 = Text(\"Use power-reduction formula\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Power-reduction identity step\n        trig_step = MathTex(r\"\\int \\frac{1 + \\cos(2x)}{2} \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), trig_step))\n        self.wait(1)\n\n        # Explanation for integral of sum\n        explanation2 = Text(\"Integrate term-by-term\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution after integration\n        final_solution = MathTex(r\"= \\frac{x}{2} + \\frac{1}{4}\\sin(2x) + C\")\n        self.play(ReplacementTransform(trig_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and display the final solution only\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation where three differently colored dots, red, green, and blue, are grouped together and aligned to the right edge of the screen? Furthermore, I'd like a vertical line of ten small circles and a grid of twenty yellow stars arranged in four rows and five columns. The circles and stars should not be animated; they just need to be placed in their respective patterns on the screen.",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\ndef Pizza():\n    return VGroup(\n        Circle(1.3, color=\"#f7a139\", fill_opacity=1),\n        Circle(1.1, color=\"#e63838\", fill_opacity=1),\n        Circle(1, color=\"#ffd52c\", fill_opacity=1),\n        Pepperonni().shift(0.25 * UP),\n        Pepperonni().shift(0.16 * DOWN + 0.25 * RIGHT),\n        Pepperonni().shift(0.16 * DOWN + 0.25 * LEFT),\n        Pepperonni().shift(0.55 * UP + 0.55 * RIGHT),\n        Pepperonni().shift(0.55 * DOWN + 0.55 * RIGHT),\n        Pepperonni().shift(0.55 * UP + 0.55 * LEFT),\n        Pepperonni().shift(0.55 * DOWN + 0.55 * LEFT),\n        Pepperonni().shift(0.75 * UP),\n        Pepperonni().shift(0.75 * RIGHT),\n        Pepperonni().shift(0.75 * DOWN),\n        Pepperonni().shift(0.75 * LEFT),\n    )\n        \ndef Pepperonni():\n    return VGroup(\n        Circle(0.18, color=\"#d73d3d\", fill_opacity=1),\n        Circle(0.02, color=\"#f05454\", fill_opacity=1).shift(0.07 * (UP + LEFT)),\n        Circle(0.02, color=\"#f05454\", fill_opacity=1).shift(0.07 * (UP + RIGHT)),\n        Circle(0.03, color=\"#f05454\", fill_opacity=1).shift(0.07 * (DOWN))\n    )\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass PizzaFractions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        pizzas = VGroup(\n            Pizza(),\n            VGroup(\n                Pizza(),\n                AnnularSector(1.4, 0, PI, 1.5 * PI, color=BACKGROUND_COLOR),\n                DashedVMobject(Arc(1.3, 1.5 * PI, PI, color=DARK_RED_COLOR)),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR), 10)\n            ),\n            VGroup(\n                Pizza(),\n                AnnularSector(1.4, 0, PI / 2, 0, color=BACKGROUND_COLOR),\n                DashedVMobject(Arc(1.3, 0, PI / 2, color=DARK_RED_COLOR), 7),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR), 10),\n                DashedVMobject(Line(1.3 * RIGHT, 1.3 * LEFT, color=DARK_RED_COLOR), 10)\n            ),\n            VGroup(\n                Pizza(),\n                AnnularSector(1.4, 0, PI, 11/6 * PI, color=BACKGROUND_COLOR),\n                DashedVMobject(Arc(1.3, 11/6 * PI, PI, color=DARK_RED_COLOR)),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR), 10),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR)\n                    .rotate(2 * PI / 6), 10),\n                DashedVMobject(Line(1.3 * UP, 1.3 * DOWN, color=DARK_RED_COLOR)\n                    .rotate(4 * PI / 6), 10)\n            ),\n            VGroup(\n                Pizza(),\n                AnnularSector(1.4, 0, 6 * PI / 7, 17/14 * PI, color=BACKGROUND_COLOR),\n                DashedVMobject(Arc(1.3, 17/14 * PI, 6 * PI / 7, color=DARK_RED_COLOR)),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(2 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(4 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(6 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(8 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(10 * PI / 7, about_point=ORIGIN),\n                DashedVMobject(Line(ORIGIN, 1.3 * DOWN, color=DARK_RED_COLOR), 5)\n                    .rotate(12 * PI / 7, about_point=ORIGIN),\n            )\n        )\n        pizzas.scale(0.9)\n        pizzas.arrange(DOWN)\n\n        self.play(\n            LaggedStart(\n                *[SpinInFromNothing(pizza) for pizza in pizzas], \n                lag_ratio=0.2,\n                run_time=1.8\n            )\n        )\n        self.play(pizzas.animate.shift(LEFT), run_time=0.5)\n\n        arrows = []\n\n        for i in range(5):\n            arrows.append(Arrow(pizzas[i].get_right(), pizzas[i].get_right() + 1.5 * RIGHT, color=LIGHT_PURPLE_COLOR))\n\n        text1 = MathTex(\"1\", color=BLACK)\n        text1.next_to(arrows[0], RIGHT)\n        text2 = MathTex(r\"\\frac{1}{2}\", color=BLACK)\n        text2.next_to(arrows[1], RIGHT)\n        text3 = MathTex(r\"\\frac{3}{4}\", color=BLACK)\n        text3.next_to(arrows[2], RIGHT)\n        text4 = MathTex(r\"\\frac{3}{6}\", color=BLACK)\n        text4.next_to(arrows[3], RIGHT)\n        text5 = MathTex(r\"\\frac{4}{7}\", color=BLACK)\n        text5.next_to(arrows[4], RIGHT)\n        texts = [text1, text2, text3, text4, text5]\n\n        for i in range(5):\n            self.play(\n                DrawBorderThenFill(arrows[i]), \n                Write(texts[i]), \n                run_time=0.7\n            )\n\n        self.wait(1)\n        self.play(\n            *[pizza.animate.scale(0) for pizza in pizzas if pizza != pizzas[2]],\n            *[FadeOut(arrow) for arrow in arrows if arrow != arrows[2]],\n            *[FadeOut(text) for text in texts if text != texts[2]],\n            run_time=0.8\n        )\n        self.play(\n            Group(pizzas[2], arrows[2]).animate.rotate(-PI / 2).shift(0.2 * RIGHT + UP),\n            texts[2].animate.shift(2 * LEFT + 2 * DOWN),\n            run_time=0.8\n        )\n\n        arrow_num = Arrow(text3[0][0].get_left(), text3[0][0].get_left() + LEFT, color=LIGHT_RED_COLOR)\n        arrow_den = Arrow(text3[0][2].get_right(), text3[0][2].get_right() + RIGHT, color=GREEN_COLOR)\n        text_num = Tex(\"Numerador\", color=LIGHT_RED_COLOR)\n        text_num.next_to(arrow_num, LEFT)\n        text_den = Tex(\"Denominador\", color=GREEN_COLOR)\n        text_den.next_to(arrow_den, RIGHT)\n\n        self.play(\n            DrawBorderThenFill(arrow_num), \n            Write(text_num), \n            text3[0][0].animate.set_color(LIGHT_RED_COLOR)\n        )\n        self.play(\n            DrawBorderThenFill(arrow_den), \n            Write(text_den), \n            text3[0][2].animate.set_color(GREEN_COLOR)\n        )\n        self.wait(1)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Can you create an educational animation featuring five pentagons with different hues, placed side by side, that first appear by drawing their borders and then filling with color? After they appear, can each pentagon rotate around its center, with each one using a different animation speed or pattern to showcase various rotation effects?",
        "answer": "\\n from manim import *\n\nclass GrowFromPointExample(Scene):\n    def construct(self):\n        text = Text(\"GrowFromPoint - Example\")\n        self.add(text)\n\n        # First square growing from a point at the bottom\n        square1 = Square()\n        self.play(GrowFromPoint(square1, point=DOWN*3))\n\n        # Update text and show second square growing from a specific point\n        self.play(Transform(text, Text(\"Next square grows from a point\").shift(UP*2.5)))\n        square2 = Square()\n        specific_point = RIGHT*3 + UP*2\n        self.play(GrowFromPoint(square2, point=specific_point))\n\n        # Cleanup\n        self.remove(square1, square2)"
    },
    {
        "query": "I would like to create an animation where a square is rotating both clockwise and counterclockwise at the same time for a duration of three seconds. How can I do this?",
        "answer": "\\n from manim import *\n\nclass WavePath(VGroup):\n    def __init__(self, wave_freq, amplitude, start_point, end_point, color=BLUE):\n        super().__init__()\n        \n        self.wave_freq = wave_freq\n        self.amplitude = amplitude\n        self.start_point = start_point\n        self.end_point = end_point\n        self.color = color\n\n        self.path = VMobject(color=self.color)\n        self.path.set_points_as_corners([self.start_point, self.start_point])\n\n        self.add(self.path)\n        self.time = 0\n\n    def update_wave(self, dt):\n        self.time += dt\n        prev_point = self.path.points[-1]\n        new_point = prev_point + RIGHT * dt\n        new_point[1] = self.amplitude * np.sin(self.wave_freq * self.time) + self.start_point[1]\n        \n        if new_point[0] > self.end_point[0]:\n            self.path.set_points_as_corners([*self.path.points, self.end_point])\n            self.path.clear_updaters()\n        else:\n            self.path.set_points_as_corners([*self.path.points, new_point])\n\n    def start_wave(self):\n        self.path.add_updater(self.update_wave)\n\n\nclass WaveScene(Scene):\n    def construct(self):\n        start_point = LEFT * 4\n        end_point = RIGHT * 4\n        wave = WavePath(\n            wave_freq=2 * PI,\n            amplitude=1,\n            start_point=start_point,\n            end_point=end_point\n        )\n        self.add(wave)\n        wave.start_wave()\n\n        self.play(ShowCreation(wave.path), run_time=4)\n        self.wait()"
    },
    {
        "query": "Can you create an animation with a group of 20 colored squares arranged in a grid where each square fades in one after another with a slight delay between them, each square having a unique shade on the color spectrum?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Create plot and area\n        axes = Axes(x_range=[0, 5], y_range=[0, 10], axis_config={\"color\": BLUE})\n        f = lambda x: x**2\n        graph = axes.plot(f, color=WHITE)\n        area = axes.get_area(graph, x_range=[0, 2], color=[BLUE, GREEN])\n\n        # Labels for the curve and shaded area\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n        area_label = Tex(\"Area under curve\\\\nfrom x=0 to x=2\").next_to(area, RIGHT, buff=0.5)\n\n        # Animation\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n        self.play(FadeIn(graph_label), Write(area_label))\n        self.wait(1)\n        self.play(Create(area))\n        self.wait(2)\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(graph_label), FadeOut(area), FadeOut(area_label))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an animation where a green square and a red circle appear on the screen with a semi-transparent fill. The square should move upwards while the circle moves downwards simultaneously. After that, they should rearrange themselves to sit side by side. Finally, I want the circle to move to the right and double in size, with the motion happening at a constant speed, before the animation comes to a rest. Can you help me create this animation?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"=\\left. \\frac{x^{3+1}}{3+1} \\right|_0^1\")\n        self.play(Transform(problem, integration_step))\n        self.wait(2)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate at bounds\n        evaluate_at_bounds = MathTex(r\"=\\left. \\frac{x^4}{4} \\right|_0^1 = \\frac{1^4}{4} - \\frac{0^4}{4}\")\n        self.play(Transform(problem, evaluate_at_bounds))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{4}\")\n        self.play(Transform(problem, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution on screen\n        self.play(FadeIn(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation where two squares are side by side with a small gap between them. They should then simultaneously rotate 180 degrees over a period of 2 seconds. Can you create this using an animation software?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Displaying the speed of wave propagation\n        speed_of_wave = Text(\"Here, \\(c\\) represents the speed of wave propagation.\", font_size=24)\n        self.play(Transform(explanation1, speed_of_wave))\n        self.wait(2)\n\n        # D'Alembert's Solution to the wave equation\n        dalembert_solution = MathTex(r\"u(x, t) = f(x-ct) + g(x+ct)\")\n        self.play(ReplacementTransform(wave_eq, dalembert_solution))\n        self.wait(2)\n\n        # Conclusion text\n        conclusion = Text(\"D'Alembert's solution uses two arbitrary functions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Restate D'Alembert's Solution\n        self.play(Write(dalembert_solution))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animation using a Python-based animation library where a green translucent circle moves up and to the right, shrinks to half its size, and then a purple translucent square fades into the scene, enlarges three times its original size, moves to the left, drops down off screen, and finally rotates 45 degrees clockwise. After that, I want the square to return to its original state seamlessly. Can you provide me with the code to create this animation?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2\\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Mentioning type of PDE\n        type_pde = Text(\"This is the wave equation, a second-order linear PDE.\", font_size=24).to_edge(UP)\n        self.play(Write(type_pde))\n        self.wait(2)\n\n        # Explaining the term c\n        speed_of_wave = Text(\"Here, c represents the speed of the wave.\", font_size=24).next_to(type_pde, DOWN)\n        self.play(Write(speed_of_wave))\n        self.wait(2)\n\n        # General solution format\n        format_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(equation, format_solution))\n        self.wait(2)\n\n        # Mentioning general solution characteristics\n        characteristics = Text(\"f and g represent arbitrary functions determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(type_pde, characteristics))\n        self.wait(2)\n\n        # Clearing the explanation\n        self.play(FadeOut(speed_of_wave), FadeOut(characteristics))\n        self.wait(1)\n\n        # Displaying general solution again, with initial condition\n        initial_condition = Text(\"u(x, 0) = \\phi(x)\", font_size=24)\n        self.play(Write(initial_condition))\n        self.wait(1)\n        self.play(Write(format_solution))\n        self.wait(2)\n\n        # Wrapping up the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"This is a brief overview of the wave equation.\", font_size=24)))\n        self.wait(3)"
    },
    {
        "query": "I would like to create an animation where a dot starts at the center of the screen and spirals outward while changing colors and becoming more transparent as it moves away from the center over a period of three seconds. Can the color change reflect the progression of the spiral motion, and can the dot fully fade away by the time it reaches the end of the spiral?",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using a trigonometric identity\n        identity_explanation = Text(\"Use the trigonometric identity: \"\n                            \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(identity_explanation))\n        self.wait(2)\n\n        # Applying the identity\n        identity_application = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(Write(identity_application))\n        self.wait(2)\n\n        # Integrating using the identity\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Clear the scene and highlight the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
    },
    {
        "query": "Can you create a custom animation where a large yellow star appears in the center of the screen, stays still for a moment, and then disperses into a lot of small dots that fly away from the original position, giving the illusion that the star is breaking apart into tiny pieces? The star should fade out as the dots fade in, and I'd like the dots to eventually fade out too as they move further away. If possible, I would like the transition to happen smoothly over a duration of 4 seconds and have around 200 dots involved in the dispersal effect.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function to integrate\n        problem = MathTex(r\"\\int_1^3 \\sqrt{x}\\,dx\")\n        self.play(Write(problem))\n        self.wait(2)\n\n        # Set up the axes\n        axes = Axes(\n            x_range=[0, 4],\n            y_range=[0, 2],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Plot the function\n        graph = axes.plot(lambda x: np.sqrt(x), color=WHITE)\n        labels = axes.get_axis_labels()\n\n        # Highlight area under curve\n        area = axes.get_area(graph, x_range=(1, 3), color=[BLUE, GREEN], opacity=0.3)\n\n        # Display graph\n        self.play(Create(axes), Create(labels))\n        self.play(Write(graph))\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(2)\n\n        # Integral solution setup\n        solution_setup = MathTex(r\"=[\\frac{2}{3}x^{3/2}]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), solution_setup))\n        self.wait(2)\n\n        # Calculate final answer\n        final_answer = MathTex(r\"=\\frac{2}{3}(3^{3/2}) - \\frac{2}{3}(1^{3/2})\", \"=\", \"2\\sqrt{3}-\\frac{2}{3}\")\n        self.play(ReplacementTransform(solution_setup, final_answer))\n        self.wait(2)\n\n        # Clear the scene for the final answer\n        self.clear()\n        self.play(Write(final_answer))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animation where a blue dot is on the screen with the text \"Hello dot!\" appearing above it. The text should always be positioned above the dot even when the dot moves. First, I want the dot to move to the right. After that, I want the dot to become 10 times larger. Finally, I'd like the dot to move to the bottom left corner of the screen. Can you show me how to create this animation?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import NeuralNetwork\nfrom manim_ml.neural_network.layers import Convolutional2DLayer, FlattenLayer, FeedForwardLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Create a neural network architecture\n        neural_network = NeuralNetwork(\n            layers=[\n                Convolutional2DLayer(num_feature_maps=8, feature_map_size=4),\n                Convolutional2DLayer(num_feature_maps=16, feature_map_size=2),\n                FlattenLayer(),\n                FeedForwardLayer(128),\n                FeedForwardLayer(64),\n                FeedForwardLayer(10),\n            ],\n            layer_spacing=0.3,\n            neural_network_position=UP\n        )\n\n        # Add the neural network to the scene\n        self.add(neural_network)\n\n        # Animate the neural network layers\n        self.play(*[GrowFromCenter(layer) for layer in neural_network.layers])\n\n        # Perform and animate the forward propagation through the network\n        forward_pass_animations = neural_network.forward_pass_animation()\n        self.play(AnimationGroup(*forward_pass_animations, lag_ratio=0.1))\n        \n        self.wait(2)"
    },
    {
        "query": "Could you create an animation where a red dot starts on the left of the screen and a pointer is continuously pointing to it from the left as it moves horizontally to the right at a constant speed? Additionally, can you make all the objects in the scene gradually change in size depending on how far they are from the center of the screen? The closer they are to the center, the larger they should be, and the farther away, the smaller. Please make sure this scaling effect happens in real-time as the dot moves. Let the animation last for 5 seconds.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale_to_fit_height\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale_to_fit_height(3))\n            self.remove(square)"
    },
    {
        "query": "I'd like to create an animation with a red dot and a square where the red dot shifts to the left initially, and then starts moving to the right at a constant speed. Meanwhile, I want the square to stay in the center but keep rotating around its center. After a second, I want the red dot to stop moving and then, after another second, have it move upwards while at the same time the square moves to a position down and to the left of its original spot. Can you create this animation sequence for me?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function to be integrated\n        function_tex = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explanation of the integral bounds\n        bounds_explanation = Text(\"We'll find the area from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Write(bounds_explanation))\n        self.wait(2)\n\n        # Integration process\n        integration_process = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_1^3\")\n        self.play(ReplacementTransform(function_tex.copy(), integration_process))\n        self.wait(1)\n\n        # Explanation of evaluating the bounds\n        evaluation_explanation = Text(\"Place the bounds into the antiderivative\", font_size=24).to_edge(UP)\n        self.play(Transform(bounds_explanation, evaluation_explanation))\n        self.wait(2)\n\n        # Display the result of the integration\n        result = MathTex(r\"= \\frac{3^3}{3} - \\frac{1^3}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_process, result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with final answer\n        self.play(Write(result))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation that shows a horizontal number line with numbers ranging from -5 to 5. On this number line, there should be a pointer that starts at the center position, marked as 0. First, the pointer should move to the right and stop at the number 4. Then, it should move to the left and stop at the number -2. The movements to 4 and then to -2 should be animated, showing a smooth transition of the pointer from one position to the other. Can you create such an animation for me?",
        "answer": "\\n from manim import *\n\nclass CreateAndFadeOutExample(Scene):\n    def construct(self):\n        text = Text(\"Create and Fade Out\").to_edge(UP)\n        self.play(Write(text))\n        \n        squares = VGroup(\n            Square().shift(LEFT),\n            Square().shift(ORIGIN),\n            Square().shift(RIGHT)\n        )\n        \n        self.play(Create(squares))\n        self.wait(1)\n        self.play(FadeOut(squares))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated visualization of a parabola whose curvature changes over time. The scene should start by showing a parabola with its curvature corresponding to a coefficient of 1. This parabola is plotted on a set of axes that range from -2 to 2 on the x-axis and -8.5 to 8.5 on the y-axis. The whole graph should fit within a reasonable size, so it's easy to view. I want to see the parabola's curvature increase to represent a coefficient of 2 and then decrease to a coefficient of -2. Afterwards, it should return back to a coefficient of 1.\n\nDuring this transformation, I would like a numerical indicator displayed next to the parabola that shows the current value of the coefficient. This indicator should be updated in real-time as the coefficient changes and should be formatted to show three decimal places. If the number is too long, it should end with an ellipsis.\n\nAll the elements of the parabola including its equation should be colored red for easy distinction. I'd like the transitions between different curvatures to be smooth, showcasing how the shape of the parabola changes as the coefficient varies. Can you create such an animation?",
        "answer": "\\n class ConflictingAnimations(Scene):\n    def construct(self):\n        s = Square()\n        self.add(s)\n        self.play(Rotate(s, PI), Rotate(s, -PI), run_time=3)"
    },
    {
        "query": "Can you create an animation with a small circle in the center that grows to fill the entire screen and as it expands dots that are contained within it change color? Also, include a horizontal line that moves from left to right and then back again, with dots changing color based on which side of the line they are on. Additionally, there should be a distinctive sound every time a dot changes color.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # f(x) = x^2\n        func = axes.plot(lambda x: x**2, color=WHITE)\n        func_label = axes.get_graph_label(func, label='x^2')\n\n        # Area under curve\n        area = axes.get_area(func, x_range=(0, 2), color=GREEN, opacity=0.5)\n\n        # Display axes, function, and area\n        self.play(Write(axes), Write(func), FadeIn(func_label))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Problem statement\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\").to_corner(UL)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Show the area calculation\n        integration_result = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        integration_result.next_to(problem, DOWN)\n        self.play(Write(integration_result))\n        self.wait(1)\n\n        # Show definite integral result\n        final_result = MathTex(r\"= \\frac{1}{3}2^3 - \\frac{1}{3}0^3 =\", r\"\\frac{8}{3}\")\n        final_result.next_to(integration_result, DOWN)\n        self.play(ReplacementTransform(integration_result, final_result))\n        self.wait(1)\n\n        # Clear the scene and conclude with the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "I would like a step-by-step visual representation of the De Casteljau's algorithm for the construction of a B\u00e9zier curve. Please start with four points: two endpoint crosses and two control point dots. The background should be a calming dark green. The points should be connected by lines that change dynamically as an intermediate point moves along the lines to trace out the resulting curve. All intermediate points and lines should be clearly distinguishable from the control points and primary curve. As the animation plays, I'd like to see the intermediary lines and points fade away, leaving just the B\u00e9zier curve and endpoint crosses on the screen. The curve itself should be clearly highlighted in red as it is being drawn.",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using u substitution\n        explanation1 = Text(\"Use u-substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # U substitution step\n        u_sub_step = MathTex(r\"u = 2x\", r\"\\quad\", r\"du = 2 \\,dx\", r\"\\quad\", r\"\\frac{du}{2} = dx\")\n        self.play(Write(u_sub_step))\n        self.wait(2)\n\n        # Adjust the problem after substitution\n        problem_after_sub = MathTex(r\"\\int \\frac{1}{2} e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), problem_after_sub))\n        self.play(FadeOut(u_sub_step))\n        self.wait(2)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem_after_sub, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I'd like to see an animated demonstration of different easing (rate functions) in an animation. Could you create a video that displays squares, each representing a different rate function like smooth, smoothstep, smootherstep, and smoothererstep? Each square should be clearly labeled with the rate function it represents and be filled with a distinct shade of brown. Below the squares, include a horizontal line with a dot marker that moves from left to right at a constant speed to represent the passage of time. As time progresses, I want the squares to move downwards, each at a pace determined by their specific rate function, so I can visually compare how each function affects the animation. The animation should last about 4 seconds and end with a brief pause.",
        "answer": "\\n from manim import *\n\nclass ChemistryAnimation(Scene):\n    def construct(self):\n        molecule_group = VGroup(oxygen(), metal(), electron())\n        molecule_group.arrange(RIGHT, buff=1)\n\n        self.play(Create(molecule_group))\n        self.wait(2)\n\n        # Animate creation of a positive ion\n        positive_ion = positive()\n        self.play(FadeIn(positive_ion, shift=UP))\n        self.wait(1)\n\n        # Animate creation of a negative ion\n        negative_ion = negative()\n        self.play(FadeIn(negative_ion, shift=DOWN))\n        self.wait(1)\n\n        # Combine ions into an ionic compound\n        compound = VGroup(positive_ion, negative_ion)\n        compound.arrange(RIGHT, buff=0.5)\n        self.play(Transform(molecule_group, compound))\n        self.wait(2)\n\n        # Move the compound in a zigzag pattern\n        zigzag_path = VMobject()\n        zigzag_path.set_points_as_corners([UL, UR, DL, DR, ORIGIN])\n        self.play(MoveAlongPath(compound, zigzag_path), run_time=4, rate_func=linear)\n        self.wait(2)\n\n        # Finish the scene\n        self.play(FadeOut(compound))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video that visually represents how data flows through a simple convolutional neural network, detailing the process of how an input image is transformed through multiple convolutional layers followed by some final feedforward layers? The video should have a high resolution, with a clear focus on the structure of the network, and it should illustrate the forward pass - where data is being processed through each layer.",
        "answer": "\\n from manim import *\n\n# Define colors to be used\nBACKGROUND_COLOR = \"#FAEBD7\"\nTEXT_COLOR = \"#5B5A5A\"\nBLUE_COLOR = \"#1E90FF\"\nGREEN_COLOR = \"#32CD32\"\nRED_COLOR = \"#FF6347\"\nYELLOW_COLOR = \"#FFD700\"\nPURPLE_COLOR = \"#8A2BE2\"\n\n# Configure frame properties\nconfig.frame_size = (1920, 1080)\nconfig.frame_width = 16\nconfig.frame_height = 9\n\nclass FigureTwo(Scene):\n    def construct(self):\n        # Set the background color of the scene\n        self.camera.background_color = BACKGROUND_COLOR\n        \n        # Create several circles with different colors and arrange them\n        circles = VGroup(\n            Circle(stroke_color=BLUE_COLOR, fill_color=RED_COLOR, fill_opacity=0.5),\n            Circle(stroke_color=GREEN_COLOR, fill_color=YELLOW_COLOR, fill_opacity=0.5),\n            Circle(stroke_color=PURPLE_COLOR, fill_color=GREEN_COLOR, fill_opacity=0.5)\n        )\n        circles.arrange(RIGHT, buff=1)\n        \n        # Create mathematical expression and position it below the circles\n        equation = MathTex(r\"e^{i\\pi} + 1 = 0\", color=TEXT_COLOR)\n        equation.next_to(circles, DOWN)\n        \n        # Create a text label for each circle and position it at the center of each circle\n        labels = VGroup(\n            Text(\"i\", font_size=24, color=TEXT_COLOR).move_to(circles[0]),\n            Text(\"ii\", font_size=24, color=TEXT_COLOR).move_to(circles[1]),\n            Text(\"iii\", font_size=24, color=TEXT_COLOR).move_to(circles[2])\n        )\n        \n        # Animate the circles appearing one after another\n        self.play(LaggedStart(*(Create(circle) for circle in circles), lag_ratio=0.5), run_time=2)\n        # Show equation\n        self.play(Write(equation), run_time=1)\n        # Display the text labels\n        self.play(LaggedStart(*(FadeIn(label) for label in labels), lag_ratio=0.5), run_time=2)\n        \n        # Wait for a short duration\n        self.wait(2)\n        \n        # Move everything to the left and then clear the screen\n        animation_group = VGroup(circles, labels, equation)\n        self.play(animation_group.animate.shift(LEFT*3))\n        self.wait(1)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Can you show me how to create a simple animation with text saying \"Your first scene!\" using ManimCE?",
        "answer": "\\n from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Display the series to be tested\n        series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation of the convergence test\n        explanation1 = Text(\"Apply the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Display the p-test condition\n        p_test = MathTex(r\"p > 1\")\n        self.play(Write(p_test))\n        self.wait(1)\n\n        # Showing that p=2 satisfies the p-test (since our series has n^2)\n        satisfaction = MathTex(r\"2 > 1\")\n        self.play(Write(satisfaction))\n        self.wait(1)\n\n        # Explanation for the convergence conclusion\n        explanation2 = Text(\"The series converges by the p-test\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Conclusion that the series converges\n        conclusion = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\", r\"\\text{ converges}\")\n        self.play(ReplacementTransform(series, conclusion[0]), Write(conclusion[1]))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation that visualizes a simple three-layer feedforward neural network, with the first layer having 3 neurons, the second layer having 5 neurons, and the third layer also having 3 neurons, using ManimCE?",
        "answer": "\\n from manim import Scene, Create\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Connection\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Defining a custom neural network with two hidden layers.\n        layers = [\n            FeedForwardLayer(num_nodes=4, label=\"Input\"),\n            FeedForwardLayer(num_nodes=6, label=\"Hidden1\"),\n            FeedForwardLayer(num_nodes=6, label=\"Hidden2\"),\n            FeedForwardLayer(num_nodes=2, label=\"Output\")\n        ]\n\n        # Creating the neural network.\n        custom_nn = NeuralNetwork(layers)\n\n        # Adding connections that represent weights.\n        weights = [\n            Connection(layers[0], layers[1]),\n            Connection(layers[1], layers[2]),\n            Connection(layers[2], layers[3])\n        ]\n\n        # Adding the neural network to the Scene.\n        self.add(custom_nn)\n        for weight in weights:\n            self.add(weight)\n\n        # Animating the neural network creation.\n        self.play(Create(custom_nn))\n        for weight in weights:\n            self.play(Create(weight))"
    },
    {
        "query": "I would like to create an educational animation that illustrates a forward pass through a simple neural network with three layers. The first layer should have 3 nodes, the second layer should have 5 nodes, and the third layer should also have 3 nodes. Can you show me how this process would look in an animated format?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Writing the function\n        function = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Displaying the area problem\n        area_problem = MathTex(r\"A = \\int_{a}^{b} x^2 \\,dx\")\n        self.play(Write(area_problem))\n        self.wait(1)\n\n        # Showing area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 2], color=BLUE)\n        area = area = Integral(curve, (0, 2))\n        self.play(Create(curve))\n        self.play(Write(area))\n        self.wait(1)\n\n        # Calculating the integral\n        integral_calculation = MathTex(r\"A = \\frac{1}{3} x^3 \\Big|_a^b\")\n        self.play(Transform(area_problem, integral_calculation))\n        self.wait(1)\n\n        # Substitute the limits\n        limits_substituted = MathTex(r\"A = \\frac{1}{3} b^3 - \\frac{1}{3} a^3\")\n        self.play(ReplacementTransform(integral_calculation, limits_substituted))\n        self.wait(1)\n\n        # Displaying final answer\n        final_answer = MathTex(r\"A = \\frac{1}{3} (b^3 - a^3)\")\n        self.play(ReplacementTransform(limits_substituted, final_answer))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that visually represents a neural network with three convolutional layers having respective depths of 1, 3, and 5, each with 3 by 3 filter sizes, followed by two fully connected layers with three neurons each, and show a forward pass through this network? The convolutional layers should have their filters spaced appropriately to clearly distinguish each one. Additionally, the entire network should be positioned centrally and the transition between each layer should have a clear spacing.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and the area under the curve\n        func = lambda x: 0.1 * x**2\n        area = area = self.get_area(func, 0, 4)\n\n        # Plot the function\n        graph = self.get_graph(func, color=WHITE)\n        graph_label = self.get_graph_label(graph, label='y = 0.1x^2')\n\n        self.play(ShowCreation(graph), Write(graph_label))\n        self.wait(1)\n\n        # Show the area under the curve\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(1)\n\n        # Annotate the area\n        area_label = MathTex(r\"\\int_0^4 0.1x^2 \\,dx\", color=WHITE)\n        area_label.next_to(area, DOWN)\n\n        self.play(Write(area_label))\n        self.wait(2)\n\n        # Calculate the definite integral on screen\n        definite_integral = MathTex(r\"= [ \\frac{0.1x^3}{3} ]_0^4\")\n        self.play(ReplacementTransform(area_label, definite_integral))\n        self.wait(1)\n\n        # Show the final result\n        final_result = MathTex(r\"= \\frac{0.1 \\cdot 4^3}{3} - \\frac{0.1 \\cdot 0^3}{3}\", r\"= \\frac{6.4}{3}\", r\"= \\frac{64}{30}\")\n        self.play(ReplacementTransform(definite_integral, final_result))\n        self.wait(2)\n\n        # Display the final answer as a decimal\n        decimal_result = MathTex(r\"\\approx 2.13\")\n        self.play(Transform(final_result, decimal_result))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.play(ShowCreation(graph), Write(graph_label), FadeIn(area, scale=0.5), Write(decimal_result))\n        self.wait(2)\n\n    def get_area(self, func, t_min, t_max):\n        area = Integral(func, (t_min, t_max))\n        return area\n\n    def get_graph(self, func, **kwargs):\n        graph = FunctionGraph(func, **kwargs)\n        return graph"
    },
    {
        "query": "\"Can you create an educational animation that showcases how a neural network processes an image of a digit through its layers, including convolutional layers and feedforward layers, and centers this demonstration on the screen?\"",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying Fourier Series definition\n        fourier_series_def = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left(a_n \\cos(nx) + b_n \\sin(nx) \\right)\")\n        self.play(Write(fourier_series_def))\n        self.wait(2)\n\n        # Explanation for Fourier Series\n        explanation1 = Text(\"A periodic function can be represented as a sum of sines and cosines.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(3)\n\n        # Example of Fourier Series for a square wave\n        explanation2 = Text(\"Example: Fourier Series of a square wave\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying Fourier Series for a square wave\n        square_wave = MathTex(r\"f(x) = \\frac{4}{\\pi} \\sum_{n=1,3,5}^{\\infty} \\frac{\\sin(nx)}{n}\")\n        self.play(Transform(fourier_series_def, square_wave))\n        self.wait(2)\n\n        # Explanation for coefficients\n        explanation3 = Text(\"Coefficients are determined by the function's periodicity and shape.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the scene and conclude with a graphic\n        self.clear()\n        self.wait(1)\n        square_wave_graphic = Text(\"Here would be a graphic of the square wave.\", font_size=24)\n        self.play(FadeIn(square_wave_graphic))\n        self.wait(2)"
    },
    {
        "query": "\"Can you create an animated video that visually demonstrates how data flows through a simple convolutional neural network with the following layer configuration: one input channel followed by three convolutional layers with 8, 6, and 2 filters respectively, and the second and third convolutional layers having a kernel size of 3 and 2, and include a max pooling layer with a kernel size of 2 between the second and third convolutional layers? Also, please make sure that the network is centered on the screen and add a pause for one second before showing the data flow animation.\"",
        "answer": "\\n from manim import *\n\n\nclass SineWaveOnComplexPlane(ComplexPlane):\n    def get_sine_wave_dots(self):\n        input_dot = Dot(color=GREEN)\n        output_dot = always_redraw(lambda: Dot(point=self.n2p(np.sin(self.p2n(input_dot.get_center()))),\n                                               color=BLUE))\n        return input_dot, output_dot\n\n\nclass SineWaveAnimation(Scene):\n    def construct(self):\n        complex_plane = SineWaveOnComplexPlane()\n        complex_plane.add_coordinates()\n        self.add(complex_plane)\n\n        input_dot, output_dot = complex_plane.get_sine_wave_dots()\n        input_dot.move_to(complex_plane.n2p(0))\n\n        wave_path = TracedPath(output_dot.get_center, stroke_color=RED, min_distance_to_new_point=0.1)\n\n        self.add(input_dot, output_dot, wave_path)\n\n        self.play(input_dot.animate.shift(RIGHT*PI*2), run_time=5, rate_func=linear)\n        self.wait()"
    },
    {
        "query": "How can I create an animated visualization of a neural network using Manim, showing a forward pass, that includes two convolutional layers with different numbers of filters and a fully connected layer, as well as different activation functions for each layer?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"TracedPath\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot(color=RED)\n            trace = TracedPath(dot.get_center)\n            self.add(dot, trace)\n            self.wait(0.5)\n            self.play(dot.animate.shift(UP), run_time=0.5)\n            self.play(dot.animate.shift(LEFT), run_time=0.5)\n            self.play(dot.animate.shift(DOWN+RIGHT), run_time=0.5)\n            self.remove(dot, trace)"
    },
    {
        "query": "Can you create an animation that shows a neural network with 5 layers, where the first layer has 3 neurons, the second has 5 neurons, the third has 3 neurons, the fourth has 5 neurons, and the fifth layer has 4 neurons, with a dropout effect demonstrating the deactivation of 25% neurons randomly during a forward pass in the network, and have the network be centered on the screen?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Highlighting the area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 2])\n        area = area = self.get_area(curve, 0, 2)\n        self.play(ShowCreation(curve), FadeIn(area))\n        self.wait(2)\n\n        # Explanation of the definite integral\n        explanation = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Show antiderivative formation\n        antiderivative = MathTex(r\"= \\frac{1}{3}x^3 \\Big|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), antiderivative))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(antiderivative, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "How can I create an animated video that visually represents the forward propagation process in a simple neural network with three layers, where the first layer has three neurons, the second layer has five neurons, and the third layer has three neurons again, using a Python library for creating animations?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralSphericalExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{1} \\rho^2 \\sin \\phi\\, d\\rho\\,d\\theta\\,d\\phi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{2\\pi} [\\frac{1}{3}\\rho^3 \\sin \\phi]_{0}^{1} d\\theta\\,d\\phi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplified after inner integral\n        simplified_inner = MathTex(r\"= \\frac{1}{3} \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\sin \\phi \\, d\\theta\\,d\\phi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\frac{1}{3} \\int_{0}^{\\pi} [2\\pi \\sin \\phi]_{0}^{2\\pi} d\\phi\")\n        self.play(ReplacementTransform(simplified_inner, middle_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation3 = Text(\"Finally, integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution step\n        final_solution = MathTex(r\"= \\frac{2\\pi}{3} \\int_{0}^{\\pi} \\sin \\phi \\, d\\phi\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Explain final integral solution\n        explanation4 = Text(\"Evaluate the sine integral over phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{2\\pi}{3} [-\\cos \\phi]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        \n        # Resolve to actual number\n        resolved_final_answer = MathTex(r\"= \\frac{4\\pi}{3}\")\n        self.play(ReplacementTransform(final_answer, resolved_final_answer))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animated video that visually demonstrates the architecture of a simple neural network with three feed-forward layers, where the middle layer uses a ReLU activation function, and the layers are connected to a summation operation also with a ReLU activation function? Include an animation showing data passing through this network and annotate the visualization with the corresponding Python code that defines the network structure and animation. Make sure the animation and code are well-organized and presented side by side for educational purposes.",
        "answer": "\\n from manim import *\n\nclass MovingSquare(Scene):\n    def construct(self):\n        square = Square(color=RED, fill_opacity=1)\n        square.set_width(1)\n\n        # Animate the square across the screen\n        self.play(square.animate.shift(RIGHT * 5), run_time=2)\n        self.wait(0.5)\n\n        # Animate the square to change color\n        self.play(square.animate.set_color(BLUE), run_time=1)\n        self.wait(0.5)\n\n        # Animate the square to move in a circle\n        circle_path = Circle(radius=2.5, color=WHITE)\n        self.play(MoveAlongPath(square, circle_path), run_time=2)\n        self.wait(0.5)\n\n        # Animate the square scaling up and then fading out\n        self.play(square.animate.scale(3), run_time=1)\n        self.play(FadeOut(square), run_time=1)\n        self.wait()"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the workings of a simple neural network. The animation should include a sequence of feed-forward layers with ReLU activation functions and a summation operation also with a ReLU activation. Each layer should have three neurons, and there should be connections shown between the layers and the summation operation. It would be great if the animation could highlight the forward pass of data through the network. Additionally, can you create a code snippet that represents the network architecture and can be displayed alongside the neural network in the animation? Please ensure that the visual presentation of the neural network is centered and clear for educational purposes.",
        "answer": "\\n from manim import *\n\nclass ComplexRootsOfUnity(Scene):\n    def construct(self):\n        plane = ComplexPlane().add_coordinates()\n        roots = [np.exp(2 * PI * 1j * k / 5) for k in range(5)]\n        dots = VGroup(*[Dot(plane.n2p(root), color=BLUE) for root in roots])\n        lines = VGroup(*[Line(plane.n2p(0), dot.get_center(), color=YELLOW) for dot in dots])\n\n        self.play(Create(plane))\n        self.play(AnimationGroup(*[GrowFromCenter(dot) for dot in dots], lag_ratio=0.1))\n        self.play(ShowCreation(lines))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using Manim to show the forward pass of a convolutional neural network with a convolutional layer visualizing an MNIST digit image, and also include a code snippet on the screen that describes the animation process?",
        "answer": "\\n from manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n# Make the neural network\nnn = NeuralNetwork([\n    FeedForwardLayer(num_nodes=3),\n    FeedForwardLayer(num_nodes=5),\n    FeedForwardLayer(num_nodes=3)\n])\nself.add(nn)\n# Make the animation\nforward_pass_animation = nn.make_forward_pass_animation()\n# Play the animation\nself.play(forward_pass_animation)"
    },
    {
        "query": "\"Can you create an animated video that visually demonstrates how a simple convolutional neural network processes an image? The video should showcase an image going through layers of a neural network, including convolutional layers and fully connected layers, and highlight the transformation at each stage. I'd like the neural network to consist of an initial image layer, followed by two convolutional layers with specified parameters. The first with 1 feature map and 6-size with padding, the second with 3 feature maps and a 3-size filter with no padding. After that, it should include two fully connected layers. The animation should clearly show the data flowing from input to output and be simple enough for educational purposes.\"",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Displaying the ODE\n        ode_text = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(ode_text))\n        self.wait(1)\n        \n        # Explain the concept of angular frequency\n        explanation1 = Text(\"Angular frequency\", font_size=24).to_edge(UP)\n        angular_freq = MathTex(r\"\\omega = \\sqrt{\\frac{k}{m}}\")\n        self.play(Write(explanation1))\n        self.wait(1)\n        self.play(FadeIn(angular_freq, shift=DOWN))\n        self.wait(2)\n\n        # Rewrite the ODE using angular frequency\n        rewritten_ode = MathTex(r\"\\frac{d^2x}{dt^2} + \\omega^2 x = 0\")\n        self.play(Transform(ode_text, rewritten_ode))\n        self.wait(1)\n        \n        # Solution of the ODE\n        explanation2 = Text(\"Solution of the ODE\", font_size=24).to_edge(UP)\n        general_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(Transform(explanation1, explanation2))\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Visual Representation\n        explanation3 = Text(\"Harmonic motion visualization\", font_size=24).to_edge(UP)\n        oscillator = Circle(radius=1).set_stroke(color=WHITE, opacity=0.5)\n        dot = Dot(oscillator.get_right(), color=RED)\n        path = TracedPath(dot.get_center, stroke_color=RED, stroke_opacity=0.6)\n        self.play(Transform(explanation1, explanation3))\n        self.play(FadeIn(oscillator), FadeIn(dot))\n        self.add_foreground_mobject(dot)\n        self.remove(angular_freq, rewritten_ode, general_solution)\n        self.play(MoveAlongPath(dot, oscillator), run_time=2, rate_func=linear)\n        self.add(path)\n        self.wait(2)\n\n        # Conclusion and clearing the scene\n        self.play(FadeOut(oscillator), FadeOut(dot), FadeOut(path), FadeOut(explanation1))\n        self.wait(1)\n        final_text = Text(\"Harmonic oscillator dynamics\", font_size=24)\n        self.play(Write(final_text))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using Manim showing a neural network with convolutional layers processing an image? Specifically, I'd like to see the layers visualized along with a forward pass animation to demonstrate how an image is transformed through the network. Also, please include a code snippet within the animation itself to illustrate what the underlying Python script for building the neural network might look like. Make sure the animation and code snippet are clearly visible with a proper layout on the screen.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Display the double integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1-x} e^{-(x+y)} dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral calculation\n        inner_integral = MathTex(r\"= \\int_{0}^{1} [-e^{-(x+y)}]_{0}^{1-x} dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplify inner integral step\n        simplified_inner = MathTex(r\"= \\int_{0}^{1} (e^{-x} - e^{-1}) dx\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for the final integral\n        explanation2 = Text(\"Now integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral calculation\n        final_integral = MathTex(r\"= [ -e^{-x} - x e^{-1} ]_{0}^{1}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for the final result\n        explanation3 = Text(\"Evaluate at the boundaries\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= (1 - \\frac{1}{e}) - (0 - 0) = 1 - \\frac{1}{e}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)"
    },
    {
        "query": "Please create an educational animation using Manim that shows a visual representation of a Variational Autoencoder (VAE) neural network architecture. I'd like to see how the data flows through an image input layer, several feedforward layers, an embedding layer that represents the bottleneck of the VAE, and then back through feedforward layers to an image output layer. The animation should illustrate the forward pass of data through the network. Additionally, I would like the animation to display a snippet of the code that creates the network, with syntax highlighting to make it easy to read. Also, ensure that the whole neural network is centered and scaled appropriately on the screen and that the animation runs smoothly for an audience to follow along. If possible, include an actual image file for the input and output layers of the network.",
        "answer": "\\n from manim import *\n\nclass ChemicalBonds(Scene):\n    def construct(self):\n        # Create a water molecule representation with bonds\n        oxygen_atom = Circle(radius=0.5, color=BLUE).set_fill(BLUE, opacity=1)\n        hydrogen_atom1 = Circle(radius=0.25, color=WHITE).set_fill(WHITE, opacity=1)\n        hydrogen_atom2 = Circle(radius=0.25, color=WHITE).set_fill(WHITE, opacity=1)\n\n        bond1 = Line(start=oxygen_atom.get_right(), end=hydrogen_atom1.get_left())\n        bond2 = Line(start=oxygen_atom.get_left(), end=hydrogen_atom2.get_left())\n\n        water_molecule = VGroup(\n            oxygen_atom, \n            hydrogen_atom1.next_to(oxygen_atom, RIGHT, buff=0.5), \n            hydrogen_atom2.next_to(oxygen_atom, LEFT, buff=0.5),\n            bond1, \n            bond2\n        )\n\n        # Create labels for the atoms\n        oxygen_label = Text(\"O\", color=WHITE).move_to(oxygen_atom.get_center())\n        hydrogen_label1 = Text(\"H\", color=BLACK).move_to(hydrogen_atom1.get_center())\n        hydrogen_label2 = Text(\"H\", color=BLACK).move_to(hydrogen_atom2.get_center())\n\n        # Combine the molecule and the labels\n        molecule_with_labels = VGroup(water_molecule, oxygen_label, hydrogen_label1, hydrogen_label2)\n\n        # Animate the construction of the water molecule\n        self.play(Create(oxygen_atom))\n        self.play(Create(hydrogen_atom1), Create(hydrogen_atom2))\n        self.play(Create(bond1), Create(bond2))\n        self.play(FadeIn(oxygen_label), FadeIn(hydrogen_label1), FadeIn(hydrogen_label2))\n\n        # Scale up the molecule to focus on it\n        self.play(molecule_with_labels.animate.scale(2))\n\n        # Rotate the molecule within the scene\n        self.play(Rotate(molecule_with_labels, angle=2 * PI))\n\n        self.wait(2)  # Pause to admire our water molecule before ending the scene."
    },
    {
        "query": "Could you create an animated visualization of a variational autoencoder neural network architecture using images as input and output with a code snippet overlay that explains how the network is constructed?",
        "answer": "\\n from manim import *\n\nclass Custom2DGridScene(Scene):\n    def create_grid(self, rows: int, cols: int, cell_size: float = 1.0):\n        \"\"\"\n        Create a 2D grid of squares given row and column counts.\n\n        Args:\n            rows (int): The number of rows in the grid.\n            cols (int): The number of columns in the grid.\n            cell_size (float): The side length of each square cell.\n\n        Returns:\n            VGroup: A group containing all the grid squares.\n        \"\"\"\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                square = Square(side_length=cell_size)\n                square.move_to(np.array([j * cell_size, -i * cell_size, 0]))\n                grid.add(square)\n        grid.move_to(ORIGIN)  # Center the grid.\n        return grid\n\n    def construct(self):\n        rows, cols = 5, 5  # Define the number of rows and columns for the grid.\n        grid = self.create_grid(rows, cols)  # Create the grid using the helper function.\n        self.add(grid)  # Add the grid to the scene.\n\nclass ComplexPathAnimation(Scene):\n    def construct(self):\n        # Create a dot that will move along a path.\n        dot = Dot(radius=0.1, color=RED)\n        \n        # Define the complex path points.\n        path_points = [UP * 2, UP + RIGHT * 2, DOWN + RIGHT * 2, DOWN * 2, DOWN + LEFT * 2, UP + LEFT * 2, UP * 2]\n        complex_path = VGroup()\n        \n        # Iterate over the points to create the visual path with lines.\n        for i in range(len(path_points) - 1):\n            line = Line(path_points[i], path_points[i + 1], stroke_width=2, color=BLUE)\n            complex_path.add(line)\n        \n        # Show the path on screen.\n        self.add(complex_path)\n        \n        # Create a custom animation by moving the dot along the defined path.\n        def custom_path_position(alpha):\n            num_points = len(path_points)\n            curr_point = int(alpha * (num_points - 1))\n            sub_alpha = (alpha * (num_points - 1)) % 1\n            return path_points[curr_point] + (path_points[curr_point + 1] - path_points[curr_point]) * sub_alpha\n\n        self.play(MoveAlongPath(dot, complex_path), run_time=4, rate_func=linear)\n        self.add(dot)  # Keep the dot displayed at the end."
    },
    {
        "query": "Could you create an animation that visualizes the layers of a neural network processing an image from the MNIST dataset? I'd like to see the image pass through convolutional layers, max pooling, and finally some fully connected layers. Each layer should transition smoothly to the next to show the forward pass of the neural network. The scene should be in 3D and the neural network should be centered on the screen. It's important that the image used comes from an actual MNIST dataset image file. Can the animation be designed to fit a 1200 by 1900 pixel screen space?",
        "answer": "\\n from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the surface integral problem\n        problem = MathTex(r\"\\iint_{S} \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parametrization of S\n        explanation1 = Text(\"Parametrize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parametrized surface step\n        parametrized_surface = MathTex(r\"\\vec{r}(u, v) = f(u, v)\\hat{i} + g(u, v)\\hat{j} + h(u, v)\\hat{k}\")\n        self.play(ReplacementTransform(problem.copy(), parametrized_surface))\n        self.wait(1)\n\n        # Normal vector explanation\n        explanation2 = Text(\"Find the normal vector dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Normal vector calculation\n        normal_vector = MathTex(r\"d\\vec{S} = \\left| \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right| dudv\")\n        self.play(ReplacementTransform(parametrized_surface, normal_vector))\n        self.wait(1)\n\n        # Final surface integral with parametrization\n        explanation3 = Text(\"Write the surface integral with parametrization\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral calculation\n        final_integral = MathTex(r\"\\iint_{D} \\vec{F}( \\vec{r}(u, v) ) \\cdot \\left( \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right) dudv\")\n        self.play(ReplacementTransform(normal_vector, final_integral))\n        self.wait(2)\n\n        # Complete the scene\n        self.play(FadeOut(final_integral), FadeOut(explanation1))\n        self.wait(1)"
    },
    {
        "query": "I want to create a detailed 3D animation of a neocognitron neural network model showing its layers and how data passes through them. Each layer should have multiple cells, and the layers should be connected by filters that represent the connections in the network. The animation should include pulsing effects when data is passed from one layer to the next to visualize the forward pass process. Additionally, I'd like to be able to rotate the model for a better perspective and have labels for each layer. Could you also add a title above the neural network that says \"Neocognitron\"?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r\\, dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[\\frac{1}{2}r^2\\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_{0}^{2\\pi} \\frac{1}{2} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Calculate the result\n        result_text = Text(\"The area inside the unit circle is \", font_size=24).to_edge(UP)\n        result = MathTex(r\"= \\frac{1}{2} \\theta \\Big|_{0}^{2\\pi} = \\pi\")\n        self.play(Transform(explanation1, result_text), Write(result))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually represents the Fibonacci sequence with squares and arrows, and transitions that follow this sequence: 0, 1, 1, 2, 3, 5, 8? The animation should start with a title 'Observe a sequ\u00eancia abaixo:', display the initial part of the Fibonacci sequence '0, 1, 1, 2, 3, 5, 8, 13, ...', and then showcase the addition process that creates the sequence using arrows and annotations. Each addition should be shown by an arrow between two consecutive numbers, and the result should be displayed on a line. The colors of the arrows and annotations should change with each step, and I would like the animation to follow an arc-shaped transition with a smooth easing in effect. After the sequence is displayed, the word 'Fibonacci' should appear at the bottom of the screen, and eventually, the entire animation should fade out. Please use a light, neutral background color and ensure that the text and arrows are easily visible but not too harsh on the eyes. Can the animation be formatted to fit a vertical smartphone screen?",
        "answer": "\\n from manim import *\n\nclass ChemicalBondingScene(Scene):\n    def construct(self):\n        # Create an Oxygen molecule\n        oxygen_molecule = VGroup(oxygen(), oxygen()).arrange(RIGHT, buff=1)\n\n        # Create a Sodium atom\n        sodium_atom = metal().scale(0.9).next_to(oxygen_molecule, LEFT, buff=1)\n\n        # Create a Chlorine atom\n        chlorine_atom = negative().scale(0.9).next_to(oxygen_molecule, RIGHT, buff=1)\n\n        # Animate the creation of the Sodium-Oxygen-Chlorine structure\n        self.play(AnimationGroup(\n            Create(sodium_atom),\n            Create(oxygen_molecule),\n            Create(chlorine_atom),\n            lag_ratio=0.5\n        ))\n\n        # Pause for a moment\n        self.wait(1)\n\n        # Animate the transformation to a new structure\n        self.play(\n            sodium_atom.animate.shift(UP * 2),\n            oxygen_molecule.animate.shift(DOWN * 2),\n            chlorine_atom.animate.shift(UP * 2)\n        )\n\n        self.wait(2)\n\n        # Fade out all elements\n        self.play(FadeOut(VGroup(sodium_atom, oxygen_molecule, chlorine_atom)))"
    },
    {
        "query": "I would like to create an educational animation that visually represents the Fibonacci sequence using colored squares. Each square should be proportional in size to its corresponding Fibonacci number and colored in a sequence of light blue, light red, light orange, aqua green, and light purple, repeating this color pattern as the sequence progresses. Following the squares, I want to see an animation of an arc being drawn at each corner of the squares in a spiral fashion, with a small dot tracing the path of the arc as it goes. The background should be a light cream color with all the text and lines in a dark gray. Also, to ensure the animation looks smooth, each square and its number should appear one after another with a slight delay between them, and similarly, the arcs should be drawn with a smooth progression according to the size of the squares. Could each arc take longer to draw based on the size of its corresponding square so that larger arcs take more time to complete? Additionally, at the end of the animation, all elements should gradually fade out before the scene ends. Can this be created as a vertical video suitable for mobile viewing?",
        "answer": "\\n from manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Convolutional2DLayer\n\nnn = NeuralNetwork([\n        Convolutional2DLayer(1, 7, 3, filter_spacing=0.32), # Note the default stride is 1. \n        Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n        Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n        FeedForwardLayer(3),\n        FeedForwardLayer(3),\n    ],\n    layer_spacing=0.25,\n)\n# Center the neural network\nnn.move_to(ORIGIN)\nself.add(nn)\n# Make a forward pass animation\nforward_pass = nn.make_forward_pass_animation()"
    },
    {
        "query": "I would like to create an animated video introduction for a presentation about number sequences using ManimCE. In this video, the background should be a light beige, and the main text should be in a dark gray color. I'd like to have the title \"Sequ\u00eancias Num\u00e9ricas\" divided into two lines, with each word stacked on top of the other, placed in the center of the screen.\n\nAround the title, there should be two concentric squares; the inner one should be just a white outline, and the outer square should be solid red with a white outline as well. Before the title and squares appear, I want two images representing groups of numbers to fly into the frame, one from each side of the two squares. These images should be sourced from \"./assets/NumberGroup1.png\" and \"./assets/NumberGroup2.png\".\n\nAdditionally, I want two thin red horizontal rectangles to fade in next to the squares: one next to the left of the outer square and moving slightly upwards, and the other to the right of the square moving slightly downwards.\n\nOnce everything is set up, the two images of number groups should swiftly move downwards, exiting the frame with the first moving faster and the second following 0.8 seconds later a bit more slowly. To finish the introduction, all elements should simultaneously slide out of the frame to the left as if pushed by an unseen force.\n\nPlease set the video's dimensions to be suitable for a mobile device, with a resolution ratio of 9:16. Can you generate an animation like that for me?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2\\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3\\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem, inner_integral))\n        self.wait(1)\n\n        # Simplified inner integral step\n        simplified_inner = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3}\\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \u03b8\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [\\frac{1}{3}(-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for final step\n        explanation3 = Text(\"Evaluate the antiderivative at the limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}(1 - (-1))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplified final solution\n        simplified_solution = MathTex(r\"= \\frac{2}{3}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that displays a sequence of numbers, specifically the powers of 3 (1, 3, 9, 27, 81, 243, ...), accompanied by arrows between them indicating multiplication by 3? Start with a title saying \"Observe a sequ\u00eancia abaixo:\" which means \"Observe the sequence below:\" in Portuguese. Use a gentle color scheme with a light background, and have the arrows appear in sequence with a dynamic effect. Once all elements are shown, fade them out and clear the screen. Ensure the animation is vertical (portrait mode) and suitable for a mobile display.",
        "answer": "\\n from manim import *\n\nclass Neuron(VGroup):\n    CONFIG = {\n        \"radius\": 0.2,\n        \"fill_color\": BLUE,\n        \"fill_opacity\": 0.8,\n        \"stroke_color\": WHITE,\n        \"stroke_width\": 2,\n    }\n\n    def __init__(self, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.circle = Circle(radius=self.radius,\n                             fill_color=self.fill_color,\n                             fill_opacity=self.fill_opacity,\n                             stroke_color=self.stroke_color,\n                             stroke_width=self.stroke_width)\n        self.add(self.circle)\n        self.axon = None  # Will be used to store output lines\n\n    def add_axon(self, axon):\n        self.axon = axon\n        self.add(axon)\n\n\nclass Layer(VGroup):\n    CONFIG = {\n        \"neurons\": 5,\n        \"neuron_spacing\": 0.5,\n    }\n\n    def __init__(self, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.neurons = VGroup(*[Neuron() for _ in range(self.neurons)])\n        self.neurons.arrange(RIGHT, buff=self.neuron_spacing)\n        self.add(self.neurons)\n\n\nclass NeuralNetworkScene(ThreeDScene):\n    def construct(self):\n        layer_spacing = 1.5\n        layers = VGroup()\n\n        # Create layers of neurons\n        for num_neurons in [4, 5, 3]:\n            layer = Layer(neurons=num_neurons)\n            if layers:\n                layer.next_to(layers[-1], DOWN, buff=layer_spacing)\n            layers.add(layer)\n\n        # Draw axons\n        for i in range(len(layers) - 1):\n            for n1 in layers[i].neurons:\n                for n2 in layers[i + 1].neurons:\n                    n1.add_axon(Line(n1.get_center(), n2.get_center(), buff=0.1))\n\n        # Add the VGroup of Layers to the scene and animate\n        self.add(layers)\n        self.play(ShowCreation(layers))\n\n        # Rotate the neural network\n        self.move_camera(phi=80 * DEGREES, theta=45 * DEGREES)\n        self.wait(2)"
    },
    {
        "query": "Please create an educational animation that visually demonstrates a multiplying pattern sequence on a neutral-colored background. I'd like the sequence to start with the number 1 and each subsequent number to be three times the previous one, up to five steps in the sequence. The numbers should appear one after the other with a small animation between them that indicates multiplication by three.\n\nCould you make sure that the animation has a clear title at the beginning saying \"Observe a sequ\u00eancia abaixo:\"? The title and the multiplication sign should be in a light red color, while the numbers should be in a standard text color.\n\nFor the multiplication animation, use arrows that connect each number in the sequence, with the label \"x3\" next to each arrow to emphasize the multiplying action. The arrows should be in a light blue color, alternate between the top and bottom of the sequence, and include an exciting animation behavior when they appear.\n\nAfter showing the sequence up to 243, fade everything out smoothly so that the animation ends on the neutral background.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area under the curve\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.5)\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n\n        self.play(Create(axes), Create(graph), FadeIn(area), Write(graph_label))\n        self.wait()\n\n        # Display the integral symbol with limits\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Calculation of the integral\n        calculation = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(Transform(integral, calculation))\n        self.wait(1)\n\n        # Show the final result\n        final_result = MathTex(r\"=\\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3 = \\frac{8}{3}\")\n        self.play(Transform(integral, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), FadeOut(graph_label), FadeOut(integral))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated sequence diagram augmented with a title and a pattern of numbers that displays consecutive numbers from 1 to 8, and between each number, visualize the transition with a directed arc and label \"+1\" to indicate incrementation? Also, alternate the arcs' positions, pointing upwards for even and downwards for odd transitions. Could you make sure the arcs have tips, animate the appearance of the title and numbers, and then have each transition depicted by these arcs appear sequentially? After the sequence is complete, could you fade out the diagram except for the title? I would like a gentle color scheme with a soft background and contrasting texts and arcs, and the title should have a distinct color to stand out. Lastly, adjust the animation settings for a vertical frame similar to a smartphone screen.",
        "answer": "\\n from manim import *\n\nclass SurfaceAreaParametricSurfaceExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint_S\", r\"\\sqrt{1 + (\\frac{\\partial z}{\\partial x})^2 + (\\frac{\\partial z}{\\partial y})^2}\", r\"\\,dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"Parameterize the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization step\n        parameterization = MathTex(r\"S(x, y) = (x, y, f(x, y))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(1)\n\n        # Explanation for partial derivatives\n        explanation2 = Text(\"Compute the partial derivatives\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Computing the partial derivatives\n        partial_derivatives = MathTex(r\"\\frac{\\partial z}{\\partial x} = f_x\", r\"\\quad\\text{and}\\quad\", r\"\\frac{\\partial z}{\\partial y} = f_y\")\n        self.play(ReplacementTransform(parameterization, partial_derivatives))\n        self.wait(1)\n\n        # Explanation for normal vector\n        explanation3 = Text(\"Find the normal vector\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Normal vector step\n        normal_vector = MathTex(r\"\\mathbf{N} = (-f_x, -f_y, 1)\")\n        self.play(ReplacementTransform(partial_derivatives, normal_vector))\n        self.wait(1)\n\n        # Explanation for the magnitude of the normal vector\n        explanation4 = Text(\"Calculate the magnitude of the normal vector\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Magnitude step\n        magnitude = MathTex(r\"||\\mathbf{N}|| = \\sqrt{f_x^2 + f_y^2 + 1}\")\n        self.play(ReplacementTransform(normal_vector, magnitude))\n        self.wait(1)\n\n        # Final surface integral step\n        surface_integral = MathTex(r\"\\iint_S\", r\"\\sqrt{f_x^2 + f_y^2 + 1}\", r\"\\,dA\")\n        self.play(ReplacementTransform(magnitude, surface_integral))\n        self.wait(1)\n\n        # Explanation for the final integral\n        explanation5 = Text(\"Integrate over the region A\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation5))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"\\text{Surface Area} = \\int\\int_A\", r\"\\sqrt{f_x^2 + f_y^2 + 1}\", r\"\\,dA\")\n        self.play(ReplacementTransform(surface_integral, final_answer))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates fractions using a chocolate bar metaphor. The chocolate bar should be divided into 12 equal squares, representing the whole. The animation should start with a title saying \"1 de um total de 12 peda\u00e7os\" in a light red color, followed by the fraction 1/12 also in light red. The chocolate bar should initially be off-screen to the right and smoothly move into the center. Once in place, one square from the top row should lift slightly to visually represent one part of the whole. Please animate the fraction appearing below the title and ensure that the square that lifted returns to its original position after a short moment. To conclude the animation, everything should shrink down and disappear. The background color of the animation should be a warm off-white, and the squares of the chocolate bar should look realistic with a lighter brown fill and darker brown stroke. Additionally, choose a color palette that uses pleasant and educational-friendly colors for the other elements as well.",
        "answer": "\\n from manim import *\n\n\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\n\ndef electron() -> Mobject:\n    return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)\n\n\ndef oxygen() -> Mobject:\n    list = []\n    start = 0.3\n    end = 0.6\n    list.append(Line(start=LEFT * start, end=LEFT * end))\n    list.append(Line(start=RIGHT * start, end=RIGHT * end))\n    list.append(Line(start=UP * start, end=UP * end))\n    list.append(Line(start=DOWN * start, end=DOWN * end))\n    list = map(lambda x: x.set_opacity(0.7), list)\n    return VGroup(circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)\n\n\ndef metal() -> Mobject:\n    return circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n\ndef metal_oxid(rows: int, cols: int, scale=1.5) -> Mobject:\n    list = []\n    for i in range(rows):\n        for j in range(cols):\n            if (j + i) % 2 == 0:\n                list.append(oxygen().set_x(i / scale).set_y(j / scale))\n            else:\n                list.append(metal().set_x(i / scale).set_y(j / scale))\n    return VGroup(*list).set_x(0).set_y(0)"
    },
    {
        "query": "Can you create an educational animation that demonstrates dividing a rectangle and a circle into equal parts, with different colors to distinguish the divided areas, and include a title that says \"Divided into equal parts\" with part of the title in a unique color? Also, make sure the animation is suitable for a vertical format video, like those found on mobile platforms.",
        "answer": "\\n from manim import *\n\nclass AVLTree(VGroup):\n    def __init__(self, scene, node_radius=0.4, balance_factor=2):\n        super().__init__()\n        self.scene = scene\n        self.node_radius = node_radius\n        self.balance_factor = balance_factor\n        self.root = None\n\n    class AVLNode:\n        def __init__(self, value, node_radius, balance_factor):\n            self.value = value\n            self.height = 1\n            self.balance = 0\n            self.node = None\n            self.edge_left = None\n            self.edge_right = None\n            self.node_visual = Circle(radius=node_radius, color=WHITE).set_fill(GREEN, opacity=1)\n            self.label_visual = MathTex(str(value))\n            self.node_radius = node_radius\n            self.balance_factor = balance_factor\n            self.left = None\n            self.right = None\n\n        def update_heights(self):\n            left_height = self.left.height if self.left else 0\n            right_height = self.right.height if self.right else 0\n            self.height = 1 + max(left_height, right_height)\n\n        def update_balances(self):\n            left_height = self.left.height if self.left else 0\n            right_height = self.right.height if self.right else 0\n            self.balance = left_height - right_height\n\n        def update_visuals(self, center_point):\n            self.node_visual.move_to(center_point)\n            self.label_visual.move_to(center_point)\n\n    def insert(self, value, node=None):\n        if self.root is None:\n            self.root = self.AVLNode(value, self.node_radius, self.balance_factor)\n            self.root.update_visuals(ORIGIN)\n            self.add(self.root.node_visual, self.root.label_visual)\n            return\n\n        if node is None:\n            node = self.root\n\n        if value < node.value:\n            if node.left is None:\n                node.left = self.AVLNode(value, self.node_radius, self.balance_factor)\n                left_position = node.node_visual.get_center() + LEFT * node.node_radius * 2\n                node.left.update_visuals(left_position)\n                node.edge_left = Line(node.node_visual.get_center(), left_position)\n                self.add(node.left.node_visual, node.left.label_visual, node.edge_left)\n            else:\n                self.insert(value, node.left)\n        else:\n            if node.right is None:\n                node.right = self.AVLNode(value, self.node_radius, self.balance_factor)\n                right_position = node.node_visual.get_center() + RIGHT * node.node_radius * 2\n                node.right.update_visuals(right_position)\n                node.edge_right = Line(node.node_visual.get_center(), right_position)\n                self.add(node.right.node_visual, node.right.label_visual, node.edge_right)\n            else:\n                self.insert(value, node.right)\n\n        # Update the height and balance of ancestor node\n        node.update_heights()\n        node.update_balances()\n\n        # Balance the tree\n        node = self.rebalance(node)\n\n    def rotate_left(self, z):\n        y = z.right\n        T2 = y.left\n\n        y.left = z\n        z.right = T2\n\n        z.update_heights()\n        z.update_balances()\n        y.update_heights()\n        y.update_balances()\n\n        return y\n\n    def rotate_right(self, y):\n        z = y.left\n        T3 = z.right\n\n        z.right = y\n        y.left = T3\n\n        y.update_heights()\n        y.update_balances()\n        z.update_heights()\n        z.update_balances()\n\n        return z\n\n    def rebalance(self, node):\n        if node.balance < -self.balance_factor:\n            if node.right.balance > 0:\n                node.right = self.rotate_right(node.right)\n                return self.rotate_left(node)\n            return self.rotate_left(node)\n\n        if node.balance > self.balance_factor:\n            if node.left.balance < 0:\n                node.left = self.rotate_left(node.left)\n                return self.rotate_right(node)\n            return self.rotate_right(node)\n\n        return node\n\n\nclass AVLScene(Scene):\n    def construct(self):\n        avl_tree = AVLTree(self)\n        self.add(avl_tree)\n        values = [30, 40, 50, 60, 70, 75]\n        for value in values:\n            avl_tree.insert(value)\n            self.wait(0.5)  # Pause between insertions for visual effect\n        self.wait(2)  # Wait before the scene exits"
    },
    {
        "query": "Create an animated video in which the background is a light beige color, and the primary text color is dark grey. I'd like to see a visual representation of the fractions 3/5 with three orange triangles and two black triangles, arranged side by side with the orange triangles rotating to form a pattern. On each triangle, place a digit from 1 to 5 in a specific sequence: digits 1, 2, and 3 on orange triangles and digits 4 and 5 on black triangles, all in dark grey.\n\nThe video should begin with all triangles off-screen to the right. Then, the group of triangles should smoothly move leftward into the frame. After settling in the center, the digits 1, 2, and 3 should be written one after each other on the corresponding triangles. Once they're all visible, the orange triangles should move upwards slightly, carrying the digits with them. Subsequently, write the fraction 3/5 below the triangles and animate it to emphasize the number 3 by changing its color to match the orange triangles and scaling the slash to double its size.\n\nAfter that, fade out the first three digits, and rewrite the sequence of five digits across all triangles with the same dark grey color. When this is complete, finish writing the fraction by adding its denominator, and then fade out the digit sequence. Finally, slide the entire scene off to the left and clear the screen. The overall theme should maintain a modern, flat design aesthetic with sharp colors like red, green, and blue mixing well together throughout the animation.",
        "answer": "\\n from manim import *\n\nclass SimpleHarmonicOscillator(Scene):\n    def construct(self):\n        # Displaying the differential equation\n        diff_eq = MathTex(r\"m\\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Explain the variables\n        variables_explanation = Text(\"m: mass, k: spring constant\", font_size=24).to_edge(UP)\n        self.play(FadeIn(variables_explanation, shift=UP))\n        self.wait(2)\n\n        # Formation of the characteristic equation\n        char_eq = MathTex(r\"\\lambda^2 + \\frac{k}{m} = 0\")\n        self.play(ReplacementTransform(diff_eq.copy(), char_eq))\n        self.wait(1)\n\n        # Explain characteristic equation\n        explanation = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(variables_explanation, explanation))\n        self.wait(2)\n\n        # Characteristic roots\n        roots = MathTex(r\"\\lambda = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution for the oscillator\n        general_solution = MathTex(r\"x(t) = A\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + B\\sin\\left(\\sqrt{\\frac{k}{m}}t\\right)\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation2 = Text(\"General solution for simple harmonic motion\", font_size=24).to_edge(UP)\n        self.play(Transform(variables_explanation, explanation2))\n        self.wait(2)\n\n        # Clear the scene and show only the general solution\n        self.clear()\n        final_message = Text(\"Visualizing Simple Harmonic Motion\", font_size=32)\n        self.play(FadeIn(final_message, shift=UP))\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that starts with a vertical arrangement of geometric shapes, specifically three sets of rectangles, displayed on a light beige background. The first and third sets should have a black rectangle on each side with a red-filled rectangle in the middle. For the second set, both rectangles should be red-filled. On the second stage, numbers from 1 to 6 should be displayed sequentially on top of the corresponding red rectangles, followed by a fraction appearing to the right, showing 6 over 10 with the numerator in red. After that, I'd like the numbers to fade away and a new set of numbers, from 1 to 10, to appear on each rectangle, regardless of the color. The remaining part of the fraction should also be shown, and then all the numbers fade out. The animation should conclude by moving everything offscreen to the left.",
        "answer": "\\n from manim import *\n\nclass Atom(VMobject):\n    def __init__(self, label, radius=0.2, color=BLUE, label_color=WHITE, **kwargs):\n        super().__init__(**kwargs)\n        self.circle = Circle(radius=radius, color=color)\n        self.label = Tex(label, color=label_color).scale(0.5)\n        self.add(self.circle, self.label)\n\n    def set_label(self, new_label):\n        self.label.become(Tex(new_label).scale(0.5))\n        return self\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        grid = VGroup()\n        for x in range(-5, 6):\n            for y in range(-3, 4):\n                atom = Atom(label=\"H\", radius=0.3, color=RED)\n                atom.move_to(x*0.6*RIGHT + y*0.6*UP)\n                grid.add(atom)\n\n        self.play(Create(grid))\n        self.wait()\n\n        # Animate the change of all atoms labels to \"He\"\n        for atom in grid:\n            self.play(atom.set_label(\"He\"), run_time=0.1)\n        self.wait()"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates different fractions using the metaphor of slicing pizzas. The pizzas should be represented as colorful circles with pepperoni, and then portions should be visually removed or highlighted to show 1 whole, 1/2, 3/4, 3/6, and 4/7 fraction parts. Each of these fractions should be introduced one after the other with a corresponding written fraction appearing next to them. After showing all fractions, I want to focus on the 3/4 pizza, rotate and shift it to the center, while the rest fade away. Additionally, I'd like to indicate which part of the written \"3/4\" fraction represents the numerator and which part represents the denominator with arrows and labels. Lastly, once that part of the animation is finished, could all the elements on the screen be cleaned up in preparation for a new scene?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.become\").shift(UP*2.5)), run_time=0.5)\n            circ = Circle(fill_color=RED, fill_opacity=0.8).shift(RIGHT*1.5)\n            square = Square(fill_color=BLUE, fill_opacity=0.2).shift(LEFT*1.5)\n            self.add(circ,square)\n            self.wait(0.5)\n            self.play(circ.animate.become(square))\n            self.remove(circ,square)"
    },
    {
        "query": "I would like to see an educational animation that helps visualize division of the number 5 by numbers from 1 to 5. It should show the quotient and the remainder for each division, and these calculations should be color-coded for easy understanding. Also, I want the animation to highlight the divisions by 1 and 5 with a surrounding red rectangle to emphasize that they yield no remainder. Can the background be a light cream color, and the main text in a dark grey to contrast with the background? All numbers should be large and easily readable, and please ensure a smooth transition between each division being displayed. Can the final scene gracefully fade out all elements at the end?",
        "answer": "\\n from manim import *\n\nclass ChemicalAnimation(Scene):\n    def construct(self):\n        # Create a grid of alternating oxygen and metal ions\n        grid = metal_oxid(3, 3)\n        self.play(FadeIn(grid))\n        \n        # Add an electron moving through the grid\n        e = electron()\n        self.play(FadeIn(e))\n        path_points = [\n            UP * 0.5 + LEFT * 0.5,\n            UP * 0.5 + RIGHT * 1.5,\n            DOWN * 1.5 + RIGHT * 1.5,\n            DOWN * 1.5 + LEFT * 0.5,\n            UP * 0.5 + LEFT * 0.5\n        ]\n        self.play(*move_along_complex_path(e, [2], path_points, run_time=2))\n        \n        # Display positive and negative ions\n        positive_ion = positive()\n        negative_ion = negative()\n        self.play(FadeIn(positive_ion), FadeIn(negative_ion))\n        self.play(positive_ion.animate.move_to(UP * 2), negative_ion.animate.move_to(DOWN * 2))\n        \n        # Add a lithium_grid\n        lithium = lithium_grid(2, 2)\n        self.play(FadeIn(lithium))\n        self.play(lithium.animate.move_to(RIGHT * 3))\n        \n        # Add a carbon grid\n        carbon_lattice = carbon_grid(2)\n        self.play(FadeIn(carbon_lattice))\n        self.play(carbon_lattice.animate.move_to(LEFT * 3))\n        \n        # Wait to see the full animation before exiting\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation that displays the sentence \"Existem infinitos n\u00fameros primos!\" with the word \"infinitos\" highlighted in purple, on a light beige background and the rest of the text in a dark gray color? After the sentence appears, I want it to stay on the screen for a moment and then shrink down to disappear. Also, please set the video dimensions suitable for a vertical orientation, like a mobile phone screen.",
        "answer": "\\n from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint\\limits_S\", r\" \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"First, parameterize the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization step\n        parametrization = MathTex(r\"\\vec{r}(u, v) = u\\vec{i} + v\\vec{j} + f(u,v)\\vec{k}\")\n        self.play(ReplacementTransform(problem.copy(), parametrization))\n        self.wait(2)\n\n        # Explanation for the dot product with the normal vector\n        explanation2 = Text(\"Compute the dot product of F and the normal vector\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Dot product step\n        dot_product = MathTex(r\"\\vec{F} \\cdot (r_u \\times r_v)\")\n        self.play(ReplacementTransform(parametrization, dot_product))\n        self.wait(2)\n\n        # Explanation for integral calculation\n        explanation3 = Text(\"Evaluate the double integral over the region D\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Integral calculation\n        integral_calculation = MathTex(r\"\\iint\\limits_D\", r\" \\vec{F} \\cdot (r_u \\times r_v) \\,du \\,dv\")\n        self.play(ReplacementTransform(dot_product, integral_calculation))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"\\text{Flux} = \\int\\int_D ... \\,du \\,dv\")\n        self.play(ReplacementTransform(integral_calculation, final_answer))\n        self.wait(1)\n\n        # Conclusion of the scene\n        self.clear()\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an educational animation using illustrated animals to discuss the concept of prime numbers. The animation should have a soft-colored background, and it should be in a vertical format suitable for a smartphone screen. Start with an image of the first animal on the left side of the screen and a speech bubble that says \"What are prime numbers?\" Then, the second animal should appear from the right side with its speech bubble explaining \"They are numbers that have only two divisors,\" followed by the rest of the explanation popping up separately saying \"1 and itself.\" Lastly, a third animal asks, \"Is the number five prime?\" Each animal and their speech bubbles should slide into the center of the screen when it's their turn to speak and slide out when they're done. Use friendly and warm colors for the speech bubbles to make the animation engaging for learners. Can you create this animation for me?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the function and its graph\n        f = lambda x: 0.1 * x ** 2\n        graph = FunctionGraph(f, x_range=[0, 10])\n        area = graph.get_area(x_range=[2, 8], color=BLUE, opacity=0.5)\n\n        # Display function and area under curve\n        self.play(Create(graph), run_time=2)\n        self.play(FadeIn(area, scale=0.3), run_time=2)\n        self.wait(1)\n\n        # Show area calculation\n        problem = MathTex(r\"\\int_2^8 0.1x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the area under the curve\n        explanation = Text(\"Area between 2 and 8\", font_size=24).next_to(area, UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Calculate the area\n        integral_calculation = MathTex(r\"= \\left[\\frac{0.1}{3}x^3\\right]_2^8\")\n        self.play(Transform(problem, integral_calculation))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\frac{0.1}{3}(8^3 - 2^3)\", r\"= \\frac{0.1}{3}(512 - 8)\", r\"= \\frac{0.1}{3}(504)\", r\"= 16.8\")\n        self.play(ReplacementTransform(integral_calculation, final_answer))\n        self.wait(1)\n\n        # Conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video where the background is a soft beige color and contains a character represented by an image file named \"Asset 1.png\" on the left side of the screen. The character should have a speech bubble with a brown background and white text, saying \"Is the number six prime?\" in two lines. The speech bubble should appear to be a combination of a rounded rectangle and a small polygon that resembles the tail of the speech bubble. The entire animation should have the character, speech bubble, and text slide in from the left to the center of the screen smoothly. After pausing for a moment with everything visible, they should all slide back out to the left and disappear. The overall feel of the animation should be gentle and have a hand-drawn aesthetic. The colors used for the text and other features should be soft and not overly bright, with a preference for pastel tones.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_1^3\", r\"x^3\", r\"\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Use the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        power_rule_definite = MathTex(r\"\\int_a^b\", r\"x^n \\,dx\", r\"=\", r\"\\left[\\frac{x^{n+1}}{n+1}\\right]_a^b\")\n        self.play(Write(power_rule_definite))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"=\", r\"\\left[\\frac{x^{3+1}}{3+1}\\right]_1^3\")\n        self.play(ReplacementTransform(problem[1].copy(), solution1[1]))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution step 1\n        final_solution_step1 = MathTex(r\"=\", r\"\\left[\\frac{x^4}{4}\\right]_1^3\")\n        self.play(ReplacementTransform(solution1, final_solution_step1))\n        self.wait(1)\n\n        # Final solution step 2\n        final_solution_step2 = MathTex(r\"=\", r\"\\frac{3^4}{4}\", r\"-\", r\"\\frac{1^4}{4}\")\n        self.play(ReplacementTransform(final_solution_step1, final_solution_step2))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"=\", r\"\\frac{80}{4}\")\n        self.play(ReplacementTransform(final_solution_step2, final_solution))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"= 20\")\n        self.play(ReplacementTransform(final_solution, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final result\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an educational animation video that teaches division with the number 6. Can you show each division from 1 to 6, represent each division as both a fraction and a calculation, display them with clear and colorful visuals, and highlight the results that divide evenly by surrounding them with red boxes? I'd also appreciate smooth transitions and fades between the divisions to keep the presentation engaging.",
        "answer": "\\n from manim import *\n\nclass DifferentialEquationSolution(Scene):\n    def construct(self):\n        equation = MathTex(r\"\\frac{dy}{dx}\", \"=\", r\"x^2 - y^2\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        step1 = Tex(\"Separate the variables: $\\\\frac{dy}{y^2} = x^2dx$\")\n        self.play(Write(step1))\n        self.wait(1)\n\n        step2 = Tex(\"Integrate both sides: $\\\\int \\\\frac{dy}{y^2} = \\\\int x^2dx$\")\n        self.play(Write(step2))\n        self.wait(1)\n\n        step3 = MathTex(r\"- \\frac{1}{y}\", \"=\", r\"\\frac{x^3}{3} + C\")\n        self.play(Write(step3))\n        self.wait(1)"
    },
    {
        "query": "Create an educational animation that discusses what the smallest prime number is. The setting should be a continuous conversation between three cartoon animals, each appearing from off-screen one after the other to chime in with their part of the explanation. Use a soft and calming pastel color palette for the background and the speech bubbles. Have the first animal appear with a speech bubble asking what the smallest prime number is, then move off-screen as the second animal appears with a speech bubble to share that the smallest prime number is two. Finally, the third animal should correct the common misconception that one is a prime number by stating it isn't because it only has one divisor. Ensure each character's speech bubble and corresponding text moves in sync with them as they enter and exit the screen. After each character has spoken and moved off-screen, the scene should end with a clear view of the background.",
        "answer": "\\n from manim import *\n\nclass MoleculeAnimation(Scene):\n    def construct(self):\n        # Create a group of molecules in a grid\n        molecule_group = self.create_molecule_grid(rows=4, cols=4)\n        # Animate the group of molecules\n        self.play(FadeIn(molecule_group, shift=UP))\n        self.wait(1)\n        self.play(Rotate(molecule_group, angle=PI/2))\n        self.wait(1)\n        self.play(FadeOut(molecule_group, shift=DOWN))\n\n    def hydrogen_molecule(self) -> Mobject:\n        # Create a group of two hydrogen atoms\n        left_hydrogen = circle_with_text(0.25, \"H\", color=BLUE, font_size=24, font_color=WHITE, stroke_width=1, fill_color=BLUE)\n        right_hydrogen = circle_with_text(0.25, \"H\", color=BLUE, font_size=24, font_color=WHITE, stroke_width=1, fill_color=BLUE)\n        right_hydrogen.next_to(left_hydrogen, RIGHT, buff=0.5)\n        bond = Line(left_hydrogen.get_center(), right_hydrogen.get_center()).set_stroke(width=2)\n        return VGroup(left_hydrogen, bond, right_hydrogen)\n\n    def create_molecule_grid(self, rows: int, cols: int) -> VGroup:\n        # Create a grid of hydrogen molecules\n        molecule_group = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                molecule = self.hydrogen_molecule()\n                molecule.move_to(np.array([i - rows / 2, j - cols / 2, 0]))\n                molecule_group.add(molecule)\n        return molecule_group\n    \n    def circle_with_text(self, r: float, txt: str, color=WHITE, font_size: int = 24, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE) -> Mobject:\n        # Create a circle with text in the center\n        c = Circle(radius=r, color=color)\n        c.set_fill(color=fill_color, opacity=1)\n        c.set_stroke(color=color, width=stroke_width)\n        t = Text(txt, font_size=font_size, color=font_color)\n        t.move_to(c.get_center())\n        return VGroup(c, t)"
    },
    {
        "query": "Can you create an animated video displaying the first ten prime numbers in Portuguese, with a visually appealing color scheme, on a 9x16 vertical frame suitable for a smartphone wallpaper video, where each prime number appears one after the other with a smooth drawing animation and then all of them scale down to disappear at the end?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Integration limits\n        limits = MathTex(r\"[0, 2]\")\n        self.play(FadeIn(limits.next_to(problem, DOWN)))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Use the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(1)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(1)\n\n        # Performing the integration\n        solution_step1 = MathTex(r\"= \\frac{x^{3}}{3} \\Big|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution_step1))\n        self.wait(1)\n\n        # Explanation for evaluation at limits\n        explanation2 = Text(\"Evaluate at limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(1)\n\n        # Evaluating the solution\n        solution_step2 = MathTex(r\"= \\frac{2^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(ReplacementTransform(solution_step1, solution_step2))\n        self.wait(1)\n\n        # Final calculation\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(solution_step2, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation video that teaches viewers about prime numbers. In the video, I want to have a gentle, pastel color background, and the text displaying the numbers should be in a neutral dark color that is easy to read. Then, I would like prime numbers to be highlighted one color, let's say a light red, and composite numbers (non-primes) in another color, maybe light blue. The composite numbers should be shown as a product of their factors to emphasize the difference between primes and composites. Can we also have the animation run with each of these numbers and their descriptions appearing in a list, with a moderate pause after they have all appeared, before disappearing again? I'm looking for a video format suitable for mobile screens, so the aspect ratio should be portrait rather than the traditional landscape.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesScene(Scene):\n    def construct(self):\n        title = Text(\"Fourier Series\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction of a square wave\n        square_wave_text = Text(\"Consider a square wave signal:\", font_size=24).shift(UP*2)\n        signal_formula = MathTex(r\"f(x) = \\begin{cases} \n        1 & \\text{if } 0 \\leq x < \\frac{1}{2} \\\\\n        -1 & \\text{if } \\frac{1}{2} \\leq x < 1 \n        \\end{cases}\", substrings_to_isolate=\"x\")\n        signal_formula.next_to(square_wave_text, DOWN)\n\n        self.play(FadeIn(square_wave_text))\n        self.play(Write(signal_formula))\n        self.wait(2)\n\n        # Introduction of the Fourier series formula\n        fouriers_series_text = Text(\"Its Fourier series expansion is given by:\", font_size=24).shift(UP*2)\n        formula = MathTex(r\"f(x) \\sim \\frac{4}{\\pi}\\sum_{n=1,3,5}^{\\infty}\\frac{1}{n}\\sin(2\\pi nx)\", substrings_to_isolate=\"x\")\n        formula.next_to(fouriers_series_text, DOWN)\n\n        self.play(Transform(square_wave_text, fouriers_series_text))\n        self.play(Transform(signal_formula, formula))\n        self.wait(2)\n\n        # Show partial sum of Fourier series\n        partial_sum_text = Text(\"Partial sum of the series:\", font_size=24).shift(UP*2)\n        partial_sum_formula = MathTex(r\"S_N(x) = \\frac{4}{\\pi}\\sum_{n=1,3,5}^{N}\\frac{1}{n}\\sin(2\\pi nx)\", substrings_to_isolate=\"N\")\n        partial_sum_formula.next_to(partial_sum_text, DOWN)\n\n        self.play(Transform(square_wave_text, partial_sum_text))\n        self.play(Transform(signal_formula, partial_sum_formula))\n        self.wait(2)\n\n        # Clear the scene and finish\n        self.clear()\n        conclusion_text = Text(\"This is an example of Fourier Series approximation.\", font_size=24)\n        self.play(Write(conclusion_text))\n        self.wait(2)"
    },
    {
        "query": "I want to create an educational video animation highlighting basic algebra operations. The video should be in portrait mode, perfect for a smartphone screen. Can you design it with a pleasing pastel color scheme, making sure the background and text are easy on the eyes? I need the animation to begin with an image representing the first algebraic operation, followed by the operation itself, \"+ 6 = 12,\" displayed next to it. Then the operation should transition to emphasize the \"6\" on the left-hand side in a different color, and this should morph to form a bold and distinctly colored algebraic statement, to indicate it's the start of the equation. After this, I would like an image representing the conclusion, featuring simply \"= 6\", to appear with a spin effect but smaller in size than the previous ones. Each step should sequentially arrange itself one below the other with some space in between. Lastly, the entire set of elements should slide off the screen to the left, concluding the animation.",
        "answer": "\\n from manim import *\n\nfrom manim_physics import *\n\nclass MultiPendulumExample(SpaceScene):\n    def construct(self):\n        p = MultiPendulum(RIGHT, LEFT)\n        self.add(p)\n        self.make_rigid_body(*p.bobs)\n        p.start_swinging()\n        self.add(TracedPath(p.bobs[-1].get_center, stroke_color=BLUE))\n        self.wait(10)"
    },
    {
        "query": "I'd like to create an educational animation that teaches algebra through the visual illustration of a simple equation solving process. The animation should start with a representation of an unknown value multiplied by 6 to equal 24, then gradually reveal that the unknown value is 4. I want the animation to include visual elements such as images, along with the text of the equations.\n\nThe unknown value should initially be represented by a visual placeholder image, then in subsequent steps by the letter 'a' highlighted in orange, and finally, it should be revealed to be the number 4, again highlighted in orange. I want each step of the equation to appear one after the other by shifting into view, and then transform smoothly into the next step.\n\nOnce the value of the unknown is found, both the image with the equation and the equation in the text form, which proves that 'a' is equal to 4, should appear with a special spinning effect. After the final result is shown, all elements should shift out of view to conclude the animation.\n\nFor the color scheme, let's use a light beige for the background, and various colors like light red, green, blue, etc., for other elements as per a provided color palette. The final animation should be in a portrait format, suitable for viewing on a smartphone screen.\n\nCan you create this animation that visually demonstrates the process of solving the equation \"a times 6 equals 24\" to find out that 'a' is equal to 4, using engaging visual and transformation effects?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iiint_V x^2 y^2 z \\,dV\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for z integral\n        explanation1 = Text(\"Integrate with respect to z first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Z integral step\n        z_integral = MathTex(r\"= \\iint_A x^2 y^2 \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}dA\")\n        self.play(ReplacementTransform(problem.copy(), z_integral))\n        self.wait(1)\n\n        # Explanation for y integral\n        explanation2 = Text(\"Then, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Y integral step\n        y_integral = MathTex(r\"= \\int_B x^2 \\left[\\frac{1}{3}y^3\\right]_{y_1}^{y_2} \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}dx\")\n        self.play(ReplacementTransform(z_integral, y_integral))\n        self.wait(1)\n\n        # Explanation for x integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # X integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{4}x^4\\right]_{x_1}^{x_2} \\left[\\frac{1}{3}y^3\\right]_{y_1}^{y_2} \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}\")\n        self.play(ReplacementTransform(y_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an educational video that visualizes the process of solving simple algebraic equations with single variables. Specifically, I want the video to animate three separate algebra problems, each showing the initial equation and then the solved variable below it. Each of these problems should be enclosed in a colorful dashed box. The problems and solutions I want to demonstrate are:\n\n1. \"x + 3 = 5\" with the solution \"x = 2\"\n2. \"9 - d = 2\" with the solution \"d = 7\"\n3. \"2 . a = 6\" with the solution \"a = 3\"\n\nFor the animation itself, I'd like each equation set to appear one at a time with a spinning effect, pausing a moment on each to give viewers time to see the solved equation. After all the problems have been presented, the group of equations should slide off to the left side of the screen, finishing the animation. \n\nThe overall video should have a friendly and light appearance with a warm-toned background. Please use a variety of soft colors for the boxes and dark text to make the equations easy to read. The video will be in portrait mode, suitable for viewing on mobile devices. Can you help me create this animated math tutorial?",
        "answer": "\\n from manim import *\n\nclass CircularMotionExample(Scene):\n    def construct(self):\n        # Write the equation of the motion\n        equation = MathTex(r\"m \\vec{a} = m \\vec{g} + \\vec{T}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explain the terms in the equation\n        terms_explanation = Text(\"Where m is mass, a is acceleration,\\ng is gravity, and T is tension\", font_size=24).to_edge(UP)\n        self.play(FadeIn(terms_explanation, shift=UP))\n        self.wait(2)\n\n        # Transforming equation into circular motion specific form\n        circular_eq = MathTex(r\"m \\frac{v^2}{r} = m g \\cos(\\theta) + T\")\n        self.play(ReplacementTransform(equation.copy(), circular_eq))\n        self.wait(1)\n\n        # Explain circular motion equation\n        explanation1 = Text(\"Equation for circular motion in a vertical plane\", font_size=24).to_edge(UP)\n        self.play(Transform(terms_explanation, explanation1))\n        self.wait(2)\n\n        # Derive the expression for tension T\n        tension_eq = MathTex(r\"T = \\frac{m v^2}{r} - m g \\cos(\\theta)\")\n        self.play(ReplacementTransform(circular_eq.copy(), tension_eq))\n        self.wait(1)\n\n        # A visual representation of circular motion\n        circle = Circle(radius=1.5, color=BLUE)\n        dot = Dot(radius=0.1, color=RED)\n        dot.move_to(circle.get_start())\n        path = TracedPath(dot.get_center, stroke_width=2, stroke_color=RED)\n        self.add(circle, dot, path)\n        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)\n        self.wait()\n\n        # Explain the tension in terms of circular motion\n        explanation2 = Text(\"Tension throughout the motion\", font_size=24).to_edge(UP)\n        self.play(Transform(terms_explanation, explanation2))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion_text = Text(\"This is the conclusion of circular motion example.\", font_size=24)\n        self.play(FadeIn(conclusion_text, shift=UP))\n        self.wait(1)"
    },
    {
        "query": "I would like an animated video that features a table with names and favorite fruits, which transitions into a colorful bar graph representing the count of people who favor each fruit. Can the table have black borders and black text with names like Pablo, Gabriela, Bianca, Murilo, Heitor, and Isabela paired with fruits such as Banana, Strawberry (Morango), and Orange (Laranja)? After the table appears, I want each fruit to be highlighted one by one in the table, with corresponding bars in a bar chart animating to show the quantity of people who prefer that fruit. The colors of the bars should be light yellow for bananas, light orange for oranges, and light red for strawberries. Also, include labels on both axes of the chart to indicate the type of fruit and the number of people. After completing the graph animation, all elements should fade out, leaving a blank screen. The background color throughout should be a soft cream, and please ensure the video format is suitable for a portrait orientation on mobile devices.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExpansion(Scene):\n    def construct(self):\n        # Introduction\n        intro_text = Tex(\"Fourier Series Expansion of a Periodic Function\")\n        self.play(Write(intro_text))\n        self.wait(1)\n\n        # Explanation of Fourier series\n        explanation = Tex(\"A periodic function can be expressed as the sum of\\\\\\\\\",\n                          \"sines and cosines of different frequencies.\")\n        explanation.next_to(intro_text, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Showing the formula\n        formula = MathTex(\"f"
    },
    {
        "query": "I would like an educational animation that displays a survey result for favorite fruits among a group of people. The video should be in portrait mode, suitable for mobile viewing. Begin with a nicely formatted table showing names and their corresponding favorite fruit. Use soft, pastel colors for the table and background to make it visually appealing.\n\nThe fruits listed include bananas, strawberries, and oranges. Next to the table, please show a segmented circle graph representing the quantities of each fruit choice within the group. For each fruit, display its segment growing in the graph to indicate the proportion of people who favor that fruit. Accompany the graph with a legend that uses colored squares to signify the corresponding fruit with labels next to them.\n\nAnimate the cells of the table highlighting corresponding names as the graph is being drawn for each fruit segment. Ensure that each cell highlights with the color corresponding to the fruit selected, and only remove the highlight after its segment on the graph is fully grown.\n\nOnce the graph is complete, shift the entire animation to the left and out of view, to potentially make space for additional content in the video if necessary. The colors, table, and graph should be modern and professional, aimed at delivering clear and informative content for an educational video.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral representing the area under the curve\n        integral_expr = MathTex(r\"\\int_0^3\", r\"x^2\", r\"\\,dx\")\n        self.play(Write(integral_expr))\n        self.wait(1)\n\n        # Highlight the function to integrate\n        function_highlight = SurroundingRectangle(integral_expr[1], color=YELLOW)\n        self.play(Create(function_highlight))\n        self.wait(1)\n\n        # Explain the definite integral represents area\n        explanation = Text(\"The definite integral represents the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Perform integration\n        integral_solution = MathTex(r\"=\\left[\\frac{x^3}{3}\\right]_0^3\")\n        self.play(ReplacementTransform(integral_expr, integral_solution))\n        self.wait(1)\n\n        # Calculate the final area value\n        final_area = MathTex(r\"= \\frac{3^3}{3} - \\frac{0^3}{3}\")\n        self.play(ReplacementTransform(integral_solution, final_area))\n        self.wait(1)\n\n        final_value = MathTex(r\"= 9\")\n        self.play(ReplacementTransform(final_area, final_value))\n        self.wait(1)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(final_value))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video graph that displays monthly profits in Brazilian reais for the first half of the year. The graph should have a vertical axis ranging from 0 to 9000 with 1000 unit increments, and a horizontal axis representing the months from January to June. Each month should have a labeled point indicating the profit for that month, and these points should be connected with lines. For a visual emphasis, I wish to sequentially highlight the points and lines between January to February, February to April, and April to June with a different color, making the dots and lines temporarily larger during the highlight. The animated sequence should start with the title \"Lucro mensal em reais\" fading in along with the axes, followed by the points appearing one after another, with auxiliary lines across the graph at each 1000 unit interval on the vertical axis. After the monthly profits for June are shown, and after the last highlight sequence, I would like all the graph contents to fade out gracefully. For design, I prefer a light background and dark axes, with clear but not overly bright colors for the data points and highlights.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Introduce the equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Show the wave equation label\n        label = Text(\"This is the wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(label))\n        self.wait(2)\n\n        # Describe the wave speed\n        wave_speed = Text(\"Here, \\(c\\) represents the wave speed.\", font_size=24)\n        wave_speed.next_to(label, DOWN)\n        self.play(Write(wave_speed))\n        self.wait(2)\n\n        # Transform to a 3D wave equation\n        equation_3d = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2}\\right)\")\n        self.play(Transform(equation, equation_3d))\n        self.wait(2)\n\n        # Acknowledge the 3D context\n        context_3d = Text(\"Now it's a 3D wave equation!\", font_size=24)\n        context_3d.next_to(label, DOWN)\n        self.play(Transform(wave_speed, context_3d))\n        self.wait(2)\n\n        # Provide an example solution\n        solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(equation_3d, solution))\n        self.wait(2)\n\n        # Explain the solution components\n        components = Text(\"Where \\(A\\) is amplitude, \\(k\\) is wave number, and \\(\\omega\\) is angular frequency.\", font_size=24)\n        components.to_edge(DOWN)\n        self.play(Write(components))\n        self.wait(2)\n\n        # Fade out everything to conclude\n        self.play(FadeOut(solution), FadeOut(components), FadeOut(wave_speed), FadeOut(label))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an educational animation that shows how multiplying fractions works. Can you produce a video where two fractions, 2/3 and 4/6, are displayed side by side? Above and below these fractions, can there be curved arrows pointing from the first fraction to the second, signifying that the second is a result of multiplying the first by 2? Include an \"equal\" sign after the second fraction. Additionally, animate the text \"Multiplied by 2\" to appear above the top arrow and below the bottom arrow to indicate what the multiplication factor is. Please ensure the animation has a clean background and the text and fractions are clearly visible and colorful. The video should be vertical, designed for a phone screen, and the animation should progress step by step to allow the concept to be clear for students learning to multiply fractions.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.shift\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            self.play(circle.animate.shift(UP), run_time=0.5)\n            self.play(circle.animate.shift(DOWN), run_time=0.5)\n            self.play(circle.animate.shift(LEFT), run_time=0.5)\n            self.play(circle.animate.shift(RIGHT), run_time=0.5)\n            self.remove(circle)"
    },
    {
        "query": "I would like to create a mathematical animation where two non-equivalent fractions, 3/6 and 9/12, are shown side by side on a vertical mobile phone screen orientation. Can you depict an upward curved arrow pointing from the first fraction to the second, with a label saying \"Multiplied by 3\", and a downward curved arrow pointing back at the first fraction with a label saying \"Multiplied by 2\"? Both arrows and their respective annotations should be in contrasting colors. Additionally, a \"not equal\" sign should appear between the two fractions to emphasize their non-equivalence, and after a brief pause, the entire scene should fade out.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.wag\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.wag())\n            self.remove(square)"
    },
    {
        "query": "I would like an educational animation that visually demonstrates the simplification of the fraction four-eighths to one-half and then its expansion to five-tenths. The animation should start with the fraction four-eighths on the left, and one-half in the middle, and end with five-tenths on the right. Above and below the first fraction, there should be blue-colored arrows curving towards the second fraction, with a text above that says \"Divided by 4\" and below it, indicating the simplification process. Similarly, there should be another set of blue arrows from one-half to five-tenths with text \"Multiplied by 5\" indicating the expansion process. Can the three fractions be large and the animation take place on a vertical screen layout like a smartphone screen? Also, add brief pauses to allow the viewer to follow along, and at the end of the demonstration, all elements should fade out, ending the animation.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Displaying the function\n        function_label = MathTex(r\"f(x) = x^2\").to_edge(UP)\n        self.play(Write(function_label))\n        self.wait(1)\n\n        # Plotting the function\n        graph = FunctionGraph(lambda x: x**2, x_range=[-2, 2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Specifying the area of interest\n        area_label = MathTex(r\"\\int_{0}^{1} x^2 \\,dx\").next_to(graph, DOWN)\n        self.play(Write(area_label))\n        self.wait(2)\n\n        # Coloring the area under the curve\n        area = graph.get_area(x_range=[0, 1], color=[BLUE, GREEN], opacity=0.5)\n        self.play(DrawBorderThenFill(area))\n        self.wait(2)\n\n        # Calculating the area\n        area_solution = MathTex(r\"=\\dfrac{1}{3}\").to_edge(DOWN)\n        self.play(ReplacementTransform(area_label, area_solution))\n        self.wait(1)\n\n        # Clear the scene and show the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(area_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational video animation that visually demonstrates the concept of division using the number six as an example. Specifically, I want to show the six possible division operations using the numbers one to six as divisors for the number six. Each division should be represented by its own image and these images should be arranged neatly on the screen, scaling them up a bit for better visibility.\n\nCan we have a sequence where each individual division fades in, one after the other, creating a dynamic entrance? After all the divisions are displayed, I would like to highlight the results of the divisions by one, two, three, and six with a colored square surrounding those particular divisions, drawing attention to them.\n\nOnce highlighted, let's hold the view for a short while so viewers can take in the information, and then conclude the scene by fading out all of the elements together quickly.\n\nFor a professional look, could we have the video in the portrait mode (9:16 aspect ratio) commonly used on mobile phones, and set a background color that is easy on the eyes?",
        "answer": "\\n class SquareToCircle(Scene):\n    def construct(self):\n        square = Square()  # Create a square\n        circle = Circle()  # Create a circle\n        circle.set_fill(PINK, opacity=0.5)  # Set the color and transparency for the circle\n\n        self.play(Create(square))  # Animate the creation of the square\n        self.play(Transform(square, circle))  # Animate the square turning into a circle\n        self.play(FadeOut(square))  # Animate the fading out of the circle (originally the square)"
    },
    {
        "query": "Could you create a vertical animation that shows all the unique ways to divide the number 10, displaying one-by-one, with the divisors and the results of each division getting larger, and then highlighting the divisors 1, 2, 5, and 10 with a red border before everything fades out? The background color should be customizable, and the animation should be suitable for a 1080x1920 portrait video format with the aspect ratio maintained at 9:16.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\frac{1}{2}xy \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{4}x \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you please create a 3D animation that shows a magnetic field around a horizontal circular wire to visually demonstrate the concept of electromagnetism?",
        "answer": "\\n from manim import *\n\nclass CosineGraphScene(Scene):\n    def construct(self):\n        # Create a cosine graph\n        axes = Axes(\n            x_range=[-4, 4],\n            y_range=[-2, 2],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.get_graph(lambda x: np.cos(x), color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='\\\\cos(x)')\n\n        # Display the graph\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(2)\n\n        # Derivative of cosine\n        derivative = axes.get_graph(lambda x: -np.sin(x), color=GREEN)\n        derivative_label = axes.get_graph_label(derivative, label=\"\\\\text{Derivative of } \\\\cos(x)\")\n\n        # Show the derivative\n        self.play(Create(derivative), Write(derivative_label))\n        self.wait(2)\n\n        # Antiderivative of cosine\n        antiderivative = axes.get_graph(lambda x: np.sin(x), color=PINK)\n        antiderivative_label = axes.get_graph_label(antiderivative, label=\"\\\\text{Antiderivative of } \\\\cos(x)\")\n\n        # Show the antiderivative\n        self.play(Transform(graph, antiderivative), Transform(graph_label, antiderivative_label))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Ending message\n        end_text = Text(\"This is the graph of cosine and its derivatives\", font_size=24)\n        self.play(Write(end_text))\n        self.wait(2)"
    },
    {
        "query": "Can you create a 3D animation that shows a magnetic field generated by an electric current in a circular wire, with the ability to view the setup from different angles?",
        "answer": "\\n from manim import *\n\nclass PlanetaryMotion(ThreeDScene):\n    def construct(self):\n        sun = Sphere(radius=0.5, color=YELLOW).shift(LEFT * 2)\n        earth = Sphere(radius=0.2, color=BLUE).shift(RIGHT * 3)\n\n        self.play(FadeIn(sun), FadeIn(earth))\n        description = Tex(\"The Earth orbits around the Sun due to gravitational forces.\")\n        self.play(Write(description))\n        self.wait(1)\n\n        orbit = Ellipse(width=6, height=3, color=WHITE)\n        self.play(ShowCreation(orbit))\n        self.wait(1)\n\n        self.play(Rotating(earth, about_point=sun.get_center(), run_time=5))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using ManimCE that illustrates how light rays interact with a pair of lenses? The lenses should be displayed as blue and semi-transparent, and there should be one on the left and one on the right of the screen. Please show multiple red light rays originating from the left side traveling horizontally across the screen with varying vertical starting positions to demonstrate the different paths the rays take after passing through both lenses.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-1, 5], y_range=[-1, 6], axis_config={\"color\": BLUE})\n        graph = axes.plot(lambda x: 0.1 * (x - 2)**2 + 1, color=GREEN)\n        area = axes.get_area(graph, x_range=(0,4), color=GREY, opacity=0.5)\n        label = MathTex(r\"f(x) = 0.1(x-2)^2 + 1\").next_to(graph, UP)\n\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.play(Write(label))\n        self.wait(2)\n\n        # Explanation of the area calculation\n        explanation = Text(\"This shaded area represents the integral from 0 to 4\",\n                           font_size=24).to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Calculation of the area\n        calculation = MathTex(r\"\\int_0^4 0.1(x-2)^2 + 1 \\,dx\")\n        self.play(ReplacementTransform(label.copy(), calculation), FadeOut(explanation))\n        self.wait(1)\n\n        # Solution\n        solution = MathTex(r\"A = \\frac{8}{3} + 4\")\n        self.play(ReplacementTransform(calculation, solution))\n        self.wait(2)\n\n        # Clear the scene and show only the solution\n        self.clear()\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create a simple animated physics demonstration showing two objects falling under the influence of gravity and coming to rest on the ground within an enclosed space. The first object should be a red circle that falls slightly to the right, and the second object should be a yellow square that starts higher up and is rotated 45 degrees. The square should also be half the size of the circle. The scene should have visible walls and a ground to contain the objects. Can you show these objects as they fall and then come to rest on the ground due to gravity, playing out for 5 seconds?",
        "answer": "\\n ```python\nfrom manim import *\n\nclass NeocognitronScene(ThreeDScene):\n    def construct(self):\n        num_neurons = [3, 4, 2]  # Define the number of neurons in each layer\n\n        layers = VGroup()  # Group to hold all layers\n\n        # Iterate over each layer and create the neurons\n        for i, num in enumerate(num_neurons):\n            layer = VGroup()\n            for n in range(num):\n                neuron = Sphere(radius=0.2, resolution=(20, 20))\n                neuron.set_color(BLUE)\n                if layer.submobjects:\n                    neuron.next_to(layer[-1], DOWN, buff=0.5)\n                layer.add(neuron)\n            layers.add(layer)\n\n        # Align layers from left to right\n        layers.arrange(RIGHT, buff=1.0)\n\n        # Draw edges between neurons in adjacent layers\n        edges = VGroup()\n        for i in range(len(num_neurons) - 1):\n            for n_prev in layers[i]:\n                for n_next in layers[i + 1]:\n                    edge = Line(n_prev.get_center(), n_next.get_center(), buff=0.2)\n                    edge.set_stroke(BLACK, 1.5)\n                    edges.add(edge)\n\n        # Create the self-contained neural network group\n        neural_network = VGroup(layers, edges)\n\n        neural_network.move_to(ORIGIN)  # Center the network\n        self.add(neural_network)  # Add network to the scene\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)  # Adjust camera\n\n```"
    },
    {
        "query": "I would like to see an animation of a double pendulum system with the behavior of chaos theory visualized through the motion of the pendulums, including a trace of the path that the end of the second pendulum takes. I'm interested in physics and I've heard about chaotic systems, so please make sure the swinging motion is included and emphasize the unpredictability with a colored path that follows the last bob of the pendulum. Can you create something like this and let it run for a substantial amount of time so I can observe the pattern it creates?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer, EmbeddingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 720\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass VAECodeSnippetScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make Neural Network\n            nn = NeuralNetwork([\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ], layer_spacing=0.1)\n            # Play animation\n            self.play(nn.make_forward_pass_animation())\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            # background_stroke_color=WHITE,\n            insert_line_no=False,\n            background=\"window\",\n            # font=\"Monospace\",\n            style=\"one-dark\",\n            language=\"py\",\n        )\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\", point_radius=0.04).scale(\n            1.0\n        )\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ],\n            layer_spacing=0.1,\n        )\n\n        nn.scale(1.1)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        # nn.rotate(-PI/2)\n        # nn.all_layers[0].image_mobject.rotate(PI/2)\n        # nn.all_layers[0].image_mobject.shift([0, -0.4, 0])\n        # nn.all_layers[-1].image_mobject.rotate(PI/2)\n        # nn.all_layers[-1].image_mobject.shift([0, -0.4, 0])\n        nn.shift([0, -1.4, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(0.52)\n        code_snippet.shift([0, 1.25, 0])\n        # code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(), run_time=10)\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Neural Network\n    nn_scene = VAECodeSnippetScene()\n    nn_scene.render()"
    },
    {
        "query": "I would like to see an animation of multiple pendulums with different lengths swinging at the same time, where they all start swinging together and continue for a while so I can observe the pattern they create. Can this be visualized in a physics-enabled environment?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(\n            r\"\\iiint_D\", \"xyz\", r\"\\,dx\\,dy\\,dz\", \n            r\"\\quad (D:\", r\"\\ 0 \\leq x \\leq 1,\",\n            r\"\\ 0 \\leq y \\leq 1,\",\n            r\"\\ 0 \\leq z \\leq 1)\"\n        )\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Start with innermost integral (with respect to x)\n        explanation1 = Text(\"Integrate with respect to x:\", font_size=24).to_edge(UP)\n        inner_integral = MathTex(r\"= \\int_0^1 \\int_0^1 [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(Write(explanation1))\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(2)\n\n        # Then the middle integral (with respect to y)\n        explanation2 = Text(\"Now, integrate with respect to y:\", font_size=24).to_edge(UP)\n        middle_integral = MathTex(r\"= \\int_0^1 [\\frac{1}{2}xz(y^2)]_{0}^{1} \\,dz\")\n        self.play(Transform(explanation1, explanation2))\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(2)\n\n        # Final integral step (with respect to z)\n        explanation3 = Text(\"Finally, integrate with respect to z:\", font_size=24).to_edge(UP)\n        final_solution = MathTex(r\"= [\\frac{1}{2}z]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(Transform(explanation1, explanation3))\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(2)\n\n        # Conclude by showing the final solution\n        self.clear()\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "\"Can you create an animation of a simple linear wave in a 3D space, where the wave starts, runs for a short time, and then comes to a stop, while the camera is positioned at an elevated angle?\"",
        "answer": "\\n from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for formula of infinite geometric series\n        explanation1 = Text(\"To find S, use the formula for an infinite geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up condition |r| < 1\n        condition = MathTex(r\"|r| < 1\")\n        self.play(Write(condition))\n        self.wait(3)\n        self.play(FadeOut(condition))\n        \n        # Showing the sum formula\n        sum_formula = MathTex(r\"S = \\frac{a}{1-r}\")\n        self.play(ReplacementTransform(series.copy(), sum_formula))\n        self.wait(1)\n\n        # Explanation for geometric series convergence\n        explanation2 = Text(\"This converges only if |r| < 1\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Example with actual numbers\n        example = MathTex(r\"S = \\sum_{n=0}^{\\infty} \\frac{1}{2^n}\")\n        numeric_formula = MathTex(r\"S = \\frac{1}{1-\\frac{1}{2}} = 2\")\n        self.play(Transform(series, example))\n        self.wait(1)\n        self.play(ReplacementTransform(example, numeric_formula))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(explanation1), FadeOut(numeric_formula))\n        conclusion = Text(\"The sum of the series is 2.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Could you create a 3D animation of blue radial waves originating from two points on the screen using mathematical animation software? These waves should start from the left bottom and the right bottom of the screen and be visualized in a blue checkerboard pattern without any stroke lines. The camera should be positioned at an angle to view the waves well, and the animation should show the waves starting, running for a short time, and then coming to a stop.",
        "answer": "\\n from manim import *\n\nclass Atom(Scene):\n    def construct(self):\n        proton = Circle(color=RED, fill_opacity=0.5)\n        proton_text = Tex('p$^+$', color=WHITE)\n        proton_group = VGroup(proton, proton_text)\n\n        neutron = Circle(color=BLUE, fill_opacity=0.5)\n        neutron_text = Tex('n$^0$', color=WHITE)\n        neutron_group = VGroup(neutron, neutron_text)\n\n        electron = Circle(radius=0.1, color=WHITE).shift(DOWN)\n        electron_text = Tex('e$^-$', color=WHITE).scale(0.5).move_to(electron.get_center())\n        electron_group = VGroup(electron, electron_text)\n\n        nucleus = VGroup(proton_group, neutron_group).arrange(buff=0.1)\n\n        self.play(Create(nucleus))\n        self.play(nucleus.animate.scale(0.8).to_edge(UP))\n        self.play(Create(electron_group))\n        self.play(electron_group.animate.rotate(PI / 2).shift(UP * 2 + RIGHT * 2))\n\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation showing a sequence of four different standing waves with increasing numbers of antinodes, displayed one below the other, and make them all start oscillating simultaneously?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= [-\\frac{1}{3} \\cos(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Show the final result\n        final_result = MathTex(r\"= -\\frac{1}{3}(\\cos(\\pi) - \\cos(0)) = \\frac{2}{3}\")\n        self.play(Write(final_result))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation that displays a colored circle with customizable text in the center, where I can set the circle's radius, the text, the circle's border color, text font size, text color, and the circle's border thickness, as well as the ability to fill the circle with a solid color?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to have an animation that displays a circle with a label inside it, representing the element Cobalt (Co). The circle should be filled with a distinct color, and the label should be clearly legible against the circle's color. The stroke width of both the circle and the text should be minimal to keep the design clean. Could you create something that fits this description, please?",
        "answer": "\\n from manim import *\n\nclass PythagoreanProof(Scene):\n    def construct(self):\n        # Display the Pythagorean theorem\n        theorem = MathTex('a^2 + b^2 = c^2')\n        self.play(Write(theorem))\n        self.wait(1)\n\n        # Show the triangle\n        triangle = Triangle().scale(2)\n        sides_text = VGroup(\n            MathTex('a').next_to(triangle, LEFT),\n            MathTex('b').next_to(triangle, DOWN),\n            MathTex('c').move_to(triangle.get_center())\n        )\n        self.play(Create(triangle))\n        self.play(Write(sides_text))\n        self.wait(2)\n\n        # Square on each side\n        squares = VGroup(\n            Square().scale(0.5).next_to(triangle, LEFT),\n            Square().scale(0.5).next_to(triangle, DOWN),\n            Square().scale(0.7).align_to(triangle, UP+RIGHT)\n        )\n        self.play(Create(squares))\n        self.wait(1)\n\n        # Mapping squares to theorem\n        mapping = VGroup(\n            Arrow(start=theorem[0].get_top(), end=squares[1].get_center()),\n            Arrow(start=theorem[2].get_top(), end=squares[0].get_center()),\n            Arrow(start=theorem[4].get_top(), end=squares[2].get_center())\n        )\n        self.play(ShowCreation(mapping))\n        self.wait(2)\n\n        # Clear scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text('Pythagorean Theorem Proved!', font_size=36)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an educational animation that visually represents a metal ion and an electron. The metal ion should be a blue circle with the symbol \"Co\" written inside of it, while the electron should be a smaller yellow circle with the symbol \"e^-\" inside. The symbols should be clearly legible and the metal ion symbol should be white and the electron symbol black to stand out against their respective background colors. Additionally, the circles should have a slight outline to define their shapes clearly. Could you please generate an animation that fulfills these requirements?",
        "answer": "\\n from manim import *\n\nclass ChemicalScene(Scene):\n    def construct(self):\n        electron_particle = electron()\n        oxygen_particle = oxygen()\n        metal_particle = metal()\n        positive_particle = positive()\n        negative_particle = negative()\n\n        self.play(\n            FadeIn(electron_particle),\n            FadeIn(oxygen_particle),\n            FadeIn(metal_particle),\n            FadeIn(positive_particle),\n            FadeIn(negative_particle),\n        )\n\n        self.wait(1)\n\n        grid = metal_oxid(3, 3)\n        self.play(Transform(VGroup(electron_particle, oxygen_particle, metal_particle, positive_particle, negative_particle), grid))\n\n        self.wait(1)\n\n        lithium_grid_object = lithium_grid(2, 2)\n        self.play(Transform(grid, lithium_grid_object))\n\n        self.wait(1)\n\n        carbon_grid_object = carbon_grid(3)\n        self.play(Transform(lithium_grid_object, carbon_grid_object))\n\n        self.wait(1)\n\n        complex_path_points = [UP * 2, UP + RIGHT, RIGHT * 2, DOWN + RIGHT, DOWN * 2, DOWN + LEFT, LEFT * 2, UP + LEFT, UP * 2]\n        stopping_indices = [2, 5]\n\n        electron_particle.move_to(UP * 2)\n        self.play(*(move_along_complex_path(electron_particle, stopping_indices, complex_path_points, run_time=2)))\n\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animation that shows a labeled circle representing an electron. Can you make a customizable function where I can set the radius of the circle, its border color, border thickness, fill color, and the text inside it, along with the text's font size and color? Additionally, could you add a specific implementation of this function to depict an electron with appropriate colors and label?",
        "answer": "\\n from manim import *\n\nclass ChemicalCompoundScene(Scene):\n    def construct(self):\n        # Create an oxygen atom\n        oxygen_atom = Circle(radius=0.5, color=GREY_B).set_fill(GREY_B, opacity=1)\n        oxygen_text = Tex(\"O\", color=WHITE).scale(1.5)\n        oxygen = VGroup(oxygen_atom, oxygen_text)\n\n        # Create a hydrogen atom\n        hydrogen_atom = Circle(radius=0.2, color=WHITE).set_fill(WHITE, opacity=1)\n        hydrogen_text = Tex(\"H\", color=BLACK).scale(0.8)\n        hydrogen = VGroup(hydrogen_atom, hydrogen_text)\n\n        # Position hydrogen atoms around the oxygen\n        hydrogen1 = hydrogen.copy().next_to(oxygen, UP, buff=0.6)\n        hydrogen2 = hydrogen.copy().next_to(oxygen, DOWN, buff=0.6)\n\n        # Create bond lines\n        bond1 = Line(oxygen.get_top(), hydrogen1.get_center(), color=WHITE)\n        bond2 = Line(oxygen.get_bottom(), hydrogen2.get_center(), color=WHITE)\n\n        # Group together the full molecule\n        water_molecule = VGroup(oxygen, hydrogen1, hydrogen2, bond1, bond2)\n\n        # Center the molecule and animate its creation\n        water_molecule.move_to(ORIGIN)\n        self.play(FadeIn(water_molecule, shift=UP), run_time=3)\n        self.wait()\n\n        # Label for the molecule\n        water_label = Tex(\"H$_2$O\", color=WHITE).next_to(water_molecule, DOWN)\n\n        # Animate the label\n        self.play(Write(water_label))\n        self.wait(2)\n\n        # Animate the dissociation of the water molecule\n        self.play(\n            FadeOut(hydrogen1),\n            FadeOut(bond1),\n            hydrogen2.shift, LEFT * 3,\n            oxygen.shift, RIGHT * 3,\n            FadeOut(bond2),\n            run_time=2\n        )\n        self.wait(2)"
    },
    {
        "query": "I need an animation that displays positive and negative signs inside small colored circles. The positive sign should be within a small red circle, while the negative sign should be within a small blue circle. Both circles should have a solid fill with their respective colors and a small black outline. The signs themselves need to be clearly visible, so please make sure they are in black and large enough to be easily read. Can you create such an animation with labels for these positive and negative charges or concepts?",
        "answer": "\\n from manim import *\n\nimport numpy as np\n\n\nclass Shape(Scene):\n    def construct(self):\n        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])\n        position_list = [\n            [4, 1, 0],  # middle right\n            [4, -2.5, 0],  # bottom right\n            [0, -2.5, 0],  # bottom left\n            [0, 3, 0],  # top left\n            [2, 1, 0],  # middle\n            [4, 3, 0],  # top right\n        ]\n        square_and_triangles = Polygon(*position_list, color=PURPLE_B)\n        self.add(isosceles, square_and_triangles)\n        myC=Circle()"
    },
    {
        "query": "Please create an educational animation using simple geometric shapes to visually represent atoms, including electrons, oxygen atoms, and metal atoms. For electrons, use small yellow circles with an \"e-\" label inside. For oxygen atoms, depict them as larger gray circles with \"O2+\" labels, and include faint crossection lines to indicate the oxygen molecule's geometry. For metal atoms, use cobalt as an example and make them blue circles with \"Co\" labels. Finally, arrange the oxygen and cobalt atoms in an alternating pattern to form a lattice structure that represents a metal oxide, with the ability to specify the number of rows and columns in the lattice, and adjust the overall scale of the lattice for better visibility.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Write the integral\n        integral_text = MathTex(r\"\\int_{2}^{4} (x^2 - 2x + 1) \\,dx\")\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Add explanation about the integrand function\n        function_explanation = Text(\"Function: x^2 - 2x + 1\", font_size=24).to_edge(UP)\n        self.play(Write(function_explanation))\n        self.wait(2)\n\n        # Show the antiderivative\n        antiderivative = MathTex(r\"= \\left[ \\frac{x^3}{3} - x^2 + x \\right]_{2}^{4}\")\n        self.play(ReplacementTransform(integral_text, antiderivative))\n        self.wait(1)\n\n        # Replace explanation with the evaluation step\n        evaluation_explanation = Text(\"Evaluate at 4 and 2\", font_size=24).to_edge(UP)\n        self.play(Transform(function_explanation, evaluation_explanation))\n        self.wait(2)\n\n        # Evaluate antiderivative at the bounds\n        evaluated_solution = MathTex(r\"= \\left( \\frac{4^3}{3} - 4^2 + 4 \\right) - \\left( \\frac{2^3}{3} - 2^2 + 2 \\right)\")\n        self.play(ReplacementTransform(antiderivative, evaluated_solution))\n        self.wait(1)\n\n        # Calculate the final result\n        final_result = MathTex(r\"= \\frac{56}{3}\")\n        self.play(Transform(evaluated_solution, final_result))\n        self.wait(1)\n\n        # Clear everything and show final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that shows circles with a letter \"C\" inside them to represent carbon atoms? The circles should have adjustable sizes for depiction at different scales. Also, I'd like the option to change the colors and other properties like the thickness of the circle's border and the size of the font inside the circle. It would be nice to have different layers or levels of focus indicated by the circle's layering order, with certain circles appearing on top of others.",
        "answer": "\\n from manim import *\n\nconfig.background_color = \"#faf4e1\"\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        colors = [\n            \"#f55e61\",\n            \"#5fcb50\",\n            \"#408ef5\",\n            \"#e3883d\",\n            \"#a346eb\",\n            \"#0dc786\",\n            \"#34a853\",\n            \"#bf2626\",\n            \"#3333FF\",\n            \"#b3a77d\",\n            \"#b85842\"\n        ]\n        \n        fib_numbers = [0, 1]\n        for _ in range(7):\n            fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n\n        squares = VGroup()\n        for index, fib_num in enumerate(fib_numbers[2:]):\n            square = Square(\n                side_length=fib_num,\n                color=colors[index % len(colors)],\n                fill_opacity=0.5\n            )\n            squares.add(square)\n        \n        spirals = VGroup()\n        start_point = ORIGIN\n        angle = 0\n        for index, square in enumerate(squares):\n            square.move_to(start_point)\n            spirals.add(Arc(\n                start_angle=angle,\n                angle=TAU/4,\n                radius=square.side_length/2,\n                color=colors[index % len(colors)]\n            ).move_arc_center_to(start_point))\n            if index % 4 == 0:\n                start_point += square.side_length * RIGHT / 2\n                start_point += squares[index - 1].side_length * UP / 2 if index > 0 else ORIGIN\n                angle += TAU / 4\n            elif index % 4 == 1:\n                start_point += square.side_length * UP / 2\n                start_point += squares[index - 1].side_length * LEFT / 2\n                angle += TAU / 4\n            elif index % 4 == 2:\n                start_point += square.side_length * LEFT / 2\n                start_point += squares[index - 1].side_length * DOWN / 2\n                angle += TAU / 4\n            else:\n                start_point += square.side_length * DOWN / 2\n                start_point += squares[index - 1].side_length * RIGHT / 2\n                angle += TAU / 4\n\n        fibonacci_spiral = VGroup(squares, spirals).move_to(ORIGIN)\n        self.play(Create(fibonacci_spiral), run_time=4)\n        self.wait()"
    },
    {
        "query": "I would like to create an educational animation that visualizes a layered carbon grid structure, where each carbon atom is represented by a circle and a \"C\" label inside it. The carbon atoms need to be connected by lines to represent the chemical bonds, with smaller circles for outer atoms, and a translucent polygon to highlight each layer of the structure. Can you make it so that I can easily adjust the number of layers and rows of carbon atoms? I\u2019d also like to be able to customize the size and colors of the atoms and bonds for better visibility. Can you help me with this?",
        "answer": "\\n from manim import *\n\nclass TracedPathExample(Scene):\n    def construct(self):\n        # Create a square and make it move in a circular path\n        square = Square(color=BLUE_C)\n        square.add_updater(lambda mobj, dt: mobj.rotate(dt).shift(RIGHT*dt))\n\n        # Create a traced path for the square\n        traced_path = TracedPath(square.get_center, stroke_width=6, stroke_color=YELLOW)\n\n        # Add the square and the traced path to the scene\n        self.add(square, traced_path)\n\n        # Play the animation for a few seconds\n        self.wait(4)\n\n        # Cease the rotation and movement\n        square.clear_updaters()\n\n        # Wait a bit before finishing\n        self.wait(1)"
    },
    {
        "query": "I'd like to create a customized animation where an object, for example a shape or a character, follows a specific path on the screen that I can design. The path should be made up of straight lines between points that I can specify, and I want the ability to choose where the object pauses along the path. Additionally, I want to control how long the animation takes and have the option to adjust the pacing of the movement. Can you help me with that?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\frac{1}{2} xyz^2 \\Big|_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{2} x \\frac{1}{2} y^2 \\Big|_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{4} \\frac{1}{3} x^3 \\Big|_{0}^{1}\", r\"= \\frac{1}{12}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video that visually explains the parts of a DC motor. I want the animation to have labeled components like the rotor, stator, and brushes. Each label should be connected to the corresponding part of the motor with dashed lines for clarity. In the animation, I prefer a simple yet detailed representation of the DC motor. Make sure to use contrasting colors so that each part is distinct and the labels are clear against a white background. Can you provide an animation that meets these specifications?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.align_on_border\").shift(UP*2.5)), run_time=0.5)\n            square = Square().shift(LEFT*2)\n            self.play(square.animate.align_on_border(direction=np.array([0,1,0])))\n            self.remove(square)"
    },
    {
        "query": "I would like to see an animated video that illustrates the basic parts of a simple electric motor. The motor should have a stand and two basic sections that represent the rotor and the stator. The rotor is central and typically rotates, while the stator is the static part of the motor surrounding the rotor. Additionally, labels for the rotor and stator should be included with lines pointing to each respective part. The overall design should be simple and clear, using grayscale colors with a white background for a clean look. Can you create such an animation?",
        "answer": "\\n class ProjectileMotionScene(MovingCameraScene):\n    def construct(self):\n        self.camera_frame.move_to(2 * UP)\n        formula = MathTex(\n            r\" \\vec{v}(t) &= v_0 \\cos(\\theta) \\mathbf{i} + \"\n            r\"\\left(v_0 \\sin(\\theta) - g t\\right)\\mathbf{j}\"\n        )\n        formula.to_corner(UL)\n\n        def trajectory(t):\n            v0 = 25\n            theta = PI / 4\n            return np.array(\n                (v0 * t * np.cos(theta), v0 * t * np.sin(theta) - 0.5 * 9.8 * t**2, 0)\n            )\n\n        projectile = ParametricFunction(trajectory, t_max=2, color=YELLOW)\n        self.play(Create(projectile))\n        self.wait(1)\n\n        arrow = Arrow(start=ORIGIN, end=[5 * np.cos(PI / 4), 5 * np.sin(PI / 4), 0], color=BLUE)\n        arrow_label = MathTex(r\"v_0\", color=BLUE).next_to(arrow.get_center(), UP)\n        self.play(GrowArrow(arrow), Write(arrow_label))\n\n        self.play(FadeIn(formula))\n        self.wait(1)\n\n        fireworks = VGroup()\n        for j in range(5):\n            sparks = VGroup()\n            i_loc = trajectory(2)\n            for angle in np.linspace(0, TAU, 100):\n                def spark_trajectory(t, theta=angle):\n                    v_spark = 4\n                    return np.array(\n                        (i_loc[0] + v_spark * t * np.cos(theta), \n                         i_loc[1] + v_spark * t * np.sin(theta) - 0.5 * 4.9 * t**2,\n                         0)\n                    )\n                spark = ParametricFunction(spark_trajectory, t_min=0.05, t_max=0.4, color=RED)\n                sparks.add(spark)\n            fireworks.add(sparks)\n\n        self.play(*[Create(sparkle) for sparkle in fireworks], run_time=1.5)\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation using Manim that shows two red oxygen atoms coming together to form a molecule? I would like the atoms to first fade into view, then rotate around, and finally scale up to double their size before fading out. Also, I want the molecule to be shown with a double bond between the atoms.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Flash\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Ta Da\").set_color(YELLOW)\n            self.add(some_text)\n            self.play(Flash(some_text))\n            self.remove(some_text)"
    },
    {
        "query": "I want to create an animated video using a math visualization tool where a blue hexagon shape is drawn and then a small particle referred to as an \"electron\" moves along the edges of the hexagon. The hexagon should appear first, and once it's fully drawn, the electron should start at one corner and follow the hexagon's path until it completes one cycle around it. The entire path traversal by the electron should take about 6 seconds to complete. After the electron finishes its journey around the hexagon, all the elements in the scene should fade away.",
        "answer": "\\n from manim import *\n\n\nclass Pendulum(VGroup):\n    def phi_fun(self, amplitude, acceleration, length, time):\n        return amplitude * np.sin(np.sqrt(acceleration / length) * time - np.pi / 2)\n\n    def __init__(self, weight, amplitude, acceleration, length, time):\n        VGroup.__init__(self)\n        self.sound_stamps_there = []\n        self.sound_stamps_back = []\n\n        self.amplitude = amplitude\n        self.acceleration = acceleration\n        self.length = length\n        self.time = time\n        self.phi = self.phi_fun(amplitude, acceleration, length, time)\n        self.anchor = Dot(ORIGIN, color=RED)\n        self.line = Line(\n            ORIGIN, length * 1.8 * DOWN, stroke_width=1.6, stroke_opacity=0.2\n        )\n        self.line.rotate(self.phi * DEGREES, about_point=self.line.get_start())\n        self.mass = Dot().set_color(BLUE).scale(1.4)\n        self.mass.move_to(self.line.get_end())\n        self.mobj = VGroup(self.line, self.anchor, self.mass)\n        self.add(self.mobj)\n\n    def start(self):\n        self.mobj.current_time = 0.000001\n\n        def updater(mob, dt):\n            mob.current_time += dt\n            old_phi = self.phi_fun(\n                self.amplitude,\n                self.acceleration,\n                self.length,\n                mob.current_time - 2 * dt,\n            )\n            new_phi = self.phi_fun(\n                self.amplitude, self.acceleration, self.length, mob.current_time\n            )\n            mob[0].rotate(\n                (new_phi - self.phi) * DEGREES, about_point=self.line.get_start()\n            )\n            if (old_phi > self.phi) & (\n                self.phi < new_phi\n            ):  # only used when sound is added.\n                self.sound_stamps_there.append(mob.current_time)\n            if (old_phi < self.phi) & (self.phi > new_phi):\n                self.sound_stamps_there.append(mob.current_time)\n\n            self.phi = new_phi\n            self.mass.move_to(self.line.get_end())\n\n        self.mobj.add_updater(updater)\n\n\nclass PendulumScene(Scene):\n    def construct(self):\n        g = 10\n        oszilations = np.array([8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n        period_length = 30\n        times = 1 / oszilations * period_length\n        lengths = (times / (2 * PI)) ** 2 * g\n        total = len(lengths)\n        pendulums1 = []\n        for i, val in enumerate(lengths):\n            pendulum = Pendulum(\n                weight=1, amplitude=32, acceleration=g, length=val, time=0\n            )\n            if i % 2 == 0:\n                pendulum.mass.set_color(GREEN)\n            anchor_pos = pendulum.anchor.get_center()\n            dest_pos = (-total / 2 + i) * 0.6 * RIGHT + 3.5 * UP\n            pendulum.shift(anchor_pos + dest_pos)\n            pendulums1.append(pendulum)\n            self.add(pendulum)\n        pendulums2 = []\n        for i, val in enumerate(lengths):\n            pendulum = Pendulum(\n                weight=1, amplitude=32, acceleration=10, length=val, time=0\n            )\n            if i % 2 == 0:\n                pendulum.mass.set_color(GREEN)\n            anchor_pos = pendulum.anchor.get_center()\n            dest_pos = 3.5 * UP\n            pendulum.shift(anchor_pos + dest_pos)\n            pendulums2.append(pendulum)\n        self.wait()\n        self.play(Transform(VGroup(*pendulums1), VGroup(*pendulums2)))\n        self.wait(1)\n        for el in pendulums1:\n            el.start()\n        self.wait(35)\n        banner = ManimBanner(dark_theme=True).scale(0.3).to_corner(DR)\n        self.play(FadeIn(banner))\n        self.play(banner.expand())\n        self.wait(30)"
    },
    {
        "query": "I want to create an animated company logo that starts with three separate colored shapes - a green circle, a blue square, and a red triangle. These shapes should start spread out and spiral inwards to the center of the screen. Once they reach the center, a large, black letter 'M' appears and fades in above them. After the 'M' appears, the shapes and the 'M' should move together towards the right side of the screen until they are a comfortable distance away. Then the word 'anim' in bold, with each letter appearing one after another next to the 'M', should fade in at the bottom to complete the logo. The shapes should match the color scheme I've given and the background color should be a light cream. The animation should have a smooth and professional look. Can you create an animation sequence like this for me?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_x\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.set_x(-1))\n            self.remove(square)"
    },
    {
        "query": "Could you create an animated video that demonstrates a Hamiltonian cycle on a graph with 20 nodes? I'd like to show the nodes as dots and connect them with lines to illustrate the cycle. The dots should form concentric circles and be color-coded as they are visited in the cycle. Once the cycle is complete, I want the entire graph to move to the left side of the screen and have text appear that says \"The graph\" alongside a miniature version of the graph, followed by another text line underneath it that states \"has a Hamiltonian cycle.\" Then, end the video by fading everything out.",
        "answer": "\\n from manim import *\n\nclass DisplayUnits(Scene):\n    def construct(self):\n        # Create a grid to visualize screen units\n        grid = NumberPlane()\n        self.add(grid)\n\n        # Different percentages of the screen width and color for each rectangle\n        percentages = [10, 20, 30, 40, 50]\n        colors = [RED, GREEN, BLUE, ORANGE, PURPLE]\n\n        # Create and add rectangles to the scene\n        for percent, color in zip(percentages, colors):\n            self.add(\n                Rectangle(\n                    width=percent * Percent(X_AXIS),\n                    height=10 * Percent(Y_AXIS),\n                    color=color,\n                    fill_opacity=0.5\n                )\n            )\n\n        # Create and add a dot at a fixed number of pixels from the origin\n        dot = Dot(point=ORIGIN).shift(150 * Pixels * UP + 150 * Pixels * RIGHT)\n        self.add(dot)"
    },
    {
        "query": "Can you create an animated video of a sort algorithm where a shuffled list of numbers from 1 to 50 gets sorted in ascending order? Visualize the list as a series of adjacent vertical bars of varying heights that represent the numbers, with each bar moving into place as the sort progresses. The bars should start shuffled and move to their sorted position with the lowest bar on the left and the tallest on the right. As the current bar being sorted, highlight it in yellow, and once it's in the correct place, turn it green. Keep the sorting speed relatively fast and align the bars at the bottom of the screen.",
        "answer": "\\n from manim_ml.neural_network import NeuralNetwork, Convolutional2DLayer, MaxPooling2DLayer\n# Make neural network\nnn = NeuralNetwork([\n        Convolutional2DLayer(1, 8),\n        Convolutional2DLayer(3, 6, 3),\n        MaxPooling2DLayer(kernel_size=2),\n        Convolutional2DLayer(5, 2, 2),\n    ],\n    layer_spacing=0.25,\n)\n# Center the nn\nnn.move_to(ORIGIN)\nself.add(nn)\n# Play animation\nforward_pass = nn.make_forward_pass_animation()\nself.wait(1)\nself.play(forward_pass)"
    },
    {
        "query": "Can you create a visual animation that demonstrates Euler's formula on the complex plane using a moving dot to represent the complex number as it changes with different angles, and alongside that, display the mathematical expression for Euler's formula with the dots' corresponding values showcased in matching colors? Additionally, can you include the path traced by the complex number as it moves, a visual indicator such as a circle that highlights this path when the animation is running, and an interaction where the dot follows a complete rotation equivalent to tau radians, then moves to represent a pure imaginary number, and finally rotates around the origin?",
        "answer": "\\n from manim import *\n\nclass PerceptronScene(Scene):\n    def construct(self):\n        # Define perceptron layer with 3 inputs and 1 output neuron\n        layer = VGroup()\n        neurons = [Circle(radius=0.15, fill_color=WHITE, fill_opacity=1) for _ in range(4)]\n        inputs = VGroup(*neurons[:3]).arrange(DOWN, buff=0.5)\n        output = neurons[-1]\n\n        # Add input and output neurons to the layer\n        layer.add(inputs)\n        layer.add(output)\n        layer.move_to(ORIGIN)\n\n        # Drawing the synapses (lines connecting neurons)\n        synapses = VGroup()\n        for input_neuron in inputs:\n            synapse = Line(input_neuron.get_center(), output.get_center(), buff=0.15).set_stroke(width=2)\n            synapses.add(synapse)\n        \n        # Add synapses to layer\n        layer.add(synapses)\n\n        # Add neurons numbers\n        for i, input_neuron in enumerate(inputs, 1):\n            neuron_num = Text(f\"x{i}\", color=BLACK).scale(0.5).move_to(input_neuron)\n            layer.add(neuron_num)\n        output_neuron_num = Text(\"y\", color=BLACK).scale(0.5).move_to(output)\n        layer.add(output_neuron_num)\n\n        # Add layer to the scene\n        self.add(layer)\n\n        # Animation part\n        self.play(FadeIn(layer))\n        for synapse in synapses:\n            self.play(ShowCreation(synapse))\n            self.wait(0.1)\n        self.play(*[GrowFromCenter(neuron) for neuron in neurons])\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that illustrates basic probability concepts such as single event probability, complement probability, union and intersection of two events, and conditional probability. Can you visualize these concepts using a colorful and interactive raindrop analogy where falling drops change color when they hit certain areas? Additionally, I want the animation to include probability labels that update to match the concept being demonstrated.",
        "answer": "\\n from manim import *\n\nclass SigmoidNeuron(VGroup):\n    def __init__(self, position, neuron_radius=0.2, color=BLUE, **kwargs):\n        super().__init__(**kwargs)\n        self.neuron_circle = Circle(radius=neuron_radius, color=color)\n        self.neuron_circle.move_to(position)\n        self.activation_text = MathTex(r'\\sigma').scale(0.5).move_to(self.neuron_circle.get_center())\n        self.add(self.neuron_circle, self.activation_text)\n\n    def get_activation_animation(self):\n        activation = ApplyMethod(self.neuron_circle.set_fill, YELLOW, rate_func=there_and_back)\n        return activation\n\n\nclass LayerOfSigmoidNeurons(VGroup):\n    def __init__(self, n_neurons, center, **kwargs):\n        super().__init__(**kwargs)\n        self.neurons = VGroup(*[\n            SigmoidNeuron(position=center + i * RIGHT * 0.5)\n            for i in range(n_neurons)\n        ])\n        self.add(self.neurons)\n\n    def get_layer_activation_animation(self):\n        return AnimationGroup(*[neuron.get_activation_animation() for neuron in self.neurons], lag_ratio=0.1)\n\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        sigmoid_layer = LayerOfSigmoidNeurons(n_neurons=5, center=UP*2)\n        output_neuron = SigmoidNeuron(position=DOWN*2, color=RED, neuron_radius=0.3)\n        self.add(sigmoid_layer, output_neuron)\n\n        # Creating animated edges\n        edges = VGroup()\n        for neuron in sigmoid_layer.neurons:\n            edge = Line(neuron.get_center(), output_neuron.get_center(), buff=0.2, stroke_width=2.0)\n            edges.add(edge)\n        self.add(edges)\n\n        # Animating neurons\n        self.play(sigmoid_layer.get_layer_activation_animation())\n        self.wait(1)\n\n        # Creating animated output edges with color change\n        edges_animation = [\n            ShowPassingFlash(\n                edge.copy().set_color(YELLOW),\n                time_width=0.5,\n                run_time=1\n            ) for edge in edges\n        ]\n        output_activation = output_neuron.get_activation_animation()\n\n        self.play(\n            AnimationGroup(*edges_animation, lag_ratio=0.1),\n            output_activation\n        )\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation in which a labeled ball bounces inside a rectangular box to represent a particle in a confined space. The ball should have properties of velocity and acceleration, reacting to the edges of the box by changing direction as it hits them. Additionally, display the version number of the animation in the top-right corner. The ball label should match the version number displayed. Later on, introduce more balls with different labels like Greek letters Psi, Alpha, and Lambda. Apply some physics to simulate gravity affecting the balls' vertical movement. Finally, create a smaller, translucent cutout of the scenario, move it to the right, and then fade out all objects except for a Manim banner at the bottom right, which then expands to fill the screen. Can we make the animation background a soft cream color and add a touch of branding with our logo at the end?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{-1}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2}xyz^2]_{-1}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy^3]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that shows a Lissajous curve, which is a path traced by a point whose x and y coordinates are defined by two independent sine functions. The animation should begin with a simple colored dot and the curve should start to become visible, drawn with a thick yellow gradient stroke over a slightly thicker black background path, creating a visual effect of the curve glowing. The curve should scale to double its original size and be centered on the screen. Additionally, one feature should be that the dot is moving along the path to show the progression of the drawing of the curve in real time and the curve's drawing should take 9 seconds and be linear, without any acceleration or deceleration effects.\n\nThe background of the scene should be an off-white color. After the Lissajous curve is fully drawn, I want the Manim Community Edition banner to fade into view in the bottom right corner, then expand to its full size. I would like the entire animation to start and end with a brief pause to make the transitions smooth.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Circumscribe\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Look Here\")\n            self.add(some_text)\n            self.play(Circumscribe(some_text))\n            self.play(Circumscribe(some_text, Circle))\n            self.remove(some_text)"
    },
    {
        "query": "Could you create a detailed animation of a Binary Search Tree (BST) using custom visual graphics that demonstrates how data gets structured and inserted into the tree? The tree should have animated insertions for the sequence of numbers 8, 4, 2, 1, 3, 6, 5, 7, 12, 10, 9, 11, 14, 13, 15. It should be visually appealing with a color gradient from blue (for low values) to red (for high values), distinguishing the nodes based on their values with smooth insertion animations. Additionally, include a text label at the top stating \"Great for storing structured data.\" and display the completed BST before fading everything out. Please also make sure that the tree is not too spread out horizontally and has a moderate animation speed for easy understanding.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FocusOn\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Here!\")\n            self.add(some_text)\n            self.play(FocusOn(some_text))\n            self.remove(some_text)"
    },
    {
        "query": "Create an educational animation that illustrates the Earth's orbit around the Sun, with special focus on the phenomena occurring on certain dates like the June and December solstices, and the March and September equinoxes. Show the Earth's path as an ellipse with a trail marking its progress and the changes in distance to the Sun. Make sure to label significant points with dates and include a moving Sun with its own trail to represent its apparent movement. Include visual elements like arrows to show directions and tilts, and have these illustrations update dynamically as the Earth orbits. To enhance understanding, periodically add diagrams to the animation detailing the tilt of the Earth's axis and the Sun's position at critical points of orbit, specifically when the Earth is at its minimum and maximum x displacement relative to the Sun. The camera should follow the Sun's movement after a short delay, to keep the animation focused while still showing the overall motion. The animation should run smoothly and be comprehensible for educational purposes.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r \\, dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_solution = MathTex(r\"= [\\frac{1}{2}\\theta]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Display the solution\n        solution = MathTex(r\"= \\frac{1}{2} \\pi\")\n        self.play(Write(solution))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animated New Year's greeting video that starts with a scene simulating a rocket shooting upwards, then exploding into multiple colorful sparks, followed by a celebratory message and some festive flashing lights. The rocket should follow a realistic trajectory, defined by a physics equation for projectile motion. After the explosion, the sparks should scatter in all directions, somewhat resembling a burst of fireworks, and gradually fade out. As the sparks disappear, I want a math equation representing the rocket's path to slowly fade in at the bottom left corner of the screen. The equation should comprise of a 2D trajectory formula broken into 'x' and 'y' components over time, 't', to give a hint of the science behind the movement. Last but not least, I'd like the animation to end with a fun visual element, such as a banner of the software or animation studio responsible for this creation, popping up in the bottom right corner and then disappearing after a few seconds. The overall feel should be one of celebration and the wonders of math and science.",
        "answer": "\\n from manim import *\n\nclass TrigonometricSubstitution(Scene):\n    def construct(self):\n        # Display the integration problem\n        problem = MathTex(r\"\\int \\sqrt{1-x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Introduction of trigonometric substitution\n        explanation1 = Text(\"Use trigonometric substitution:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Defining the substitution\n        substitution = MathTex(r\"x = \\sin(\\theta), \\, dx = \\cos(\\theta)d\\theta\")\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Substituting into the integral\n        substituted_integral = MathTex(r\"= \\int \\sqrt{1-\\sin^2(\\theta)} \\cos(\\theta) \\,d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), substituted_integral))\n        self.wait(1)\n\n        # Simplifying the integral with a trigonometric identity\n        explanation2 = Text(\"Use the Pythagorean identity:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        simplified_integral = MathTex(r\"= \\int \\cos^2(\\theta) \\,d\\theta\")\n        self.play(ReplacementTransform(substituted_integral, simplified_integral))\n        self.wait(2)\n\n        # Integrating the simplified integral\n        integrated_solution = MathTex(r\"= \\frac{\\theta}{2} + \\frac{\\sin(2\\theta)}{4} + C\")\n        self.play(ReplacementTransform(simplified_integral, integrated_solution))\n        self.wait(1)\n\n        # Back-substituting using the original substitution\n        explanation3 = Text(\"Back-substitute using x = sin(\u03b8):\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        back_substituted_solution = MathTex(r\"= \\frac{\\arcsin(x)}{2} + \\frac{x\\sqrt{1-x^2}}{2} + C\")\n        self.play(ReplacementTransform(integrated_solution, back_substituted_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display final answer\n        self.play(Write(back_substituted_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational video animation that explains the relationship between the areas of a right triangle and its legs. The animation should start by drawing a right triangle on the screen with the sides labeled \"a\", \"b\", and \"c\". Include a perpendicular height \"h\" from the right angle to the hypotenuse and label the intersection \"D\".\n\nNext, the animation should show that the area of the full triangle \"ABC\" can be broken down into two smaller triangles, \"ADC\" and \"BDC\". Indicate the areas of the smaller triangles with semi-transparent colors and transition their representations to simplified area formulas involving \"h\", the respective \"x\" and \"y\" (which are the lengths of \"AD\" and \"BD\" respectively), and the area formula for a triangle. Then, using these colored areas, the animation should illustrate that the sum of the areas of triangles \"ADC\" and \"BDC\" is equal to the area of triangle \"ABC\" by moving them next to it.\n\nPlease clarify the relationship between the sides of the triangle and the area by transitioning from the area formulas to the expression \"ab = h(x + y)\" where \"a\" and \"b\" are the legs and \"c\" is the hypotenuse of the triangle \"ABC\". Then, show a further simplification to \"ab = hc\", since \"c\" is the sum of \"x\" and \"y\". \n\nSubsequently, reformulate \"ab = hc\" to \"ab/h = c\" and underscore the significance of this result by shifting the formula and the triangle to make room for the next part of the lesson.\n\nThe final segment should introduce the Pythagorean theorem, \"a^2 + b^2 = c^2\", and use the earlier result \"ab/h = c\" to make a substitution into the theorem. Exhibit some algebra that involves squares and fractions, demonstrating the transition from \"a^2 + b^2 = (ab/h)^2\" to the final form, \"1/a^2 + 1/b^2 = 1/h^2\". Conclude the lesson by emphasizing the 'inverse Pythagorean theorem' with a surrounding rectangle to highlight it.\n\nLastly, ensure all of these steps are clearly depicted with smooth animations and pauses for effect where appropriate, such as after each major transition or revelation. The style should be educational, engaging, and suitable for a typical high school geometry class.",
        "answer": "\\n from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Display the integral to solve\n        integral = MathTex(r\"\\int \\sqrt{1+x^2} \\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Show the substitution\n        substitution = Text(\"Use trigonometric substitution: \"\n                            \"x = tan(theta)\", font_size=24).to_edge(UP)\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Show the dx and sqrt changes\n        changes = MathTex(r\"dx = sec^2(\\theta) d\\theta, \\quad\",\n                          r\"\\sqrt{1+x^2} = \\sqrt{1+\\tan^2(\\theta)}\")\n        self.play(Write(changes))\n        self.wait(2)\n\n        # Show the new integral\n        new_integral = MathTex(r\"= \\int \\sqrt{1+\\tan^2(\\theta)} sec^2(\\theta) d\\theta\")\n        self.play(ReplacementTransform(integral.copy(), new_integral))\n        self.wait(1)\n\n        # Simplify the integral using trigonometric identity\n        simplification = Text(\"Use identity: \"\n                              \"1+tan^2(theta) = sec^2(theta)\", font_size=24).to_edge(UP)\n        self.play(Transform(substitution, simplification))\n        self.wait(2)\n\n        # Integral after simplification\n        simplified_integral = MathTex(r\"= \\int sec^3(\\theta) d\\theta\")\n        self.play(ReplacementTransform(new_integral, simplified_integral))\n        self.wait(1)\n\n        # Explain further steps\n        further_steps = Text(\"This requires integration techniques \"\n                             \"like reduction formulae\", font_size=24).to_edge(UP)\n        self.play(Transform(substitution, further_steps))\n        self.wait(2)\n\n        # Conclude the problem\n        conclusion = Text(\"Skipping to the solution after \"\n                          \"applying reduction formulae\", font_size=24).to_edge(UP)\n        self.play(Transform(substitution, conclusion))\n        self.wait(1)\n\n        # The final answer\n        final_answer = MathTex(r\"= \\frac{1}{2} \\left( sec(\\theta)tan(\\theta) + ln|sec(\\theta)+tan(\\theta)| \\right) + C\")\n        self.play(ReplacementTransform(simplified_integral, final_answer))\n        self.wait(1)\n\n        # Clear the scene and show the final conclusion\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "I would like an animated Valentine's Day card that has a mathematical theme. The animation should start with a white background and black axes drawn in the middle of the screen, with the axes labeled with tick marks at the pi over 2 intervals. The graph should feature animations of the sine function and its inverse, as well as circles that transition into heart shapes. Specifically, I want the positive sine function and its reflection across the y-axis to be drawn and labeled, turning gradually into a red color, followed by two circles that also fill with red color while being traced. Then, I'd like to rotate these graphs and their labels about the line y=x to turn them into their inverse functions. Finally, all the red parts should come together to form a complete heart shape, which then gets filled with solid red, that is then minimized to make room for a special Valentine's Day message that reads \"With love from\" next to a small heart icon. In the end, I want the Manim Community logo to be displayed at the bottom. All of this should be accompanied by smooth transitions and appropriate pauses to ensure a visually appealing presentation.",
        "answer": "\\n from manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        self.wait()\n\n        a = RegularPolygon(n=10, color=BLUE_E)\n        b = RegularPolygon(n=11, color=YELLOW)\n        c = RegularPolygon(n=12, color=WHITE)\n        d = RegularPolygon(n=30, color=GREEN_C).next_to(c, RIGHT)\n\n        g1 = Group(a, b, c).arrange(RIGHT, 0.75)\n        self.play(Create(a))\n        self.play(Transform(a.copy(), b))\n        self.play(Transform(b.copy(), c))\n        self.clear()\n        self.play(Create(d))\n\n        self.wait()"
    },
    {
        "query": "\"Can you create an educational animation that illustrates a series of pendulums hanging side by side, each with different lengths corresponding to their natural oscillation frequencies? I'd like them to swing with their respective frequencies when simulated to visualize the concept of pendulum periods and how they depend on the length of the string. Initially, the pendulums should all be aligned, but as time progresses, their individual motions should demonstrate the periodic nature and their desynchronization due to the differences in length. For the pendulums, alternate their colors between blue and green for better visual distinction. Additionally, include a banner of the Manim community at the end of the animation as a reference to the tool used for creating this illustration.\"",
        "answer": "\\n         self.play(Transform(text,Text(\"Flash\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Ta Da\").set_color(YELLOW)\n        self.add(some_text)\n        self.play(Flash(some_text))\n        self.remove(some_text)"
    },
    {
        "query": "I would like to create an educational video on Lissajous curves and I want to show the audience how these curves form over time. Could you please create an animation that displays multiple Lissajous curves with different parameters growing simultaneously? Each curve should start from a single point and extend outward, with older parts of the curve disappearing to maintain a certain length on screen. To distinguish the curves, color them differently, ranging from red to purple. The formation should be slow enough so that viewers can observe the evolution of each curve's shape. Can you also ensure the animation exhibits the effect of phase differences between the curves?",
        "answer": "\\n from manim import *\n\nclass QuadraticEquationExample(Scene):\n    def construct(self):\n        # Displaying the quadratic equation\n        equation = MathTex(r\"ax^2 + bx + c = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation of discriminant\n        explanation1 = Text(\"The discriminant of the equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Writing the discriminant\n        discriminant = MathTex(r\"\\Delta = b^2 - 4ac\")\n        self.play(ReplacementTransform(equation.copy(), discriminant))\n        self.wait(1)\n\n        # Explanation of roots based on discriminant\n        explanation2 = Text(\"Nature of roots\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Types of roots\n        roots_type = VGroup(\n            MathTex(r\"\\Delta > 0\", r\"\\Rightarrow\", r\"\\text{Real and Distinct}\"),\n            MathTex(r\"\\Delta = 0\", r\"\\Rightarrow\", r\"\\text{Real and Equal}\"),\n            MathTex(r\"\\Delta < 0\", r\"\\Rightarrow\", r\"\\text{Complex Roots}\")\n        ).arrange(DOWN, aligned_edge=LEFT)\n\n        self.play(ReplacementTransform(discriminant, roots_type))\n        self.wait(1)\n\n        # Formula for roots\n        formula_for_roots = MathTex(r\"x = \\frac{{-b \\pm \\sqrt{\\Delta} }}{2a}\")\n        self.play(Write(formula_for_roots))\n        self.wait(1)\n\n        # Explanation for the formula\n        explanation3 = Text(\"Formula for calculating the roots\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and show roots formula\n        self.clear()\n        self.wait(1)\n        self.play(Write(formula_for_roots))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an educational animation that explains the principles of optics using an interactive and engaging approach. The animation should feature a diagram of a lens showing how it bends light and how changing the distance of an object from the lens affects the image formed on the other side. Include moving components to illustrate the relationship between object distance, image distance, and focal length according to the thin lens formula. Also, I'm interested in comparing this to how the human eye works; show an anatomically inspired model of an eye adjusting its lens thickness to maintain focus on objects at different distances, highlighting parts like the cornea, lens, and retina, and explain the similarities and differences between an eye and a simple lens in focusing light. Make sure to use colors and labels to make the different parts and distances clear, and animate changes to reinforce the learning experience.",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using a trigonometric identity\n        explanation1 = Text(\"Use the trigonometric identity: \"\n                            \"sin(2x) = 2 sin(x) cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Solving using the identity\n        identity_applied = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), identity_applied))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= - \\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(identity_applied, integration_step))\n        self.wait(1)\n\n        # Clear the scene and show conclusion\n        self.clear()\n        self.wait(1)\n        final_solution = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx = - \\frac{1}{4} \\cos(2x) + C\")\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visualizes modular multiplication on a star-shaped figure? The star should be dynamic, changing its appearance as the multiplication factor varies. There should also be lines connecting points on the star which correspond to the multiplication of numbers around the star by a certain factor, and these lines should change as the factor changes. To clarify this concept, labels indicating the current modulus and multiplication factor would be great. Can the animation cycle through different multiplication factors over time, showing the viewer how the patterns evolve? Additionally, is it possible to make sure the overall design is aesthetically pleasing, perhaps by using a nice color for the star and fine lines for the connections?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier Series definition\n        series_def = MathTex(r\" f(x) = a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(series_def))\n        self.wait(1)\n\n        # Explanation of Fourier Series\n        explanation = Text(\"Fourier Series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Example function\n        function = MathTex(r\"f(x) = \\cos(x) + \\frac{1}{3} \\cos(3x)\")\n        self.play(Transform(series_def, function))\n        self.wait(1)\n\n        # Highlighting cosine terms\n        highlight = SurroundingRectangle(series_def[1][12:23], color=YELLOW)\n        self.play(Create(highlight))\n        self.wait(1)\n\n        # Explanation of coefficients\n        coeffs_explanation = Text(\"The coefficients determine the function's shape\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, coeffs_explanation))\n        self.wait(2)\n\n        # Displaying one term of the series\n        one_term = MathTex(r\"a_n \\cos(nx)\")\n        self.play(FadeOut(highlight), Transform(series_def[1], one_term))\n        self.wait(1)\n\n        # Conclusion on Fourier Series\n        conclusion = Text(\"Fourier Series are used in many fields such as signal processing\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of Demonstration\", font_size=36)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated visualization of the bubble sort algorithm using colored bars where the height of each bar represents a different value in an array? The animation should show the swapping process of the bars as they are being sorted in ascending order.",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Displaying the ODE\n        ode = MathTex(r\"m \\frac{d^2x}{dt^2} + b \\frac{dx}{dt} + kx = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explanation of the physical context\n        explanation1 = Text(\"Damped Harmonic Oscillator\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation for the associate characteristic equation\n        explanation2 = Text(\"Associated characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(1)\n\n        # Writing the characteristic equation\n        char_eq = MathTex(r\"mr^2 + br + k = 0\")\n        self.play(ReplacementTransform(ode.copy(), char_eq))\n        self.wait(2)\n\n        # Calculate the roots of the characteristic equation\n        roots_title = Text(\"Roots of the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, roots_title))\n        roots = MathTex(r\"r = \\frac{-b \\pm \\sqrt{b^2 - 4mk}}{2m}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(2)\n\n        # Display the general solution depending on the discriminant\n        solution_title = Text(\"General solution depends on the discriminant\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, solution_title))\n        different_cases = VGroup(\n            MathTex(r\"\\text{If } \\Delta > 0: x(t) = C_1 e^{r_1 t} + C_2 e^{r_2 t}\"),\n            MathTex(r\"\\text{If } \\Delta = 0: x(t) = (C_1 + C_2 t) e^{-bt / 2m}\"),\n            MathTex(r\"\\text{If } \\Delta < 0: x(t) = e^{-bt / 2m}(C_1 \\cos{\\omega t} + C_2 \\sin{\\omega t})\")\n        ).arrange(DOWN, aligned_edge=LEFT, buff=0.5)\n\n        self.play(Write(different_cases))\n        self.wait(2)\n\n        # Clear scene and conclude with the case of critical damping\n        self.clear()\n        self.wait(1)\n        crit_damping = Text(\"Case of critical damping (\\\\(\\\\Delta = 0\\\\))\", font_size=24)\n        crit_solution = MathTex(r\"x(t) = (C_1 + C_2 t) e^{-bt / 2m}\")\n        self.play(Write(crit_damping))\n        self.wait(1)\n        self.play(Write(crit_solution))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animation demonstrating the Law of Large Numbers by flipping a coin 100 times and updating the proportion of heads to the total number of flips in real-time at the top edge of the screen? The proportion should be represented as a decimal number and should dynamically change as the coin lands on heads or tails. The animation should proceed quickly and complete within 10 seconds, with a brief pause at the end.",
        "answer": "\\n from manim import *\n\nclass ChemicalBonding(Scene):\n    def construct(self):\n        # Create oxygen and hydrogen objects\n        oxygen = Circle(radius=0.5, color=BLUE).set_fill(BLUE, opacity=0.5)\n        hydrogen1 = Circle(radius=0.2, color=WHITE).set_fill(WHITE, opacity=0.5)\n        hydrogen2 = Circle(radius=0.2, color=WHITE).set_fill(WHITE, opacity=0.5)\n\n        # Positioning hydrogen objects on the left and right of the oxygen\n        hydrogen1.move_to(LEFT)\n        hydrogen2.move_to(RIGHT)\n\n        # Adding bond lines\n        bond1 = Line(hydrogen1.get_center(), oxygen.get_center())\n        bond2 = Line(hydrogen2.get_center(), oxygen.get_center())\n\n        # Group the molecules and bonds\n        water_molecule = VGroup(oxygen, hydrogen1, hydrogen2, bond1, bond2)\n\n        # Animate creation of the water molecule\n        self.play(\n            Create(oxygen),\n            Create(hydrogen1),\n            Create(hydrogen2),\n            GrowFromCenter(bond1),\n            GrowFromCenter(bond2)\n        )\n\n        # Wait for 2 seconds\n        self.wait(2)\n\n        # Rotate the molecule\n        self.play(Rotate(water_molecule, PI), run_time=2)\n\n        # Wait for 2 seconds\n        self.wait(2)\n\n        # Fade out all elements\n        self.play(FadeOut(water_molecule))\n\n        # End the scene\n        self.wait(2)"
    },
    {
        "query": "Could you please create a 3D animation of a helix curve, where the x, y, and z coordinates follow the sine, cosine, and a linear function, respectively? I'd like the curve to be colored blue and to have a full rotation around the z-axis. Additionally, please include a set of 3D axes for reference. To make it more visually appealing, start the camera at a tilted angle and have it slowly rotate around the scene as the animation plays. Let the video run long enough to appreciate the camera movement after the curve is drawn.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Set up the axes\n        axes = Axes(\n            x_range=[0, 2, 0.5],\n            y_range=[0, 2, 0.5],\n            axis_config={\"color\": BLUE},\n        )\n        self.play(Create(axes))\n        self.wait(1)\n\n        # Define the curve and area under the curve\n        curve = axes.plot(lambda x: x**2, x_range=[0, 1.5], color=RED)\n        area = axes.get_area(curve, x_range=[0, 1.5], color=RED, opacity=0.5)\n        self.play(Create(curve), FadeIn(area))\n        self.wait(1)\n\n        # Adding a label to the curve\n        curve_label = axes.get_graph_label(curve, label='x^2')\n        self.play(Write(curve_label))\n        self.wait(1)\n\n        # Display the integral that represents the area\n        integral = MathTex(r\"\\int_0^{1.5} x^2 \\,dx\").next_to(area, UP)\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Solving the integral, step by step\n        integral_step_1 = MathTex(r\"= \\frac{1}{3} x^3 \\Big|_0^{1.5}\")\n        self.play(Transform(integral, integral_step_1))\n        self.wait(2)\n\n        integral_step_2 = MathTex(r\"=\\frac{1}{3} (1.5)^3 - \\frac{1}{3} (0)^3\")\n        self.play(Transform(integral, integral_step_2))\n        self.wait(2)\n\n        integral_solution = MathTex(r\"= \\frac{1}{3} \\cdot 3.375\")\n        self.play(Transform(integral, integral_solution))\n        self.wait(2)\n\n        integral_final = MathTex(r\"= 1.125\")\n        self.play(Transform(integral, integral_final))\n        self.wait(2)\n\n        # Clear the scene and show the final solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(integral_final))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated video of a red dot tracing out a Lissajous curve with the x-component 2sin(3t + pi/2) and the y-component 2sin(2t) over the course of one full cycle. Can the tracing be done smoothly over a duration of 5 seconds and remain on the screen for an additional second once the tracing is complete?",
        "answer": "\\n from manim import *\n\nclass CircleTheorem(Scene):\n    def construct(self):\n        # Create a circle with a radius\n        circle = Circle(radius=2)\n        radius = Line(start=ORIGIN, end=circle.get_top())\n        radius_label = Tex(\"r\").next_to(radius, LEFT)\n\n        self.play(Create(circle))\n        self.play(Create(radius), Write(radius_label))\n        self.wait(1)\n\n        # Explain the area of a circle\n        area_explanation = Tex(\"The area of a circle is given by the formula \\\\\\\\\",\n                               r\"Area = \\pi r^2\")\n        area_explanation.to_edge(UP)\n\n        self.play(Write(area_explanation))\n        self.wait(2)\n\n        # Create the formula for the area of the circle\n        area_formula = Tex(r\"A = \\pi r^2\").to_edge(DOWN)\n        self.play(Transform(area_explanation, area_formula))\n        self.wait(2)\n\n        # Show circumference of a circle\n        circle_circumference = Circle(radius=2, color=YELLOW)\n        dot = Dot(circle_circumference.point_at_angle(0))\n        circumference_label = Tex(\"Circumference = 2\\\\pi r\").move_to(circle.get_bottom() + DOWN*0.5)\n\n        self.play(Create(dot))\n        self.play(MoveAlongPath(dot, circle_circumference), rate_func=linear, run_time=2)\n        self.play(dot.animate.move_to(circle.get_right()), FadeOut(dot))\n        self.play(Write(circumference_label))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that visually explains the concept of the fifth roots of unity using colors to distinguish between the roots and the lines connecting them to the center of a complex plane, and label the axes for clearer understanding?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_points\").shift(UP*2.5)), run_time=0.5)\n            circ = Circle(fill_color=RED, fill_opacity=0.8).shift(RIGHT*1.5)\n            square = Square(fill_color=BLUE, fill_opacity=0.2).shift(LEFT*1.5)\n            self.add(circ,square)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)\n            self.play(FadeOut(circ),FadeOut(square))"
    },
    {
        "query": "Could you create an educational animation featuring a simple pendulum, including the point of suspension (pivot) and the bob at the bottom, that shows the pendulum rod swinging back and forth through a small angle, similar to a real pendulum's motion, with the entire setup appearing smoothly on the screen and the swinging action occurring over a short period of time?",
        "answer": "\\n from manim import *\n\nclass FourierCirclesScene(Scene):\n    def construct(self):\n        wave = lambda x: np.sin(x)\n        fourier_circles = FourierSeries(wave, color=BLUE, n_terms=5).scale(0.5)\n        \n        self.add(fourier_circles)\n        self.play(Create(fourier_circles.animate.shift(3*LEFT)))\n        self.wait(2)\n\n        path = fourier_circles.make_path(up_to=3*TAU, step_size=0.05)\n        self.play(Create(path), run_time=3)\n\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation showing the first ten terms of a Fourier series approximation of a square wave using Manim?",
        "answer": "\\n from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        layers = VGroup(\n            RoundedRectangle(cornerRadius=0.15, width=4, height=1, fill_color=BLUE, fill_opacity=0.5),\n            RoundedRectangle(cornerRadius=0.15, width=4, height=1, fill_color=GREEN, fill_opacity=0.5),\n            RoundedRectangle(cornerRadius=0.15, width=4, height=1, fill_color=RED, fill_opacity=0.5),\n        )\n        # Arrange layers vertically with a specified distance between them\n        layers.arrange(DOWN, buff=0.5)\n\n        # Add layer labels\n        for i, layer in enumerate(layers):\n            label = Text(f\"Layer {i+1}\", color=WHITE).scale(0.5)\n            label.move_to(layer.get_center())\n            layer.add(label)\n\n        # Create arrows between layers\n        arrows = VGroup()\n        for i in range(len(layers) - 1):\n            arrow = Arrow(start=layers[i].get_bottom(), end=layers[i+1].get_top(), buff=0.1)\n            arrows.add(arrow)\n\n        # Create the full neural network diagram and move it to the center\n        neural_net = VGroup(layers, arrows)\n        neural_net.move_to(ORIGIN)\n\n        # Animation\n        self.play(FadeIn(neural_net, shift=UP))\n        self.wait(1)\n        self.play(Transform(layers[0], layers[0].copy().set_fill(YELLOW, 0.5)))\n        self.wait(1)\n        self.play(Transform(layers[1], layers[1].copy().set_fill(YELLOW, 0.5)))\n        self.wait(1)\n        self.play(Transform(layers[2], layers[2].copy().set_fill(YELLOW, 0.5)))\n        self.wait(1)\n\n        # Fade out animation\n        self.play(FadeOut(neural_net, shift=DOWN))"
    },
    {
        "query": "Can you create an animation that shows a 3D spherical-like object with a rippling effect on its surface, rotate the camera around it to get a better view, and make the animation last for about 8 seconds?",
        "answer": "\\n from manim import *\n\nclass StreamLinePlot(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        stream_lines = StreamLines(\n            lambda p: np.array([p[1], -p[0], 0]), \n            stroke_width=3,\n            max_anchors_per_line=30,\n        )\n        self.add(plane)\n        self.add(stream_lines)\n        self.play(stream_lines.create())  # Uses the StreamLines Animation\n        self.wait(2)"
    },
    {
        "query": "I'd like to see a visually engaging animation where there is a grid that represents the plane, and on top of that, I want to see a field of arrows that seem to rotate around the origin. Can you make it so that the arrows to the left of the origin point upwards and the arrows to the right point downwards, creating a sort of swirling pattern across the entire grid? The grid should cover the space between negative five to positive five both horizontally and vertically and the animation should last a couple of seconds.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Defining the integral problem\n        problem = MathTex(r\"\\int_2^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Displaying the integration bounds\n        bounds = Text(\"From x=2 to x=3\", font_size=24).to_edge(UP)\n        self.play(Write(bounds))\n        self.wait(2)\n\n        # Applying the power rule for definite integrals\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration between the bounds\n        solution = MathTex(r\"= \\left. \\frac{x^{3}}{3} \\right|_2^3\")\n        self.play(ReplacementTransform(problem.copy(), solution))\n        self.wait(1)\n\n        # Evaluating the definite integral at the upper bound\n        evaluated_at_upper = MathTex(r\"= \\frac{3^3}{3}\")\n        self.play(ReplacementTransform(solution.copy(), evaluated_at_upper))\n        self.wait(1)\n\n        # Evaluating the definite integral at the lower bound\n        evaluated_at_lower = MathTex(r\"-\\frac{2^3}{3}\")\n        self.play(Write(evaluated_at_lower.next_to(evaluated_at_upper, RIGHT)))\n        self.wait(1)\n\n        # Calculating the final value of the definite integral\n        final_value = MathTex(r\"= \\frac{27}{3} - \\frac{8}{3}\")\n        self.play(ReplacementTransform(VGroup(evaluated_at_upper, evaluated_at_lower), final_value))\n        self.wait(1)\n\n        # Simplifying the final result\n        final_result = MathTex(r\"= 6\")\n        self.play(ReplacementTransform(final_value, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final solution\n        final_solution_display = MathTex(r\"\\int_2^3 x^2 \\,dx = 6\")\n        self.play(Write(final_solution_display))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation for a math class where we are discussing probability theory, specifically the Monty Hall Problem. In the animation, can you show three doors side by side with one randomly having a car behind it and the other two having goats? I'd also like a description at the top stating, \"One of these doors has a car behind it, and the others have goats.\" Each door should be revealed with its content (either a goat or the car) after being presented. Can you make this happen?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left[\\frac{x^{n+1}}{n+1}\\right]_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left[\\frac{x^{3+1}}{3+1}\\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate from a to b:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate the solution with bounds\n        evaluated_solution = MathTex(r\"= \\left[\\frac{1}{4}x^4\\right]_0^2\")\n        self.play(Transform(solution1, evaluated_solution))\n        self.wait(1)\n\n        solution2 = MathTex(r\"= \\left. \\frac{1}{4}x^4 \\right|_0^2\")\n        self.play(Transform(evaluated_solution, solution2))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{4}(2^4) - \\frac{1}{4}(0^4)\")\n        self.play(Transform(solution2, final_solution))\n        self.wait(1)\n\n        final_result = MathTex(r\"= 4\")\n        self.play(Transform(final_solution, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(3)"
    },
    {
        "query": "I would like to create an animated video that explains the process of solving a differential equation. The specific equation I want to focus on is dy/dx = x^2 - y^2. I'd like the animation to proceed through the following steps: first, display the original equation, then show the process of separating variables, followed by integrating both sides of the equation, and finally, show the integrated result with the constant of integration. Each step should be written out mathematically, and I want a short pause after writing each step to give viewers time to comprehend the material.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"CounterclockwiseTransform\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            star = Star()\n            self.play(CounterclockwiseTransform(square,star))\n            self.remove(square,star)"
    },
    {
        "query": "Could you create an animated video that starts by displaying the mathematical function \"f(x) = sin(x)\" on the screen, then changes the text to \"Fourier Transform of f(x)\" after a brief pause, and finally after another short pause, adds a statement below saying \"This transforms the function into frequency space\"?",
        "answer": "\\n from manim import *\n\nclass ThirdOrderODEExample(Scene):\n    def construct(self):\n        # Display the differential equation\n        ode = MathTex(r\"y''' - 3y'' + 3y' - y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Show the characteristic equation explanation\n        char_eq_expl = Text(\"Characteristic equation:\", font_size=24).to_edge(UP)\n        self.play(FadeIn(char_eq_expl))\n        self.wait(2)\n\n        # Write the characteristic equation\n        char_eq = MathTex(r\"r^3 - 3r^2 + 3r - 1 = 0\")\n        self.play(Transform(ode, char_eq))\n        self.wait(2)\n\n        # Solve the characteristic equation\n        sol_expl = Text(\"Solve for r:\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_expl, sol_expl))\n        self.wait(2)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = 1\")\n        self.play(Transform(ode, roots))\n        self.wait(2)\n\n        # Display the general solution to the ODE\n        general_sol = MathTex(r\"y = (C_1 + C_2 x + C_3 x^2) e^x\")\n        self.play(FadeOut(ode), FadeIn(general_sol))\n        self.wait(2)\n\n        # General solution explanation\n        gen_sol_expl = Text(\"General solution for the ODE:\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_expl, gen_sol_expl))\n        self.wait(2)\n\n        # Conclude the scene\n        self.play(FadeOut(char_eq_expl), FadeOut(general_sol))\n        self.wait(1)\n        self.play(Write(general_sol))\n        self.wait(1)"
    },
    {
        "query": "Could you create a 3D animation that starts with a set of 3D axes, then writes out the complex function f(z) = z^2, and finally shows a 3D model of the graph of that function?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{x} e^{y^2} dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} [e^{y^2}]_{0}^{x} dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [e^{x^2}]_{0}^{1}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Final answer\n        answer = MathTex(r\"= e - 1\")\n        self.play(Write(answer))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation using ManimCE that depicts the Earth orbiting around the Sun to illustrate planetary motion, with the Sun being larger and placed to the left, and the Earth smaller and blue, placed to the right? The animation should fade in both the Sun and the Earth, include a descriptive text about the Earth's orbit due to gravitational forces, show the visible path of the Earth's orbit as an ellipse, and conclude with the Earth rotating around the Sun for a set time.",
        "answer": "\\n from manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        chart = BarChart(\n            values=[-5, 40, -10, 20, -3],\n            bar_names=[\"one\", \"two\", \"three\", \"four\", \"five\"],\n            y_range=[-20, 50, 10],\n            y_length=6,\n            x_length=10,\n            x_axis_config={\"font_size\": 36},\n        )\n\n        c_bar_lbls = chart.get_bar_labels(font_size=48)\n        self.add(chart, c_bar_lbls)"
    },
    {
        "query": "Could you create an educational animation that visually demonstrates the Pythagorean Theorem by first showing a right-angled triangle with the sides labeled 'a', 'b', and 'c', where 'c' is the hypotenuse, and then by showing squares on each of these sides to prove that the area of the square on the hypotenuse ('c') is equal to the sum of the areas of the squares on the other two sides ('a' and 'b')? Additionally, could the animation have an explanatory text about the theorem and conclude with the formula \"a^2 + b^2 = c^2\" displayed on screen?",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillator(Scene):\n    def construct(self):\n        # Display the differential equation\n        ode = MathTex(r\"m\\ddot{x} + kx = 0\")\n        self.play(Write(ode))\n        self.wait(2)\n\n        # Display the explanation for the angular frequency\n        angular_freq_explanation = Text(\"Angular frequency:\", font_size=24).to_edge(UP)\n        self.play(Write(angular_freq_explanation))\n        self.wait(1)\n\n        # Display the angular frequency formula\n        omega = MathTex(r\"\\omega = \\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(ode.copy(), omega))\n        self.wait(2)\n\n        # Explaining the solution type\n        solution_type_explanation = Text(\"The solution is harmonic\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq_explanation, solution_type_explanation))\n        self.wait(2)\n\n        # Display the general solution of the harmonic oscillator\n        solution = MathTex(r\"x(t) = A \\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(omega, solution))\n        self.wait(2)\n\n        # Exhibit the amplitude and phase\n        amplitude_phase_explanation = Text(\"A is amplitude, and \u03c6 is phase\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq_explanation, amplitude_phase_explanation))\n        self.wait(2)\n\n        # Clear the scene and conclude with the final solution\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"Complete harmonic motion equation\", font_size=24).to_edge(UP)\n        self.play(Write(conclusion))\n        self.play(Write(solution))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational math animation that visually demonstrates the concept of limits in calculus using a graph? Specifically, I'd like to see a simple graph, like a parabola for the function y=x^2, where you show how the value of the function approaches a certain point as x approaches the value of 2. Also, include a text explanation stating \"As x approaches 2, the value of x^2 approaches 4.\" at the top of the screen and highlight the point on the graph (2,4) with a red dot and a dashed yellow line from the x-axis to this point to signify the approach.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explaining the equation\n        explanation1 = Text(\"This is the wave equation, where c is the wave speed.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Discussing the solution\n        explanation2 = Text(\"Solutions can be sinusoidal or composed of superposed waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Presenting a sinusoidal solution\n        sinusoidal_solution = MathTex(r\"u(x, t) = A \\cos(kx - \\omega t + \\phi)\")\n        self.play(ReplacementTransform(equation, sinusoidal_solution))\n        self.wait(1)\n\n        # Discussing the components of sinusoidal solutions\n        explanation3 = Text(\"Here, A is amplitude, k is wave number, \u03c9 is angular frequency, and \u03c6 is phase shift.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Demonstrating superposition principle\n        explanation4 = Text(\"By the superposition principle, we can add solutions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Displaying the superposition of two waves\n        superposed_waves = MathTex(r\"u(x, t) = u_1(x, t) + u_2(x, t)\")\n        self.play(Transform(sinusoidal_solution, superposed_waves))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(explanation4))\n        self.wait(1)\n        self.play(FadeIn(sinusoidal_solution, shift=DOWN))\n        self.wait(1)"
    },
    {
        "query": "I need an educational animation that explains the process of matrix multiplication. The visual should begin by showing two matrices side by side - the first matrix is a 2x2 containing the numbers 1, 2 in the first row and 3, 4 in the second row, and the second matrix is also a 2x2 with the numbers 2, 0 in the first row and 1, 3 in the second row. Both matrices should be enclosed in parentheses as their brackets.\n\nOnce the matrices are displayed, a text description should appear at the top that reads: \"To multiply two matrices, we take the dot product of rows from the first matrix with columns of the second.\" Make sure the audiences have enough time to read and understand this part.\n\nThen, I want to draw the viewers' attention to the multiplication process. Please highlight the first row of the first matrix and the first column of the second matrix using different colors, let's say green for the row and pink for the column, and pause for a bit to let it sink in.\n\nAfter highlighting, can you have the matrices animated so that they transform into the resulting matrix to the right side of the screen? The result of the multiplication should be another 2x2 matrix with 2, 6 in the first row and 6, 12 in the second row, again enclosed in parentheses. The entire animation should be paced slowly enough for an educational setting where viewers need time to understand each step.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Rotate\").shift(UP*2.5)), run_time=0.5)\n            star = Star()\n            self.play(Rotate(star))\n            self.wait(0.5)\n            self.remove(star)"
    },
    {
        "query": "How can I create an animation that shows a red dot at the center to represent a positive charge with a plus sign above it, followed by the field lines emanating outward to visualize an electric field?",
        "answer": "\\n from manim import *\n\n\ndef lissajous_curve_func(t):\n    return np.array((np.sin(3 * t), np.sin(4 * t) + 2 / 3 * PI, 0))\n\n\nclass MyScene(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        dot = Dot()\n        dummy_func = ParametricFunction(lissajous_curve_func, t_max=TAU, fill_opacity=0)\n        dummy_func.scale(2).move_to(ORIGIN)\n        func1 = dummy_func.copy().set_stroke(width=18)\n        func1 = CurvesAsSubmobjects(func1)\n        func1.set_color_by_gradient(YELLOW_A, YELLOW_D)\n        func2 = dummy_func.copy().set_color(BLACK).set_stroke(width=20)\n        dot.add_updater(lambda m: m.move_to(dummy_func.get_end()))\n        dummy_func.set_opacity(0)\n        # or dummy_func.fade(1) )\n        self.add(dot)\n        self.play(\n            ShowCreation(dummy_func),\n            ShowCreation(func2),\n            ShowCreation(func1),\n            rate_func=linear,\n            run_time=9,\n        )\n        self.add(func1)\n        self.wait()\n        banner = ManimBanner(dark_theme=False).scale(0.3).to_corner(DR)\n        self.play(FadeIn(banner))\n        self.play(banner.expand())\n        self.wait(3)"
    },
    {
        "query": "Please create an educational animation that explains Euler's Formula and visually demonstrates how it connects complex exponentials with trigonometric functions on a complex plane. The animation should start with writing out Euler's Formula, followed by a brief written explanation of its significance in complex analysis. Then, show a complex plane and a circle representing the unit circle in the complex plane. Additionally, include a moving red dot on the circumference of the circle and an arrow from the origin to the red dot, showing how as the dot moves, it represents the complex exponential traveling around the unit circle. The animation should be clear and paced well for an educational presentation.",
        "answer": "\\n from manim import *\n\nclass QuadraticEquationScene(Scene):\n    def construct(self):\n        # Display the quadratic equation\n        equation = MathTex(\"ax^2 + bx + c = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Display the formula for finding roots\n        roots_formula = MathTex(r\"x = \\frac{{-b \\pm \\sqrt{{b^2 - 4ac}}}}{{2a}}\")\n        self.play(Write(roots_formula))\n        self.wait(1)\n\n        # Transition to Discriminant\n        discriminant = MathTex(r\"D = b^2 - 4ac\")\n        self.play(ReplacementTransform(roots_formula.copy(), discriminant))\n        self.wait(2)\n\n        # Discuss the nature of roots based on discriminant\n        roots_nature = Text(\"Nature of roots depends on D\", font_size=24).to_edge(DOWN)\n        self.play(Write(roots_nature))\n        self.wait(2)\n\n        # Example with positive discriminant\n        example_positive_D = MathTex(r\"D = 1^2 - 4(1)(-1) = 5\")\n        self.play(ReplacementTransform(discriminant, example_positive_D))\n        self.wait(1)\n        \n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude by displaying the nature of roots\n        conclusion = Text(\"D > 0, Two distinct real roots\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the process of solving the integral of x*cos(x^2) with respect to x using the method of integration by substitution? The steps should include the following: First, show the original integral. Next, animate the substitution of u = x^2 and the calculation of du. Then, display the rewritten integral in terms of u. Afterward, show the process of integrating with respect to u to get the antiderivative. Finally, replace u with x^2 to show the result back in terms of x. Include pauses after each step so the viewers have time to understand the material.",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass FibonacciPattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Group(\n            Tex(\"Observe a sequ\u00eancia\", color=LIGHT_RED_COLOR),\n            Tex(\"abaixo:\", color=LIGHT_RED_COLOR)\n        )\n        title.arrange(DOWN)\n        title.scale(1.8)\n        title.shift(3.5 * UP)\n        colors = [\n            LIGHT_BLUE_COLOR, \n            LIGHT_RED_COLOR, \n            LIGHT_ORANGE_COLOR, \n            AQUA_GREEN_COLOR, \n            LIGHT_PURPLE_COLOR, \n            LIGHT_BLUE_COLOR\n        ]\n        sequence = [0, 1, 1, 2, 3, 5, 8]\n        pattern_text = Tex(\"0, 1, 1, 2, 3, 5, 8, 13, ...\", color=TEXT_COLOR).scale(1.5)\n        previous_arc = None\n        previous_arc_text = None\n        previous_arc_box = None\n\n        self.add(title)\n        self.play(FadeIn(Group(pattern_text)), run_time=0.8)\n        self.wait(1)\n\n        for i in range(6):\n            start = -2.1 + i * 0.85\n            end = -3.25 + i * 0.85\n\n            arc_text = Tex(f\"{sequence[i]}+{sequence[i+1]}\", color=colors[i])\n            arc_text.scale(0.8)\n\n            if i % 2 == 0:\n                y1 = 0.5\n                y2 = 0.5\n                direction = UP\n            else:\n                y1 = -0.6\n                y2 = -0.39\n                direction = DOWN\n\n            arc = ArcBetweenPoints([start, y1, 0], [end, y1, 0], color=colors[i])\n            arc.flip(UP)\n\n            if i % 2 == 1:\n                arc.flip(RIGHT)\n\n            arc.add_tip(tip_shape=ArrowTriangleFilledTip)\n            arc_text.next_to(arc, direction)\n            arc_box = Line(np.array([end - 0.455, y2, 0]), np.array([start - 0.555, y2, 0]), color=colors[i])\n\n            if previous_arc is None:\n                self.play(FadeIn(Group(arc_text, arc, arc_box)), run_time=0.25)\n            else:\n                self.play(\n                    Transform(previous_arc_text.copy().set_opacity(0), arc_text), \n                    Transform(previous_arc.copy().set_opacity(0), arc),\n                    Transform(previous_arc_box.copy().set_opacity(0), arc_box),\n                    rate_func=rate_functions.rush_from,\n                    run_time=0.4\n                )\n\n            previous_arc_text = arc_text\n            previous_arc = arc\n            previous_arc_box = arc_box\n            self.wait(0.7)\n        \n        text = Tex(\"Fibonacci\", color=TEXT_COLOR)\n        text.shift(DOWN * 3.5)\n        text.scale(2)\n\n        self.play(Write(text))\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects)))"
    },
    {
        "query": "Please create an animated video using ManimCE that demonstrates projectile motion with the effects of air resistance where the animation starts with the title \"Projectile motion with air resistance\" followed by a subtitle \"The motion is influenced by gravity and drag force.\" Then, show two physics equations representing the drag force and the resulting acceleration due to gravity and drag force. Finally, animate a dot following a parabolic path to represent the projectile motion influenced by these forces, making sure the animation of the projectile motion lasts for about four seconds.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{-1}^{1} \\int_{-1}^{1} [\\frac{1}{2}xyz^2]_{-1}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{-1}^{1} [\\frac{1}{2}xy^2z^2]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}x^2y^2z^2]_{-1}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that introduces the concept of Fourier series, showing the text \"Fourier Series Expansion of a Periodic Function\" first, then adds an explanation stating that a periodic function can be represented as the sum of sines and cosines, and finally displays the mathematical formula for a Fourier series?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the function and the area to be shaded\n        func = lambda x: x**2\n        area_start = 0\n        area_end = 2\n\n        # Display the function\n        function_graph = FunctionGraph(func, x_min=area_start, x_max=area_end)\n        self.play(Create(function_graph))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = area = Integral(function_graph, (area_start, area_end))\n        self.play(Write(area))\n        self.wait(2)\n\n        # Display the integral form\n        integral_text = MathTex(r\"\\int_{0}^{2} x^2 \\,dx\")\n        integral_text.next_to(area, UP)\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Show the solution step-by-step\n        solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\")\n        self.play(Transform(integral_text, solution))\n        self.wait(2)\n\n        solution_final = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(Transform(solution, solution_final))\n        self.wait(2)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_final))\n        self.wait(1)"
    },
    {
        "query": "\"I want to create an animated math video using ManimCE where the scene starts with a 2D coordinate plane. On this plane, I want to show a visualization of a vector field where particles seem to be flowing along the streamlines. Specifically, I would like the vector field to represent a simple rotation, where the horizontal component is directed in the direction of the y-value and the vertical component in the opposite direction of the x-value. I\u2019d also like the streamlines to be fairly smooth with a moderate stroke width for clear visibility. Could you also ensure the animation runs for a few seconds so I can see the particles moving along these streamlines?\"",
        "answer": "\\n from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the surface integral problem\n        problem = MathTex(r\"\\iint_S \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Detail the vector field F\n        vector_field = MathTex(r\"\\vec{F} = x\\hat{i} + y\\hat{j} + z\\hat{k}\").next_to(problem, DOWN)\n        self.play(Write(vector_field))\n        self.wait(1)\n        \n        # Detail surface S\n        surface_s = MathTex(r\"S: z = x^2 + y^2\").next_to(vector_field, DOWN)\n        self.play(Write(surface_s))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"Parameterize Surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization of S\n        parameterization = MathTex(r\"\\vec{r}(u,v) = u\\hat{i} + v\\hat{j} + (u^2+v^2)\\hat{k}\", r\",\\quad S: u^2+v^2 \\leq 1\")\n        self.play(Write(parameterization))\n        self.wait(2)\n\n        # Compute dS\n        explanation2 = Text(\"Compute dS using cross product of partial derivatives\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Computation of dS\n        compute_ds = MathTex(r\"d\\vec{S} = \\left|\\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v}\\right| du\\, dv \\hat{k}\")\n        self.play(Write(compute_ds))\n        self.wait(2)\n\n        # Plug in F and dS\n        explanation3 = Text(\"Substitute F and dS into the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n        \n        # Substituting in the integral\n        substituted_integral = MathTex(r\"\\iint_S (x\\hat{i} + y\\hat{j} + z\\hat{k}) \\cdot d\\vec{S}\")\n        self.play(Transform(problem, substituted_integral))\n        self.wait(1)\n\n        # Final steps\n        explanation4 = Text(\"Evaluate the integral over the parameterized domain\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n        \n        # Final evaluation\n        final_evaluation = MathTex(r\"\\iint_{D} f(u, v) \\ du \\ dv\", r\",\\quad D:\\  u^2+v^2 \\leq 1\")\n        self.play(Transform(problem, final_evaluation))\n        self.wait(1)\n        \n        # Conclude with the solution\n        solution = Text(\"Compute the final integral to get the result.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, solution))\n        self.wait(2)"
    },
    {
        "query": "I would like an animation that introduces the concept of prime numbers using rectangles. The background should be a soft tan color, and I want the title \"N\u00fameros primos e ret\u00e2ngulos\" in light green at the top. Can you create animated rectangles, each representing a different prime number up to 29, where the width is always 1 and the height is the prime number itself? Please display a label on each rectangle with the product of its width and height, which will be the prime number itself, in the same color as the rectangle. The rectangles should fade in with a quadratic ease-in effect and be arranged in two rows and five columns. Transition them with a short delay between each. After all have appeared, wait a moment, and then fade them all out together. The overall appearance should be pleasing, with a gradual change in rectangle colors from light blue to purple across the prime numbers.",
        "answer": "\\n from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        integral_problem = MathTex(r\"\\iint_{S} (x^2 + y^2) dS\")\n        self.play(Write(integral_problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        param_explanation = Text(\"Parametrize the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(param_explanation))\n        self.wait(2)\n\n        # Parameterization step\n        parameterization = MathTex(r\"S(\\theta, \\phi) = (r\\sin\\phi\\cos\\theta, r\\sin\\phi\\sin\\theta, r\\cos\\phi)\")\n        self.play(ReplacementTransform(integral_problem.copy(), parameterization))\n        self.wait(1)\n\n        # Explanation for the surface element\n        surf_elem_explanation = Text(\"Compute the surface element dS\", font_size=24).to_edge(UP)\n        self.play(Transform(param_explanation, surf_elem_explanation))\n        self.wait(2)\n\n        # Surface element step\n        surface_element = MathTex(r\"dS = r^2\\sin\\phi d\\phi d\\theta\")\n        self.play(ReplacementTransform(parameterization, surface_element))\n        self.wait(1)\n\n        # Integrate problem converted\n        integrate_converted = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2\\pi} (r^2\\sin^2\\phi) r^2\\sin\\phi d\\phi d\\theta\")\n        self.play(ReplacementTransform(surface_element, integrate_converted))\n        self.wait(1)\n\n        # Explanation for solving the integral\n        solve_integral_explanation = Text(\"Solve the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(param_explanation, solve_integral_explanation))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 4\\pi r^4 \\int_{0}^{\\pi} \\sin^3\\phi d\\phi\")\n        self.play(ReplacementTransform(integrate_converted, final_solution))\n        self.wait(1)\n\n        # Final result after integration\n        final_result = MathTex(r\"= \\frac{4}{3}\\pi r^4\")\n        self.play(ReplacementTransform(final_solution, final_result))\n        self.wait(2)"
    },
    {
        "query": "I would like to see an animation that explains the concept of a derivative using a visual representation. Can you create an animation where a graph is shown on a set of axes with both the original function and its derivative? The function should be something simple, like f(x) = x^2, and its derivative should also be shown on the graph. Also, I would like to see a tangent line drawn at the point where x equals 1 on the original function's graph to illustrate the slope of the tangent, which represents the value of the derivative at that point. Additionally, include some text in the animation that explains that the tangent line represents the derivative of the function. The text should be clearly visible and placed appropriately in relation to the tangent line. Can you ensure that each element of the animation is presented one after the other with some pauses in between to give viewers a moment to process the information?",
        "answer": "\\n from manim import *\n\nclass MovingShapes(Scene):\n    def construct(self):\n        circles = VGroup(\n            *[Circle(radius=0.5, color=Color(hue=k/7, saturation=1, luminance=0.5), fill_opacity=0.5)\n              for k in range(7)]\n        ).arrange_in_grid(rows=1)\n        self.play(FadeIn(circles), run_time=2)\n        self.play(\n            circles.animate.shift(UP * 2),\n            rate_func=smooth,\n            run_time=2\n        )\n        self.play(\n            circles.animate.arrange(DOWN).scale(0.75),\n            rate_func=there_and_back_with_pause,\n            run_time=2\n        )\n        self.wait()"
    },
    {
        "query": "I would like to create an animation where a robot contemplates a mathematics question. The setting should be as if it's thinking about the question \"What is the square root of 16?\" This thought should be visually represented by a thought bubble appearing next to the robot. The robot should begin off the screen to the right, then move to the center while the thought bubble and the question within it fade in. After a few seconds, the robot should move back to its original off-screen position as the thought bubble and question fade out. Can we also ensure the colors used in the animation are soft and calming? The robot image file is named 'robot_image.png' and is located in a folder called 'assets'.",
        "answer": "\\n from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyingNonEquivalent(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{3}{6}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{9}{12}\", color=TEXT_COLOR).scale(2)\n        ).arrange(RIGHT, buff=3)\n        arrow_up = ArcBetweenPoints(\n            fractions[0].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[1].get_top() + 0.2 * UP + 0.1 * LEFT, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down = ArcBetweenPoints(\n            fractions[0].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * LEFT, \n            color=LIGHT_RED_COLOR\n        ).add_tip()\n        text_up = Tex(r\"Multiplicado por 3\", color=LIGHT_BLUE_COLOR)\n        text_up.next_to(arrow_up, UP)\n        text_down = Tex(r\"Multiplicado por 2\", color=LIGHT_RED_COLOR)\n        text_down.next_to(arrow_down, DOWN)\n        equal = MathTex(r\"\\neq\", color=LIGHT_RED_COLOR)\n        equal.shift(0.1 * LEFT)\n        equal.scale(2)\n\n        self.play(Write(fractions), run_time=0.5)\n        self.play(\n            Write(arrow_up),\n            Write(text_up, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down),\n            Write(text_down, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal), run_time=0.5)\n        self.wait(0.5)\n        self.play(FadeOut(Group(*self.mobjects)), run_time=0.7)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the concept of screen units and percentages of the screen dimensions in the context of computer graphics. Could you provide an animation that includes a grid as a reference, and then sequentially displays rectangles of increasing width, each representing a different percentage of the screen's width? Each rectangle should be a different color to clearly distinguish them, and also partially transparent so I can see how they overlap if they do. Finally, is it possible to place a dot at a precise location measured in pixels from the center of the screen, for example, 150 pixels up and to the right?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"MoveToTarget\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            circle.generate_target()\n            circle.move_to(RIGHT)\n            self.play(MoveToTarget(circle))\n            self.remove(circle)"
    },
    {
        "query": "How can I create a simple animation using ManimCE where a pink circle with semi-transparency fades into the scene and remains visible for a couple of seconds before ending the animation?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 3, 1],\n            y_range=[0, 8, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes labels\n        x_label = axes.get_x_axis_label(MathTex(\"x\"))\n        y_label = axes.get_y_axis_label(MathTex(\"y\")).shift(VRIGHT)\n\n        # The function to plot\n        func_graph = axes.plot(lambda x: x**2, color=GREEN)\n\n        # Area under curve\n        area = axes.get_area(func_graph, x_range=[0,2], color=GREEN, opacity=0.3)\n\n        # Integral symbol\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\", font_size=30).to_corner(UR)\n\n        # Displaying the graph\n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.play(Create(func_graph))\n        self.play(FadeIn(area))\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Evaluate the integral\n        result = MathTex(r\"=\\frac{2^3}{3} - \\frac{0^3}{3}\", r\"=\\frac{8}{3}\", font_size=30).next_to(integral, DOWN)\n\n        self.play(Transform(integral, result))\n        self.wait(2)"
    },
    {
        "query": "I would like an animated video that visually demonstrates Prim's algorithm for finding a minimum spanning tree on a graph. The graph should be circular with seven vertices connected by a selection of edges. The animation should start by showing the complete graph with all vertices and edges, and then proceed to apply Prim's algorithm, progressively highlighting the edges that create the minimum spanning tree using dashed blue lines. The animation should also include a label stating \"Minimum Spanning Tree (Prim's Algorithm)\" above the graph. After the algorithm has finished running, the video should conclude by fading out both the graph and the label.",
        "answer": "\\n from manim import *\n\nclass AtomGridScene(Scene):\n    def construct(self):\n        grid = self.create_atom_grid(4, 4)\n        self.play(Create(grid))\n        self.wait(2)\n\n    def create_atom_grid(self, rows: int, cols: int) -> Mobject:\n        atom_list = []\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom_list.append(self.hydrogen_atom().move_to(np.array([i - rows // 2, j - cols // 2, 0])))\n                else:\n                    atom_list.append(self.chlorine_atom().move_to(np.array([i - rows // 2, j - cols // 2, 0])))\n        return VGroup(*atom_list)\n\n    def hydrogen_atom(self) -> Mobject:\n        return Circle(radius=0.2, color=WHITE).add(Tex(\"H\", color=BLACK).scale(0.5))\n\n    def chlorine_atom(self) -> Mobject:\n        return Circle(radius=0.3, color=GREEN).add(Tex(\"Cl\", color=WHITE).scale(0.5))"
    },
    {
        "query": "Create a simple animation that shows the Moon orbiting around the Earth. The Earth should be represented as a blue circle at the center of the screen, and the Moon as a smaller grey circle orbiting around it. The path of the Moon\u2019s orbit should be indicated with a faint white circle. Make the radius of the Earth significantly smaller than the Moon's orbit path, but the Moon itself should be even smaller than the Earth. The Moon should complete its orbit at a consistent rate, taking one minute to go all the way around. The animation should be realistic in the sense that it continuously shows the Moon in motion around the Earth without any pauses or changes in speed.",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#E0E0E0\"\nTEXT_COLOR = \"#383838\"\nLIGHT_BLUE_COLOR = \"#ADD8E6\"\nDARK_BLUE_COLOR = \"#00008B\"\n\nconfig.frame_width = 14\nconfig.frame_height = 8\n\n\ndef AppleSlice():\n    return VGroup(\n        Circle(1, color=LIGHT_BLUE_COLOR, fill_opacity=1, stroke_color=DARK_BLUE_COLOR),\n        Line(UP, DOWN, color=DARK_BLUE_COLOR),\n        Line(LEFT, RIGHT, color=DARK_BLUE_COLOR),\n    )\n\n\nclass ApplePie(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Apple Pie Slices\", color=TEXT_COLOR)\n        title.scale(1.5)\n        pie_slice = AppleSlice()\n        pie_slices = VGroup(*[AppleSlice() for _ in range(8)])\n        pie_slices.arrange_in_grid(buff=0.2, rows=2)\n        Group(title, pie_slices).arrange(DOWN, buff=1)\n\n        self.play(Write(title))\n        self.play(LaggedStart(*[GrowFromCenter(slice) for slice in pie_slices], lag_ratio=0.3, run_time=2))\n        self.wait(1)\n\n        # Animate some slices as if taking them out\n        taken_slices = [pie_slices[2], pie_slices[5]]\n        for slice in taken_slices:\n            self.play(slice.animate.shift(3 * UP + 2 * RIGHT), run_time=0.5)\n        self.wait(0.5)\n\n        # Move back the taken slices\n        for slice in taken_slices:\n            self.play(slice.animate.shift(3 * DOWN + 2 * LEFT), run_time=0.5)\n        self.wait(1)\n\n        # Scale down everything and fade out\n        self.play(\n            Group(*self.mobjects).animate.scale(0.5),\n            FadeOut(Group(*self.mobjects)),\n            run_time=1\n        )"
    },
    {
        "query": "Can you create an educational animation that shows a math student thoughtfully considering the greatest common divisor (GCD) of two numbers, 48 and 64, and then display the answer? I would like a pensive imagery with thought bubbles, and after a short pause, the answer should be revealed clearly. Can the overall color theme be soft with a background that is easy on the eyes?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 3x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Demonstrating the power rule with limits\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left[\\frac{x^{n+1}}{n+1}\\right]_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n        \n        # Performing the integration step with boundaries\n        solution1 = MathTex(r\"= \\left[\\frac{3x^{2+1}}{2+1}\\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n        \n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the boundaries:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Evaluating the integral at the boundaries\n        solution2 = MathTex(r\"= \\left[\\frac{3x^3}{3}\\right]_0^2\")\n        self.play(Transform(solution1, solution2))\n        self.wait(1)\n        \n        # Plugging in the upper and lower limits\n        solution3 = MathTex(r\"= \\left[ x^3 \\right]_0^2\")\n        self.play(Transform(solution1, solution3))\n        self.wait(1)\n\n        # Calculating the final value\n        final_value = MathTex(r\"= 2^3 - 0^3 = 8 \")\n        self.play(ReplacementTransform(solution3, final_value))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final value\n        self.play(Write(final_value))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where a blue semi-transparent triangle and a yellow semi-transparent rectangle appear on the screen. The triangle should then move to the left and the rectangle to the right simultaneously. After that, I want the triangle to rotate clockwise by 45 degrees and the rectangle to rotate counter-clockwise by the same angle at the same time. Finally, I'd like the triangle to transform into the rectangle, and a copy of the rectangle to replace the original triangle's position. Can you please provide code for such an animation using ManimCE?",
        "answer": "\\n from manim import *\n\nclass ChemicalScene(Scene):\n    def construct(self):\n        co_oxid_grid = self.metal_oxid(4, 3, 2)\n        self.play(ShowCreation(co_oxid_grid))\n        self.wait()\n\n    def metal_oxid(self, rows: int, cols: int, scale=1.5) -> Mobject:\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (j + i) % 2 == 0:\n                    oxygen_atom = self.oxygen().move_to(np.array([i, j, 0]) / scale)\n                    grid.add(oxygen_atom)\n                else:\n                    metal_atom = self.metal().move_to(np.array([i, j, 0]) / scale)\n                    grid.add(metal_atom)\n        return grid\n\n    def oxygen(self) -> Mobject:\n        circle = Circle(radius=0.285, color=GREY_B)\n        circle.set_fill(GREY_B, opacity=1)\n        oxygen_text = Tex(\"O$^2$\", color=WHITE).scale(0.7)\n        oxygen_atom = VGroup(circle, oxygen_text)\n        return oxygen_atom\n\n    def metal(self) -> Mobject:\n        circle = Circle(radius=0.285, color=BLUE_D)\n        circle.set_fill(BLUE_D, opacity=1)\n        metal_text = Tex(\"Co\", color=WHITE).scale(0.7)\n        metal_atom = VGroup(circle, metal_text)\n        return metal_atom"
    },
    {
        "query": "I'd like to create an animation where a blue semi-transparent rectangle and a yellow semi-transparent triangle start together, then move apart in opposite directions. After moving, I want the rectangle to rotate 45 degrees clockwise and the triangle to rotate 45 degrees counterclockwise. Finally, I would like the rectangle to transform into a triangle that looks just like the original yellow triangle. Can you help me with that?",
        "answer": "\\n from pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 20.0\nconfig.frame_width = 20.0\n\nROOT_DIR = Path(__file__).parents[2]\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=4.5),\n                Convolutional2DLayer(1, 28),\n                Convolutional2DLayer(6, 28, 5),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(16, 10, 5),\n                MaxPooling2DLayer(kernel_size=2),\n                FeedForwardLayer(8),\n                FeedForwardLayer(3),\n                FeedForwardLayer(2),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        # code = make_code_snippet()\n        # code.next_to(nn, DOWN)\n        # self.add(code)\n        # Group it all\n        # group = Group(nn, code)\n        # group.move_to(ORIGIN)\n        nn.move_to(ORIGIN)\n        # Play animation\n        # forward_pass = nn.make_forward_pass_animation()\n        # self.wait(1)\n        # self.play(forward_pass)"
    },
    {
        "query": "How can I create an animated video using the ManimCE Python library where a labeled square is surrounded by a colorful, moving boundary? I want the square, with a text that says \"Math is Fun!\", to increase and decrease in size, and after a short pause, both the square and its animated boundary should disappear from the view.",
        "answer": "\\n from manim import *\n\nclass FlowingVectorField(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        field = ArrowVectorField(lambda p: np.array([p[1], -p[0], 0]), x_range=[-7, 7], y_range=[-5, 5])\n        stream_lines = StreamLines(\n            lambda p: np.array([p[1], -p[0], 0]),\n            x_range=[-7, 7], y_range=[-5, 5], \n            resolution=(11, 11), stream_line_config={\"stroke_width\": 3}\n        )\n\n        self.play(Create(plane), Create(field))\n        self.play(Create(stream_lines))\n        self.wait(2)\n        self.play(FadeOut(plane), FadeOut(field), FadeOut(stream_lines))"
    },
    {
        "query": "Could you create an animation using Manim where three separate texts appear one below the other with some space between them, each surrounded by a rectangle that highlights them? The first text says \"This is a sample,\" the second one says \"of moving,\" and the third one says \"FrameBoxes.\" I would like the first text to be highlighted with a blue rectangle, and then, after a short pause, a green rectangle replaces the blue one to highlight the second text, followed by another short pause and then a red rectangle highlights the third text. Lastly, could you make the red rectangle move upwards while following the text \"FrameBoxes\" for a few seconds before the animation ends?",
        "answer": "\\n        from manim import *\n\nfrom manim_physics import *\n\nclass MagneticFieldExample(ThreeDScene):\n    def construct(self):\n        wire = Wire(Circle(2).rotate(PI / 2, UP))\n        mag_field = MagneticField(\n            wire,\n            x_range=[-4, 4],\n            y_range=[-4, 4],\n        )\n        self.set_camera_orientation(PI / 3, PI / 4)\n        self.add(wire, mag_field)"
    },
    {
        "query": "I would like to create an animation that shows a row of 5 simple \"neuron-like\" objects appearing one after the other and then disappearing together. Can you make the objects look a bit like small circles and line them up in the center of the screen? The circles should be colored like a square (assuming the square is a color or represents a specific color in this context). After they have all appeared, I'd like them to fade out at the same time.",
        "answer": "\\n from manim import *\n\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.math_operation_layer import MathOperationLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        nn = NeuralNetwork({\n            \"feed_forward_1\": FeedForwardLayer(3),\n            \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n            \"feed_forward_3\": FeedForwardLayer(3),\n            \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n        })\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Add the network\n        nn = NeuralNetwork({\n                \"feed_forward_1\": FeedForwardLayer(3),\n                \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n                \"feed_forward_3\": FeedForwardLayer(3),\n                \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n            },\n            layer_spacing=0.38\n        )\n        # Make connections\n        input_blank_dot = Dot(\n            nn.input_layers_dict[\"feed_forward_1\"].get_left() - np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(input_blank_dot, \"feed_forward_1\", arc_direction=\"straight\")\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        output_blank_dot = Dot(\n            nn.input_layers_dict[\"sum_operation\"].get_right() + np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(\"sum_operation\", output_blank_dot, arc_direction=\"straight\")\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        # Group it all\n        group = Group(nn, code)\n        group.move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)"
    },
    {
        "query": "Can you create an animation where a text saying \"Hello, Manim!\" appears on the screen, then has a wave effect applied to it twice\u2014with the second wave being less intense than the first\u2014and finally disappears from the screen?",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting u = 2x\n        explanation1 = Text(\"Let u = 2x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Step to integrate by substitution\n        subst_step = MathTex(r\"\\int \\frac{1}{2}e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), subst_step))\n        self.wait(1)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate with respect to u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(subst_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where the word \"Inscribe\" appears on the screen and then transitions to say \"Inscribe a Square\" and moves downwards. Next, a square should be drawn surrounding the words. After a short pause, the square fades away. Then, the text changes to \"Inscribe a Triangle\", again moving downwards, and a triangle is drawn around the new text. Finally, both the triangle and the text disappear from the screen. Can you make this animation for me?",
        "answer": "\\n from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        # Create a hydrogen atom with an electron orbiting around it\n        proton = self.create_proton()\n        electron = self.create_electron()\n\n        orbit = Circle(color=BLUE).scale(0.5)\n        orbit.move_to(proton)\n\n        electron.move_to(orbit.point_from_proportion(0))\n        self.play(FadeIn(proton), FadeIn(orbit), FadeIn(electron))\n        self.play(Rotate(electron, angle=2*PI, about_point=proton.get_center()), run_time=2, rate_func=smooth)\n        self.wait()\n\n    def create_proton(self) -> Mobject:\n        # Proton represented by a circle with a 'P+'\n        return Circle(radius=0.15, color=RED).set_fill(RED, opacity=1).add(\n            Tex(\"P$^+$\", color=WHITE).scale(0.7)\n        )\n\n    def create_electron(self) -> Mobject:\n        # Electron represented by a small dot\n        return Dot(radius=0.05, color=WHITE)\n\n# Additional function to animate the electron along a custom path\ndef electron_orbit_path(electron: Mobject, orbit: Mobject, run_time: float) -> Animation:\n    def update_electron(mob, dt):\n        mob.move_to(orbit.point_from_proportion((mob.time_elapsed / run_time) % 1))\n        mob.time_elapsed += dt\n\n    electron.time_elapsed = 0\n    return UpdateFromFunc(electron, update_electron)"
    },
    {
        "query": "I'd like to create an animation where it looks like many small particles come together to form a big, solid red circle. These particles should start out invisible, become visible as they move closer to form the circle, and then the completed circle becomes more solid and clearly defined as the particles merge into it. There should be around 200 of these particles, and I want the whole process to run over a span of 4 seconds. Can you design such an animation for me?",
        "answer": "\\n from manim import *\n\nclass GrowFromCenterExample(Scene):\n    def construct(self):\n        # Create a square and a circle\n        square = Square().shift(LEFT * 2)\n        circle = Circle().shift(RIGHT * 2)\n\n        # Add the square to the scene\n        self.add(square)\n\n        # Wait for 1 second\n        self.wait(1)\n\n        # Transform the square into a circle and move it to the right\n        self.play(Transform(square, circle), run_time=1)\n\n        # Remove the circle from the scene\n        self.remove(circle)\n\n        # Create a new star shape and grow it from the center\n        star = Star().shift(DOWN * 2)\n        self.play(GrowFromCenter(star))\n        self.wait(1)"
    },
    {
        "query": "I would like to create a 3D animation of a torus rotating slowly. The torus should be semi-transparent, have a main radius of 1 unit, and a tube radius of 0.25 units. The surface should be colored blue and have a slight opacity, to allow for seeing the depth as it rotates. The animation should start with the creation of the torus surface, take about 3 seconds to appear, and then rotate continuously for around 10 seconds. Can this be done in a way that gives the torus a smooth appearance?",
        "answer": "\\n from manim import *\n\nclass RayTracing(Scene):\n    def construct(self):\n        # Setting up the mirror and the object\n        mirror_radius = 2\n        focal_length = mirror_radius / 2\n        object_height = 1\n        object_position = LEFT * 3\n        \n        concave_mirror = Arc(\n            radius=mirror_radius,\n            start_angle=-np.pi / 3,\n            angle=2 * np.pi / 3,\n            color=WHITE\n        )\n        principal_axis = Line(\n            start=LEFT * 5,\n            end=RIGHT * 5,\n            color=BLUE\n        )\n        object_arrow = Arrow(\n            start=object_position,\n            end=object_position + UP * object_height,\n            buff=0,\n            color=RED\n        )\n\n        focal_point = Dot(\n            point=RIGHT * focal_length,\n            color=YELLOW\n        )\n        center_curve = Dot(\n            point=RIGHT * mirror_radius,\n            color=YELLOW\n        )\n\n        # Add elements to the scene\n        self.add(concave_mirror, principal_axis, object_arrow, focal_point, center_curve)\n\n        # Calculate image position based on mirror equation\n        object_distance = abs(object_position[0])\n        image_distance = 1 / ((1 / focal_length) + (1 / object_distance))\n        image_height = (image_distance / object_distance) * object_height\n\n        # The position for the image_arrow is negative since in concave mirrors \n        # real images are formed on the same side as the object\n        image_position = RIGHT * (-image_distance)\n        image_arrow = Arrow(\n            start=image_position,\n            end=image_position - UP * image_height,\n            buff=0,\n            color=GREEN\n        )\n\n        # Add image to the scene\n        self.play(ShowCreation(image_arrow))\n        self.wait(1)\n\n        # Create light rays\n        # Ray 1 - Parallel to principal axis and then through focal point\n        ray1 = DashedLine(start=object_arrow.get_top(), end=RIGHT * 5, color=PURPLE)\n        ray1_reflect = DashedLine(\n            start=ray1.get_end(),\n            end=focal_point.get_center(),\n            color=PURPLE\n        )\n\n        # Ray 2 - Through the focal point and then parallel to the principal axis\n        ray2_start = object_arrow.get_top()\n        ray2_end = focal_point.get_center() + UP * (ray2_start[1] - focal_point.get_center()[1])\n\n        ray2 = DashedLine(start=ray2_start, end=ray2_end, color=ORANGE)\n        ray2_reflect = DashedLine(\n            start=ray2.get_end(),\n            end=ray2_start + RIGHT * (5 - abs(ray2_start[0])),\n            color=ORANGE\n        )\n\n        # Ray 3 - Through center of curvature which reflects back on same path\n        ray3 = DashedLine(start=object_arrow.get_top(), end=center_curve.get_center(), color=TEAL)\n        ray3_reflect = DashedLine(start=ray3.get_end(), end=ray3.get_start(), color=TEAL)\n\n        # Add light rays to the scene\n        self.play(ShowCreation(ray1), ShowCreation(ray1_reflect))\n        self.play(ShowCreation(ray2), ShowCreation(ray2_reflect))\n        self.play(ShowCreation(ray3), ShowCreation(ray3_reflect))\n\n        self.wait(2)\n\n        self.play(FadeOut(ray1), FadeOut(ray1_reflect),\n                  FadeOut(ray2), FadeOut(ray2_reflect),\n                  FadeOut(ray3), FadeOut(ray3_reflect),\n                  FadeOut(image_arrow), FadeOut(object_arrow),\n                  FadeOut(concave_mirror), FadeOut(principal_axis),\n                  FadeOut(focal_point), FadeOut(center_curve))\n\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that shows a composition of basic geometric shapes on the left side, a vertical lineup of rectangles in the center, and a grid of various regular polygons on the right side, with each shape colored differently and some transparency applied to the polygons?",
        "answer": "\\n from manim import *\n\nMOON_ORBIT_RADIUS = 2\nEARTH_RADIUS = 0.3\nMOON_RADIUS = 0.1\nMOON_ORBIT_RATE = 0.25\nANIMATION_TIME = 60\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Earth and moon\n        earth = Circle(radius=EARTH_RADIUS, color=BLUE)\n        moon_orbit = Circle(radius=MOON_ORBIT_RADIUS, color=WHITE, stroke_opacity=0.3)\n        moon = Circle(radius=MOON_RADIUS, color=GREY)\n\n        earth.move_to(ORIGIN)\n        moon_orbit.move_to(earth.get_center())\n        moon.move_to(moon_orbit.point_at_angle(0))\n\n        self.add(earth, moon_orbit, moon)\n\n        # Moon's orbit around earth\n        moon_tracker = ValueTracker(0)\n        def update_moon(mob):\n            alpha = moon_tracker.get_value() / ANIMATION_TIME\n            angle = TAU * alpha * MOON_ORBIT_RATE\n            mob.move_to(moon_orbit.point_at_angle(angle))\n        \n        moon.add_updater(update_moon)\n\n        # Animate the system\n        self.add(moon_tracker)\n        self.play(moon_tracker.animate.set_value(ANIMATION_TIME), run_time=ANIMATION_TIME, rate_func=linear)"
    },
    {
        "query": "I'd like to see an animation where a triangle appears on the screen and then rotates by 90 degrees before morphing into a circle over the span of 3 seconds. Can you create this using a tool that is suitable for mathematical animations?",
        "answer": "\\n from manim import *\n\nclass OscillatingCircleScene(Scene):\n    def construct(self):\n        circle = Circle(color=BLUE).scale(2)\n        oscillation_path = ParametricFunction(\n            lambda t: np.array([np.sin(t), np.cos(2 * t), 0]),\n            t_min=0,\n            t_max=TAU,\n            color=YELLOW\n        )\n\n        self.play(Create(oscillation_path), run_time=2)\n        self.play(ShowCreation(circle), run_time=2)\n        self.play(MoveAlongPath(circle, oscillation_path, rate_func=linear), run_time=4)\n        self.play(FadeOut(circle), FadeOut(oscillation_path), run_time=2)\n        self.wait(1)"
    },
    {
        "query": "I want to create an animation of a blue square that wiggles as if it's being jostled or shaken. The square should expand a bit and rotate slightly while it wiggles. The whole animation should take about 2 seconds to complete. How could I do that using an animation software?",
        "answer": "\\n from manim_physics import *\n\n\nclass MagneticFieldExample(ThreeDScene):\n    def construct(self):\n        wire = Wire(Circle(2).rotate(PI / 2, UP))\n        mag_field = MagneticField(wire)\n        self.set_camera_orientation(PI / 3, PI / 4)\n        self.add(wire, mag_field)"
    },
    {
        "query": "Can you create an educational animation that visually explains the concept of a circle, its radius, and the formulas for its area and circumference? Start with the animation showing a circle and a line representing the radius, with a label 'r'. Then, have a text appear that explains that the area of a circle is given by the formula 'Area = \u03c0r^2'. Next, transform that text into a formula and position it at the bottom of the screen. Finally, animate a dot moving around the circumference of the circle to illustrate the concept of circumference, and conclude with the text 'Circumference = 2\u03c0r' appearing below the circle. Make sure to have pauses throughout the animation to give viewers time to understand each step.",
        "answer": "\\n from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyingFractions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{2}{3}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{4}{6}\", color=TEXT_COLOR).scale(2)\n        ).arrange(RIGHT, buff=3)\n        arrow_up = ArcBetweenPoints(\n            fractions[0].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[1].get_top() + 0.2 * UP + 0.1 * LEFT, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down = ArcBetweenPoints(\n            fractions[0].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * LEFT, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up = Tex(r\"Multiplicado por 2\", color=LIGHT_BLUE_COLOR)\n        text_up.next_to(arrow_up, UP)\n        text_down = Tex(r\"Multiplicado por 2\", color=LIGHT_BLUE_COLOR)\n        text_down.next_to(arrow_down, DOWN)\n        equal = MathTex(\"=\", color=LIGHT_BLUE_COLOR)\n        equal.scale(2)\n\n        self.play(Write(fractions), run_time=0.5)\n        self.play(\n            Write(arrow_up),\n            Write(text_up, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down),\n            Write(text_down, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal), run_time=0.5)\n        self.wait(0.5)"
    },
    {
        "query": "Could you create an animated visualization of a simple feedforward neural network with four layers, where the first layer has 4 neurons, the second layer has 6 neurons, the third again has 4 neurons, and the final output layer has just a single neuron? Additionally, could you animate a forward pass through the network to show how data moves through it?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = 3x^2 - 2x + 1\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Show the area problem\n        area_problem = MathTex(r\"\\int_1^3 f(x) \\,dx\")\n        self.play(Transform(function, area_problem))\n        self.wait(2)\n\n        # Set up the integral\n        setup_integral = MathTex(r\"\\int_1^3\", r\"3x^2 - 2x + 1 \\,dx\")\n        self.play(Transform(area_problem, setup_integral))\n        self.wait(1)\n\n        # Perform the integration step\n        integration_step = MathTex(r\"= [\\frac{3}{3}x^3 - \\frac{2}{2}x^2 + x]_1^3\")\n        self.play(ReplacementTransform(setup_integral.copy(), integration_step))\n        self.wait(2)\n\n        # Simplify the integral result\n        simplified_result = MathTex(r\"= [x^3 - x^2 + x]_1^3\")\n        self.play(Transform(integration_step, simplified_result))\n        self.wait(2)\n\n        # Final evaluation\n        final_evaluation = MathTex(r\"= (3^3 - 3^2 + 3) - (1^3 - 1^2 + 1)\", r\"= 27 - 9 + 3 - (1 - 1 + 1)\", r\"= 20\")\n        self.play(ReplacementTransform(simplified_result, final_evaluation))\n        self.wait(2)\n\n        # Clear scene and show the final answer\n        self.clear()\n        self.play(Write(final_evaluation))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animated video that displays a spiral of dots, where each dot represents a number from 1 to 400, and have each prime number highlighted in red? The non-prime numbers should be yellow, and the rest of the dots green. Also, can you include a title saying \"Prime Number Spiral\" at the top in a blue color and draw a number line with numbers at the bottom of the screen to provide a scale reference? Additionally, set a light, calming color scheme for the background and the elements of the video.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FadeIn\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(FadeIn(square))\n            self.play(Transform(text,Text(\"FadeOut\").shift(UP*2.5)), run_time=0.5)\n            self.play(FadeOut(square))\n            self.remove(square)"
    },
    {
        "query": "Could you create an animation where a series of multiplication problems involving the number 5 and the numbers 1 through 5 are displayed one under the other on a white background? Each multiplication step should be shown in a sequence where the number 5 is red, the multiplier of 5 is blue, and the resultant product is green. Also, I'd like the multiplication symbol and equals sign to be in pink. After showing all the equations, can you draw a red rectangle around the first multiplication equation and a blue one around the last? Once all the equations and rectangles are shown, I want them to disappear simultaneously.",
        "answer": "\\n from manim import *\n\nclass GraphTheoryPrim(Scene):\n    def construct(self):\n        vertices = [\n            (np.cos(ang), np.sin(ang), 0)\n            for ang in np.linspace(0, TAU, 7, endpoint=False)\n        ]\n\n        edges = [\n            (0, 2),\n            (0, 3),\n            (1, 3),\n            (1, 4),\n            (2, 3),\n            (2, 5),\n            (3, 4),\n            (3, 5),\n            (3, 6),\n            (4, 6),\n            (5, 6),\n        ]\n\n        g = Graph(vertices, edges, layout=\"spring\", labels=True)\n        self.play(Create(g))\n        self.wait()\n\n        def prims_algorithm(graph, start_vertex=0):\n            mst_edges = set()\n            visited_vertices = {start_vertex}\n            available_edges = {\n                edge for edge in graph.edges if start_vertex in edge\n            }\n\n            while available_edges:\n                min_edge = min(\n                    available_edges,\n                    key=lambda edge: graph[edge[0]].get_center().get_distance(\n                        graph[edge[1]].get_center()\n                    ),\n                )\n                available_edges.remove(min_edge)\n                if min_edge[0] not in visited_vertices:\n                    new_vertex = min_edge[0]\n                else:\n                    new_vertex = min_edge[1]\n\n                if new_vertex not in visited_vertices:\n                    visited_vertices.add(new_vertex)\n                    mst_edges.add(min_edge)\n                    for edge in graph.edges:\n                        if new_vertex in edge and edge not in mst_edges:\n                            available_edges.add(edge)\n\n            return mst_edges\n\n        mst_edges = prims_algorithm(g)\n        mst_graph = Graph(\n            vertices,\n            list(mst_edges),\n            layout=\"spring\",\n            labels=True,\n            edge_type=DashedLine,\n            edge_config={\"stroke_width\": 4, \"color\": BLUE},\n        )\n\n        self.play(Transform(g, mst_graph))\n        self.wait()\n\n        tree_label = Tex(\"Minimum Spanning Tree (Prim's Algorithm)\")\n        tree_label.move_to(3 * UP)\n        self.play(Write(tree_label))\n        self.wait(1)\n\n        self.play(FadeOut(g), FadeOut(tree_label))"
    },
    {
        "query": "Can you create an animated educational video using simple graphics where a teacher character appears on the left side of the screen, thinks about the Pythagorean theorem, and then the answer to what the Pythagorean theorem is appears below the thought bubble? The background should be a warm cream color, the text and the teacher's thought bubble should be clearly readable, and it should end by clearing the screen of all elements.",
        "answer": "\\n         self.play(Transform(text,Text(\"GrowFromEdge - DOWN\").shift(UP*2.5)), run_time=0.5)\n        squares = [Square() for _ in range(4)]\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(Transform(text,Text(\"GrowFromEdge - RIGHT\").shift(UP*2.5)), run_time=0.5)\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(Transform(text,Text(\"GrowFromEdge - UP\").shift(UP*2.5)), run_time=0.5)\n        self.play(GrowFromEdge(squares[2], UP))\n        self.play(Transform(text,Text(\"GrowFromEdge - LEFT\").shift(UP*2.5)), run_time=0.5)\n        self.play(GrowFromEdge(squares[3], LEFT))\n        self.remove(*squares)"
    },
    {
        "query": "I would like an animation that explains how to add fractions with the same denominator. Please start with the fraction 1/4 plus 1/4. The background should be white and all the text and numbers in black for good contrast. I want the fractions and the addition sign to first appear on the screen. Then, show a brace above these two fractions with a label \"Same Denominator\" and another brace below them with the label \"Add Numerators.\" After that, demonstrate the result of the addition by transforming the original fractions and the plus sign into the resulting fraction 1/2. End the animation with all elements fading out. I prefer the video dimensions to be similar to a standard A4 paper size.",
        "answer": "\\n from manim import *\n\nclass HydrogenGridScene(Scene):\n    def construct(self):\n        grid = self.hydrogen_grid(3, 3)\n        self.play(ShowCreation(grid))\n        self.wait(1)\n\n    def hydrogen_atom(self) -> Mobject:\n        return circle_with_text(0.2, \"H\", RED_B, 20, BLACK, 1, RED_B)\n\n    def hydrogen_grid(self, rows: int, cols: int) -> Mobject:\n        list_of_atoms = []\n        for i in range(rows):\n            for j in range(cols):\n                atom = self.hydrogen_atom().shift(RIGHT * i + UP * j)\n                list_of_atoms.append(atom)\n        return VGroup(*list_of_atoms)\n\n    def circle_with_text(\n        self, r: float, txt: str, color=WHITE, font_size: int = 20, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE\n    ) -> Mobject:\n        circle_obj = Circle(radius=r, color=color).set_opacity(1).set_fill(fill_color)\n        text_obj = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(circle_obj, text_obj)"
    },
    {
        "query": "I would like to create an animated video demonstrating a simple neural network architecture with Manim. The network should start with two convolutional layers, followed by three feedforward layers. The first convolutional layer has 1 input channel, 16 output channels, and a kernel size of 5; the second convolutional layer has 16 input channels, 32 output channels, and a kernel size of 3. After the convolutional layers, there should be a total of three feedforward layers with the following number of neurons: 128, 64, and 10. The animation should include a visual representation of the neural network with an indication of a forward pass through the layers. Can you help create this animation using the Manim library without expecting me to write or understand the code?",
        "answer": "\\n from manim import *\n\nconfig.frame_size = (1080, 1920)\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#1e1e1e\"\nTEXT_COLOR = \"#ffffff\"\nHIGHLIGHT_COLOR = \"#ff0000\"\nGRAPH_COLOR = \"#00ff00\"\n\nclass MonthlyExpenseGraph(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Monthly Expenses\", color=TEXT_COLOR)\n        axes = NumberPlane(\n            x_range=[0, 6, 1],\n            y_range=[0, 1000, 250],\n            x_length=6,\n            y_length=6,\n            axis_config={\"color\": TEXT_COLOR},\n            background_line_style={\n                \"stroke_color\": TEXT_COLOR,\n                \"stroke_width\": 1,\n                \"stroke_opacity\": 0.5\n            }\n        )\n        axes.add_coordinates()\n        title.next_to(axes, UP)\n\n        points_data = [\n            (1, 300),\n            (2, 500),\n            (3, 450),\n            (4, 650),\n            (5, 400),\n        ]\n\n        lines = VGroup()\n        dots = VGroup()\n        for point in points_data:\n            dot = Dot(color=HIGHLIGHT_COLOR).move_to(axes.c2p(*point))\n            dots.add(dot)\n            if lines:\n                line = Line(start=lines[-1].get_end(), end=dot.get_center(), color=GRAPH_COLOR)\n                lines.add(line)\n\n        self.play(Create(axes), Write(title))\n        self.play(LaggedStart(\n            *[Create(dot) for dot in dots], lag_ratio=0.5),\n            *[Create(line) for line in lines],\n            run_time=3)\n        self.wait(1)\n        self.play(FadeOut(VGroup(axes, title, dots, lines)))"
    },
    {
        "query": "Could you please create an animation that shows a simple graph of a quadratic function, specifically y = x^2, plotted on a set of Cartesian axes that range from -5 to 5 for both the x and y axes, with the axes drawn in blue and the quadratic curve in green?",
        "answer": "\\n from manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\nfrom manim_ml.neural_network.animations.dropout import make_neural_network_dropout_animation\n# Make nn\nnn = NeuralNetwork([\n        FeedForwardLayer(3),\n        FeedForwardLayer(5),\n        FeedForwardLayer(3),\n        FeedForwardLayer(5),\n        FeedForwardLayer(4),\n    ],\n    layer_spacing=0.4,\n)\n# Center the nn\nnn.move_to(ORIGIN)\nself.add(nn)\n# Play animation\nself.play(\n    make_neural_network_dropout_animation(\n        nn, dropout_rate=0.25, do_forward_pass=True\n    )\n)\nself.wait(1)"
    },
    {
        "query": "Could you create an animation where a square grows out of a single point at the bottom of the frame, and then after it finishes, have the animation update with new text indicating a second square that will grow from a specific point towards the top right of the screen? After the second square finishes growing, both squares and the text should disappear.",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Display the ODE\n        ode = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explain the main terms\n        mass_term_explanation = Text(\"This is the mass term\", font_size=24).next_to(ode, DOWN)\n        self.play(FadeIn(mass_term_explanation, shift=UP))\n        self.wait(2)\n        self.play(FadeOut(mass_term_explanation, shift=DOWN))\n\n        spring_term_explanation = Text(\"This is the spring constant term\", font_size=24).next_to(ode, DOWN)\n        self.play(FadeIn(spring_term_explanation, shift=UP))\n        self.wait(2)\n        self.play(FadeOut(spring_term_explanation, shift=DOWN))\n\n        # Form characteristic equation\n        char_eq = MathTex(r\"mr^2 + k = 0\")\n        self.play(Transform(ode, char_eq))\n        self.wait(1)\n\n        # Solve the characteristic equation\n        roots = MathTex(r\"r = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(ode, roots))\n        self.wait(1)\n\n        # General solution for harmonic oscillator\n        gen_solution = MathTex(r\"x(t) = C_1\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + C_2\\sin\\left(\\sqrt{\\frac{k}{m}}t\\right)\")\n        self.play(Write(gen_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation = Text(\"General solution for the harmonic oscillator\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene and animate the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(gen_solution))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that demonstrates a simplified version of the solar system with the Sun, Earth, and Moon. Show the Earth orbiting around the Sun and the Moon orbiting around the Earth. The Sun should be yellow and larger in the center, the Earth should be blue and smaller moving around the Sun, and the Moon should be even smaller and grey, revolving around the Earth. Also, include the paths or orbits of the Earth and Moon as white and light grey circles, respectively. Make the animation three-dimensional and set the viewpoint to give a sense of depth. Have the Earth complete its orbit in about 8 seconds and the Moon in about 2 seconds, and let the camera slowly pan around the scene to enhance the 3D effect.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Write the integral problem\n        integral_text = MathTex(r\"\\int_1^3\", r\"x^2\", r\"\\,dx\")\n        integral_text.to_edge(UP)\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Show the area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[1,3], color=BLUE)\n        area = area = Integral(curve, (1, 3), fill_opacity=0.3)\n        self.play(ShowCreation(curve), FadeIn(area))\n        self.wait(1)\n\n        # Calculate the integral\n        calculation = MathTex(r\"=\", r\"\\left[\\frac{x^3}{3}\\right]_1^3\")\n        self.play(ReplacementTransform(integral_text.copy()[1], calculation))\n        self.wait(1)\n\n        # Evaluation part\n        evaluation = MathTex(r\"= \\frac{3^3}{3} - \\frac{1^3}{3}\", \"=\", \"9 - \\frac{1}{3}\", \"=\", r\"\\frac{26}{3}\")\n        self.play(ReplacementTransform(calculation, evaluation))\n        self.wait(1)\n\n        # Show final answer on the screen\n        final_answer = MathTex(r\"\\frac{26}{3}\").move_to(evaluation)\n        self.play(Transform(evaluation, final_answer))\n        self.wait(1)\n\n        # Conclude by showing the area equals the final answer\n        conclusion = VGroup(curve, area, final_answer).scale(0.7).to_corner(DL)\n        self.play(FadeOut(integral_text), Transform(evaluation, conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like to see an animated graph of my monthly expenses. The graph should have a vertical axis with increments of $250 up to $1000 and a horizontal axis representing 6 months. Each month should have a distinct point on the graph indicating my spending, for instance, $300 in the first month, then $500, followed by $450, $650, and $400. I want each point to be highlighted and connected with a green line to show the trend of my expenses. The background should be dark, and all text and axes should be white for contrast. Additionally, I'd like the title \"Monthly Expenses\" to appear above the graph. After showing the full graph, let the whole scene fade out. The video should have a vertical orientation, like a phone screen.",
        "answer": "\\n from manim import *\n\nclass FallingObjects(Scene):\n    def construct(self):\n        balls = VGroup(*[Ball() for _ in range(5)])\n        balls.arrange(RIGHT, buff=0.5)\n        floor = Line(LEFT, RIGHT).shift(DOWN)\n        \n        self.play(ShowCreation(balls), ShowCreation(floor))\n        self.wait(1)\n        \n        for ball in balls:\n            ball.set_fill(BLUE, opacity=0.5)\n            self.play(Fall(ball), run_time=2)\n        \n        self.wait(2)"
    },
    {
        "query": "Can you create an animation with five colored balls arranged in a horizontal line at the top, which then fall down one by one to hit a floor and stay there? Each ball should have a random color and there should be a pause at the end to view the final position of the balls.",
        "answer": "\\n from manim import *_x000D_\n_x000D_\nclass QuadraticFormulaExample(Scene):_x000D_\n    def construct(self):_x000D_\n        # Displaying the quadratic equation_x000D_\n        equation = MathTex(\"ax^2 + bx + c = 0\")_x000D_\n        self.play(Write(equation))_x000D_\n        self.wait(1)_x000D_\n_x000D_\n        # Explanation for using the quadratic formula_x000D_\n        explanation1 = Text(\"Use the quadratic formula to solve for x\", font_size=24).to_edge(UP)_x000D_\n        self.play(Write(explanation1))_x000D_\n        self.wait(2)_x000D_\n_x000D_\n        # Showing the quadratic formula_x000D_\n        quadratic_formula = MathTex(r\"x = \\frac{{-b \\pm \\sqrt{{b^2-4ac}}}}{{2a}}\")_x000D_\n        self.play(ReplacementTransform(equation, quadratic_formula))_x000D_\n        self.wait(1)_x000D_\n_x000D_\n        # Explanation for solution_x000D_\n        explanation2 = Text(\"Solve for roots\", font_size=24).to_edge(UP)_x000D_\n        self.play(Transform(explanation1, explanation2))_x000D_\n        self.wait(2)_x000D_\n_x000D_\n        # Possible solutions_x000D_\n        solutions = MathTex(r\"x_1 = \\frac{{-b + \\sqrt{{b^2-4ac}}}}{{2a}}\", \",\", _x000D_\n                            r\"x_2 = \\frac{{-b - \\sqrt{{b^2-4ac}}}}{{2a}}\")_x000D_\n        self.play(ReplacementTransform(quadratic_formula, solutions))_x000D_\n        self.wait(1)_x000D_\n_x000D_\n        # Clear the scene and conclude_x000D_\n        self.clear()_x000D_\n        self.wait(1)_x000D_\n        self.play(Write(Text(\"The solutions are x_1 and x_2\", font_size=24)))_x000D_\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated video of a vertical bar graph using ManimCE that displays quarterly sales data? The video should be in portrait orientation with a resolution of 1080x1920 pixels. The graph should represent data for four quarters, with the values 10, 6, 9, and 5 for Q1, Q2, Q3, and Q4 respectively. I'd like the maximum value of the scale to be 10 to reflect a percentage scale. Also, can the bars be color-coded with Q1 in a cool blue, Q2 in a red tone, Q3 in a green shade, and Q4 in a yellow hue? Above the graph, please include the title 'Quarterly Sales' and ensure all text and the title are in a dark gray color. For the background of the video, use a soft beige color. Lastly, make sure there are labels for each bar with their respective quarter names and a visible Y-axis with labels but without arrow tips on both axes. Let the animation show the title first and then gradually build up the graph with each bar appearing in sequence, completed within 2 seconds per bar. Can you also maintain a short pause at the end to let viewers take in the final image?",
        "answer": "\\n class WiggleExampleScene(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1)\n        self.add(square)\n        self.play(Wiggle(square, scale_value=2, rotation_angle=0.1*PI, run_time=2))"
    },
    {
        "query": "I would like to create an educational animation video that visually represents the concept of powers of two. The video should start with a title called \"Powers of Two\" in a light green color at the top of the screen. Right below it, put a subtitle with the series \"2, 4, 8, 16, 32, ...\" in a more neutral color. The background of the video should be a warm, light cream color, providing a soft contrast to the titles and the animations that will follow.\n\nAfter the titles fade in, I want a sequence of colored squares, each labeled with a power of two, to appear one by one. The size of the square should correspond to the value it represents, starting from 2 and going up to 32. Alternate the colors of the squares between light blue and light purple for visual variety.\n\nEach subsequent square should transform from the previous one and position itself a bit to the right, creating a nice visual flow. After all the squares are displayed, they should arrange themselves in a horizontal line at the center of the screen and then uniformly scale down to fit nicely.\n\nFinally, all the squares should change their color to a light yellow to signify completion, and then the whole scene should fade out. Add some nice smooth transitions, and let each step in the animation have a little pause to let the viewers register the change. The overall feel should be simple, clean, and educational.",
        "answer": "\\n from manim import *\n\nclass AnimatedBoundaryExample(Scene):\n    def construct(self):\n        # Create a square and an associated animated boundary\n        square = Square()\n        animated_boundary = AnimatedBoundary(square, cycle_rate=2, colors=[YELLOW, PINK, WHITE])\n\n        # Add the square and its animated boundary to the scene\n        self.add(square, animated_boundary)\n\n        # Play animation for 4 seconds\n        self.wait(4)\n\n        # Transform the square into a triangle while moving it up\n        triangle = Triangle().shift(UP)\n        self.play(Transform(square, triangle), run_time=1)\n\n        # Wait for 2 seconds before concluding the animation\n        self.wait(2)"
    },
    {
        "query": "Could you create an animation using a square with the word \"Inside\" at its center, and then have a blue outline circle around the square, followed by a text saying \"Outside\" appearing below the square, and then finally have a red rectangle circumscribe the outside text while it fades away?",
        "answer": "\\n from manim import *\n\nclass CalculateSeriesLimit(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"S_n = \\sum_{k=1}^{n} \\frac{1}{k}\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for approaching infinity\n        explanation1 = Text(\"Consider the limit as n approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Writing the limit\n        limit_expression = MathTex(r\"S = \\lim_{n \\to \\infty} S_n\")\n        self.play(ReplacementTransform(series.copy(), limit_expression))\n        self.wait(1)\n\n        # Explanation for harmonic series divergence\n        explanation2 = Text(\"This is the harmonic series, which diverges\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Divergence result\n        divergence_result = MathTex(r\"\\lim_{n \\to \\infty} S_n = \\infty\")\n        self.play(ReplacementTransform(limit_expression, divergence_result))\n        self.wait(1)\n\n        # Clear the scene and show divergence\n        self.clear()\n        self.wait(1)\n        self.play(Write(divergence_result))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that demonstrates the concept of the derivative, using a quadratic function as an example? I'd like the animation to include a graph with a function f(x)=x^2 plotted on it. Additionally, I'd like to see the derivative of that function displayed on the same graph. The various elements should come into view one after the other, starting with the axes and the quadratic function graph. After a brief pause, there should be a mathematical text explanation appearing at the top that explains the derivative of x^2 is 2x. Then, the derivative function should be drawn. Finally, highlight the slope of the tangent to the quadratic function at x=1 with a colored line and place a dot to signify the point of tangency. Could you make sure that each part of the animation is introduced separately and there's a small wait time between each for better understanding?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\left[\\frac{1}{2}x^2yz\\right]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{1}{2}yz\\right]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{4}z^2\\right]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Create an educational video animation using ManimCE that shows a simple blue rectangle representing a bar magnet with its north pole labeled with an \"N\" and south pole labeled with an \"S\". Above and below the magnet respectively. After displaying the magnet and its poles, animate blue magnetic field lines around the magnet that visually represent how magnetic fields emanate from the north pole and curve around to enter the south pole, symbolizing a two-dimensional magnetic field. Ensure that the field lines are generated dynamically as if they're streaming around the magnet, and let this animation run for a few seconds.",
        "answer": "\\n class LaggingGroup(Scene):\n    def construct(self):\n        squares = VGroup(*[Square(color=Color(hue=j/20, saturation=1, luminance=0.5), fill_opacity=0.8) for j in range(20)])\n        squares.arrange_in_grid(4, 5).scale(0.75)\n        self.play(AnimationGroup(*[FadeIn(s) for s in squares], lag_ratio=0.15))"
    },
    {
        "query": "Could you create an educational animation that shows a series of geometric shapes with different colors to help with learning basic shapes? Start with a purple square, an orange circle, and a teal triangle, and line them up on the left side of the screen. Below these, can you make a row of five small colorful rectangles, each with random colors? Finally, add three rows of five pentagons, semi-transparent and also in random colors, arranged below the rectangles. Ensure that all shapes are clearly separated and neatly organized.",
        "answer": "\\n from manim import *\n\nclass GaussianIntegralExample(Scene):\n    def construct(self):\n        # Display the integral\n        integral = MathTex(r\"\\int_{-\\infty}^{\\infty} e^{-x^2} \\,dx\")\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Explanation for transforming the integral\n        transform_explanation = Text(\n            \"Use square to transform the integral\", font_size=24\n        ).to_edge(UP)\n        self.play(Write(transform_explanation))\n        self.wait(2)\n\n        # Transform the integral\n        transformed_integral = MathTex(\n            r\"= \\left( \\int_{-\\infty}^{\\infty} e^{-x^2} \\,dx \\right)^2\"\n        )\n        self.play(ReplacementTransform(integral.copy(), transformed_integral))\n        self.wait(2)\n\n        # Change to polar coordinates\n        polar_explanation = Text(\n            \"Change to polar coordinates\", font_size=24\n        ).to_edge(UP)\n        self.play(Transform(transform_explanation, polar_explanation))\n        self.wait(2)\n\n        # Polar coordinates step\n        polar_step = MathTex(r\"= \\int_0^{2\\pi} \\int_0^{\\infty} e^{-r^2} r \\,dr \\,d\\theta\")\n        self.play(ReplacementTransform(transformed_integral, polar_step))\n        self.wait(2)\n\n        # Explanation for evaluating the integral\n        evaluation_explanation = Text(\n            \"Evaluate the Gaussian integral\", font_size=24\n        ).to_edge(UP)\n        self.play(Transform(transform_explanation, evaluation_explanation))\n        self.wait(2)\n\n        # Evaluate the integral\n        evaluated_integral = MathTex(r\"= \\pi\")\n        self.play(ReplacementTransform(polar_step, evaluated_integral))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\n            \"The Gaussian integral evaluates to sqrt(pi)\", font_size=24\n        )\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animated video that visually demonstrates how matrix multiplication works. The animation should show two matrices, one above the other, and then animate the process of multiplying them element by element to produce the resulting matrix. Each step of the multiplication should be clear and intuitive, even for someone who might not be familiar with matrix multiplication. Can we have the elements of the first matrix and the second matrix come together, show their product, and then vanish to indicate they've contributed to a component of the resulting matrix? The final product matrix should then emerge from the combination of the initial two matrices.",
        "answer": "\\n from manim import *\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass NeuralNetworkArchitecture(Scene):\n    def construct(self):\n        layer_sizes = [4, 8, 8, 4]\n        nn = VGroup()\n        last_layer = None\n        for i, size in enumerate(layer_sizes):\n            layer = VGroup(*[Circle(radius=0.1, stroke_width=2, stroke_color=WHITE, fill_color=BLUE, fill_opacity=0.5) for _ in range(size)])\n            layer.arrange(DOWN, buff=0.2)\n            nn.add(layer)\n            if last_layer:\n                for prev_neuron in last_layer:\n                    for neuron in layer:\n                        nn.add(Line(prev_neuron.get_top(), neuron.get_bottom(), stroke_width=1, stroke_color=GRAY))\n            last_layer = layer\n        nn.arrange(RIGHT, buff=1)\n        self.play(ShowCreation(nn))\n        self.wait(2)\n\n        forward_pass = [layer[0].set_fill(GREEN, opacity=1) for layer in nn]\n        self.play(LaggedStart(*forward_pass, lag_ratio=0.5), run_time=2)\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation sequence that starts by writing the words \"Wave Propagation\" on the screen, then after a pause, makes the text look like it ripples like a wave? After another short pause, can you change the text to say \"Wave Effect\" and move it down on the screen, followed by another wave ripple running from bottom to top? Then, once the second wave effect is complete, can you remove the text from the screen?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        integral_problem = MathTex(r\"\\int_0^3 x^2 \\,dx\")\n        self.play(Write(integral_problem))\n        self.wait(1)\n\n        # Explanation for calculating the area under the curve\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Antiderivative step\n        antiderivative_step = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^3\")\n        self.play(ReplacementTransform(integral_problem.copy(), antiderivative_step))\n        self.wait(1)\n\n        # Solving the antiderivative\n        solve_step = MathTex(r\"= \\frac{3^3}{3} - \\frac{0^3}{3}\")\n        self.play(ReplacementTransform(antiderivative_step, solve_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_result = MathTex(r\"= 9\")\n        self.play(ReplacementTransform(solve_step, final_result))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "I'm interested in creating an educational video on fractions using animated pie slices. Can you design an animation that shows a group of pie slices arranged in two rows, resembling apple pie slices with a light blue filling and a dark blue crust outline? I'd like the video to start with a title \"Apple Pie Slices\" at the top in a subtle gray color, followed by the pie slices appearing one by one. After they appear, I want a couple of slices to look like they are being taken out and then placed back. The pie slices should be simple geometric shapes with a line across the middle to indicate the slices. In the end, I would like the whole scene to shrink and fade out smoothly. The background of the video should be a light gray to keep the focus on the colorful pie slices. Can this be done in an animated format suitable for a classroom setting?",
        "answer": "\\n from manim import *\n\nclass ChemicalBondAnimation(Scene):\n    def construct(self):\n        # Create two oxygen atoms\n        oxygen_1 = oxygen().shift(LEFT)\n        oxygen_2 = oxygen().shift(RIGHT)\n\n        # Create an electron\n        e = electron()\n\n        # Animations\n        self.play(FadeIn(oxygen_1), FadeIn(oxygen_2))\n        self.play(e.animate.move_to(oxygen_1))\n        self.wait(0.5)\n        self.play(e.animate.move_to(oxygen_2))\n        self.wait(0.5)\n\n        # Bond creation\n        bond = Line(oxygen_1.get_center(), oxygen_2.get_center(), color=GRAY)\n        self.play(Create(bond))\n\n        # Group oxygen and bond together\n        molecule = VGroup(oxygen_1, oxygen_2, bond)\n\n        # Show the shifting of the molecule\n        self.play(molecule.animate.shift(UP * 2))\n        self.play(molecule.animate.scale(0.5).rotate(PI / 2))\n        self.wait(1)\n\n        # Disappear the molecule\n        self.play(FadeOut(molecule))"
    },
    {
        "query": "I want to create an animation of a sinusoidal wave path that starts from the left side of the screen and travels to the right side. The wave should have a specific frequency and amplitude, and it should build up over time rather than appearing all at once. As the wave progresses from left to right, it should be as if the wave is being drawn in real time. Can you show me how to animate a wave flowing across the screen like this using Manim?",
        "answer": "\\n from manim import *\n\nclass GraphingExample(Scene):\n    def construct(self):\n        # Define the functions\n        function1 = MathTex(\"y = x^2\")\n        function2 = MathTex(\"y = 2x + 1\")\n        \n        # Display the functions\n        self.play(Write(function1))\n        self.wait(1)\n        self.play(Transform(function1, function2))\n        self.wait(1)\n        \n        # Clear the description\n        self.remove(function1)\n\n        # Setting the axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 8, 1],\n            axis_config={\"color\": BLUE}\n        )\n\n        # Create the graphs\n        graph1 = axes.plot(lambda x: x**2, color=GREEN)\n        graph1_label = axes.get_graph_label(graph1, label='x^2')\n\n        graph2 = axes.plot(lambda x: 2*x + 1, color=RED)\n        graph2_label = axes.get_graph_label(graph2, label='2x+1')\n\n        # Display the graphs\n        self.play(Create(axes), Write(graph1), Write(graph1_label))\n        self.wait(1)\n        self.play(ReplacementTransform(graph1, graph2), ReplacementTransform(graph1_label, graph2_label))\n        self.wait(1)\n\n        # Clear the graphs\n        self.play(FadeOut(graph2), FadeOut(graph2_label), FadeOut(axes))\n        self.wait(1)"
    },
    {
        "query": "Can you create a detailed animation that visually demonstrates how a simple convolutional neural network goes through the forward pass process using an example image I have? The animation should start by showing the image, followed by the layers of the network, including convolutional layers, max pooling, and feedforward layers. Each layer should be visually distinct and the flow of data through the network should be animated step by step. Additionally, I'd like the neural network diagram to be centered and the whole forward pass animation to last for about 15 seconds, ending with a short pause.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{\\sqrt{1-y^{2}}} x^2 dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to x first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\left[ \\frac{1}{3}x^3 \\right]_{0}^{\\sqrt{1-y^{2}}} dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{3}(\\sqrt{1-y^{2}})^3 dy\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for final step\n        explanation3 = Text(\"Evaluate the final integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[\\text{Solution Expression Here}\\right]_{0}^{1}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n\n        # Display final solution value (example value shown, replace with actual solution)\n        final_value = Text(\"Solution: \\(\\frac{1}{6}\\pi\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_value))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the concept of equivalent fractions. The animation should begin with a white background, and three fractions should be displayed horizontally across the screen: 1/2, 2/4, and 4/8. Each fraction should be written in black and be large enough to be easily readable. Between the first and second fraction, and the second and third fraction, there should be a blue arrow pointing from one to the next to signify the equivalence of the fractions. Above each arrow, the text \"times 2\" and \"times 4\" respectively should appear, also in blue, indicating the multiplication factor from one fraction to the next. Each element should appear in sequence with slight animations: first the fraction 1/2 is written, then an arrow grows from it to the fraction 2/4 with \"times 2\" appearing at the same time, followed by the fraction 2/4 appearing, and the process repeats for the fraction 4/8 with \"times 4\" above the second arrow. After a short pause where all elements are visible, the entire scene fades out. Could you please create such an animation for my educational content?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series equation\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^\\infty \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right)\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Explanation of Fourier series\n        explanation1 = Text(\"A Fourier series decomposes periodic functions\", font_size=24)\n        explanation2 = Text(\"into a sum of sines and cosines.\", font_size=24)\n        explanation = VGroup(explanation1, explanation2).arrange(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Application example\n        explanation3 = Text(\"Used in signal processing, physics, and more.\", font_size=24)\n        self.play(Transform(explanation, explanation3))\n        self.wait(2)\n\n        # Displaying partial sum approximation\n        partial_sum = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^N \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right)\")\n        self.play(ReplacementTransform(fourier_series, partial_sum))\n        self.wait(1)\n\n        # Conclusion with both explanation and formula\n        conclusion_text = Text(\"We can approximate functions using N terms.\", font_size=24)\n        conclusion = VGroup(partial_sum, conclusion_text).arrange(DOWN)\n        self.play(Transform(explanation, conclusion_text))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Write the final thought\n        final_thought = Text(\"Fourier series is a cornerstone in harmonic analysis.\", font_size=24)\n        self.play(Write(final_thought))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated pie chart with four sections that represent the market share percentages for four different products: Product A with 30%, Product B with 45%, Product C with 10%, and Product D with 15%? Please use a radius of 2 units for the chart and assign the colors red, blue, green, and yellow to each product respectively. I'd also like the labels for the products to be clearly visible in white, placed at a distance that's not too close but still readable, maybe at 1.5 units away from the center. Furthermore, could each slice of the pie have a shade of teal, with each slice being a slightly different variant? And finally, let's start the first section (Product A) from the top of the circle \u2013 a 90-degree angle from the horizontal line.",
        "answer": "\\n from manim import *\n\n\ndef create_dc_motor() -> Mobject:\n    r_inner = Rectangle(GREY_D, 2.8, 0.3).set_fill([RED, BLUE], 1).set_z_index(5).rotate(1)\n    c_inner = Circle(0.68, GREY_B).set_fill(GREY_B, 1).set_z_index(4)\n    c_hidden = Circle(0.75, WHITE).set_fill(WHITE, 1).set_z_index(3)\n    c_middle = Circle(1.6, GREY_D).set_fill(WHITE, 1).set_z_index(2)\n    c_outer = Circle(2, GREY_D).set_fill([RED, BLUE], 1).set_z_index(1).rotate(1 / 4 * np.pi)\n    a = Arc(0.7, 1.2, np.pi - 0.4, color=GOLD_D, stroke_width=10).set_z_index(4)\n    b = Arc(0.7, 0.8, -np.pi + 0.4, color=GOLD_D, stroke_width=10).set_z_index(4)\n    upper_rect = (\n        Rectangle(GREY_D, height=1, width=0.3).set_fill([GREY_C, BLUE], 1).set_z_index(2).set_y(1.09).rotate(np.pi)\n    )\n    lower_rect = Rectangle(GREY_D, height=1, width=0.3).set_fill([GREY_C, RED], 1).set_z_index(2).set_y(-1.09)\n    stand = (\n        Polygon(\n            [-2, -2.2, 0],\n            [2, -2.2, 0],\n            [2, -2, 0],\n            [1.75, -2, 0],\n            [np.sqrt(2), -np.sqrt(2), 0],\n            [-np.sqrt(2), -np.sqrt(2), 0],\n            [-1.75, -2, 0],\n            [-2, -2, 0],\n            color=GREY_D,\n        )\n        .set_fill(GRAY_C, 1)\n        .set_z_index(0)\n    )\n\n    return VGroup(c_inner, c_middle, c_outer, stand, r_inner, a, b, upper_rect, lower_rect, c_hidden)\n\n\nclass DCMotor(Scene):\n    def construct(self):\n\n        rotor = Text(\"Rotor\", color=BLACK).set_x(-5.5).set_y(2)\n        rotor_line = VGroup(\n            DashedVMobject(Line([-6.4, 1.65, 0], [-3.5, 1.65, 0], color=BLACK), num_dashes=12),\n            DashedVMobject(Line([-3.5, 1.65, 0], [-0.5, -0.5, 0], color=BLACK).set_z_index(10)),\n            DashedVMobject(Line([-1.96, 0.545, 0], [-0.5, 0.545, 0], color=BLACK).set_z_index(10), num_dashes=7),\n        )\n        stator = Text(\"Stator\", color=BLACK).set_x(5.5).set_y(-1.1)\n        stator_line = VGroup(\n            DashedVMobject(Line([6.4, -1.45, 0], [3.7, -1.45, 0], color=BLACK), num_dashes=10),\n            DashedVMobject(Line([3.7, -1.45, 0], [1.3 * 1.8, -1.3 * 1.8, 0], color=BLACK).set_z_index(10), num_dashes=7),\n        )\n\n        brushes = Text(\"B\u00fcrsten\", color=BLACK).set_x(5).set_y(3)\n        brushes_line = VGroup(\n            DashedVMobject(Line([6.4, 2.65, 0], [3.7, 2.65, 0], color=BLACK), num_dashes=10),\n            DashedVMobject(Line([3.15, 1.09 * 1.8, 0], [0, 1.09 * 1.8, 0], color=BLACK).set_z_index(3), num_dashes=11),\n            DashedVMobject(Line([3.7, 2.65, 0], [0, -1.09 * 1.8, 0], color=BLACK).set_z_index(3), num_dashes=22),\n        )\n\n        self.camera.background_color = WHITE\n        everything = create_dc_motor()\n        self.add(everything.scale(1.8), rotor, rotor_line, stator, stator_line, brushes, brushes_line)"
    },
    {
        "query": "Can you create an animation where a red triangle appears to grow from the center of the screen and then a yellow hexagon fades in to the left side of the triangle with a small separation between them? The triangle should be somewhat transparent, and the hexagon should be even more transparent.",
        "answer": "\\n from manim import *\nfrom PIL import Image\nimport numpy as np\nfrom manim_ml.neural_network import Convolutional2DLayer, NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork({\n            \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n            \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n            \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1)\n        })\n        # Add the residual connection\n        nn.add_connection(\"layer1\", \"layer3\")\n        # Make the animation\n        self.play(nn.make_forward_pass_animation())\n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass ConvScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n\n        nn = NeuralNetwork(\n            {\n                \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n                \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n                \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1),\n            },\n            layer_spacing=0.25,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)"
    },
    {
        "query": "I'd like to create an animation of a stack of sandwiches, with each sandwich having distinct layers such as bread, cheese, and lettuce. I want them to materialize one by one with a slight delay between each. Then, I'd like each sandwich to get a bite mark, sequentially, where the bite appears to be taken out of them. Afterwards, all the sandwiches should slide to the left together, with the bite marks moving accordingly. Finally, I want all the elements to fade away, and the background of the animation should be a green screen color, suitable for chroma keying in video production. Can you do that for me?",
        "answer": "\\n from manim import *\n\nclass EulerianPath(Scene):\n    def construct(self):\n        vertices = 6\n        edges = [\n            (0, 1), (0, 2), (1, 2), (2, 3), (3, 2), \n            (3, 4), (4, 3), (4, 5), (5, 4), (1, 5),\n        ]\n        dots = [Dot().move_to(UP + ii * RIGHT) for ii in range(vertices)]\n        for ind, dot in enumerate(dots):\n            dot.move_to(\n                3 * (np.cos(ind / vertices * TAU) * RIGHT +\n                     np.sin(ind / vertices * TAU) * UP)\n            )\n        lines = VGroup()\n        for u, v in edges:\n            lines.add(Line(dots[u].get_center(), dots[v].get_center()))\n        \n        vgroup = VGroup(lines, *dots)\n        vgroup.move_to(ORIGIN)\n        self.play(LaggedStart(*[FadeIn(dot) for dot in dots], lag_ratio=0.5))\n        self.wait(0.5)\n        self.play(LaggedStart(*[ShowCreation(line) for line in lines], lag_ratio=0.5))\n        self.wait(1)\n\n        path_ind = [0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 5]\n        path_lines = []\n        for k in range(len(path_ind) - 1):\n            self.play(dots[path_ind[k]].set_color, BLUE, run_time=0.5)\n            new_line = Line(\n                dots[path_ind[k]].get_center(),\n                dots[path_ind[k + 1]].get_center(),\n                color=BLUE,\n                stroke_width=5,\n            )\n            path_lines.append(new_line)\n            self.play(ShowCreation(new_line), run_time=0.5)\n        self.play(dots[path_ind[-1]].set_color, BLUE, run_time=0.5)\n        self.wait(1)\n\n        label = Tex(\"Eulerian Path\", color=BLUE).to_edge(UP)\n        self.play(Write(label))\n\n        graph_copy = VGroup(*dots, *path_lines).copy()\n        self.play(\n            ApplyFunction(\n                lambda m: m.scale(0.5).next_to(label, DOWN),\n                graph_copy\n            )\n        )\n        \n        self.wait(1)\n        self.play(FadeOut(VGroup(*self.mobjects)))"
    },
    {
        "query": "I would like to create an animated video sequence that showcases a simple pie chart visualizing the sales distribution of different-colored products. The background should be a soft cream color, and the pie chart needs to have slices in light teal, light pink, and light brown, representing three products respectively. Alongside the chart, there should be labels matching the colors, stating \"Teal Product,\" \"Pink Product,\" and \"Brown Product.\"\n\nAs it animates, each slice of the pie should display its corresponding percentage of sales in large, clear text in the same cream color as the background. After the chart appears, I'd like each slice to be individually highlighted with a scale effect while the legend labels temporarily change to darker versions of teal, pink, and brown.\n\nThe video sequence should begin by fading in the pie chart and the legends, and end by fading them out. All transitions should be smooth. Keep everything visually appealing and straightforward, and please ensure the animation lasts a few seconds, allowing viewers to take in the information.",
        "answer": "\\n from manim import *\n\nclass MovingAlongEpicycloid(Scene):\n    def construct(self):\n        def epicycloid(t):\n            R, r, d = 3, 1, 2\n            theta = t\n            x = (R + r) * np.cos(theta) - d * np.cos((R + r) / r * theta)\n            y = (R + r) * np.sin(theta) - d * np.sin((R + r) / r * theta)\n            return np.array([x, y, 0])\n\n        path = ParametricFunction(\n            epicycloid,\n            t_range=[0, 4 * PI],\n            color=BLUE\n        )\n\n        dot = Dot(color=BLUE).move_to(path.get_start())\n        self.add(dot, path)\n        self.play(MoveAlongPath(dot, path), run_time=8, rate_func=linear)\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an animation where a blue square appears to move with a wave-like motion up and down across the screen for a brief amount of time. Can you describe how one might go about designing such an animation with a sense of rhythm to it, similar to a sine wave pattern, where the height of the wave and its length can be adjusted for visual effect? This animation should have the appearance of the square being gently swept by the wave, ideally over a duration of two seconds, and then coming to a rest. Can you guide me through the process of making this animation?",
        "answer": "\\n from manim import *\n\nclass Atom(Scene):\n    def construct(self):\n        # Create the center of the atom\n        nucleus = circle_with_text(0.4, \"N\", RED_E, 30, WHITE, 2, RED_E)\n        nucleus.move_to(ORIGIN)\n        \n        # Create three electrons\n        e1 = electron()\n        e2 = electron()\n        e3 = electron()\n        \n        # Position electrons around the nucleus\n        e1.move_to(UP * 0.8)\n        e2.move_to(DOWN * 0.6 + LEFT * 0.6)\n        e3.move_to(DOWN * 0.6 + RIGHT * 0.6)\n\n        # Animate the creation of nucleus and electrons\n        self.play(Create(nucleus))\n        self.play(FadeIn(e1), FadeIn(e2), FadeIn(e3))\n        \n        # Animate electrons' circular orbits around the nucleus\n        self.play(\n            Rotating(e1, about_point=nucleus.get_center(), radians=2*PI),\n            Rotating(e2, about_point=nucleus.get_center(), radians=2*PI, rate_func=linear),\n            Rotating(e3, about_point=nucleus.get_center(), radians=2*PI, rate_func=linear),\n            run_time=4,\n            rate_func=linear\n        )\n\n        self.wait(2)"
    },
    {
        "query": "Can you create a custom animation using Python and Manim where a square first dissolves into numerous small dots and then those dots come together to form the square again, but it should happen smoothly over a duration with the dots starting semi-transparent, becoming fully opaque, and then fading out as they form the square? I'd like to see the effect of the square first disintegrating and then assembling back from these dots, with about 200 dots being used in the process, and the whole animation running across four seconds.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the graph\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.3)\n        \n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n        \n        # Show the area under the curve\n        area_label = MathTex(r\"\\text{Area} = \\int_0^2 x^2 \\,dx\").next_to(area, DOWN)\n        self.play(FadeIn(area), Write(area_label))\n        self.wait(2)\n\n        # Calculate the area under the curve\n        area_calculation = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(ReplacementTransform(area_label, area_calculation))\n        self.wait(1)\n\n        # Final area\n        final_area = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(area_calculation, final_area))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), FadeOut(final_area))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video showing the graph of the function y=0.5x^2, with the area under the curve between x=0 and x=2 shaded in yellow. The graph should be displayed on a set of blue axes that go from -3 to 3 on the x-axis and -1 to 5 on the y-axis, with tick marks at each unit. I'd also like the equation of the function to appear next to the graph. Once everything is displayed, the animation should pause for a moment. Can you help me with that?",
        "answer": "\\n from manim import *\n\nclass MoleculeAnimation(Scene):\n    def construct(self):\n        # Create an Oxygen molecule\n        oxygen_molecule = self.create_oxygen_molecule()\n        # Position the oxygen molecule\n        oxygen_molecule.to_edge(UP)\n\n        # Create a Lithium ion\n        lithium_ion = self.create_lithium_ion()\n        # Position the lithium ion\n        lithium_ion.next_to(oxygen_molecule, DOWN)\n\n        # Animate the creation of the oxygen molecule and the lithium ion\n        self.play(Create(oxygen_molecule), FadeIn(lithium_ion))\n\n        # Move the lithium ion to the oxygen molecule\n        self.play(lithium_ion.animate.move_to(oxygen_molecule.get_center()))\n\n        # Combine the lithium ion with the oxygen molecule to form a compound\n        lithium_oxygen_compound = VGroup(oxygen_molecule, lithium_ion)\n        self.play(FadeIn(lithium_oxygen_compound))\n\n        # Show the final combined molecule\n        self.play(lithium_oxygen_compound.animate.scale(1.5).move_to(ORIGIN))\n\n        # Hold the final state for a while before ending the scene\n        self.wait(2)\n\n    def create_oxygen_molecule(self):\n        oxygen_left = circle_with_text(0.3, \"O\", RED, 30, WHITE, 2, RED)\n        oxygen_right = circle_with_text(0.3, \"O\", RED, 30, WHITE, 2, RED)\n        oxygen_pair = VGroup(oxygen_left, oxygen_right).arrange(buff=0.5)\n        return oxygen_pair\n\n    def create_lithium_ion(self):\n        return circle_with_text(0.2, \"Li$^+$\", GREY_B, 26, BLACK, 2, GREY_B)"
    },
    {
        "query": "I am looking to create a short animation using ManimCE, which should initially display the word \"Inscribe\" at the bottom of the screen. Then, I want this word to quickly move to the top of the screen. After that, I would like another text saying \"Watch Here\" to appear in the center. That text should blink or be highlighted to draw attention, and I also want it to blink or be highlighted in red at some point. Once that's done, I want the \"Watch Here\" text to disappear. Can you create a script for an animation like this?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\left[\\frac{1}{2}x^2yz\\right]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem, inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{1}{2}yz\\right]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{4}z^2\\right]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animation that visualizes an Eulerian Path on a graph. The graph should have six vertices arranged in a circular pattern and ten directed edges connecting the vertices. The animation should show the vertices and edges appearing consecutively with some delay between them to make it clear. Once the graph is displayed, I want to highlight an Eulerian Path by changing the color of the vertices and the path edges to blue as it travels through the graph, including returning paths. After showing the Eulerian Path, the animation should display the text \"Eulerian Path\" at the top of the screen and then create a smaller copy of the graph with the path below the label. Finally, the entire scene should fade out. Can you create this animation for me, ensuring that the visualization is clear and the path distinctly marked?",
        "answer": "\\n from manim import *\n\n\nclass AtomicStructure(Scene):\n    def construct(self):\n        # Create elements for the atomic structure\n        nucleus = self.create_nucleus()\n        electron_orbit = self.create_electron_orbit()\n\n        # Position elements\n        nucleus.move_to(ORIGIN)\n        electron_orbit.move_to(nucleus.get_center())\n\n        # Create electron and define its motion\n        electron = electron().move_to(electron_orbit.point_from_proportion(0))\n        electron_motion = self.create_electron_motion(electron, electron_orbit)\n\n        # Animate elements\n        self.play(FadeIn(nucleus, scale=0.5), FadeIn(electron_orbit, scale=0.5))\n        self.wait(1)\n        self.play(*electron_motion)\n        self.wait(2)\n\n    def create_nucleus(self):\n        nucleus = VGroup()\n        # Create protons and neutrons for the nucleus\n        protons = VGroup(*[positive().next_to(ORIGIN, direction, buff=SMALL_BUFF) for direction in [UP, LEFT]])\n        neutrons = VGroup(*[neutral().next_to(ORIGIN, direction, buff=SMALL_BUFF) for direction in [DOWN, RIGHT]])\n        \n        # Add the protons and neutrons to the nucleus\n        nucleus.add(protons, neutrons)\n        return nucleus\n\n    def create_electron_orbit(self, radius=1.5):\n        orbit = Circle(radius=radius, color=BLUE_D, opacity=0.5)\n        return orbit\n\n    def create_electron_motion(self, electron, orbit):\n        electron_motion = Rotate(electron, angle=2*PI, about_point=orbit.get_center())\n        return electron_motion\n\ndef positive() -> Mobject:\n    return circle_with_text(0.2, \"+\", RED, 28, WHITE, 4, RED)\n\ndef neutral() -> Mobject:\n    return circle_with_text(0.2, \"n\", GREY_BROWN, 28, WHITE, 4, GREY_BROWN)"
    },
    {
        "query": "Can you create an animation where a red square appears on the screen with the caption \"This is a square\" below it, then both the square and the caption fade in, stay visible for a short moment, and then fade out?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.next_to\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift((RIGHT+UP)*2)\n            square = Square().shift(LEFT*2)\n            self.add(dot)\n            self.play(square.animate.next_to(dot))\n            self.remove(square,dot)"
    },
    {
        "query": "I'd like to create an animation where a red rectangle with a slight transparency appears on the screen followed by an orange triangle that also has some transparency. The rectangle should have a width of 4 units and a height of 2 units. The triangle should appear above the rectangle, and it should look like it's growing from a single point at the origin. After the shapes finish appearing, I want the animation to pause for a moment. Can you make this for me using the Manim library?",
        "answer": "\\n from manim import *\n\n\nclass ValentineScene(GraphScene, MovingCameraScene):\n    def setup(self):\n        MovingCameraScene.setup(self)\n\n    def construct(self):\n        self.camera.background_color = WHITE\n        self.axes_color = BLACK\n        self.x_min = -PI\n        self.x_max = PI\n        self.x_axis_config = {\"tick_frequency\": PI / 2}\n        self.x_axis_width = 10\n\n        self.y_min = -3\n        self.y_max = 3\n        self.y_axis_height = 10\n        self.graph_origin = ORIGIN\n\n        self.camera_frame.scale(1.3)\n        self.setup_axes()\n        self.remove(\n            self.x_axis, self.y_axis, self.y_axis_label_mob, self.x_axis_label_mob\n        )\n        self.y_axis_label_mob.shift(0.4 * DOWN + 0.2 * RIGHT)\n        self.play(\n            Write(\n                VGroup(\n                    self.x_axis,\n                    self.y_axis,\n                    self.y_axis_label_mob,\n                    self.x_axis_label_mob,\n                )\n            )\n        )\n\n        axis_labels = [\n            MathTex(\"\\\\frac{\\\\pi}{2}\")\n            .scale(0.8)\n            .move_to(self.coords_to_point(PI / 2, -0.35)),\n            MathTex(\"-\\\\frac{\\\\pi}{2}\")\n            .scale(0.8)\n            .move_to(self.coords_to_point(-PI / 2, -0.35)),\n        ]\n\n        # Label axes.\n        self.play(*[Write(label) for label in axis_labels])\n\n        # Draw positive sin.\n        positive_sin = self.get_graph(\n            lambda x: np.sin(x) + 1, color=GRAY, x_min=-PI, x_max=PI\n        )\n        positive_sin_label = (\n            MathTex(\"f(x) = \", \"\\\\sin(x) + 1\")\n            .scale(0.7)\n            .move_to(self.coords_to_point(-PI, 1.2))\n        )\n        self.play(\n            Write(positive_sin_label),\n            ShowCreation(positive_sin),\n        )\n        self.wait(0.7)\n\n        # Trace heart section.\n        heart_red = \"#e0245e\"\n        heart_stroke_width = 6\n\n        def draw_positive_section(section, dt):\n            section.total_time += dt\n            section.total_time = min(section.total_time, 1)\n            new_section = self.get_graph(\n                lambda x: np.sin(x) + 1,\n                color=heart_red,\n                x_min=-PI / 2,\n                x_max=-PI / 2 + PI * section.total_time,\n                stroke_width=heart_stroke_width,\n            )\n            section.become(new_section)\n\n        positive_sin_heart_section = self.get_graph(\n            lambda x: np.sin(x) + 1,\n            color=heart_red,\n            x_min=-PI / 2,\n            x_max=-PI / 2,\n            stroke_width=heart_stroke_width,\n        )\n        positive_sin_heart_section.total_time = 0\n        positive_sin_heart_section.add_updater(draw_positive_section)\n        self.add(positive_sin_heart_section)\n\n        self.wait()\n        self.wait(0.7)\n\n        # Draw negative sin.\n        negative_sin = self.get_graph(\n            lambda x: -np.sin(x) - 1, color=GRAY, x_min=-PI, x_max=PI\n        )\n        negative_sin_label = (\n            MathTex(\"f(x) = \", \"-\\\\sin(x) - 1\")\n            .scale(0.7)\n            .move_to(self.coords_to_point(-PI, -1.2))\n        )\n        self.play(\n            Write(negative_sin_label),\n            ShowCreation(negative_sin),\n        )\n        self.wait(0.7)\n\n        # Trace heart section.\n        def draw_negative_section(section, dt):\n            section.total_time += dt\n            section.total_time = min(section.total_time, 1)\n            new_section = self.get_graph(\n                lambda x: -np.sin(x) - 1,\n                color=heart_red,\n                x_min=-PI / 2,\n                x_max=-PI / 2 + PI * section.total_time,\n                stroke_width=heart_stroke_width,\n            )\n            section.become(new_section)\n\n        negative_sin_heart_section = self.get_graph(\n            lambda x: -np.sin(x) - 1,\n            color=heart_red,\n            x_min=-PI / 2,\n            x_max=PI / 2,\n            stroke_width=heart_stroke_width,\n        )\n        negative_sin_heart_section.total_time = 0\n        negative_sin_heart_section.add_updater(draw_negative_section)\n        self.add(negative_sin_heart_section)\n        self.wait()\n        self.wait(0.7)\n\n        # Draw the positive circle.\n        positive_circle = Circle(\n            radius=self.y_axis_config[\"unit_size\"],\n            stroke_color=GRAY,\n        ).move_to(self.coords_to_point(PI / 2, 1))\n        positive_circle_label = (\n            MathTex(\"\\\\left(x-\\\\frac{\\\\pi}{2}\\\\right)^2 + (y-1)^2 = 1\")\n            .scale(0.7)\n            .next_to(positive_circle, UR, buff=0.1)\n            .shift(LEFT * 0.8 + DOWN * 0.2)\n        )\n        self.bring_to_back(positive_circle)\n        self.play(ShowCreation(positive_circle), Write(positive_circle_label))\n\n        # Trace the heart section.\n        def draw_positive_circle_section(section, dt):\n            section.total_time += dt\n            section.total_time = min(section.total_time, 1)\n            new_section = Arc(\n                radius=self.y_axis_config[\"unit_size\"],\n                start_angle=PI / 2,\n                angle=-PI * section.total_time,\n                color=heart_red,\n                stroke_width=heart_stroke_width,\n            ).move_arc_center_to(self.coords_to_point(PI / 2, 1))\n            section.become(new_section)\n\n        positive_circle_heart_section = Arc(\n            radius=self.y_axis_config[\"unit_size\"],\n            start_angle=PI / 2,\n            angle=-PI,\n            color=heart_red,\n            stroke_width=heart_stroke_width,\n        ).move_arc_center_to(self.coords_to_point(PI / 2, 1))\n        positive_circle_heart_section.total_time = 0\n        self.add(positive_circle_heart_section)\n        positive_circle_heart_section.add_updater(draw_positive_circle_section)\n        self.wait()\n        self.wait(0.7)\n\n        # Draw the negative circle.\n        negative_circle = Circle(\n            radius=self.y_axis_config[\"unit_size\"],\n            stroke_color=GRAY,\n        ).move_to(self.coords_to_point(PI / 2, -1))\n        negative_circle_label = (\n            MathTex(\"\\\\left(x-\\\\frac{\\\\pi}{2}\\\\right)^2 + (y+1)^2 = 1\")\n            .scale(0.7)\n            .next_to(negative_circle, DR, buff=0.1)\n            .shift(LEFT * 0.8 + UP * 0.2)\n        )\n        self.bring_to_back(negative_circle)\n        self.play(ShowCreation(negative_circle), Write(negative_circle_label))\n\n        # Trace the heart section.\n        def draw_negative_circle_section(section, dt):\n            section.total_time += dt\n            section.total_time = min(section.total_time, 1)\n            new_section = Arc(\n                radius=self.y_axis_config[\"unit_size\"],\n                start_angle=-PI / 2,\n                angle=PI * section.total_time,\n                color=heart_red,\n                stroke_width=heart_stroke_width,\n            ).move_arc_center_to(self.coords_to_point(PI / 2, -1))\n            section.become(new_section)\n\n        negative_circle_heart_section = Arc(\n            radius=self.y_axis_config[\"unit_size\"],\n            start_angle=-PI / 2,\n            angle=PI,\n            color=heart_red,\n            stroke_width=heart_stroke_width,\n        ).move_arc_center_to(self.coords_to_point(PI / 2, 1))\n        negative_circle_heart_section.total_time = 0\n        self.add(negative_circle_heart_section)\n        negative_circle_heart_section.add_updater(draw_negative_circle_section)\n\n        self.wait()\n        self.wait(0.7)\n\n        # Flip over y = x\n        def inverse_function(func):\n            flipped_func = func.copy()\n            for i, point in enumerate(func.points):\n                x, y, _ = point\n                flipped_func.points[i] = self.coords_to_point(y * 2 / PI, x * PI / 5.2)\n            return flipped_func\n\n        graph_sections = [\n            positive_sin,\n            positive_sin_heart_section,\n            negative_sin,\n            negative_sin_heart_section,\n            positive_circle,\n            positive_circle_heart_section,\n            negative_circle,\n            negative_circle_heart_section,\n        ]\n        for func in graph_sections:\n            func.clear_updaters()\n\n        transforms = []\n        for func in graph_sections:\n            transforms.append(Transform(func, inverse_function(func)))\n\n        graph_label_data = [\n            # f(x) = sin(x) + 1\n            {\n                \"label\": positive_sin_label,\n                \"offset\": UP * 4.5 + RIGHT * 0.5,\n                \"inverse\": [\"f(x) = \", \"-\\\\arcsin(-x + 1)\"],\n            },\n            # f(x) = sin(x) - 1\n            {\n                \"label\": negative_sin_label,\n                \"offset\": UP * 4.5 + LEFT * 0.5,\n                \"inverse\": [\"f(x) = \", \"-\\\\arcsin(x + 1)\"],\n            },\n            # \\\\left(x-\\\\frac{\\\\pi}{2}\\\\right)^2 + (y-1)^2 = 1\n            {\n                \"label\": positive_circle_label,\n                \"offset\": DOWN * 4.1 + RIGHT * 0,\n                \"inverse\": \"\\\\left(y-\\\\frac{\\\\pi}{2}\\\\right)^2 + (x-1)^2 = 1\",\n            },\n            # \\\\left(x-\\\\frac{\\\\pi}{2}\\\\right)^2 + (y+1)^2 = 1\n            {\n                \"label\": negative_circle_label,\n                \"offset\": DOWN * 4.1 + LEFT * 0,\n                \"inverse\": \"\\\\left(y-\\\\frac{\\\\pi}{2}\\\\right)^2 + (x+1)^2 = 1\",\n            },\n        ]\n        animations = []\n        for i, data in enumerate(graph_label_data):\n            label = data[\"label\"]\n            offset = data[\"offset\"]\n            inverse = data[\"inverse\"]\n            x, y, _ = label.get_center()\n            target = label.generate_target()\n            # Match the corresponding terms for the sin transformations.\n            if i < 2:\n                target_tex = MathTex(inverse[0], inverse[1])\n            else:\n                target_tex = MathTex(inverse)\n            target.become(target_tex)\n            target.move_to(self.coords_to_point(y, x)).shift(offset)\n            animations.append(MoveToTarget(label))\n\n        self.play(self.camera_frame.animate.scale(1.2), *transforms, *animations)\n        self.wait(0.5)\n\n        graph_sections = [\n            positive_sin,\n            negative_sin,\n            positive_circle,\n            negative_circle,\n        ]\n        graph_labels = [data[\"label\"] for data in graph_label_data]\n        animations = [\n            FadeOut(mob)\n            for mob in graph_sections\n            + graph_labels\n            + axis_labels\n            + [self.x_axis, self.y_axis, self.x_axis_label_mob, self.y_axis_label_mob]\n        ]\n        self.play(*animations)\n\n        heart_mob = VMobject(\n            stroke_color=heart_red,\n            fill_color=heart_red,\n            stroke_width=heart_stroke_width,\n        )\n        for i, graph_section in enumerate(\n            [\n                positive_sin_heart_section,\n                positive_circle_heart_section,\n                negative_sin_heart_section,\n                negative_circle_heart_section,\n            ]\n        ):\n            heart_mob.append_points(graph_section.points)\n\n        self.remove(\n            positive_sin_heart_section,\n            positive_circle_heart_section,\n            negative_circle_heart_section,\n            negative_sin_heart_section,\n        )\n        self.add(heart_mob)\n        self.play(heart_mob.animate.set_fill(opacity=1))\n        self.wait(0.5)\n\n        heart_mob.generate_target().scale(0.15).shift(UP * 1.7)\n        self.play(MoveToTarget(heart_mob))\n\n        message_front = (\n            Text(\"With\", fill_color=BLACK).scale(1.5).next_to(heart_mob, LEFT)\n        )\n        message_back = (\n            Text(\"from\", fill_color=BLACK).scale(1.5).next_to(heart_mob, RIGHT)\n        )\n\n        self.play(FadeIn(message_front), FadeIn(message_back))\n\n        banner_location = (\n            VGroup(message_front, heart_mob, message_back).get_center() + 3 * DOWN\n        )\n\n        banner = ManimBanner(dark_theme=False).scale(0.9).move_to(banner_location)\n        banner.scale_factor = 2.5\n        self.play(banner.create())\n\n        for mob in [banner.triangle, banner.circle, banner.square]:\n            mob.clear_updaters()\n        self.bring_to_front(banner.M)\n\n        # Position the targets of the M.\n        banner.M.generate_target().shift(LEFT * banner.anim.get_width() * 0.57),\n\n        # Position the anim based on the location of the target.\n        banner.anim.next_to(banner.M.target, RIGHT, 0.1)\n        banner.anim.align_to(banner.M.target, DOWN)\n\n        self.play(\n            banner.M.animate.shift(LEFT * banner.anim.get_width() * 0.57),\n            banner.triangle.animate.shift(RIGHT * banner.anim.get_width() * 0.57),\n            banner.square.animate.shift(RIGHT * banner.anim.get_width() * 0.57),\n            banner.circle.animate.shift(RIGHT * banner.anim.get_width() * 0.57),\n            AnimationGroup(\n                ApplyMethod(VGroup(banner.anim[1], banner.anim[2]).set_opacity, 1),\n                ApplyMethod(VGroup(banner.anim[0], banner.anim[-1]).set_opacity, 1),\n                lag_ratio=0.3,\n            ),\n        )\n\n        self.wait()"
    },
    {
        "query": "Can you create an educational animation that shows a fraction bar graph with each bar representing a fraction of the total number of bars, starting from 1/6 up to 6/6, with each bar having a label beneath it indicating the fraction it represents? The graph should have a white background, with bars colored in a shade of blue and labels in a darker color for contrast. The bars should grow from the bottom one by one along with their labels, and once all of them are displayed, I'd like all bars except for the third one to disappear. Following that, the third bar and its label should change color to yellow to highlight it, and then the entire graph should fade out to the left, ending the animation.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Write the function\n        function = MathTex(r\"f(x) = e^{-x^2}\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Explain what the area under the curve represents\n        explanation = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Set up the integral\n        integral = MathTex(r\"\\int_0^2 e^{-x^2} \\,dx\")\n        self.play(Transform(function, integral))\n        self.wait(1)\n\n        # Explain numerical approximation since it can't be expressed in elementary functions\n        explanation2 = Text(\"We'll approximate the integral numerically\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, explanation2))\n        self.wait(2)\n\n        # Show approximation step\n        approximation = MathTex(r\"\\approx 0.88208\")\n        self.play(Transform(integral, approximation))\n        self.wait(1)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(approximation))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational math animation that showcases a three-dimensional red spiral that coils around an axis. The animation should feature the spiral rotating slowly to allow a clear view from multiple angles. The spiral needs to look like it's rising upwards as it extends outward in a circular pattern, similar to a spring or the threads on a screw. The background should include a set of 3D axes to help visualize the spiral in three-dimensional space. The animation should start with the camera positioned at a slight elevation and an angle that gives a good initial view of the spiral and axes. After the elements are drawn, the camera should continuously rotate around the spiral, giving an all-around, panoramic view of the structure. The animation should last long enough for viewers to appreciate the spiral's shape, so maybe about 6 seconds of rotation after the spiral is created. Can you make such an animation in a way that could be used for a math class to demonstrate 3D geometry?",
        "answer": "\\n from manim import *\n\nfrom manim_ml.neural_network import Convolutional2DLayer, FeedForwardLayer, NeuralNetwork\n\n# This changes the resolution of our rendered videos\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n# Here we define our basic scene\nclass BasicScene(ThreeDScene):\n\n    # The code for generating our scene goes here\n    def construct(self):\n        # Make the neural network\n        nn = NeuralNetwork([\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the neural network\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make a forward pass animation\n        forward_pass = nn.make_forward_pass_animation()\n        # Play animation\n        self.play(forward_pass)"
    },
    {
        "query": "Can you create an educational animation that visually explains how image formation works with a concave mirror by showing light rays tracing from an object to the mirror and reflecting according to the rules of ray tracing? The animation should include a representation of a concave mirror with a principal axis, focal point, and center of curvature marked. An upright object in front of the mirror, and its inverted real image formed by the mirror should also be shown. Additionally, the animation should trace three specific light rays: one that travels parallel to the principal axis and then reflects through the focal point, another that travels towards the focal point and reflects parallel to the principal axis, and a third that travels toward the center of curvature and reflects back along the same path. At the end of the animation, all elements should fade out, leaving a blank screen.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Description of Wave Equation\n        description = Text(\"This describes the propagation of waves.\", font_size=24).to_edge(DOWN)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Displaying solution formula\n        solution_formula = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, solution_formula))\n        self.wait(2)\n\n        # Explanation of solution components\n        explanation = Text(\"f and g are arbitrary functions representing waveforms.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(description, explanation))\n        self.wait(2)\n\n        # Displaying a specific example\n        example_solution = MathTex(r\"u(x, t) = A\\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(solution_formula, example_solution))\n        self.wait(1)\n\n        # Explanation of specific example\n        example_explanation = Text(\"This is a monochromatic plane wave.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(description, example_explanation))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(example_solution), FadeOut(description))\n        self.wait(1)"
    },
    {
        "query": "I need an educational animation to explain the basics of an electrical generator. The animation should visually represent the main parts of a simple generator: a rotating armature and the magnetic field. To do this, create a grey circle to symbolize the base of the generator, with blue arcs around it to illustrate the coils of the magnetic field. Deploy a red double-sided arrow at the center to denote the armature. Additionally, include labeled arrows pointing to the relevant parts\u2014blue for \"Magnetic Field\" pointing towards one of the coils, and red for \"Current\" pointing towards the top of the armature. Make sure the labels are clear and easy to read. Set the background to white to keep the focus on the components. Can you make this animation for a learning module on electricity and magnetism?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for the outer integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3}\\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Calculation of the final integral\n        result = MathTex(r\"= [-\\frac{1}{3}\\cos(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, result))\n        self.wait(1)\n\n        # Final answer\n        answer = MathTex(r\"= -\\frac{1}{3}(\\cos(\\pi) - cos(0))\")\n        self.play(ReplacementTransform(result, answer))\n        self.wait(1)\n\n        # Simplified answer\n        final_answer = MathTex(r\"= \\frac{2}{3}\")\n        self.play(ReplacementTransform(answer, final_answer))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually represents a simple neural network architecture using three layers. Each neuron should be shown as a circle and the layers should consist of different numbers of neurons\u20144 in the first layer, 5 in the second, and 3 in the last one. Could you also use distinct colors for each layer, such as blue for the first, green for the second, and red for the third? Additionally, I want to illustrate the connections between the neurons of each layer with lines and to make the demonstration more dynamic, could you animate a yellow flash passing through the connections to simulate the signal transmission from one layer to the next? It would be great if the camera can be moved to provide a three-dimensional view of the neural network. And finally, can we finish the animation by holding the last frame so that students can take in the final image?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowFromPoint\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift(UP+RIGHT*2)\n            star = Star()\n            self.add(dot)\n            self.wait(0.5)\n            self.play(GrowFromPoint(star, dot))\n            self.remove(dot, star)"
    },
    {
        "query": "I would like to create an educational animation video that introduces an interesting mathematical concept. Can we have a scene with a pastel cream background where three colored circles appear one after another from left to right, each with a different combination of border and fill colors? Underneath these circles, I want the famous equation `e^(i*pi) + 1 = 0` to be displayed. Also, inside each circle, can we place Roman numeral labels from I to III? After presenting all the elements, I want everything to move to the left side of the screen and then clear out to transition to the next part of my video. The animation should be smooth and professional-looking, suitable for a high-quality educational content.",
        "answer": "\\n from manim import *\n\nclass EulersFormula(Scene):\n    def construct(self):\n        formula = MathTex(\"e^{i\\\\theta} = \\\\cos(\\\\theta) + i\\\\sin(\\\\theta)\")\n        self.play(Write(formula))\n        self.wait(1)\n\n        # Explanation of Euler's formula\n        explanation1 = Tex(\"Euler's formula connects complex exponentials \", \n                           \"and trigonometric functions.\")\n        explanation1.to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        explanation2 = Tex(\"It's a fundamental formula in complex analysis.\")\n        explanation2.next_to(explanation1, DOWN, aligned_edge=LEFT)\n        self.play(Write(explanation2))\n        self.wait(2)\n\n        # Visualizing on the complex plane\n        plane = ComplexPlane()\n        circle = Circle(radius=2, color=BLUE)\n\n        self.play(Create(plane), Create(circle))\n        self.wait(1)\n\n        # Animation of the formula's components\n        dot = Dot(color=RED).move_to(circle.get_start())\n        vector = Arrow(ORIGIN, circle.get_start(), buff=0)\n\n        self.play(MoveAlongPath(dot, circle), ShowCreation(vector), run_time=5, rate_func=linear)\n        self.wait(2)"
    },
    {
        "query": "\"I would like to create an educational animation where a blue square appears in the center of the screen, with a semi-transparent fill. On top of the square, the word 'Manim' should be displayed in white letters. Can you design this animation so the square and text appear together and then hold on the screen for a couple of seconds?\"",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the integration rule\n        explanation1 = Text(\"Apply the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Power rule for integration\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} \\bigg|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration\n        integration_step = MathTex(r\"= \\frac{x^{3+1}}{3+1} \\bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Simplifying the integrated function\n        explanation2 = Text(\"Now, simplify and evaluate the limits:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the integral at the bounds\n        evaluated_at_bounds = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(integration_step, evaluated_at_bounds))\n        self.wait(1)\n\n        # Calculating the result\n        final_result = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluated_at_bounds, final_result))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n\n        # Concluding with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational video animation that shows a simple probability tree diagram with four possible outcomes starting from a single event? Each outcome should be labeled with the event it represents, such as tossing a coin twice with outcomes \"HH\" for double heads, \"TT\" for double tails, and \"HT\"/\"TH\" for the mix, with equal probability of 1/4 for each. I'd like the tree to start at a single point and branch out to these four outcomes, showing the progression in a way that is easy to follow.",
        "answer": "\\n from manim import *\n\nclass ChemicalBondAnimation(Scene):\n    def construct(self):\n        # Create oxygen and hydrogen elements\n        oxygen_atom = self.create_oxygen_atom()\n        hydrogen_atom = self.create_hydrogen_atom()\n\n        # Position the atoms on screen\n        oxygen_atom.to_edge(UP)\n        hydrogen_atom.next_to(oxygen_atom, DOWN, buff=1)\n\n        # Display atoms\n        self.play(Create(oxygen_atom), Create(hydrogen_atom))\n        self.wait(1)\n\n        # Animate electron transfer from hydrogen to oxygen\n        electron = hydrogen_atom.submobjects[1].copy()\n        self.play(electron.animate.move_to(oxygen_atom.submobjects[1].get_center()))\n        self.wait(1)\n\n        # Transform into a water molecule\n        water_molecule = self.create_water_molecule()\n        water_molecule.move_to(ORIGIN)\n        self.play(Transform(VGroup(oxygen_atom, hydrogen_atom, electron), water_molecule))\n        self.wait(2)\n\n    def create_oxygen_atom(self):\n        oxygen_core = Circle(color=BLUE, fill_opacity=1).scale(0.5)\n        oxygen_label = Text(\"O\", color=WHITE).scale(0.8)\n        oxygen_atom = VGroup(oxygen_core, oxygen_label)\n        return oxygen_atom\n\n    def create_hydrogen_atom(self):\n        hydrogen_core = Circle(color=GRAY, fill_opacity=1).scale(0.3)\n        hydrogen_label = Text(\"H\", color=WHITE).scale(0.5)\n        hydrogen_electron = Dot(color=RED).scale(0.2)\n        hydrogen_atom = VGroup(hydrogen_core, hydrogen_electron, hydrogen_label)\n        hydrogen_atom.arrange(RIGHT, center=False, buff=0.1)\n        return hydrogen_atom\n\n    def create_water_molecule(self):\n        # Create water molecule components\n        oxygen_core = Circle(color=BLUE, fill_opacity=1).scale(0.5)\n        hydrogen_core_left = Circle(color=GRAY, fill_opacity=1).scale(0.3)\n        hydrogen_core_right = Circle(color=GRAY, fill_opacity=1).scale(0.3)\n        bonding_electron = Dot(color=RED).scale(0.2)\n\n        # Position components to form water molecule\n        water_molecule = VGroup(oxygen_core, hydrogen_core_left, hydrogen_core_right, bonding_electron)\n        hydrogen_core_left.next_to(oxygen_core, DL, buff=0.2)\n        hydrogen_core_right.next_to(oxygen_core, DR, buff=0.2)\n        bonding_electron.move_to(oxygen_core.get_center())\n\n        return water_molecule"
    },
    {
        "query": "Could you create an animation that shows a 2D vector field with arrows representing the flow and also includes dynamic lines that represent the flow of particles through the field? The field should have a circular motion, where the vectors point perpendicular to the radius, and I'd like to see all this over a grid background. After showing the vector field and the flowing lines for a couple of seconds, can everything then fade away smoothly?",
        "answer": "\\n from manim import *\n\nclass TrigonometricFunctionIntegration(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identity\n        explanation1 = Text(\"Use the trigonometric identity: \"\n                            r\"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Rewriting the integral\n        rewritten_integral = MathTex(r\"\\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, rewritten_integral))\n        self.wait(2)\n\n        # Performing the integral\n        integral_result = MathTex(r\"= - \\frac{1}{4} \\cos(2x) + C\")\n        self.play(Write(integral_result))\n        self.wait(1)\n\n        # Explanation for the integration result\n        explanation2 = Text(\"Integrate using the power reduction formula\", \n                            font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution after integration\n        final_solution = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(integral_result, final_solution))\n        self.wait(1)\n\n        # Conclusion and clearing the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "\"I'd like to create an animation where a red square appears on the screen and then moves to the right side over two seconds. After it stops, I want the square to change its color to blue in one second. Next, I'd like the square to follow a circular path, as if it's traveling around the circumference of an invisible circle. Once that's done, I want the square to grow three times larger and then gradually vanish from the screen. Can you describe or demonstrate how this sequence of movements and changes could be visually represented?\"",
        "answer": "\\n from manim import *\n\nclass ProbabilityTree(Scene):\n    def construct(self):\n        # Create the probability tree diagram nodes\n        start_node = Dot(point=ORIGIN)\n        end_nodes = VGroup(*[Dot() for _ in range(4)])\n\n        # Position the end nodes\n        end_nodes.arrange_in_grid(rows=2, cols=2, buff=2)\n        end_nodes.to_edge(DOWN)\n\n        # Create edges between start node and end nodes\n        edges = VGroup()\n        for end_node in end_nodes:\n            edge = Line(start_node.get_center(), end_node.get_center())\n            edges.add(edge)\n\n        # Labels for events and probabilities\n        labels = [\"HH\", \"HT\", \"TH\", \"TT\"]\n        probabilities = [\"1/4\", \"1/4\", \"1/4\", \"1/4\"]\n        event_labels = VGroup()\n        probability_labels = VGroup()\n        \n        for i, node in enumerate(end_nodes):\n            event_label = Tex(labels[i])\n            event_label.next_to(node, DOWN)\n            event_labels.add(event_label)\n\n            prob_label = Tex(probabilities[i])\n            prob_label.move_to(edge.get_center())\n            probability_labels.add(prob_label)\n\n        # Draw the tree\n        self.play(ShowCreation(start_node))\n        self.play(LaggedStart(*[GrowFromPoint(edge, start=start_node.get_center()) for edge in edges], lag_ratio=0.5))\n        self.play(*[FadeIn(label) for label in event_labels])\n        self.play(*[Write(label) for label in probability_labels])\n\n        # Hold on screen\n        self.wait(2)"
    },
    {
        "query": "\"Can you create an educational animation that shows a blue dot moving along an epicycloid path, where the epicycloid is formed by the path traced by a point at a distance from the center of a smaller circle rolling without slipping around the outside of a larger circle? I want the viewer to follow the dot as it travels on this path for a few cycles, with the motion being smooth and at a constant speed, and with the overall duration of the animation being about 8 seconds.\"",
        "answer": "\\n from manim import *\nfrom manim_voiceover import *\nfrom manim_voiceover.services.gtts import GTTSService\n\nText.set_default(color=BLACK)\nTex.set_default(color=BLACK)\n\n\nclass Main(VoiceoverScene):\n    def construct(self):\n        self.add_sound(\"vhs-startup-6088.mp3\", gain=1.1)\n        # Background.\n        background = Rectangle(height=config.frame_height, width=config.frame_width). \\\n            set_color([TEAL, BLUE, GREEN]). \\\n            set_opacity(0.7)\n        self.play(FadeIn(background, run_time=1.5))\n        self.bring_to_back(background)\n\n        # Default starting wait.\n        self.wait(1)\n\n        # Voiceover setting.\n        self.set_speech_service(GTTSService())\n\n        pi = Tex(r\"$\\pi$\").scale(2.5)\n        pi_text = Text(\"PI, which is an interesting irrational constant.\").next_to(pi, DOWN, buff=0.7)\n        g1 = Group(pi, pi_text).move_to(ORIGIN)\n\n        speech_text = \"Pi, an interesting irrational constant used by mathematicians, scientist, engineers \" \\\n                      \"and also by other stuffs.\"\n\n        with self.voiceover(text=speech_text) as tracker:\n            self.play(Create(pi))\n            self.play(Write(pi_text))\n\n        pi_value = Tex(r\"\\begin{center}$3.14159265358$ \\dots \\linebreak and million lines more\\end{center}\", color=WHITE).scale(2.4)\n\n        with self.voiceover(text=\"It has a robust value.\") as tracker:\n            self.play(FadeOut(background), Transform(g1, pi_value), run_time=1.3)\n\n        # Default ending wait.\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation that displays four different colored shapes\u2014a blue circle, a red ellipse, a green rectangle, and a yellow triangle\u2014arranged neatly in a grid with two rows and two columns?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1, shift=UP))\n        self.wait(2)\n\n        # Explanation for properties of solutions\n        explanation2 = Text(\"Its solutions represent waveforms propagating in time and space.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying a particular solution\n        particular_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(Transform(wave_eq, particular_solution))\n        self.wait(2)\n\n        # Explanation for a harmonic wave\n        explanation3 = Text(\"This is a harmonic wave where A is amplitude, k is wavenumber, and \u03c9 is angular frequency.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the scene for the next part\n        self.clear()\n        self.wait(1)\n\n        # Describing boundary conditions\n        boundary_conditions = Text(\"Boundary conditions can alter the form of the solutions.\", font_size=24)\n        self.play(Write(boundary_conditions))\n        self.wait(2)\n\n        # Show various boundary conditions\n        boundary_example1 = MathTex(r\"u(0, t) = 0\")\n        boundary_example2 = MathTex(r'u(L, t) = 0')\n        self.play(Write(boundary_example1))\n        self.wait(1)\n        self.play(Transform(boundary_example1, boundary_example2))\n        self.wait(1)"
    },
    {
        "query": "I want to create an animated video where initially, a glowing border cycles through yellow, pink, and white colors around a simple square shape. The glowing should complete a full cycle every two seconds. After displaying this for four seconds, the square should smoothly transform into a triangle and simultaneously move upwards. This transformation should take one second. Finally, the animation should hold for two more seconds with the triangle and its glowing border in the new position before ending. Can you create this using an animation software?",
        "answer": "\\n from manim import *\n\nclass CreateGraphScene(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create Graph\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n\n        # Create dot at a specific point on the graph\n        dot_at_start_graph = Dot(color=RED).move_to(axes.c2p(0, 0))\n\n        # Create label for the graph, dot, and origin\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n        dot_label = Text(\"Start\", color=RED).next_to(dot_at_start_graph, UP+RIGHT)\n        origin_label = Text(\"(0,0)\", color=ORANGE).next_to(axes.c2p(0, 0), DOWN)\n\n        # Display graph\n        self.play(Create(axes), Create(graph), FadeIn(dot_at_start_graph, shift=UP))\n        self.play(Write(graph_label), Write(dot_label), FadeInFromPoint(origin_label, axes.c2p(0, 0)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated pie chart using ManimCE to display the results of a favorite colors survey with the following data: 30% prefer Sky, 15% prefer Lavender, and 55% prefer Forest? I'd like the pie chart to have corresponding colors to these options, a legend to identify the colors, and a title at the top that says \"Favorite Colors Survey Results\". The colors should be a light blue for Sky, a light purple for Lavender, and a dark green for Forest. Additionally, I want the chart's background to be a cream color, the text to be a dark gray, and the start angle of the pie chart to be at the top or 90 degrees. Can the pie pieces have a slight transparency as well? Please place the legend at the bottom of the chart.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{-2}^{2} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2}xyz^2]_{-2}^{2} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy^2z^2]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{6}x^3y^2z^2]_{0}^{1}\", r\"= \\frac{1}{6}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation using a Python-based animation tool that will display a square with the text 'Manim' inside it? I want the square to be red and the text to be white. Also, can the text be large and bold to stand out, and can the square appear with some animation on the screen? It should stay visible for a few seconds before the animation ends.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ReplacementTransform\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            square = Square().shift(RIGHT)\n            self.play(ReplacementTransform(circle,square))\n            self.remove(circle,square)"
    },
    {
        "query": "I would like to create an animated video with a sequence of golden rectangles that spiral outwards demonstrating the golden ratio. Can you create a visual where each rectangle's length and width follow the golden ratio and where they spiral out from the smallest to the largest? I'd like the rectangles to have alternating colors from a set palette and have their length-to-width ratio labeled. Additionally, I want the animation to include a series of arcs that start from the bottom left of the last rectangle and spiral inward, with the arcs growing in radius according to the golden ratio as well. The background of the video should be dark, and I'd prefer a smooth start to the spiraling arcs. To finish off, the video should end by fading everything out gradually. Can you produce this without requiring any previous knowledge of coding or animation software?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.fade\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(RED)\n            self.add(square)\n            self.play(square.animate.fade())\n            self.remove(square)"
    },
    {
        "query": "I'd like an animation that visualizes the process of dividing a circular cookie into four equal parts. The animation should start with a title that says \"Dividing cookie into 4 parts\" at the top. The cookie itself should appear as a filled circle in the center of the screen, with a unique color very different from the background. Once the cookie is in place, I want to see two lines, one vertical and one horizontal, drawn across the cookie to create the four parts. The lines should be the same color as the background, so it looks like the cookie is being cut. After the lines are drawn, I want the cookie to shrink and move to the upper left corner of the screen. Then, in each quarter of the cookie, the fraction \"1/4\" should fade in to represent each part of the cookie. The color of the fractions should match the color of the title for consistency. Finally, I'd like the whole animation to end with the title and all elements of the cookie fading out. Can you make sure the animation has a pleasant color scheme and uses a vertical orientation suitable for a phone screen?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        problem = MathTex(r\"\\int_{0}^{\\pi/2} \\int_{0}^{1} r^2 \\sin(\\theta) dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Inner integral w.r.t r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(2)\n\n        # Middle integral simplified\n        middle_integral = MathTex(r\"= \\int_{0}^{\\pi/2} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(2)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Outer integral w.r.t theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= -\\frac{1}{3}[\\cos(\\theta)]_{0}^{\\pi/2} \")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{1}{3}\")\n        self.play(Transform(final_solution, final_answer))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually represents the simplified structure of an atom. Can you make an animation with a red nucleus labeled with the letter \"N\" at its center, surrounded by three electrons that orbit around it? The electrons should appear from thin air and then start moving in circular paths around the nucleus \u2013 not too fast, just at a pace where we can clearly see they are in motion. It would be great if the nucleus and the paths of the electrons could be distinctively colored so they stand out from each other. Can you also include a brief pause where everything stands still to conclude the animation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Transform\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            star = Star()\n            self.play(Transform(square,star))\n            self.remove(square,star)"
    },
    {
        "query": "I'd like to create an educational animation of a simple pendulum that shows both the swinging motion and the path of the bob over time. The pendulum should have an initial angle deviation from the vertical of 0.3 radians and should slowly come to a stop due to some damping effect. The length of the string should be 3 meters, the gravity should be set to 9.81 m/s\u00b2 to simulate Earth's gravity, and the mass of the bob should be 2 kilograms. Moreover, as the pendulum swings, I want to trace the bob's path with a red line that has a noticeable thickness, so it's easy to see the motion pattern. Can you create a 10-second video illustrating this concept?",
        "answer": "\\n from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        title = Text(\"Wave Equation\", font_size=34).to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eq))\n        self.wait(2)\n\n        # Write down the context of the equation\n        context = Text(\n            \"This equation describes the propagation of waves, at a speed c, through a medium.\", \n            font_size=24\n        ).next_to(wave_eq, DOWN)\n        self.play(Write(context))\n        self.wait(3)\n\n        # Show the one-dimensional example\n        one_d_example = MathTex(r\"u(x,t) = A \\sin(kx - \\omega t + \\phi)\")\n        self.play(Transform(wave_eq, one_d_example))\n        self.wait(2)\n\n        explanation = Text(\n            \"This is an example of a sinusoidal wave solution for the one-dimensional wave equation.\",\n            font_size=24\n        ).next_to(one_d_example, DOWN)\n        self.play(Write(explanation))\n        self.wait(3)\n\n        # Introduce the concept of superposition\n        superposition_expl = Text(\n            \"By the principle of superposition, solutions can be combined to form new solutions.\",\n            font_size=24\n        )\n        self.play(Transform(explanation, superposition_expl))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(title), FadeOut(one_d_example), FadeOut(explanation))\n        self.wait(1)\n\n        # Display the superposition of two waves\n        superposition_eq = MathTex(r\"u(x,t) = A \\sin(kx - \\omega t) + B \\sin(k'x - \\omega' t)\")\n        self.play(FadeIn(superposition_eq))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animated diagram of a multi-layer neural network structure, starting with four input nodes, and followed by layers with eight, six, eight, and finally four nodes, where the nodes are styled in green with blue outlines and semi-transparency, and all the nodes are connected by white lines? The animation should show the connections being drawn first and then the layers of nodes fading in, after which the entire network fades out.",
        "answer": "\\n from manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using the power rule\n        explanation1 = Text(\"Apply the power rule for integration\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Power rule step\n        power_step = MathTex(r\"\\int x^{n} \\,dx = \\frac{1}{n+1}x^{n+1} + C\")\n        self.play(ReplacementTransform(problem.copy(), power_step))\n        self.play(FadeOut(explanation1))\n        self.wait(1)\n\n        # Explanation for definite integration\n        explanation2 = Text(\"Calculate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Write(explanation2))\n        self.wait(2)\n\n        # Definite integral\n        definite_integral = MathTex(r\"\\left.\\frac{1}{n+1}x^{n+1} \\right|_0^1\")\n        self.play(ReplacementTransform(power_step, definite_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left.\\frac{1}{3}x^3 \\right|_0^1\", \"=\", \"\\frac{1}{3}\")\n        self.play(Transform(definite_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(Text(\"Area under the parabola from 0 to 1 is 1/3\", font_size=24)))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animation where a triangle appears, rotates 90 degrees, transforms into a square, and then disappears?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1}\\int_{0}^{1} \\frac{1}{2}xyz^2\\Big|_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{4}xy^2\\Big|_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for the outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{8}x^2\\Big|_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I'd like an animation of a red ball balancing on a blue seesaw, which teeters on a small green fulcrum. The seesaw should look like a simple rectangle, and the ball should be a circle that starts on the right end of the seesaw. The ball should move and cause the seesaw to tilt back and forth, simulating a real-life balancing scenario under the influence of gravity. The ball should bounce slightly when it hits the seesaw and the seesaw should be able to rotate around the fulcrum. Can you create a video demonstrating this with realistic physics, that lasts for about 5 seconds?",
        "answer": "\\n from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define layers\n        layers = VGroup(*[Rectangle(height=0.1, width=2) for _ in range(4)])\n        layers.arrange(DOWN, buff=0.5)\n\n        # Add Text for each layer\n        layer_labels = VGroup(*[\n            Text(f\"Layer {i+1}\", size=0.5).move_to(layers[i])\n            for i in range(4)\n        ])\n\n        # Group layers with labels\n        neural_network = VGroup(layers, layer_labels)\n\n        # Position the entire network\n        neural_network.move_to(ORIGIN)\n\n        # Connections between layers\n        connections = VGroup()\n        for i in range(len(layers) - 1):\n            conn = Arrow(\n                layers[i].get_bottom(),\n                layers[i+1].get_top(), \n                buff=0.1\n            )\n            connections.add(conn)\n\n        # Group everything\n        complete_network = VGroup(neural_network, connections)\n\n        # Add everything to the scene\n        self.add(complete_network)\n\n        # Animate the neural network\n        self.play(FadeIn(neural_network), GrowArrow(connections))\n        self.wait(2)\n\n        # Animate activation\n        activation = Rectangle(height=0.1, width=2, fill_color=BLUE, fill_opacity=0.8)\n        activations = VGroup()\n        for layer in layers:\n            activation_copy = activation.copy().move_to(layer)\n            activations.add(activation_copy)\n\n        self.play(LaggedStart(*[FadeIn(a) for a in activations], lag_ratio=0.5))\n        self.wait(2)"
    },
    {
        "query": "How can I create an animation that starts with a semi-transparent red triangle, then transitions into a semi-transparent yellow square, followed by a brief highlight of the square before it disappears?",
        "answer": "\\n         self.play(Transform(text,Text(\"GrowFromPoint\").shift(UP*2.5)), run_time=0.5)\n        dot = Dot().shift(UP+RIGHT*2)\n        star = Star()\n        self.add(dot)\n        self.wait(0.5)\n        self.play(GrowFromPoint(star, dot))\n        self.remove(dot, star)"
    },
    {
        "query": "Could you create an animation that visually demonstrates the process of estimating the value of Pi using the Monte Carlo method? I want the animation to show a square with a circle inside it, and have random points generated within the square. Points that fall inside the circle should be one color, while points outside should be another. As points are placed, the animation should update an estimate of Pi based on the ratio of points inside the circle to the total number of points, and I'd like to see a running numerical estimate of Pi displayed below the circle. Could we try with 1000 points to see how close the estimation gets to the actual value of Pi?",
        "answer": "\\n from manim import *\n\nclass ChemicalReaction(Scene):\n    def construct(self):\n        # Create reactants\n        reactant1 = oxygen().shift(LEFT * 2)\n        reactant2 = metal().shift(RIGHT * 2)\n        \n        # Create products\n        product1 = electron().shift(LEFT * 2 + DOWN * 2)\n        product2 = positive().shift(RIGHT * 2 + DOWN * 2)\n        \n        # Create plus and arrow symbols\n        plus = Tex(\"+\").shift(UP * 0.5)\n        arrow = Tex(r\"\\rightarrow\").next_to(plus, DOWN)\n        \n        # Group elements\n        reactants = VGroup(reactant1, plus, reactant2)\n        products = VGroup(product1, arrow, product2)\n        \n        # Animate the chemical reaction\n        self.play(FadeIn(reactants))\n        self.wait(1)\n        self.play(Transform(reactants, products))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that demonstrates the phases of the Moon as seen from Earth throughout a lunar month? I would like the animation to include a representation of Earth at the center, the Moon's orbit around the Earth as an ellipse, and the Moon moving along this elliptical path. Each phase of the Moon should be highlighted at its appropriate position along the orbit with labels, and the Moon itself should change position to reflect the real-time progress of its orbit. Please ensure that the animation is accurate, and that it runs for a duration that represents one lunar month, with the Moon's movement rate proportional to the actual lunar cycle.",
        "answer": "\\n from manim import *\n\n# Constants\nMOON_ORBIT_RADIUS = 3.0\nEARTH_MOON_DISTANCE = 3.8\nEARTH_RADIUS = 0.2\nMOON_RADIUS = 0.05\nMOON_ORBIT_RATE = 0.1\nWAIT_TIME = 15\nMOON_START_PROPORTION = 0.25\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Earth\n        earth = Dot(radius=EARTH_RADIUS, color=BLUE)\n        self.add(earth)\n\n        # Moon\n        moon_orbit_path = Circle(radius=MOON_ORBIT_RADIUS, color=WHITE, stroke_opacity=0.5)\n        self.add(moon_orbit_path)\n\n        moon = Dot(radius=MOON_RADIUS, color=GREY)\n        moon.move_to(moon_orbit_path.point_from_proportion(MOON_START_PROPORTION))\n\n        # Moon orbit\n        orbit_val = ValueTracker(MOON_START_PROPORTION)\n\n        def orbit(m):\n            proportion = (orbit_val.get_value() * MOON_ORBIT_RATE) % 1\n            m.move_to(moon_orbit_path.point_from_proportion(proportion))\n        moon.add_updater(orbit)\n\n        self.add(moon)\n\n        # Earth-Moon connection\n        earth_moon_line = Line(earth.get_center(), moon.get_center(), stroke_width=2, color=WHITE)\n\n        def update_line(line):\n            line.put_start_and_end_on(earth.get_center(), moon.get_center())\n        earth_moon_line.add_updater(update_line)\n\n        self.add(earth_moon_line)\n\n        # Animate\n        self.play(orbit_val.set_value, 1, run_time=WAIT_TIME, rate_func=linear)"
    },
    {
        "query": "Can you create an educational animation visualizing a convolutional neural network processing an image from the MNIST dataset, including various layers such as convolutional layers with feature maps, max pooling, and fully connected layers? I'd like to see how the network transforms the image step by step until it reaches the output, complete with forward pass animation and the output shown for about 15 seconds. The visual should be in high definition with a wider aspect ratio.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3}(-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= \\frac{2}{3}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(2)"
    },
    {
        "query": "I want to create an animation sequence where first, a text saying \"Create and Fade Out\" appears at the top of the screen. Then, three squares are simultaneously drawn on the screen: one on the left, one in the center, and one on the right. After a brief pause, all three squares fade away together. Can you show me how to illustrate this using animation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.arrange_in_grid\").shift(UP*2.5)), run_time=0.5)\n            boxes=VGroup(*[Square().scale(0.5) for s in range(0,6)])\n            boxes.arrange(buff=1.0)\n            self.add(*boxes)\n            self.wait(0.5)\n            self.play(boxes.animate.arrange_in_grid(rows=2, buff=0.5))\n            self.remove(*boxes)"
    },
    {
        "query": "How can I make an animation where a pink-colored semi-transparent circle transforms from a square and then fades away using a Python library for creating animations?",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef Division(numerator, denominator):\n    result = numerator // denominator\n    integerPart = int(result * denominator)\n    remainder = numerator - integerPart\n    \n    gp = VGroup(\n        VGroup(\n            MathTex(str(numerator), color=LIGHT_PURPLE_COLOR),\n            VGroup(\n                Line((0, 0, 0), (0, 0.6, 0), color=LIGHT_PURPLE_COLOR),\n                Line((0, 0, 0), (0.6, 0, 0), color=LIGHT_PURPLE_COLOR),\n                MathTex(str(denominator), color=LIGHT_PURPLE_COLOR).shift(0.3 * UP + 0.32 * RIGHT)\n            ) \n        ).arrange(RIGHT),\n        VGroup(\n            MathTex(\"-\", color=SAND_COLOR),\n            MathTex(r\"\\frac{\" + str(integerPart) + \"}{\" + str(remainder) + \"}\", color=SAND_COLOR),\n            MathTex(str(result), color=SAND_COLOR)\n        ).arrange(RIGHT)\n    )\n\n    gp[1].shift(0.5 * LEFT + 0.9 * DOWN)\n    gp[1][0].shift(0.3 * UP)\n    gp[1][1][0][1].scale(2).shift(0.03 * UP)\n    gp[1][2].shift(0.3 * UP + 0.22 * RIGHT)\n\n    return gp\n\nclass FiveDivision(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(5, 1)\n        by_one.scale(1.4)\n        by_two = Division(5, 2)\n        by_two.scale(1.4)\n        by_three = Division(5, 3)\n        by_three.scale(1.4)\n        by_four = Division(5, 4)\n        by_four.scale(1.4)\n        by_five = Division(5, 5)\n        by_five.scale(1.4)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two\n            ).arrange(RIGHT, buff=1),\n            VGroup(\n                by_three,\n                by_four,\n            ).arrange(RIGHT, buff=1),\n            by_five\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_five, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            lag_ratio=0.3,\n            run_time=1.5\n        ))\n        self.wait(2)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)"
    },
    {
        "query": "I would like to create an educational animation where different shapes appear one after another. First, I want a blue circle to grow from the center on the left side of the screen. Then, a green rectangle should fade in next to the blue circle on the right. Lastly, a red ellipse should grow from the top edge and appear next to the rectangle. Please make sure that each shape is clearly distinct and has some space between them. Can you also ensure that the animation pauses for a short while after the shapes appear so that the viewers can see the final result clearly?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral result\n        x_integral_result = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), x_integral_result))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral result\n        y_integral_result = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(x_integral_result, y_integral_result))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}z^2]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(y_integral_result, final_solution))\n        self.wait(1)\n\n        # Conclusion with result\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"The result of the triple integral is:\", font_size=24).to_edge(UP)))\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation with seven colored squares arranged in a row. Each square should have a unique hue ranging from red to violet, and they should all have a semi-transparent look. Initially, I want the squares to appear one by one. After they appear, can they move upwards together? Then, I'd like each square to perform a different action: the first one should rotate 90 degrees, the second should shrink and rotate 180 degrees, the third should enlarge and rotate 180 degrees, the fourth should become more transparent and rotate 90 degrees, the fifth should turn red and rotate 270 degrees, the sixth should change to a yellow color at a higher opacity and rotate 180 degrees, and the seventh should get a blue outline and rotate 45 degrees. Can this sequence end with a brief pause after all the transformations?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Displaying the integral to solve\n        integral_formula = MathTex(r\"\\int_0^1 x^2 \\, dx\")\n        self.play(Write(integral_formula))\n        self.wait(1)\n\n        # Explanation for choosing the method of integration\n        explanation1 = Text(\"Use the power rule for integration\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation of the antiderivative\n        antiderivative_step = MathTex(r\"\\int x^2 \\, dx\", \"=\", r\"\\frac{x^3}{3}\")\n        self.play(Transform(integral_formula, antiderivative_step))\n        self.wait(1)\n\n        # Show limits of integration\n        limits = MathTex(r\"\\Big|_0^1\")\n        self.play(Write(limits.next_to(antiderivative_step, RIGHT)))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Evaluate at the bounds of integration\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"=\", r\"\\frac{1}{3} - 0\", r\"=\", r\"\\frac{1}{3}\")\n        self.play(ReplacementTransform(antiderivative_step, final_solution))\n        self.wait(1)\n\n        # Showing the area under the curve graphically\n        axes = Axes(\n            x_range=[0, 1.2],\n            y_range=[0, 1],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(graph, x_range=(0,1), color=GREEN, opacity=0.3)\n        graph_label = axes.get_graph_label(graph, label=\"y = x^2\")\n\n        # Remove the previous solution and show graph with shaded area\n        self.play(FadeOut(final_solution), FadeOut(explanation1))\n        self.play(Write(axes), Write(graph), Write(graph_label))\n        self.play(FadeIn(area))\n        self.wait(1)\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(graph_label), FadeOut(area))\n        self.wait(1)\n\n        # Show the final answer by itself\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "I would like to create a short educational animation that visually demonstrates a simple linear transformation using geometric shapes. Specifically, I'd like to see three circles arranged in a grid layout, and then I want them to be transformed by a matrix. After they have been transformed, can you also show the axes involved in the transformation? Finally, the animation should conclude by fading out all elements from the screen. Can you make all these steps smooth and visually appealing?",
        "answer": "\\n from manim import *\n\nclass HeatEquationSolution(Scene):\n    def construct(self):\n        # Displaying the PDE\n        pde = MathTex(r\"\\frac{\\partial u}{\\partial t} = \\alpha^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(pde))\n        self.wait(1)\n\n        # Description of the PDE\n        description = Text(\"This represents the Heat Equation.\", font_size=24).to_edge(DOWN)\n        self.play(Write(description))\n        self.wait(2)\n        \n        # Steady-state solution explanation\n        steady_state_explanation = Text(\"For the steady state, \\\\(\\frac{\\partial u}{\\partial t} = 0\\\\)\", font_size=24).next_to(description, UP)\n        self.play(Write(steady_state_explanation))\n        self.wait(2)\n\n        # Steady-state solution\n        steady_state = MathTex(r\"\\alpha^2 \\frac{\\partial^2 u}{\\partial x^2} = 0\")\n        self.play(Transform(pde, steady_state))\n        self.wait(2)\n\n        # General solution for steady state\n        general_solution = MathTex(r\"u(x) = C_1 x + C_2\")\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Boundary conditions explanation\n        boundary_conditions = Text(\"Boundary conditions can give specific values to \\\\(C_1\\\\) and \\\\(C_2\\\\).\", font_size=24)\n        self.play(Transform(description, boundary_conditions))\n        self.wait(2)\n\n        # Clear the scene before concluding\n        self.play(FadeOut(pde), FadeOut(general_solution), FadeOut(steady_state_explanation))\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"Solving the Heat Equation depends on the specific scenario and constraints.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an animated video that introduces some basic shapes with elements of color and movement. It should start with a soothing blue gradient as the background, then a yellow square appears in the center and moves up and to the right. After that, a green circle appears, slightly overlaps with the square, and then positions itself above the square. Following that, both shapes should move together to the left side of the screen. Finally, all elements on the screen should fade out, concluding the video. Can you design this animation for me with smooth transitions and a simple aesthetic that's visually appealing?",
        "answer": "\\n         self.play(Transform(text,Text(\"GrowFromCenter\").shift(UP*2.5)), run_time=0.5)\n        triangle = Triangle()\n        self.play(GrowFromCenter(triangle))\n        self.remove(triangle)"
    },
    {
        "query": "I want an animation where five blue balls fall one after another onto a floor line at the bottom of the screen. The balls should be spaced evenly when they start, and when they fall, they should become semi-transparent blue. The fall should take 2 seconds for each ball, and there should be a short wait between when the balls land and when the next one begins to fall.",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegration(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\, dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explain usage of trigonometric identity\n        identity_explanation = Text(\"Use the trigonometric identity: \"\n                                    \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(identity_explanation))\n        self.wait(2)\n\n        # Display the trigonometric identity\n        trig_identity = MathTex(r\"\\int \\frac{1}{2} \\sin(2x) \\, dx\")\n        self.play(ReplacementTransform(problem, trig_identity))\n        self.wait(2)\n\n        # Explain the integration process\n        integration_explanation = Text(\"Integrate the function\", font_size=24).to_edge(UP)\n        self.play(Transform(identity_explanation, integration_explanation))\n        self.wait(2)\n\n        # Perform the integration\n        integral_result = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(trig_identity, integral_result))\n        self.wait(2)\n\n        # Conclude the integration process\n        self.play(FadeOut(identity_explanation), FadeOut(integral_result))\n        self.wait(1)\n        self.play(Write(MathTex(r\"\\int \\sin(x) \\cos(x) \\, dx = -\\frac{1}{4} \\cos(2x) + C\")))\n        self.wait(3)"
    },
    {
        "query": "I would like an educational video animation that demonstrates a basic division operation in a visually engaging way. The animation should have a portrait orientation, suitable for mobile viewing, and last a few seconds. Start with an image that represents the concept of division followed by the equation \"divided by 3 equals 15\", then show an example where this equation is solved by finding the unknown variable 'b', which is highlighted in a distinct color to emphasize its importance. Finally, present the solution to the division problem side by side with the original equation. The background should be comforting to the eyes, and the text and important elements should be clearly visible and highlighted with different colors to enhance learning. The animations between steps should be smooth and quick to maintain the viewer's attention.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_color\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1)\n            self.add(square)\n            self.play(square.animate.set_color(BLUE))\n            self.remove(square)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates how an AVL tree, which is a type of self-balancing binary search tree, is structured and how elements are inserted into it. The tree should start out empty and then show the insertion of elements one by one, adjusting the balance as it grows. It should be clear, colorful, and engaging, with animated transitions for each insertion, showing also the connections between the parent and child nodes. Ideally, the insertion process would be slowed down enough for viewers to follow along. Can this be done using some sort of animation software?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.fade_to\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(RED)\n            self.add(square)\n            self.play(square.animate.fade_to(GREEN, 0.5))\n            self.remove(square)"
    },
    {
        "query": "Can you create an animation where a square grows to double its size and simultaneously rotates 90 degrees over a duration of 3 seconds?",
        "answer": "\\n from manim import *\n\nclass DampedOscillationScene(Scene):\n    def construct(self):\n        title = Text(\"Damped Oscillation\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Displaying the second order ODE\n        second_order_ode = MathTex(r\"y'' + 2\\beta y' + \\omega^2 y = 0\", font_size=28)\n        self.play(FadeIn(second_order_ode, shift=DOWN))\n        self.wait(2)\n\n        # Explaining beta represents damping\n        damping_explanation = Text(r\"Damping Factor $\\beta$\", font_size=24).to_edge(UP)\n        self.play(Transform(title, damping_explanation))\n        self.wait(2)\n\n        # Displaying the characteristic polynomial\n        characteristic_polynomial = MathTex(r\"r^2 + 2\\beta r + \\omega^2 = 0\", font_size=28)\n        self.play(ReplacementTransform(second_order_ode, characteristic_polynomial))\n        self.wait(2)\n\n        # Describe Nature of Roots\n        root_nature = Text(\"Nature of roots depends on discriminant\", font_size=24).to_edge(UP)\n        self.play(Transform(title, root_nature))\n        self.wait(2)\n\n        # Showing the discriminant\n        discriminant = MathTex(r\"\\Delta = 4\\beta^2 - 4\\omega^2\", font_size=28)\n        self.play(Write(discriminant))\n        self.wait(2)\n\n        # Displaying the types of damping based on discriminant\n        damping_types = VGroup(\n            Text(\"Overdamped: \", font_size=24),\n            MathTex(r\"\\beta > \\omega\").scale(0.8),\n            Text(\"Critically Damped: \", font_size=24).next_to(2*DOWN),\n            MathTex(r\"\\beta = \\omega\").scale(0.8).next_to(2*DOWN),\n            Text(\"Underdamped: \", font_size=24).next_to(4*DOWN),\n            MathTex(r\"\\beta < \\omega\").scale(0.8).next_to(4*DOWN)\n        ).arrange(DOWN, center=False, align_edge=LEFT)\n\n        self.play(FadeOut(discriminant))\n        self.play(Write(damping_types))\n        self.wait(3)\n\n        # Clear the scene to conclude\n        self.play(FadeOut(title), FadeOut(damping_types), FadeOut(characteristic_polynomial))\n        self.wait(1)"
    },
    {
        "query": "Can you show me how to create an animation where a square turns into a circle using a Python library for creating animations?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} [\\frac{1}{2}x^2yz]_{0}^{3} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2} \\cdot 3x^2 \\cdot \\frac{1}{2}y^2z]_{0}^{2} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2} \\cdot 3 \\cdot \\frac{1}{2} \\cdot \\frac{1}{3}z^3]_{0}^{1}\", r\"= \\frac{3}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation with seven circles of different colors arranged in a horizontal line, which then simultaneously fade in over two seconds? After they have all appeared, I'd like them to move upward together over another two seconds. Following that, can they rearrange into a vertical line and become smaller, as if they're moving away, but then return to their original size and horizontal arrangement with a brief pause in the smaller form?",
        "answer": "\\n from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\n\nclass SalesBarGraph(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Quarterly Sales\", color=TEXT_COLOR)\n        bars = BarChart(\n            [10, 6, 9, 5], \n            max_value=10,\n            bar_colors=['#5e81ac', '#bf616a', '#a3be8c', '#ebcb8b'],\n            bar_names=['Q1', 'Q2', 'Q3', 'Q4'],\n            bar_label_scale_val=0.7,\n            label_y_axis=True,\n            y_axis_config={'include_tip': False},\n            x_axis_config={'include_tip': False}\n        )\n        title.to_edge(UP)\n        bars.to_edge(DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(bars, lag_ratio=0.2), run_time=2)\n        self.wait()"
    },
    {
        "query": "Can you create an animation of blue circular waves originating from the center that radiate outwards in a 3D space? I would like to see about five waves expanding from the point of origin until they stop, and the camera should be positioned at an angle to clearly view the waves. The animation should show the waves in motion for a brief period, then pause, and then end after a moment of stillness.",
        "answer": "\\n from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Displaying the sum notation\n        sum_notation = MathTex(r\"S_n = \\sum_{k=0}^{n} ar^k\")\n        self.play(Write(sum_notation))\n        self.wait(1)\n\n        # Explanation for geometric series\n        explanation1 = Text(\"Solve for the sum of a geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the formula\n        series_formula = MathTex(r\"S_n = \\frac{a(1-r^{n+1})}{1-r}\")\n        self.play(ReplacementTransform(sum_notation.copy(), series_formula))\n        self.wait(2)\n\n        # Explanation for convergence\n        explanation2 = Text(\"For |r| < 1, the series converges as n approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Adding the limit\n        series_limit = MathTex(r\"S = \\lim_{n \\to \\infty} S_n = \\frac{a}{1-r}\")\n        self.play(ReplacementTransform(series_formula, series_limit))\n        self.wait(2)\n\n        # Final result for infinite series\n        final_result = MathTex(r\"S = \\frac{a}{1-r}\", \",\", r\"\\text{ for } |r| < 1\")\n        self.play(ReplacementTransform(series_limit, final_result))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "Can you create a simple animation using ManimCE that shows a green square with a semi-transparent background and a blue outline, which also contains the word \"Manim\" in white text at its center?",
        "answer": "\\n from manim import *\n\n\nclass ChemicalStructureScene(Scene):\n    def construct(self):\n        # Display the title\n        title = Tex(\"Chemical Structure Example\").to_edge(UP)\n        self.add(title)\n\n        # Create a grid of oxygen and metal\n        grid = self.create_metal_oxid_grid(3, 3)\n        self.play(FadeIn(grid))\n        self.wait(2)\n\n        # Create electron\n        electron_obj = electron()\n        electron_obj.next_to(grid, DOWN)\n\n        # Create lithium ion near the grid\n        lithium_ion = lithium_ion()\n        lithium_ion.next_to(grid, LEFT)\n\n        # Animate electron path around the grid\n        electron_path = self.get_electron_path(grid)\n        electron_animations = move_along_complex_path(electron_obj, [], electron_path, run_time=5)\n        self.play(*electron_animations)\n        self.wait(2)\n\n        # Arrange some lithium ions at the bottom\n        lithium_row = VGroup(*[lithium_ion.copy() for _ in range(5)])\n        lithium_row.arrange(RIGHT, buff=0.5)\n        lithium_row.next_to(grid, DOWN, buff=1)\n        self.play(FadeIn(lithium_row))\n        self.wait(2)\n\n        # Fade everything out\n        self.play(FadeOut(VGroup(grid, electron_obj, lithium_ion, lithium_row)))\n        self.wait()\n\n    def create_metal_oxid_grid(self, rows, cols):\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                element = oxygen() if (j + i) % 2 == 0 else metal()\n                element.move_to(np.array([2 * i, 2 * j, 0]))\n                list.append(element)\n        grid = VGroup(*list)\n        grid.move_to(ORIGIN)\n        return grid\n\n    def get_electron_path(self, grid):\n        path_points = [point.get_center() for point in grid]\n        # Create a looped path that goes through the points of the grid\n        path_points.append(path_points[0])\n        return path_points\n\n# To display the scene, save this code into a Python file and\n# run it with Manim, or use it within a Jupyter Notebook cell."
    },
    {
        "query": "I would like an animation that shows a ball rolling down an inclined plane. The plane should be visibly tilted and colored blue, while the ball should be red. Can you make the animation reflect the effect of gravity on the ball's acceleration as it rolls down? The whole action should take around 2 seconds, followed by a brief pause before the animation ends.",
        "answer": "\\n from manim import *\n\nMOON_ORBIT_RADIUS = 2\nMOON_RATE = 0.1\nMOON_SIZE = 0.2\nMOON_COLOR = WHITE\nEARTH_SIZE = 0.4\nEARTH_COLOR = BLUE\nSUN_SIZE = 0.8\nSUN_COLOR = YELLOW\nANIMATION_TIME = 50\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Sun\n        sun = Dot(radius=SUN_SIZE, color=SUN_COLOR).move_to(ORIGIN)\n        self.add(sun)\n\n        # Earth orbit (invisible)\n        earth_orbit = Circle(radius=MOON_ORBIT_RADIUS, stroke_opacity=0)\n        self.add(earth_orbit)\n\n        # Earth\n        earth = Dot(radius=EARTH_SIZE, color=EARTH_COLOR)\n        earth.move_to(earth_orbit.point_from_proportion(0))\n        self.add(earth)\n\n        # Moon orbit (invisible, relative to Earth)\n        moon_orbit = Circle(radius=MOON_ORBIT_RADIUS, stroke_opacity=0)\n        moon_orbit.move_to(earth.get_center())\n        self.add(moon_orbit)\n\n        # Moon\n        moon = Dot(radius=MOON_SIZE, color=MOON_COLOR)\n        moon.move_to(moon_orbit.point_from_proportion(0))\n        self.add(moon)\n\n        # Set up the ValueTracker for the moon's orbit\n        moon_phase = ValueTracker(0)\n\n        def update_moon(mob, dt):\n            phase = moon_phase.get_value()\n            new_phase = (phase + MOON_RATE * dt) % 1\n            mob.move_to(moon_orbit.point_from_proportion(new_phase))\n            moon_phase.set_value(new_phase)\n\n        # Add the update function to the moon\n        moon.add_updater(update_moon)\n\n        # Animate the system\n        self.play(moon_phase.set_value, 1, run_time=ANIMATION_TIME, rate_func=linear)\n        self.wait()"
    },
    {
        "query": "\"Can you create an animation that demonstrates the concept of Fourier series by showing the first five terms adding together with circles and then having those circles move to the left side of the screen? After they move, I'd like to see the resulting wave they create being drawn over a short period of time as the circles rotate.\"",
        "answer": "\\n from manim import *\n\nclass FibonacciSpiralScene(Scene):\n    def construct(self):\n        fibonacci_numbers = [0, 1]\n        for _ in range(5):\n            next_number = fibonacci_numbers[-1] + fibonacci_numbers[-2]\n            fibonacci_numbers.append(next_number)\n\n        colors = [YELLOW, GREEN, BLUE, RED, PURPLE, ORANGE]\n\n        arcs = VGroup()\n        start_angle = 0\n        for i, number in enumerate(fibonacci_numbers[2:]):\n            angle = PI / 2\n            arc = Arc(radius=number, angle=angle, start_angle=start_angle, color=colors[i % len(colors)])\n            start_angle += angle\n            arcs.add(arc)\n\n        # Place the Arcs to form the Spiral\n        arcs.arrange_in_grid(rows=1, aligned_edge=UP)\n        self.add(arcs)\n\n        self.play(*[Create(arc) for arc in arcs], run_time=2)\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation where a square on the left side of the screen transforms into a circle and simultaneously moves to the right side over the course of one second, followed by the circle disappearing and then a star growing from its center at the bottom of the screen?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display Fourier Series definition\n        fourier_series_def = MathTex(\n            r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left(a_n \\cos\\left(\\frac{2\\pi n x}{P}\\right) + b_n \\sin\\left(\\frac{2\\pi n x}{P}\\right)\\right)\"\n        )\n        self.play(Write(fourier_series_def))\n        self.wait(2)\n\n        # Explanation about Fourier Series\n        explanation1 = Text(\n            \"A Fourier series is a way to represent a function as a sum of sinusoidal bases.\",\n            font_size=24,\n        ).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(3)\n\n        # Specific example with a square wave\n        explanation2 = Text(\n            \"For example, a square wave can be approximated by a Fourier series.\",\n            font_size=24,\n        ).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Display the square wave approximation equation\n        square_wave_approx = MathTex(\n            r\"f(x) \\approx \\sum_{n=1,3,5}^{\\infty} \\frac{4}{n\\pi} \\sin\\left(\\frac{2\\pi n x}{P}\\right)\"\n        )\n        self.play(ReplacementTransform(fourier_series_def, square_wave_approx))\n        self.wait(2)\n\n        # Explanation for convergence\n        explanation3 = Text(\n            \"The series converges to the actual function as the number of terms increases.\",\n            font_size=24,\n        ).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(square_wave_approx))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that depicts the Sun, Earth, and the Moon where the Sun is stationary at the center, the Earth orbits around the Sun, and the Moon orbits the Earth in a smaller circular path? The Sun should be yellow and the largest, the Earth should be blue and smaller than the Sun, and the Moon should be white and the smallest of all. Make sure the Earth's orbit is not visible, but the Earth itself should be seen clearly revolving. The animation should show the Moon completing its orbit around the Earth at a visible but slow pace, and the whole scene should last approximately 50 seconds.",
        "answer": "\\n from manim import *\n\nclass AtomDiagram(Scene):\n    def construct(self):\n        # Create an oxygen atom\n        oxygen_atom = Circle(radius=0.5, color=BLUE)\n        oxygen_atom.set_fill(BLUE, opacity=0.5)\n        oxygen_text = Text(\"O\", color=WHITE)\n        oxygen = VGroup(oxygen_atom, oxygen_text)\n\n        # Create a hydrogen atom\n        hydrogen_atom = Circle(radius=0.3, color=GREY)\n        hydrogen_atom.set_fill(GREY, opacity=0.5)\n        hydrogen_text = Text(\"H\", color=WHITE)\n        hydrogen = VGroup(hydrogen_atom, hydrogen_text)\n\n        # Position the hydrogen atoms around the oxygen\n        hydrogen.move_to(oxygen.get_edge_center(UP) + UP * 0.4)\n        hydrogen_copy1 = hydrogen.copy().shift(LEFT * 0.8 + DOWN * 0.4)\n        hydrogen_copy2 = hydrogen.copy().shift(RIGHT * 0.8 + DOWN * 0.4)\n\n        # Connect the atoms with lines to indicate bonds\n        bond1 = Line(hydrogen.get_center(), oxygen.get_edge_center(UP))\n        bond2 = Line(hydrogen_copy1.get_center(), oxygen.get_edge_center(DL))\n        bond3 = Line(hydrogen_copy2.get_center(), oxygen.get_edge_center(DR))\n\n        # Create a water molecule group\n        water_molecule = VGroup(oxygen, hydrogen, hydrogen_copy1, hydrogen_copy2, bond1, bond2, bond3)\n\n        # Display the water molecule\n        self.play(FadeIn(water_molecule))\n        self.wait(2)\n        self.play(FadeOut(water_molecule))"
    },
    {
        "query": "Could you create an animation that starts by drawing a blue square rotated by 45 degrees and then morphs it into a circle over time?",
        "answer": "\\n from manim import *\n\nclass TorusKnot(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        torus_knot = ParametricFunction(\n            lambda t: np.array([\n                (2 + np.cos(3 * t)) * np.cos(2 * t),\n                (2 + np.cos(3 * t)) * np.sin(2 * t),\n                np.sin(3 * t)\n            ]),\n            t_range=np.array([0, 2*PI]),\n            color=BLUE\n        )\n        self.play(Create(torus_knot))\n        self.begin_ambient_camera_rotation(rate=0.5)  # Start rotating the camera\n        self.wait(6)"
    },
    {
        "query": "I would like to create an educational animation that illustrates the concept of projectile motion. The animation should begin by introducing the formula for velocity as a function of time during projectile motion in a clear way. It should then show an object being launched at an initial velocity, following a trajectory that represents the projectile motion path, while the camera frame is focused on the action. The object's initial velocity vector should be visible and properly labeled. At the peak of the trajectory, I want a series of red sparks to explode outward in all directions as if the object is a firework. Can you create a dynamic and visually appealing animation that incorporates these features and helps to explain projectile motion?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series equation\n        fourier_eq = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left( a_n \\cos{\\left(\\frac{2\\pi nx}{P}\\right)} + b_n \\sin{\\left(\\frac{2\\pi nx}{P}\\right)} \\right)\")\n        self.play(Write(fourier_eq))\n        self.wait(2)\n\n        # Explanation of Fourier series\n        explanation1 = Text(\"Fourier series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Displaying a harmonic term\n        harmonic_term = MathTex(r\"a_n \\cos{\\left(\\frac{2\\pi nx}{P}\\right)} + b_n \\sin{\\left(\\frac{2\\pi nx}{P}\\right)}\")\n        self.play(Transform(fourier_eq, harmonic_term))\n        self.wait(2)\n\n        # Explanation of harmonics\n        explanation2 = Text(\"Each term represents a harmonic at a multiple of the fundamental frequency\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Example with a finite number of terms\n        partial_sum = MathTex(r\"f_N(x) = a_0 + \\sum_{n=1}^{N} \\left( a_n \\cos{\\left(\\frac{2\\pi nx}{P}\\right)} + b_n \\sin{\\left(\\frac{2\\pi nx}{P}\\right)} \\right)\")\n        self.play(Transform(fourier_eq, partial_sum))\n        self.wait(2)\n\n        # Explanation of practical computation with partial sums\n        explanation3 = Text(\"In practice, we use partial sums to approximate the function\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude with the finite approximation\n        self.clear()\n        self.wait(1)\n        self.play(Write(partial_sum))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated educational video clip that visually demonstrates a basic quadratic function graph, y = x^2, with axes ranging from -5 to 5 on both x and y axes? In the animation, I'd like the axes to be colored blue, the curve of the function to be green, and a red dot to appear at the origin point, which is labeled \"(0,0)\" in orange color. Additionally, next to the red dot, can you place a text \"Start\" in red color that appears after the dot, and a label for the curve itself, clearly stating the function \"y = x^2\"? The introduction of the axes, curve, and the dot should be animated, along with the text labelings that follow.",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identities\n        explanation1 = Text(\"Use the trigonometric identity: \"\n                            \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Rewriting the integral\n        trig_identity = MathTex(r\"\\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(Transform(problem, trig_identity))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that shows a blue dot tracing out an epitrochoid curve, which is the path traced by a point on a smaller circle as it rolls around the outside of a larger circle. The animation should include the dot starting at the beginning of the path and following it at a constant speed until the figure is complete. Can you create an animation with a larger circle of radius 3, a smaller circle of radius 1, and with the tracing point being 2 units away from the center of the smaller circle? The dot and the path it follows should both be blue, and the animation should last for 8 seconds, followed by a 1-second pause.",
        "answer": "\\n from manim import *\n\nclass MatrixMultiplication(Scene):\n    def construct(self):\n        matrix1 = Matrix([[1, 2], [3, 4]], left_bracket=\"(\", right_bracket=\")\")\n        matrix2 = Matrix([[2, 0], [1, 3]], left_bracket=\"(\", right_bracket=\")\")\n\n        self.play(Write(matrix1), Write(matrix2))\n        self.wait(1)\n\n        description = Tex(\"To multiply two matrices, we take the dot product\\\\\\\\\",\n                          \"of rows from the first matrix with columns of the second.\")\n        description.to_edge(UP)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Highlighting rows and columns\n        row_highlight = SurroundingRectangle(matrix1.get_rows()[0], color=GREEN)\n        col_highlight = SurroundingRectangle(matrix2.get_columns()[0], color=PINK)\n        self.play(Create(row_highlight), Create(col_highlight))\n        self.wait(2)\n\n        # Showing the multiplication process\n        result_matrix = Matrix([[2, 6], [6, 12]], left_bracket=\"(\", right_bracket=\")\")\n        result_matrix.move_to(RIGHT * 3)\n        self.play(Transform(matrix1, result_matrix))\n        self.wait(2)"
    },
    {
        "query": "I'd like to see an animation that shows how a circle and a square can be represented using Fourier series with their respective sine waves. For each shape, begin by drawing the actual shape, and then gradually build it up with sine waves, adding one term at a time up to 10 terms. Please show each step of the series for a brief moment. Also, I would like the background color of the animations to be a light grey. For the circle\u2019s Fourier series, use pure red sine waves, and for the square\u2019s Fourier series, make sure that only the odd harmonics are used to accurately represent the typical square wave and that the background color for both shapes is consistent.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Solution form\n        explanation2 = Text(\"The solution can be written as u(x, t) = f(x-ct) + g(x+ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the form of the solution\n        solution_form = MathTex(r\"u(x, t) = f(x-ct) + g(x+ct)\")\n        self.play(Transform(wave_eq, solution_form))\n        self.wait(1)\n\n        # Adding details about the functions\n        explanation3 = Text(\"Where f and g are arbitrary functions determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Show d'Alembert's Formula\n        dalemberts_formula = MathTex(r\"u(x, t) = \\frac{1}{2}[f(x-ct) + f(x+ct)] + \\frac{1}{2c}\\int_{x-ct}^{x+ct} g(s) ds\")\n        self.play(Transform(wave_eq, dalemberts_formula))\n        self.wait(1)\n\n        # Explain d'Alembert's Formula\n        explanation4 = Text(\"This is known as d'Alembert's Formula.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(wave_eq), FadeOut(explanation1))\n        self.wait(1)\n        conclude_message = Text(\"The wave equation models vibrational phenomena.\", font_size=24)\n        self.play(FadeIn(conclude_message))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animation that first shows a square at the top of the screen with a colorful boundary that cycles through yellow, purple, and teal, and then fades the square into view? After a short pause, can you transform the square into a triangle at the same position, and then finally remove both the shape and its colorful boundary from the screen?",
        "answer": "\\n from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nclass NoGradientBarChart(BarChart):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def _update_colors(self):\n        for i in range(len(self.bar_colors)):\n            self.bars[i].set(color=self.bar_colors[i])\n\ndef add_to_back(self, *mobjects):\n    all_mobjects = [*self.mobjects]\n\n    self.remove(*self.mobjects)\n    self.add(*mobjects, *all_mobjects)\n\nclass GraphOne(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        table = Table(\n            [\n                [\"Pablo\", \"Banana\"],\n                [\"Gabriela\", \"Morango\"],\n                [\"Bianca\", \"Laranja\"],\n                [\"Murilo\", \"Morango\"],\n                [\"Heitor\", \"Banana\"],\n                [\"Isabela\", \"Banana\"],\n            ],\n            col_labels=[Text(\"Nome\"), Text(\"Fruta Favorita\")],\n            include_outer_lines=True\n        )\n        table.get_vertical_lines().set(color=BLACK)\n        table.get_horizontal_lines().set(color=BLACK)\n        table.get_entries().set(color=BLACK)\n        table.scale(0.5)\n        chart = BarChart(\n            [0, 0, 0],\n            y_range=[0, 3, 1],\n            x_length=6,\n            y_length=4,\n            axis_config={\"color\": BLACK, \"include_ticks\": False},\n            bar_colors=[LIGHT_YELLOW_COLOR, LIGHT_ORANGE_COLOR, LIGHT_RED_COLOR],\n            bar_fill_opacity=1,\n            bar_names=[\"Banana\", \"Laranja\", \"Morango\"]\n        )\n        chart.x_axis.set(color=BLACK)\n        chart.y_axis.set(color=BACKGROUND_COLOR)\n        chart[2][0][1].set(color=BLACK)\n        Group(table, chart).arrange(DOWN, buff=2)\n        x_label = Tex(\"Frutas favoritas\", color=BLACK)\n        x_label.scale(0.7)\n        x_label.next_to(chart, DOWN)\n        x_label.shift(0.2 * RIGHT)\n        y_label = Tex(\"Quantidade de pessoas\", color=BLACK)\n        y_label.scale(0.7)\n        y_label.rotate(PI/2)\n        y_label.next_to(chart, LEFT)\n        y_label.shift(0.2 * UP)\n        table.shift(9 * RIGHT)\n        lines = VGroup(\n            Line(chart.coords_to_point(0, 1, 0), chart.coords_to_point(3, 1, 0), color=BLACK, stroke_width=1),\n            Line(chart.coords_to_point(0, 2, 0), chart.coords_to_point(3, 2, 0), color=BLACK, stroke_width=1),\n            Line(chart.coords_to_point(0, 3, 0), chart.coords_to_point(3, 3, 0), color=BLACK, stroke_width=1)\n        )\n\n        self.play(table.animate.shift(9 * LEFT), run_time=0.7)\n        self.wait(1)\n        self.play(\n            FadeIn(lines),\n            FadeIn(chart), \n            FadeIn(x_label), \n            FadeIn(y_label), \n            run_time=0.4\n        )\n        self.wait(1)\n\n        banana_cells = Group(\n            table.get_highlighted_cell((2, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((2, 2), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((6, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((6, 2), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((7, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((7, 2), color=LIGHT_YELLOW_COLOR)\n        )\n        add_to_back(self, banana_cells)\n\n        self.play(FadeIn(banana_cells), run_time=0.5)\n        self.play(chart.animate.change_bar_values([3, 0, 0]), run_time=1.3)\n        self.play(FadeOut(banana_cells), run_time=0.5)\n\n        orange_cells = Group(\n            table.get_highlighted_cell((4, 1), color=LIGHT_ORANGE_COLOR),\n            table.get_highlighted_cell((4, 2), color=LIGHT_ORANGE_COLOR)\n        )\n        add_to_back(self, orange_cells)\n\n        self.play(FadeIn(orange_cells), run_time=0.5)\n        self.play(chart.animate.change_bar_values([3, 1, 0]), run_time=0.7)\n        self.play(FadeOut(orange_cells), run_time=0.5)\n\n        strawberry_cells = Group(\n            table.get_highlighted_cell((3, 1), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((3, 2), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((5, 1), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((5, 2), color=LIGHT_RED_COLOR)\n        )\n        add_to_back(self, strawberry_cells)\n\n        self.play(FadeIn(strawberry_cells), run_time=0.5)\n        self.play(chart.animate.change_bar_values([3, 1, 2]), run_time=1)\n        self.play(FadeOut(strawberry_cells), run_time=0.5)\n\n        self.wait(2)\n\n        self.play(\n            FadeOut(lines),\n            FadeOut(chart), \n            FadeOut(x_label), \n            FadeOut(y_label), \n            run_time=0.4\n        )\n        self.remove(*self.mobjects)"
    },
    {
        "query": "I'd like to create an educational video for children where they can learn to count using fun, animated gummy bear characters. Can you make a vibrant, eye-catching animation of twelve colorful gummy bears that appear one by one on the screen? They should be arranged in an organized grid and come with cheerful background music. Additionally, it would be great if the video starts with a bright and inviting title that says \"Let's Count Gummy Bears!\" and ends with a text stating \"Total: 12 Bears\" after all the gummy bears have appeared. Make sure the colors are soft and appealing to a young audience, and include a smooth transition for all elements to fade out at the end of the video.",
        "answer": "\\n from manim import *\n\nclass SpringMassScene(Scene):\n    def construct(self):\n        # Display the differential equation of motion for a spring-mass system\n        spring_mass_eq = MathTex(r\"m\\ddot{x} + c\\dot{x} + kx = 0\")\n        self.play(Write(spring_mass_eq))\n        self.wait(1)\n\n        # Explanation for the physical system\n        system_explanation = Text(\"Spring-mass-damper system\", font_size=24).to_edge(UP)\n        self.play(Write(system_explanation))\n        self.wait(2)\n\n        # Transform the equation to the standard form\n        standard_form_eq = MathTex(r\"\\ddot{x} + 2\\zeta\\omega_n\\dot{x} + \\omega_n^2x = 0\")\n        self.play(ReplacementTransform(spring_mass_eq, standard_form_eq))\n        self.wait(1)\n\n        # Explanation for standard form equation\n        standard_form_explanation = Text(\"Standard form of the equation\", font_size=24).to_edge(UP)\n        self.play(Transform(system_explanation, standard_form_explanation))\n        self.wait(2)\n\n        # Show the characteristic equation\n        characteristic_eq = MathTex(r\"r^2 + 2\\zeta\\omega_n r + \\omega_n^2 = 0\")\n        self.play(ReplacementTransform(standard_form_eq, characteristic_eq))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        char_eq_explanation = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(system_explanation, char_eq_explanation))\n        self.wait(2)\n\n        # Present the solution based on damping ratio\n        underdamped_solution = MathTex(r\"x(t) = e^{-\\zeta\\omega_n t}(A\\cos(\\omega_d t) + B\\sin(\\omega_d t))\")\n        self.play(Write(underdamped_solution))\n        self.wait(1)\n\n        # Explanation for underdamped solution\n        underdamped_explanation = Text(\"Underdamped solution for $\\\\zeta < 1$\", font_size=24).to_edge(UP)\n        self.play(Transform(system_explanation, underdamped_explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion and final state of the system\n        final_state = Text(\"Free vibration of a spring-mass-damper system\", font_size=24)\n        self.play(Write(final_state))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that shows four circles in a row, each labeled with '1x', '2x', '3x', and '4x' respectively? The circles should be different shades of aquamarine and should gradually expand to 1, 2, 3, and 4 times their original sizes. Additionally, I want a horizontal line below the circles with a dot that moves from one end to the other during the time it takes for the circles to finish expanding. The animation should be smooth and the expansion of the circles and movement of the dot should happen simultaneously over a duration of 2 seconds.",
        "answer": "\\n from manim import *\n\nclass GeometricSumExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"S_n = \\sum_{k=0}^{n} ar^k\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the geometric sum formula\n        explanation1 = Text(\"Use the geometric sum formula\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the sum formula\n        sum_formula = MathTex(r\"S_n = \\frac{a(1-r^{n+1})}{1-r}\")\n        self.play(ReplacementTransform(problem.copy(), sum_formula))\n        self.wait(1)\n\n        # Explanation for the specific case when |r| < 1\n        explanation2 = Text(\"For |r| < 1, as n approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(1)\n\n        # Infinite sum limit\n        infinite_sum = MathTex(r\"S = \\lim_{n \\to \\infty} \\frac{a(1-r^{n+1})}{1-r}\")\n        self.play(ReplacementTransform(sum_formula, infinite_sum))\n        self.wait(1)\n\n        # Evaluating the infinite sum\n        infinite_sum_evaluated = MathTex(r\"S = \\frac{a}{1-r}\")\n        self.play(ReplacementTransform(infinite_sum, infinite_sum_evaluated))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(infinite_sum_evaluated))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation to visually compare different easing functions? Start by showing a grid of labeled squares, each representing a different easing function like linear, ease in quad, ease out quad, and others. Display all these squares in a sequence of colors from blue to red. I'd also like to see a horizontal line below this grid with a red dot sliding from left to right, synchronized with the animation of the squares moving downwards, each animated according to their respective easing function. The squares should move one after another slightly overlapped in time, and the red dot should move smoothly across the line for the duration of the entire animation sequence.",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Presenting the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for Integration technique\n        explanation1 = Text(\"Apply the anti-derivative of exponential\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integral process\n        integral_step = MathTex(r\"\\frac{1}{2} \\int e^{2x} \\cdot 2 \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), integral_step))\n        self.wait(1)\n\n        # Further explanation for integration\n        explanation2 = Text(\"Integrate by recognizing the pattern\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # The final answer\n        final_answer = MathTex(r\"= \\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(integral_step, final_answer))\n        self.wait(1)\n\n        # Clean the scene and display the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational video animation where a virtual chalkboard displays three different mathematical equations, one after the other, with a visual indication next to each whether it is correct or incorrect? The first equation should be \"2x + 1 = 5\" marked as correct, the second \"4y - 2 = 7\" marked as incorrect, and the third \"3a^2 - 9 = 0\" marked as correct. Each equation should appear with a visually distinctive check mark for correct and an X mark for incorrect, and please use a gentle, soothing background color for the chalkboard with the symbols and text in contrasting colors suitable for educational content.",
        "answer": "\\n from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create a grid of alternating electrons and oxygen atoms\n        grid = self.create_alternating_grid(rows=5, cols=5)\n        \n        # Position the grid\n        grid.move_to(ORIGIN)\n        \n        # Animate the creation of the grid\n        self.play(AnimationGroup(*[FadeIn(mobj, shift=UP*0.1) for mobj in grid], lag_ratio=0.1))\n        self.wait()\n\n        # Animate electrons moving in a pattern on the grid\n        path_indices = [0, 5, 6, 11, 16, 17, 22, 23, 18, 13, 8, 7, 2, 3, 4, 9, 14, 19, 24, 20, 15, 10]\n        electrons = self.get_electrons_on_grid(grid)\n        # Define the complex path for our electron to move along\n        points = [grid[i].get_center() for i in path_indices]\n        \n        # Create the move animations for the electron\n        move_animations = move_along_complex_path(electrons, stop_indices=[], points=points, run_time=2)\n        self.play(AnimationGroup(*move_animations, lag_ratio=0))\n        self.wait()\n\n    def create_alternating_grid(self, rows, cols):\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    grid.add(electron().next_to(ORIGIN, RIGHT, buff=0.6).shift(RIGHT*j*0.6+UP*i*0.6))\n                else:\n                    grid.add(oxygen().next_to(ORIGIN, RIGHT, buff=0.6).shift(RIGHT*j*0.6+UP*i*0.6))\n        return grid\n    \n    def get_electrons_on_grid(self, grid):\n        electrons = VGroup()\n        for atom in grid:\n            if \"e$^-$\" in atom.submobjects[1].get_tex_string():\n                electrons.add(atom)\n        return electrons\n\n# Additional functions used within the code may be identical to the functions provided by the user, e.g., 'electron()' and 'oxygen()' functions."
    },
    {
        "query": "Could you create an animation that visualizes the training process of a simple neural network with three layers, where the first layer has 4 neurons, the second layer has 7 neurons, and the third layer has 2 neurons? The neural network should be centered on the screen and the animation should clearly show some kind of training activity or process happening. Also, please ensure the animation ends with a pause so we can see the final state of the network.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Define the problem of calculating a definite integral\n        problem = MathTex(r\"\\int_2^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of the method to evaluate the definite integral\n        explanation1 = Text(\"Evaluate the integral using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the indefinite integral using the power rule\n        indefinite_integral = MathTex(r\"\\int x^2 \\,dx = \\frac{x^{3}}{3} + C\")\n        self.play(Write(indefinite_integral))\n        self.wait(2)\n\n        # Evaluating at the bounds\n        evaluation = MathTex(r\"\\bigg[ \\frac{x^{3}}{3} \\bigg]_2^3\")\n        self.play(ReplacementTransform(problem.copy(), evaluation))\n        self.wait(1)\n\n        # Explanation for the evaluation step\n        explanation2 = Text(\"Substitute the bounds and subtract:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Performing the subtraction\n        subtraction = MathTex(r\"\\bigg( \\frac{3^{3}}{3} \\bigg) - \\bigg( \\frac{2^{3}}{3} \\bigg)\")\n        self.play(ReplacementTransform(evaluation, subtraction))\n        self.wait(2)\n\n        # Final calculation\n        final_calculation = MathTex(r\"= \\frac{27}{3} - \\frac{8}{3}\")\n        self.play(Transform(subtraction, final_calculation))\n        self.wait(1)\n\n        solution = MathTex(r\"= 19 / 3\")\n        self.play(Transform(final_calculation, solution))\n        self.wait(1)\n\n        # Clear scene and display the solution\n        self.clear()\n        self.wait(1)\n\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the concept of derivatives using a simple function, such as f(x) = x^2, and show the tangent line to the curve at a specific point, say x=1, with an accompanying explanation?",
        "answer": "\\n from manim import *\n\nclass SampleScene(Scene):\n    def construct(self):\n        initial_text = Text(\"Hello!\").to_edge(UP)\n        self.add(initial_text)\n        self.wait(1)\n        self.play(Transform(initial_text, Text(\"Goodbye!\").to_edge(UP)), run_time=1)\n        warning_text = Text(\"Watch out!\").set_color(RED).next_to(initial_text, DOWN)\n        self.play(Write(warning_text))\n        self.play(Circumscribe(warning_text, color=RED, run_time=1.5))\n        self.wait(1)\n        self.play(FadeOut(initial_text), FadeOut(warning_text))"
    },
    {
        "query": "I'd like to create an educational video using animations and I need a scene where a title saying \"Writing Text Animation\" appears at the top. Below that, I want a paragraph that reads \"Manim makes elaborate animations with text quite straightforward to program!\" to be written onto the screen. Waiting for a short while, I then want the paragraph to be erased in an animated way. Lastly, I'd like the title to transform into a new text that says \"And just as easy to erase!\" Keeping the animations simple and clear would be great. How can I achieve this with an animation tool that is suitable for a programming beginner?",
        "answer": "\\n from manim import *\nimport numpy as np\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\nclass MnistNeuralNetworkScene(Scene):\n    def construct(self):\n        # Load image and convert it to numpy array\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.png\")  # To use another image file\n        numpy_image = np.array(image.convert(\"L\"))  # Convert image to grayscale\n\n        # Create a neural network\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=1.5),\n            MaxPooling2DLayer(pool_size=2, pad=True),\n            FeedForwardLayer(6),\n            FeedForwardLayer(10),\n        ], layer_spacing=0.3)\n\n        # Add the neural network to the scene\n        self.add(nn)\n\n        # Animate the forward pass of nn\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass, run_time=10)\n\n        # Wait a moment before closing the scene\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that illustrates a simple perceptron with three input neurons and one output neuron, including the connections between them, and label the input neurons as x1, x2, x3 and the output neuron as y? Also, please use individual animations to show the formation of the neuron connections followed by the appearance of the neurons themselves.",
        "answer": "\\n class CriticalPoints(Scene):\n    def construct(self):\n        c = Circle(color=GREEN, fill_opacity=0.5)\n        self.add(c)\n\n        for d in [(0,0,0), UP, UR, RIGHT, DR, DOWN, DL, LEFT, UL]:\n            self.add(Cross(scale_factor=0.2).move_to(c.get_critical_point(d)))\n\n        s = Square(color=RED, fill_opacity=0.5)\n        s.move_to([1,0,0], aligned_edge=LEFT)\n        self.add(s)"
    },
    {
        "query": "Please create an animation that starts with the word \"Hello!\" appearing at the top of the screen. After a brief pause, I want the word to change to \"Goodbye!\" in the same location. Then, directly below the \"Goodbye!\" text, display the phrase \"Watch out!\" in red color, and draw a red circle around this warning text to emphasize it. Once that's done, make both pieces of text fade away from the screen.",
        "answer": "\\n class NewYearPost(MovingCameraScene):\n    def construct(self):\n        self.camera_frame.move_to(3 * UP)\n        text = MathTex(\n            r\" s(t) &=\\left( \\begin{array}{c} \"\n            r\"x(t)\"\n            r\"\\\\ y(t)\"\n            r\"\\end{array} \\right)\"\n            r\"\\\\ &=\\left( \\begin{array}{c} \"\n            r\"v_0 t \\cos(\\theta)\"\n            r\"\\\\ v_0 t \\sin(\\theta) - \\frac{1}{2}gt^2\"\n            r\"\\end{array} \\right)\"\n        )\n\n        text.to_corner(DL).shift(3 * UP)\n\n        def func(t):\n            v0 = 10\n            theta = 0.85 * PI / 2\n            g = 9.81\n            return np.array(\n                (v0 * t * np.cos(theta), v0 * t * np.sin(theta) - 0.5 * g * t ** 2, 0)\n            )\n\n        rocket = ParametricFunction(func, t_max=1, fill_opacity=0).set_color(WHITE)\n        dot = Dot().set_color(WHITE)\n        dot2 = Dot().set_color(WHITE).move_to(rocket.get_end())\n        self.add(dot)\n        self.play(Write(rocket), rate_func=linear)\n        self.add(dot2)\n        all_sparcs = VGroup()\n        for theta in np.random.uniform(0, TAU, 90):\n\n            def func2(t):\n                v0 = 10\n                g = 9.81\n                return np.array(\n                    (\n                        v0 * t * np.cos(theta) + dot2.get_x(),\n                        v0 * t * np.sin(theta) - 0.5 * g * t ** 2 + dot2.get_y(),\n                        0,\n                    )\n                )\n\n            sparcle = ParametricFunction(\n                func2, t_min=0.04, t_max=0.3, fill_opacity=0\n            ).set_color(ORANGE)\n            all_sparcs.add((sparcle))\n        self.play(\n            *[Write(x) for x in all_sparcs.submobjects], run_time=0.8, rate_func=linear\n        )\n        dots = [\n            Dot(point=[x, y, 0])\n            for x, y in zip(np.random.uniform(-4, 4, 10), np.random.uniform(0, 6, 10))\n        ]\n        self.play(*[Flash(dot) for dot in dots], lag_ratio=0.2)\n        dots = [\n            Dot(point=[x, y, 0])\n            for x, y in zip(np.random.uniform(-4, 4, 10), np.random.uniform(0, 6, 10))\n        ]\n        self.play(FadeIn(text), *[Flash(dot) for dot in dots], lag_ratio=0.2)\n        dots = [\n            Dot(point=[x, y, 0])\n            for x, y in zip(np.random.uniform(-4, 4, 30), np.random.uniform(0, 6, 30))\n        ]\n        self.play(*[Flash(dot) for dot in dots], lag_ratio=0.2)\n\n        banner = ManimBanner(dark_theme=True).scale(0.3).to_corner(DR)\n        self.play(FadeIn(banner.shift(3 * UP)))\n        self.play(banner.expand())\n        self.play(FadeOut(banner))"
    },
    {
        "query": "Can you create an animated visualization of inserting elements into an AVL tree to maintain its balance, with pauses between each insertion to clearly see the tree structure?",
        "answer": "\\n from manim import *\n\nclass TaylorSeriesApproximation(Scene):\n    def construct(self):\n        # Display the function to be approximated\n        function_tex = MathTex(r\"f(x) = e^x\").to_edge(UP)\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Show the Taylor series approximation text\n        approx_text = Tex(\n            \"Taylor series approximation of \", r\"$f(x)$\", r\" up to nth term:\",\n            font_size=24\n        ).next_to(function_tex, DOWN)\n        self.play(Write(approx_text))\n        self.wait(2)\n\n        # Taylor series up to 4 terms\n        taylor = MathTex(\n            r\"f(x) \\approx 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!}\"\n        )\n        self.play(Write(taylor))\n        self.wait(2)\n\n        # Show the Taylor polynomial of degree 4\n        taylor_polynomial = MathTex(\n            r\"P_4(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!}\"\n        ).next_to(taylor, DOWN)\n        self.play(Transform(taylor, taylor_polynomial))\n        self.wait(2)\n\n        # Graph f(x) and P_4(x)\n        graph_group = VGroup()\n        axes = Axes(\n            x_range=[-2, 2],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        ).to_edge(DOWN)\n\n        exp_function = axes.plot(lambda x: np.exp(x), color=GREEN)\n        taylor_graph = axes.plot(lambda x: 1 + x + x**2/2 + x**3/6 + x**4/24, color=YELLOW)\n\n        original_graph_label = axes.get_graph_label(exp_function, label='f(x)=e^x')\n        taylor_graph_label = axes.get_graph_label(taylor_graph, label='P_4(x)', x_val=2, direction=UP)\n\n        graph_group.add(axes, exp_function, taylor_graph, original_graph_label, taylor_graph_label)\n        self.play(FadeIn(graph_group))\n        self.wait(2)\n\n        # Clear the scene and present only the graphs\n        self.play(FadeOut(taylor_polynomial), FadeOut(approx_text), FadeOut(function_tex))\n        self.wait(3)\n\n        # Highlight the difference in a certain interval\n        interval_highlight = axes.get_riemann_rectangles(exp_function, x_range=[-1, 1], dx=0.1)\n        self.play(ShowCreation(interval_highlight))\n        self.wait(3)"
    },
    {
        "query": "Please create an animation that shows the construction of a Fibonacci spiral using arcs with different colors. Start with the first two Fibonacci numbers and calculate the next five numbers in the sequence. Then draw each corresponding segment of the spiral as an arc, with each arc being a quarter of a circle. The arcs should be colored consecutively from a set of six colors: yellow, green, blue, red, purple, and orange. Arrange the arcs in a way that they form the spiral, and animate their creation sequentially with a total run time of 2 seconds, followed by a 1-second pause after the last arc is drawn.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r dA\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Express dA in polar coordinates as r dr d\u03b8\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral with polar coordinates\n        polar_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{1} r^2 dr d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), polar_integral))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation2 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Inner integral after r integration\n        r_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(polar_integral, r_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Now integrate with respect to \u03b8\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} d\\theta\")\n        self.play(ReplacementTransform(r_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ \\frac{1}{3}\\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(3)\n\n        # Explanation for final answer\n        explanation4 = Text(\"The final answer is \u03c0/3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation using ManimCE where the Earth is represented by a blue dot and the Moon by a grey one, showing how the Moon orbits around the Earth? The animation should illustrate the Moon's orbit with a faded white circle and include a line that connects the Earth and the Moon, updating its position as the Moon orbits. The radius of the Earth should be smaller than that of the orbit path, the diameter of the Moon should be even smaller, and these sizes should be to scale according to real astronomical data. The Moon should start at a certain point in its orbit and move around the Earth at a constant rate, completing a full orbit within a set duration for the entire animation. Can the camera also focus in on these objects, making the movement easier to view?",
        "answer": "\\n from manim import *\n\nclass SquareWithText(Scene):\n    def construct(self):\n        square = Square(side_length=3, fill_color=GREEN, fill_opacity=0.5, color=BLUE)\n        text = Text(\"Manim\", color=WHITE, font_size=24)\n        square_text_group = VGroup(square, text)\n        self.play(Create(square_text_group))\n        self.wait()"
    },
    {
        "query": "I would like to create an animation where a text labeled \"Original Text\" appears at the top of the screen and then transforms into another text labeled \"Transformed Text\" which moves to the bottom of the screen. This should take place over the duration of one second. Following the text transformation, I want a square to grow out of the center point of the screen and then disappear. How can I make this animation using ManimCE?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series equation\n        fourier_eq = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(fourier_eq))\n        self.wait(1)\n\n        # Display title\n        title = Text(\"Fourier Series\", font_size=36)\n        self.play(Write(title))\n        title.to_edge(UP)\n        self.wait(1)\n\n        # Explanation of periodic functions\n        periodic_explanation = Text(\"Fourier series represent periodic functions.\", font_size=24)\n        self.play(Write(periodic_explanation))\n        self.wait(2)\n\n        # Transition to coefficients explanation\n        coefficients_explanation = Text(\"Coefficients are calculated based on the function's periodicity.\", font_size=24)\n        self.play(Transform(periodic_explanation, coefficients_explanation))\n        self.wait(2)\n\n        # Display an example of calculating coefficients\n        coefficients_calculation = MathTex(r\"a_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\cos(nx) \\, dx\", font_size=24)\n        coefficients_calculation.to_edge(DOWN)\n        self.play(Write(coefficients_calculation))\n        self.wait(2)\n\n        # Show a square wave approximation\n        square_wave = Text(\"Square wave approximation with 3 terms\", font_size=24).to_edge(UP)\n        self.play(Transform(periodic_explanation, square_wave))\n        square_wave_eq = MathTex(r\"f(x) \\approx a_0 + a_1 \\cos(x) + b_1 \\sin(x) + a_2 \\cos(2x) + b_2 \\sin(2x) + a_3 \\cos(3x) + b_3 \\sin(3x)\")\n        self.play(Transform(fourier_eq, square_wave_eq))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(square_wave), FadeOut(fourier_eq), FadeOut(coefficients_calculation))\n        conclusion = Text(\"Fourier series are a powerful tool in signal processing and analysis.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animation featuring a sequence of concentric circles that change in color from red to blue, with each circle having slightly less stroke width than the previous one. The circles should be arranged in a horizontal line. Once they appear, I want them to move upwards and then scale down to half of their original size. The entire sequence should be smooth and aesthetically pleasing. Can this be done?",
        "answer": "\\n from manim import *\n\nclass MyScene(Scene):\n    def construct(self):\n        grid = self.create_grid(4, 5)\n        self.play(Create(grid))\n        self.wait(1)\n\n        moving_electron = electron()\n        self.play(Create(moving_electron))\n        self.play(*self.electron_movement(moving_electron, 3))\n        self.wait(2)\n\n    def electron_movement(self, electron, total_movements):\n        movements = []\n        for _ in range(total_movements):\n            movements.append(electron.animate.shift(RIGHT * 0.5))\n            movements.append(electron.animate.shift(UP * 0.5))\n        return movements\n    \n    def create_grid(self, rows, cols):\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    list.append(negative().shift(RIGHT*j + UP*i))\n                else:\n                    list.append(positive().shift(RIGHT*j + UP*i))\n        return VGroup(*list)"
    },
    {
        "query": "I would like to create an educational animation that showcases multiple sinusoidal waves with varying frequencies. Each wave should have the same amplitude, be arranged vertically with some space between them, and they should all begin animating their oscillations simultaneously. The sequence should last for a few seconds, so viewers can observe the differences in frequencies between the waves. Can you tell me how to construct this using an animation tool or software?",
        "answer": "\\n from manim import *\nimport numpy as np\nfrom PIL import Image\nfrom manim_ml.neural_network.layers import ImageLayer, Convolutional2DLayer, FeedForwardLayer, MaxPoolingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        # Load an example image\n        image_path = \"path/to/your/image.jpg\"  # Replace with the path to your image file\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n\n        # Define the neural network's structure\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(\n                    num_feature_maps=2,\n                    feature_map_size=5,\n                    kernel_size=(3, 3),\n                    stride=1,\n                    padding=0\n                ),\n                MaxPoolingLayer(\n                    pool_size=(2, 2),\n                    stride=2\n                ),\n                FeedForwardLayer(5),\n                FeedForwardLayer(2),\n            ],\n            layer_spacing=0.2,\n        )\n\n        # Center the neural network\n        self.add(nn)\n        nn.move_to(ORIGIN)\n\n        # Animate the forward pass\n        forward_pass_animation = nn.make_forward_pass_animation()\n        self.play(forward_pass_animation, run_time=15)\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation of two pendulums with one red and one blue bob, connected by a yellow spring, swinging in opposite directions? The pendulums should swing back and forth for three seconds. The red pendulum swings to the right starting from a 30-degree angle to the vertical, while the blue one starts by swinging to the left from a 30-degree angle. Both pendulums should have the same length, and after finishing the swing, the animation should pause so I can see the final state.",
        "answer": "\\n class DeCasteljau(Scene):\n    def construct(self):\n        self.camera.background_color = '#455D3E'\n        a1 = np.array([-3, -2, 0])\n        h1 = np.array([-3, 0, 0])\n        h2 = np.array([3, 0, 0])\n        a2 = np.array([3, 2, 0])\n\n        t = ValueTracker(0.001)\n        self.add(t)\n\n        d01 = Cross(scale_factor=0.2).move_to(a1)\n        d02 = Dot(color=ORANGE).move_to(h1)\n        d03 = Dot(color=ORANGE).move_to(h2)\n        d04 = Cross(scale_factor=0.2).move_to(a2)\n\n        d11 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to(\n                (1- t.get_value()) * d01.get_center() + t.get_value() * d02.get_center()\n            )\n        )\n        d12 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d02.get_center() + t.get_value() * d03.get_center())\n        )\n        d13 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d03.get_center() + t.get_value() * d04.get_center())\n        )\n\n        d21 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d11.get_center() + t.get_value() * d12.get_center())\n        )\n        d22 = Dot(color=GRAY).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d12.get_center() + t.get_value() * d13.get_center())\n        )\n\n        d31 = Dot(color=RED).add_updater(\n            lambda mob: mob.move_to((1- t.get_value()) * d21.get_center() + t.get_value() * d22.get_center())\n        )\n\n        static_lines = [\n            Line(d01.get_center(), d02, color=ORANGE),\n            Line(d02, d03),\n            Line(d03, d04.get_center(), color=ORANGE)\n        ]\n\n        dynamic_lines = [\n            always_redraw(lambda a=a, b=b: Line(a.get_center(), b.get_center(), color=LIGHT_GRAY))\n            for a, b in [\n                (d11, d12), (d12, d13), (d21, d22)\n            ]\n        ]\n        self.add(*dynamic_lines, *static_lines, d01, d02, d03, d04, d11, d12, d13, d21, d22, d31)\n        self.add(\n            TracedPath(lambda: d31.get_center(), stroke_color=RED)\n        )\n\n        self.wait(0.5)\n        self.play(t.animate(run_time=5).set_value(0.999))\n        self.wait(0.5)\n        self.play(FadeOut(VGroup(\n            *dynamic_lines, *static_lines, d02, d03, d11, d12, d13, d21, d22\n        )))\n        self.wait()"
    },
    {
        "query": "Can you create an animation that simulates rolling a six-sided die 100 times and displays the result of each roll along with a running count of how many times each face has come up beneath the die?",
        "answer": "\\n from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        # Create Molecules\n        reactant1 = oxygen()\n        reactant2 = lithium_ion()\n        product = metal_oxid(2, 3)\n\n        # Position Molecules\n        reactant1.shift(LEFT * 2)\n        reactant2.shift(RIGHT * 2)\n        product.move_to(ORIGIN)\n\n        # Animate reaction\n        self.play(FadeIn(reactant1), FadeIn(reactant2))\n        self.wait(1)\n        self.play(Transform(reactant1, product), Transform(reactant2, product))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated pie chart for me where the slices represent percentages of totals, with 30% in red, 45% in green, and 25% in blue? I would like the pie chart to have a label for each color next to each slice, and the labels should be positioned above the corresponding slice percentage indicators. Can you also make it so that the chart starts from a 90-degree angle, has a slight separation between the slices and comes together with the labels being written one after the other with a bit of a delay between each?",
        "answer": "\\n from manim import *\n\nclass WaveExample(Scene):\n    def construct(self):\n        some_text = Text(\"Hello, Manim!\")\n        self.play(Write(some_text))\n        self.wait(0.5)\n        self.play(ApplyWave(some_text))\n        self.play(ApplyWave(some_text, amplitude=0.5))\n        self.wait(0.5)\n        self.play(Unwrite(some_text))\n        self.wait(0.5)"
    },
    {
        "query": "I would like to create an animation with a series of circles that gradually change colors across a spectrum from blue to green, then yellow, and finally red as the animation progresses. The circles should be arranged in a horizontal row, with each subsequent circle slightly larger and further to the right than the previous one. Each circle should transition through the colors at a slightly delayed time compared to the previous circle, creating a cascading color effect across the group of circles. The color-changing effect should be smooth and continuous, and once the color reaches red, it should start over at blue. Additionally, each circle should have a semi-transparent fill to give the colors a softer look. Can you create an animation that achieves this effect using animation software?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Display the triple integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{6}x^3]_{0}^{1}\", r\"= \\frac{1}{6}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude with the final solution displayed\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animation that displays the Fibonacci sequence through a series of colored squares arranged in a grid, with each square's size representing a number in the sequence. After the squares appear, I want to see quarter-circle arcs connecting the corners of adjacent squares in a spiral pattern, with the arcs colored in a gradient from red to purple. Finally, I would like to see semi-transparent circles with radii equal to half the Fibonacci numbers overlay each square, adding a layer of visual complexity to the sequence representation. The background should be a light cream color, and the entire animation should be in a vertical format, suitable for a smartphone screen.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Presenting the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\frac{\\partial^2 u}{\\partial x^2} = 0\")\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Explanation of the nature of the equation\n        explanation1 = Text(\"This is the classical wave equation\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Explanation for general solution form\n        explanation2 = Text(\"One solution is of the form f(x - ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Writing the solution to the wave equation\n        solution_wave_eq = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(wave_eq, solution_wave_eq))\n        self.wait(3)\n\n        # Explanation of the arbitrary functions f and g\n        explanation3 = Text(\"Where f and g are arbitrary functions\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clearing the scene\n        self.remove(wave_eq, explanation1)\n        self.wait(1)\n\n        # Concluding with the solution\n        self.play(Write(solution_wave_eq))\n        self.wait(2)"
    },
    {
        "query": "How can I create an educational video animation using ManimCE that displays a basic arithmetic multiplication problem, starts with a white background, shows the numbers 3 and 2 being multiplied with a blue times symbol, resulting in the number 6, follows up by highlighting the multiplication operation, and then fades everything out after a short pause?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} f(r,\\theta) r \\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[ F(r,\\theta) \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ G(\\theta) \\right]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Final answer reveal\n        answer_explanation = Text(\"This gives us the final answer\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, answer_explanation))\n        self.wait(1)\n\n        answer = MathTex(r\"= G(2\\pi) - G(0)\")\n        self.play(Write(answer))\n        self.wait(2)"
    },
    {
        "query": "\"I would like to create a colorful pie chart animation on my smartphone vertical screen that displays the distribution of different fruit consumptions. The chart should have slices in different colors, with each representing a fruit: blueberry, green apple, lemon, watermelon, grape, orange, and strawberry. The exact proportions of consumption should be 60% blueberry, 10% green apple, 30% lemon, 20% watermelon, 15% grape, 50% orange, and 25% strawberry. I want each piece of the pie to have a corresponding label with the fruit's name and to also see a small legend on the upper right side that doesn't take up much space. Additionally, I want the pie chart creation and the legend appearance to be animated, each action having a smooth 1-second transition, and the final image should rest for 2 seconds before ending the animation.\"",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{-1}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2}x^2yz]_{-1}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem, inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}yz]_{-1}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that demonstrates the approximation of a sine wave using a simple polynomial. Start by showing a coordinate system that spans from 0 to 10 on the x-axis and -2 to 2 on the y-axis. Then plot the actual sine wave on these axes. At the top of the scene, add the text \"Sine wave approximation with polynomials.\" After showing the sine wave, draw a green polynomial curve that approximates the sine wave. Could you then place a red dot at the point where the angle is pi on the sine curve? Finally, from that red dot, draw a dashed yellow vertical line straight down to the x-axis. Please pause briefly after each step so that I can see each part clearly.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_min=-1, x_max=10,\n            y_min=-1, y_max=8,\n            axis_config={\"color\": BLUE},\n        )\n\n        # Labels for axes\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"y\")\n        \n        # Creating the graph\n        graph = axes.plot(lambda x: 0.1 * (x-2)**2, color=WHITE)\n        area = axes.get_area(graph, x_min=2, x_max=8, color=BLUE, opacity=0.3)\n\n        # Problem statement\n        problem = MathTex(r\"A = \\int_{2}^{8} 0.1(x-2)^2 \\, dx\").to_edge(UP)\n\n        # Writing the problem\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Drawing the axes, graph, and shaded area\n        self.play(Write(axes), Write(labels))\n        self.wait(1)\n        self.play(Create(graph), FadeIn(area, run_time=3))\n        self.wait(2)\n\n        # Explanation for computation\n        explanation = Text(\"Calculate the area under the curve\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene and present final answer\n        self.clear()\n        final_answer = MathTex(r\"A = \\frac{1}{0.3} [ \\frac{(x-2)^3}{3} ]_{2}^{8}\").move_to(problem)\n        self.play(Write(final_answer))\n        self.wait(3)"
    },
    {
        "query": "Can you create an animation that displays a Fibonacci spiral using colored squares and arcs where each square represents a number in the Fibonacci sequence, and the squares are color-coded with a specific palette? The background should be a light cream color, and the animation should gradually construct the spiral, with each square and arc being drawn in sequence, to illustrate the growth pattern of the Fibonacci sequence.",
        "answer": "\\n from manim import *\n\n\nclass Hydrogen(Scene):\n    def construct(self):\n        proton = self.proton()\n        electron = self.electron()\n        self.add(VGroup(proton, electron))\n\n    def proton(self) -> Mobject:\n        return self.circle_with_text(0.25, \"H$^+$\", RED_B, 25, WHITE, 1, RED_B)\n\n    def electron(self) -> Mobject:\n        return self.circle_with_text(0.15, \"e$^-$\", BLUE_D, 24, BLACK, 1, BLUE_D)\n        \n    def circle_with_text(self, r: int, txt: str, color=BLACK, font_size: int=10, font_color=BLACK, stroke_width: int=2, fill_color=BLACK) -> Mobject:\n        c = Circle(r, color=color).set_opacity(1).set_fill(fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)"
    },
    {
        "query": "I would like to create an animation where a series of circles of increasing sizes appear one by one on a straight line with some space between them. Each circle should begin as just a point and grow outward until it reaches its full size. After all the circles have appeared and grown, I would like them to swap places one by one, starting from the rightmost circle, which moves to the position of the second-to-last circle, and the second-to-last moves to the last position. This swapping continues until the second circle swaps with the first one. Each circle should be a blue outline with a light blue fill, somewhat transparent, and the swapping motion should look smooth and fairly quick. Can you create that sort of animation for me?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1}\\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy\\frac{1}{2}y^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n        \n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}x\\frac{1}{6}y^3]_{0}^{1}\", r\"= \\frac{1}{24}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create a 3D animated video of a blue torus knot that slowly rotates around its center. The animation should start with the camera orientated at an angle to give a clear view of the knot's structure, and then smoothly transition into a continuous rotation around the object, allowing the viewer to observe the knot from multiple perspectives. Can this animation be around 6 seconds long with a mathematical aesthetic to it?",
        "answer": "\\n class SquareToCircle(Scene):\n    def construct(self):\n        square = Square()\n        circle = Circle()\n        \n        self.play(Create(square))\n        self.play(Transform(square, circle))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational video intro using animation where the title \"Welcome to Manim\" appears at the top, followed by a series of geometric shapes\u2014a yellow square, a green circle, and a blue triangle\u2014appearing from left to right. Then, these shapes should transform into a single dot, representing a starting point. Finally, the dot should turn into the text \"Let's learn Manim!\", which will appear just below the dot to wrap up the intro. Can you show me how to animate this sequence step by step?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3} r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3} \\sin(\\theta) - \\frac{1}{3} \\cos(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(2)\n\n        # Display final evaluated solution\n        evaluated_solution = MathTex(r\"= \\frac{1}{3} - (-\\frac{1}{3}) = \\frac{2}{3}\")\n        self.play(Write(evaluated_solution))\n        self.wait(2)"
    },
    {
        "query": "I'm looking to create a festive animation to celebrate the New Year 2023. The animation should start with a dark background and then display the message \"Happy New Year 2023!\" in large letters that gradually appear on screen. The text should have a gradient color, going from blue to green. After the message is shown, I'd like a series of five random fireworks to burst in different colors on the upper half of the screen to give it a celebratory feel. Can you create this animation for me, and make sure that the fireworks appear one after the other with a slight delay between each?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the PDE\n        pde = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(pde))\n        self.wait(1)\n\n        # Explanation of the type of PDE\n        explanation1 = Text(\"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(pde, general_solution))\n        self.wait(2)\n\n        # Explanation of the general solution\n        explanation2 = Text(\"u(x, t) represents the displacement at point x and time t.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Specific solution with initial conditions\n        specific_solution = MathTex(r\"u(x, 0) = \\phi(x), \\quad \\frac{\\partial u}{\\partial t}(x, 0) = \\psi(x)\")\n        self.play(ReplacementTransform(general_solution, specific_solution))\n        self.wait(2)\n\n        # Explanation of specific solution\n        explanation3 = Text(\"The functions \u03c6 and \u03c8 represent the initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(specific_solution), FadeOut(explanation1))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The wave equation governs the propagation of waves.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an animated video that visually explains how a convolutional neural network (CNN) processes data. The video should include animations of the layers within the neural network, beginning with an initial convolutional layer with 16 feature maps, a 5x5 feature map size, 3x3 kernel size, and 'relu' activation, followed by a max pooling layer. Then it should show a second convolutional layer with 32 feature maps, and another max pooling layer. Finally, it should end with two fully connected layers, the first with 120 units and the second with 10 units. The animation should visualize a forward pass through this network. Can you create something like this that's visually engaging and easy to understand for someone with no background in machine learning or neural networks?",
        "answer": "\\n from manim import *\n\nclass ComplexFunction3D(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        self.play(Create(axes))\n        self.wait(1)\n\n        function = Tex(r\"f(z) = z^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        surface = ParametricSurface(\n            lambda u, v: axes.c2p(u * np.cos(v), u * np.sin(v), u**2),\n            u_range=[-2, 2], v_range=[0, TAU]\n        )\n        self.play(Create(surface))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visually explains the Fibonacci sequence by drawing a series of colored squares whose side lengths represent the sequence numbers, and then inscribe a spiral within those squares to showcase the growth pattern? Each square should be a different color and the spiral should smoothly transition from blue to green. I would like the squares to appear one after another, with a slight delay between each, and the spiral to form dynamically. Finally, make sure all of it is centered and moved upwards, allowing some space at the bottom of the frame.",
        "answer": "\\n from manim import *\n\nclass SphericalHarmonic(ThreeDScene):\n    def construct(self):\n        resolution_fa = 22\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        \n        def param_surface(u, v):\n            return np.array([\n                np.sin(u) * np.cos(v),\n                np.sin(u) * np.sin(v),\n                np.cos(u)\n            ]) * (1 + 0.3 * np.sin(5 * u) * np.cos(5 * v))\n\n        surface = ParametricSurface(param_surface, u_range=[0, PI], v_range=[0, TAU], resolution=(resolution_fa, resolution_fa))\n        self.play(Create(surface), run_time=3)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(5)"
    },
    {
        "query": "I would like to see an animation where a purple square moves to create a traceable path. First, it should move to the right for a noticeable distance, pause briefly, then move upwards the same distance, pause again, proceed to move left returning to its vertical starting line, pause one last time, and finally move downwards to return to its original position. After the square completes this path, I\u2019d like both the square and the traced path to disappear.",
        "answer": "\\n from manim import *\n\nclass HydrogenIonScene(Scene):\n    def construct(self):\n        h_ion = self.create_hydrogen_ion()\n        self.play(FadeIn(h_ion))\n        self.wait(1)\n        self.play(h_ion.animate.shift(UP * 2))\n        self.wait(1)\n        self.play(FadeOut(h_ion))\n\n    def create_hydrogen_ion(self) -> Mobject:\n        return Circle(radius=0.2, color=RED_B).set_fill(RED_B, opacity=1).add(\n            Tex('H$^+$', color=WHITE).scale(1.5)\n        )\n\nclass ElectronPathScene(Scene):\n    def construct(self):\n        electron_particle = Electron()\n        path = self.define_path()\n        self.add(electron_particle)\n        self.play(*move_along_complex_path(electron_particle, [0, 3], path, run_time=2, rate_func=there_and_back_with_pause))\n\n    def define_path(self):\n        points = [UP + LEFT, UP + RIGHT, DOWN + RIGHT, DOWN + LEFT]\n        return [self.coords_to_point(p[0], p[1]) for p in points]\n\ndef Electron():\n    return Circle(radius=0.1, color=BLUE).set_fill(BLUE, opacity=1).add(\n        Tex('e$^-$', color=WHITE).scale(0.5)\n    )"
    },
    {
        "query": "I want an animated visualization of a simple neural network architecture that consists of an input layer representing a 28x28 pixel image, two hidden layers with 128 and 64 units respectively and both using the ReLU activation function, and an output layer with 10 units using the softmax activation function. The layers should be represented as rectangles with their type, number of units, and activation function (if applicable) labeled above each rectangle. The animation should show each layer appearing one after the other with a slight delay between them. Can you create such an animation?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Transformation to another form\n        explanation2 = Text(\"For a string with fixed ends, solutions can be sinusoidal.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the particular solution\n        particular_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(equation, particular_solution))\n        self.wait(1)\n\n        # Explanation for harmonics\n        explanation3 = Text(\"Multiples of the fundamental frequency give harmonics.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clearing the scene to display harmonics\n        self.play(FadeOut(explanation1), FadeOut(particular_solution))\n        self.wait(1)\n\n        # Displaying first harmonic\n        first_harmonic = MathTex(r\"u_1(x, t) = A \\sin(\\frac{\\pi}{L}x - \\omega_1 t)\")\n        self.play(Write(first_harmonic))\n        self.wait(1)\n\n        # Displaying second harmonic\n        second_harmonic = MathTex(r\"u_2(x, t) = A \\sin(\\frac{2\\pi}{L}x - \\omega_2 t)\")\n        self.play(Transform(first_harmonic, second_harmonic))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The shape of the string at any given time is a standing wave.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animation using a blue square that moves along a circular path while rotating, and I want the path that the square moves on to be traced with a yellow line. Can the square also gradually stop moving and rotating after a few seconds, followed by a brief pause in the animation before it ends?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} [\\frac{1}{2}x^2yz]_{0}^{3} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}x^2 \\cdot \\frac{3}{2}y]_{0}^{2} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} [\\frac{3}{2}y]_{0}^{2} \\,dy\", r\"= [\\frac{3}{2}y^2]_{0}^{1}\", r\"= \\frac{3}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visually demonstrates how the sine wave is generated from the movement of a point along the real axis on the complex plane? Include these specifics:\n\n- The complex plane should be visible with both axes labeled.\n- Start with a green dot at the origin, which represents the input value on the real axis.\n- As this green dot moves horizontally to the right, create a blue dot that represents its corresponding sine value on the imaginary axis.\n- Have a red path showing the wave that the blue dot creates as the green dot moves two complete cycles along the real axis.\n- The animation should be smooth and last for 5 seconds, with the green dot moving at a constant speed.\n- After the movement is complete, pause the animation so the complete sine wave path is visible.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and the area under the curve\n        func = lambda x: x**2\n        area = Area(\n            axes=Axes(x_range=[0, 3], y_range=[0, 9]),\n            graph=ParametricFunction(func, t_range=[0, 3]),\n            x_range=[0, 2],\n            color=BLUE,\n            opacity=0.5\n        )\n\n        # Displaying the function and the area under the curve\n        self.play(Write(area.axes), Write(area.graph))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Displaying the integral notation\n        integral_text = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        integral_text.next_to(area, UP)\n        self.play(Write(integral_text))\n        self.wait(2)\n\n        # Explanation for the area under the curve\n        explanation = Text(\"This shaded area represents the definite integral\", font_size=24)\n        explanation.to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Solving the integral\n        solution = MathTex(r\"= [\\frac{1}{3}x^3]_0^2\", r\"= \\frac{1}{3}(2^3) - \\frac{1}{3}(0^3)\", r\"= \\frac{8}{3}\")\n        solution.next_to(integral_text, DOWN)\n        self.play(ReplacementTransform(integral_text, solution))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The value of the definite integral is 8/3.\", font_size=24)\n        conclusion.to_edge(DOWN + RIGHT)\n        self.play(Transform(explanation, conclusion))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually represents the Lucas sequence through a spiraling arrangement of colored squares. Each square should have a size corresponding to a number in the sequence and be sequentially colored from a palette of light yellow, green, blue, orange, and purple. The squares should appear one after another with a smooth ease-in and ease-out transition and have their respective Lucas number written on them. After all the squares appear, a spiral line should smoothly draw itself from the center of the first square, extending and turning at each corner to represent the growing pattern of the sequence. Finally, the entire animation should conclude by fading out all elements from the screen. The background should be a light cream color, and the text and spiral line in a contrasting darker color for readability.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(FadeIn(problem))\n        self.wait(1)\n\n        # Explanation of the problem\n        explanation = Text(\"Find the area under the curve from x=1 to x=3\", font_size=24).move_to(3*UP)\n        self.play(FadeIn(explanation))\n        self.wait(2)\n\n        # Setting up the integral\n        setup_integral = MathTex(r\"= \\left[ \\frac{1}{3} x^3 \\right]_1^3\")\n        self.play(Transform(problem, setup_integral))\n        self.wait(2)\n\n        # Calculating the definite integral\n        evaluation = MathTex(r\"= \\frac{1}{3} (3^3) - \\frac{1}{3} (1^3)\", r\"= \\frac{1}{3} (27) - \\frac{1}{3} (1)\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(Transform(problem, evaluation))\n        self.wait(2)\n\n        # Presenting the final answer\n        final_answer = Text(\"Area under the curve is 26/3\", font_size=24).move_to(3*UP)\n        self.play(ReplacementTransform(explanation, final_answer))\n        self.wait(1)\n\n        # Clear the scene and show the final answer\n        self.play(FadeOut(problem))\n        self.wait(1)\n        self.play(FadeIn(final_answer))\n        self.wait(2)"
    },
    {
        "query": "I would like an animation of a simple pendulum swinging back and forth at a fixed point in space. The pendulum should have a string or rod of moderate length, with a small bob at the end that is colored blue. The pendulum should swing from a small angle, making it look like a typical pendulum motion, with the swing slowing down at the ends before it swings back the other way. I want to see the pendulum perform this swinging motion a few times, with a brief pause at the end of each swing before it changes direction. Additionally, the pendulum should be anchored to a point above that is fixed in space and should not move throughout the animation. Can you create something like this?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_x\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift((LEFT+UP)*2)\n            star = Star()\n            self.add(dot,star)\n            self.play(star.animate.match_x(dot))\n            self.remove(star,dot)"
    },
    {
        "query": "Could you create an educational animation using Manim that introduces the concept of prime factors? I'd like the animation to include a title \"Fatores Primos\" at the top, and below that, show the number 60 broken down into its prime factors (2, 2, 3, and 5) with each prime factor highlighted in a different color. Additionally, can you add an annotation below the factors with the words \"Fatores Primos\" and include a brace emphasizing the group of prime factors? Make sure the background is a pleasant off-white and the text colors are easy on the eyes, with the prime factors standing out.",
        "answer": "\\n from manim import *\n\n\nclass Lissajous(Scene):\n    def construct(self):\n        # Simultaneous lissajous curves.\n        lissajous_size = 2\n        lissajous_a = 1\n        lissajous_b = 1\n        lissajous_delta = PI / 4\n        lissajous_rate = 5\n        lissajous_alpha = ValueTracker()\n        offset = PI / 2\n\n        def lissajous_location(t, delta):\n            A = lissajous_size\n            a = lissajous_a\n            b = lissajous_b\n            x = A * np.sin(a * t + offset)\n            y = A * np.sin(b * t + delta + offset)\n            return x * RIGHT + y * UP\n\n        def get_line_length(mob):\n            length = 0\n            start_anchors = mob.get_start_anchors()\n            for i in range(len(start_anchors) - 1):\n                length += get_norm(start_anchors[i + 1] - start_anchors[i])\n            return length\n\n        def grow_line(mob):\n            new_position = lissajous_location(\n                lissajous_alpha.get_value() * mob.rate, mob.delta\n            )\n\n            # Update line length.\n            mob.add_line_to(new_position)\n            mob.line_length += get_norm(new_position - mob.points[-1])\n\n            while get_line_length(mob) > mob.maximum_length:\n                mob.set_points(mob.points[4:])\n\n        def get_lissajous_line(delta, rate):\n            line = VMobject()\n            line.delta = delta\n            line.line_length = 0\n            line.maximum_length = 8\n            line.rate = rate\n            line.points = np.array([lissajous_location(0, line.delta)])\n            line.add_updater(grow_line)\n            return line\n\n        self.add(get_lissajous_line(1 * PI / 8, 1).set_color(RED))\n        self.add(get_lissajous_line(2 * PI / 8, 2).set_color(ORANGE))\n        self.add(get_lissajous_line(3 * PI / 8, 3).set_color(YELLOW))\n        self.add(get_lissajous_line(4 * PI / 8, 4).set_color(GREEN))\n        self.add(get_lissajous_line(5 * PI / 8, 5).set_color(BLUE))\n        self.add(get_lissajous_line(6 * PI / 8, 6).set_color(BLUE_B))\n        self.add(get_lissajous_line(7 * PI / 8, 7).set_color(PURPLE))\n\n        self.play(lissajous_alpha.animate.set_value(20), run_time=32, rate_func=linear)"
    },
    {
        "query": "I want to create a simple animation sequence where a text phrase appears to \"fade in\" at the top of the screen and then a circle appears below it. After that, the text changes to the phrase \"fade out\" while remaining in the same position, and finally, the circle disappears as if it were fading out. Can this all be done very quickly, say in half a second for the text transformations and the circle's appearance and disappearance?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3} (\\sin(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Evaluating the solution\n        evaluate_solution = MathTex(r\"= \\frac{1}{3} (\\sin(\\pi) - 0)\")\n        self.play(ReplacementTransform(final_solution, evaluate_solution))\n        self.wait(2)\n\n        # Solution result\n        solution_result = MathTex(r\"= 0\")\n        self.play(ReplacementTransform(evaluate_solution, solution_result))\n        self.wait(1)"
    },
    {
        "query": "I want to create an animation where a square is at the center of the screen with a colorful border that keeps changing colors between purple, teal, and yellow. The border should be constantly animating by cycling through these colors. First, I\u2019d like the square to scale up to 1.5 times its original size over the course of 2 seconds. After scaling, there should be a brief pause, and then the square should rotate 90 degrees over another 2 seconds. Following the rotation, the colorful border should stop changing and remain static on the last color it showed. Can we also ensure that the square stays on screen for a little while after the rotation without the animated border?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_color\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle(fill_opacity=1).set_fill(RED).shift(LEFT*2)\n            square = Square(fill_opacity=1).shift(RIGHT*2)\n            self.add(circle)\n            self.play(Create(square))\n            self.play(square.animate.match_color(circle))\n            self.remove(square,circle)"
    },
    {
        "query": "Could you create an animation that introduces the concept of prime numbers to students by highlighting each prime number one by one on a dark background? Start the animation with a bold title that says \"Prime Numbers\" at the top, and then beneath it, display the first ten prime numbers arranged in a grid format. Each prime number should be individually emphasized with a different color to catch attention, and after showing all, the entire scene should fade away. The animation should have a vertical orientation suitable for mobile screens.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"= \\left. \\frac{x^{3+1}}{3+1} \\right|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution evaluation\n        final_evaluation = MathTex(r\"= \\left. \\frac{x^4}{4} \\right|_0^2 = \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(integration_step, final_evaluation))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= 4 - 0 = 4\")\n        self.play(ReplacementTransform(final_evaluation, simplified_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final simplified solution\n        self.play(Write(simplified_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create a simple animated diagram of a neural network with three layers where the first layer is blue, the second is green, and the third is red, with arrows connecting them vertically? Then, animate each layer one by one changing their color to yellow from the top to the bottom layer, and finally, have the whole network fade out.",
        "answer": "\\n from manim_ml.neural_network import NeuralNetwork, Convolutional2DLayer, FeedForwardLayer\n# Make nn\nnn = NeuralNetwork([\n        Convolutional2DLayer(1, 7, filter_spacing=0.32),\n        Convolutional2DLayer(3, 5, 3, filter_spacing=0.32, activation_function=\"ReLU\"),\n        FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n    ],\n    layer_spacing=0.25,\n)\nself.add(nn)\n# Play animation\nforward_pass = nn.make_forward_pass_animation()\nself.play(forward_pass)"
    },
    {
        "query": "Please create an educational animation that demonstrates the concept of equivalent fractions. Display the fractions 1/2 and 2/4 side by side in blue, with a large equals sign in between to show they are equivalent. Also, include green arrows pointing between each fraction, suggesting the conversion from one to the other. Accompany the arrows with text indicating that one fraction is obtained from the other by \"Multiplying by 2\" and \"Dividing by 2\", respectively, also in green. The arrows and text should animate in after the fractions and equals sign. After a short pause, make the entire scene fade out.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iiint_V xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"Integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\iint_V \\frac{1}{2}x^2yz \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_V \\frac{1}{2}x^2\\frac{1}{2}y^2z \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{4}x^2y^2\\frac{1}{2}z^2\\Big|_V\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an animated video using a Python library that showcases various mathematical and text objects. The video should start by displaying the phrase \"A Showcase of MObjects\" at the top. Then I want to see a collection of different geometric shapes like squares, circles, triangles, annuluses, ellipses, dots, arrows, and stars. Below the shapes, there should be a line of different text and number-related objects including simple text, an integral formula, a rounded integer number, a decimal number, a bulleted list with three items, and a snippet of Python code that says 'Hello, World!'. \n\nThese collections of objects should be arranged in a grid layout with a nice visual spacing between them. Each object should fade into the scene starting from the top-left and moving to the bottom-right. After they all appear, I'd like the geometric shapes to have a wave-like effect applied one by one, and the text-based objects to be highlighted in sequence. This should be visually engaging showing a little bit of what can be done with objects in this library. \n\nFinally, all objects should fade out, including the title, to end the animation. Can you create something like that for me?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the original function\n        function_text = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_text))\n        self.wait(1)\n\n        # Explanation for calculating area under curve\n        explanation1 = Text(\"Calculate area under curve from x = 0 to x = 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # The definite integral setup\n        integral_text = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(ReplacementTransform(function_text, integral_text))\n        self.wait(1)\n\n        # Explanation for using the integral to find the area\n        explanation2 = Text(\"Use the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solution\n        solution = MathTex(r\"= \\frac{1}{3}x^3\\Big|_0^2\")\n        self.play(ReplacementTransform(integral_text, solution))\n        self.wait(1)\n\n        solution_result = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(solution, solution_result))\n        self.wait(1)\n\n        # Clear the scene and show final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_result))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation using a simple geometric shape overlay where a red triangle fades in and a yellow hexagon appears above it growing from its center. After a brief moment, I want the triangle to fade out, while the hexagon shrinks to a point above where it was positioned. Can you describe how I would visualize this using animation?",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Displaying the ODE of harmonic oscillator\n        ode = MathTex(r\"m \\frac{d^2 x}{dt^2} + b \\frac{dx}{dt} + kx = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explanation for the physical system\n        explanation1 = Text(\"Represents a damped harmonic oscillator\", font_size=24).next_to(ode, DOWN)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Converting the second-order ODE to a system of first-order equations\n        explanation2 = Text(\"Convert to a system of first order ODEs\", font_size=24)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # System of equations\n        system_eqs = MathTex(r\"\\begin{cases}\"\n                             r\"\\frac{dv}{dt} &= -\\frac{b}{m}v -\\frac{k}{m}x\\\\\"\n                             r\"\\frac{dx}{dt} &= v\"\n                             r\"\\end{cases}\")\n        self.play(Transform(ode, system_eqs))\n        self.wait(2)\n\n        # Initial conditions\n        init_cond = Text(\"Assume initial conditions: x(0) = x_0, v(0) = v_0\", font_size=24)\n        self.play(FadeIn(init_cond), *[\n            obj.animate.to_edge(UP) for obj in (ode, explanation1)\n        ])\n        self.wait(2)\n\n        # Show the damping ratio\n        damping_ratio = MathTex(r\"\\zeta = \\frac{b}{2\\sqrt{mk}}\")\n        self.play(Write(damping_ratio), FadeOut(explanation1, target_position=UP))\n        self.wait(2)\n\n        # Show the solution for under-damped system\n        solution_text = Text(\"Solution for under-damped:\", font_size=24)\n        solution = MathTex(r\"x(t) = e^{-\\zeta\\sqrt{k/m}t}(A\\cos(\\omega_d t) + B\\sin(\\omega_d t))\",\n                           r\",\\ \\omega_d = \\sqrt{\\frac{k}{m} - \\zeta^2}\")\n        self.play(\n            FadeIn(solution_text, target_position=DOWN),\n            ReplacementTransform(init_cond, solution)\n        )\n        self.wait(2)\n\n        # Clean up the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion with the general solution\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an educational animation that illustrates the concept of a derivative in calculus. Specifically, I want to visualize the tangent line to a cubic function as it moves along the curve. The cubic function should be f(x) = x^3 - 3x, and it should be graphed on a set of axes with the x-range from -3 to 3 and the y-range from -4 to 4. The curve of the function should be displayed in green. I would also like to include a stationary red line that represents the derivative of f(x) at x = 1, which is the line y = 3x - 3. Additionally, place an orange dot on the curve at the point corresponding to x = 1, and create an orange tangent line that moves with the dot as it travels along the curve, demonstrating how the tangent line relates to the derivative at various points on the function. The motion of the dot should be smooth and take approximately 4 seconds to travel from the start to the end of the visible curve, and I would like the entire animation to be simple and clear for educational purposes.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem for definite integral\n        problem = MathTex(r\"\\int_2^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{2+1}}{2+1} \\Bigg|_2^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Calculation of the definite integral\n        solution2 = MathTex(r\"= \\left. \\frac{x^3}{3} \\right|_2^3\")\n        self.play(Transform(solution1, solution2))\n        self.wait(2)\n\n        # Explanation for calculating the definite integral\n        explanation2 = Text(\"Evaluate from the bounds 2 to 3:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution for the definite integral\n        final_solution = MathTex(r\"= \\frac{3^3}{3} - \\frac{2^3}{3}\")\n        self.play(ReplacementTransform(solution2, final_solution))\n        self.wait(1)\n\n        # Simplifying the final result\n        simplified_solution = MathTex(r\"= 9 - \\frac{8}{3}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n\n        final_result = MathTex(r\"= \\frac{19}{3}\")\n        self.play(ReplacementTransform(simplified_solution, final_result))\n        self.wait(2)\n\n        # Clear the scene and display only the final result\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "How can I create an animation using Manim that starts with the title \"Manim Wave Effects\" at the top of the screen, follows with a subtitle \"Various wave animations\" appearing just below it, displays a blue semi-transparent square in the center that undergoes a series of wave animations, including a normal wave motion, a wave motion with a linear rate function, and then a subtle wave with smaller amplitude, before finally fading out?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.add_background_rectangle\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.add(square)\n            self.play(square.animate.add_background_rectangle())\n            self.remove(square)"
    },
    {
        "query": "I would like an educational animation that explains the damping in oscillatory systems. The animation should start by displaying the second-order differential equation of a damped harmonic oscillator. Then, provide a basic textual explanation of the equation. Next, show the transformation to the characteristic equation and discuss its solutions and significance, possibly visualizing the solutions in some form. Afterward, please include the general solution for the displacement of the system as a function of time, with an explanation of its components. Finally, conclude by restating the general solution with different constants to show the general form the solution can take. Can you create an animation that does just that in a clear and concise manner?",
        "answer": "\\n from manim import *\n\nclass MagnetScene(Scene):\n    def construct(self):\n        magnet = self.create_magnet()\n        magnetic_field_lines = self.create_magnetic_field_lines()\n        \n        self.play(Create(magnet))\n        self.wait(1)\n        \n        self.play(AnimationGroup(*[Create(line) for line in magnetic_field_lines], lag_ratio=0.1))\n        self.wait(2)\n\n    def create_magnet(self) -> Mobject:\n        red_pole = Rectangle(width=1, height=2, color=RED, fill_opacity=0.8).shift(LEFT * 0.5)\n        blue_pole = Rectangle(width=1, height=2, color=BLUE, fill_opacity=0.8).shift(RIGHT * 0.5)\n        magnet = VGroup(red_pole, blue_pole)\n        return magnet\n    \n    def create_magnetic_field_lines(self) -> List[Mobject]:\n        lines = []\n        for i in range(-5, 6):\n            lines.append(Arc(start_angle=-TAU/4, angle=TAU/2, radius=abs(i) + 0.5).shift(DOWN * i * 0.2))\n        return lines\n\nclass FlowingElectronScene(Scene):\n    def construct(self):\n        electron_group = VGroup(*[self.create_electron() for _ in range(5)])\n        electron_group.arrange(RIGHT, buff=1)\n        path = Line(LEFT * 4, RIGHT * 4)\n\n        self.play(Create(electron_group))\n        self.wait(1)\n\n        animations = [self.electron_flow_animation(electron, path) for electron in electron_group]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))\n        self.wait(2)\n\n    def electron_flow_animation(self, electron: Mobject, path: Mobject) -> Animation:\n        return MoveAlongPath(electron, path, run_time=5, rate_func=linear)\n\n    def create_electron(self) -> Mobject:\n        return Circle(radius=0.2, color=YELLOW).set_fill(YELLOW, opacity=0.8).add(Tex(\"e$^-$\", color=BLACK).scale(0.5))"
    },
    {
        "query": "I would like to make an educational animation demonstrating the steps to evaluate a triple integral, with a specific example of integrating the function xyz over the unit cube where x, y, and z range from 0 to 1. The animation should begin by showing the integral problem, then proceed with a step-by-step explanation starting with integrating with respect to x, then y, and finally z. After each integration step, update the integral on the screen. When the final integral is reached and solved, present the solution clearly on the screen. Finally, conclude the animation by clearly stating the result of the triple integral. Can you create this animation in a way that's easy to understand for someone learning about triple integrals for the first time?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"TransformMatchingTex\").shift(UP*2.5)), run_time=0.5)\n            eq1 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n            eq2 = MathTex(\"{{a}}^2\", \"+\", \"-{{c}}^2\", \"=\", \"-{{b}}^2\")\n            self.add(eq1)\n            self.wait(0.5)\n            self.play(TransformMatchingTex(eq1, eq2, path_arc=PI/2))\n            self.wait(0.5)\n            self.remove(eq1,eq2)"
    },
    {
        "query": "Please create an educational animation using ManimCE that visually explains the step-by-step process of evaluating the triple integral of the function xyz over the volume defined from 0 to 1 in x, 0 to 2 in y, and 0 to 3 in z, including written explanations at each step to guide the viewer through the integral calculation.",
        "answer": "\\n class ComplexExp(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes(x_range=(-0.1, 4.25), y_range=(-1.5, 1.5), z_range=(-1.5, 1.5), y_length=5, z_length=5)\n        curve = ParametricFunction(\n            lambda p: axes.coords_to_point(p, np.exp(complex(0, PI*p)).real, np.exp(complex(0, PI*p)).imag),\n            t_range=(0, 2, 0.1)\n        )\n        curve_extension = ParametricFunction(\n            lambda p: axes.coords_to_point(p, np.exp(complex(0, PI*p)).real, np.exp(complex(0, PI*p)).imag),\n            t_range=(2, 4, 0.1)\n        )\n        t = MathTex(\"z = e^{t \\pi i}, \\quad t\\in [0, 2]\")\n        t.rotate(axis=OUT, angle=90*DEGREES).rotate(axis=UP, angle=90*DEGREES)\n        t.next_to(curve, UP + OUT)\n        self.set_camera_orientation(phi=90*DEGREES, theta=0, focal_distance=10000)\n        self.add(axes)\n        self.play(Create(curve, run_time=2), Write(t))\n        self.wait()\n        self.move_camera(phi=75*DEGREES, theta=-30*DEGREES)\n        self.wait()\n        four = MathTex(\"4\").rotate(axis=OUT, angle=90*DEGREES).rotate(axis=UP, angle=90*DEGREES)\n        four.move_to(t[0][12])\n        self.play(Create(curve_extension, run_time=2), t[0][12].animate.become(four))\n        self.wait()\n        self.move_camera(phi=90*DEGREES, theta=-90*DEGREES, focal_distance=10000)\n        self.wait()\n        self.move_camera(phi=75*DEGREES, theta=-30*DEGREES)\n        self.wait()\n        self.move_camera(phi=0, theta=-90*DEGREES, focal_distance=10000)\n        self.wait()\n        self.move_camera(phi=75*DEGREES, theta=-30*DEGREES)\n        self.wait()\n        self.play(FadeOut(axes, curve, curve_extension, t, shift=IN))\n        self.wait()"
    },
    {
        "query": "Can you create an animation that explains the solution to the harmonic oscillator differential equation step by step, starting with the equation itself, proposing a trial solution, applying initial conditions to find the general solution, and concluding with the final form of the solution?",
        "answer": "\\n from manim import *\n\nclass SimpleHarmonicMotionScene(Scene):\n    def construct(self):\n        # Display the differential equation of SHM\n        shm_eq = MathTex(r\"m\\ddot{x} + kx = 0\")\n        self.play(Write(shm_eq))\n        self.wait(1)\n\n        # Show the explanation for introducing angular frequency\n        explanation1 = Text(\"Introduce angular frequency\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Define angular frequency\n        omega_eq = MathTex(r\"\\omega^2 = \\frac{k}{m}\")\n        self.play(Transform(shm_eq, omega_eq))\n        self.wait(1)\n\n        # Rewrite the SHM equation using angular frequency\n        rewritten_shm = MathTex(r\"\\ddot{x} + \\omega^2 x = 0\")\n        self.play(ReplacementTransform(shm_eq.copy(), rewritten_shm))\n        self.wait(2)\n\n        # Show the solution to the SHM equation\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(Write(solution))\n        self.wait(1)\n\n        # Explanation for the solution\n        explanation2 = Text(\"General solution of SHM\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Demonstrate the concept of phase difference\n        phase_diff = MathTex(r\"\\phi\", r\" \\text{ is the phase difference}\")\n        self.play(Write(phase_diff))\n        self.wait(2)\n\n        # Clear the scene and show only the final solution\n        self.play(FadeOut(explanation1), FadeOut(phase_diff))\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually introduces the one-dimensional wave equation, shows its mathematical representation, provides a verbal explanation followed by its general solution in a format that is easy to understand, and finally discusses the concept of specific solutions influenced by initial and boundary conditions?",
        "answer": "\\n from manim import *\n\nclass ChemicalReaction(Scene):\n    def construct(self):\n        reactant1 = electron()\n        reactant2 = oxygen()\n        product = metal_oxid(2, 3)\n\n        self.play(FadeIn(reactant1))\n        self.wait(0.5)\n        \n        self.play(Transform(reactant1, reactant2))\n        self.wait(0.5)\n        \n        self.play(Transform(reactant1, product))\n        self.wait(2)\n\n        self.play(FadeOut(reactant1))\n\n# The code provided lacks the complete structure for a manim scene.\n# You can run this scene using the Manim command line utility with the -s flag to get a still image of the final frame.\n\n# Example: `manim -pql -s your_script.py ChemicalReaction`"
    },
    {
        "query": "I would like to create an educational animation that visually explains the process of solving a trigonometric substitution problem in calculus. The animation should start by presenting the integral of 1 over the square root of 1 minus x squared. Then, it should introduce the idea of using a trigonometric substitution to solve the integral. The animation needs to show the substitution of x with the sine of theta and dx with the cosine of theta times d theta. After that, please demonstrate how the integral changes with the substitution and simplify it using the Pythagorean identity. Once the simplified integral is presented, proceed to solve the integral and display the solution. Finally, please show the process of substituting back to express the solution in terms of x and conclude with the final result clearly displayed. The explanations should be paced with waiting moments to allow the audience to follow the content comfortably.",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identities\n        explanation1 = Text(\"Use trigonometric identity: \"\n                            \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the identity\n        apply_identity = MathTex(r\"= \\frac{1}{2}\\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, apply_identity))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= -\\frac{1}{4}\\cos(2x) + C\")\n        self.play(Write(integration_step.next_to(apply_identity, DOWN)))\n        self.wait(1)\n\n        # Clear the scene and display the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an animation that visually explains the process of calculating the value of the infinite series sum of 1 over n squared, from n equals 1 to infinity, which converges to pi squared over 6. Start by showing the formula of the series, then illustrate the concept of partial sums approaching the series' value, move on to show what the partial sum looks like for the first five terms, and finally, reveal that the series converges to the known value of pi squared over 6. Include textual explanations during the transitions between the different parts of the process, and make sure each step is easy to follow and displayed sequentially.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{6}z^3]_{0}^{1}\", r\"= \\frac{1}{6}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually explains how to solve the integral of the square root of 1 minus x squared using trigonometric substitution, step by step, and then convert the final answer back into terms of x?",
        "answer": "\\n from manim import Scene, Create_x000D_\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer_x000D_\n_x000D_\nclass FeedForwardNeuralNetworkScene(Scene):_x000D_\n    def construct(self):_x000D_\n        # Define a feedforward neural network_x000D_\n        feedforward_nn = NeuralNetwork([_x000D_\n            FeedForwardLayer(4),_x000D_\n            FeedForwardLayer(6, activation_function=\"ReLU\"),_x000D_\n            FeedForwardLayer(3, activation_function=\"Softmax\")_x000D_\n        ])_x000D_\n_x000D_\n        # Display the neural network_x000D_\n        self.play(Create(feedforward_nn))_x000D_\n_x000D_\n        # Animate a forward pass through the network_x000D_\n        forward_pass_animation = feedforward_nn.make_forward_pass_animation()_x000D_\n        self.play(forward_pass_animation)"
    },
    {
        "query": "I'd like to visualize the concept of finding the area under a curve with an educational animation. Could you create an animation using the function f(x) = x^2, show it graphically on a set of axes ranging from 0 to 5 on the x-axis and 0 to 6 on the y-axis, and color the axes blue? Start by drawing the axes with labels and the graph of the function in red. Then, fill in the area under the curve from x=0 to x=2 with purple rectangles to approximate the area, with a slight transparency to see the overlap with the function. Above everything, place a title describing the action as \"Area under the curve f(x) = x^2 from x=0 to x=2\". Finally, can you display the mathematical calculation of the exact area under the curve using integration from x=0 to x=2, show the solution step by step, and then conclude by removing all elements from the screen? Make each step appear sequentially and hold for a moment to allow for clear viewing.",
        "answer": "\\n from manim import *\n\nclass WaveEquation(Scene):\n    def construct(self):\n        # Display the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for wave equation\n        explanation1 = Text(\"This is the standard wave equation for a field u.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Display speed of propagation\n        speed = MathTex(r\"c\", r\" = \\text{speed of wave propagation}\").next_to(equation, DOWN)\n        self.play(Write(speed))\n        self.wait(2)\n\n        # Explain solution form\n        explanation2 = Text(\"Solutions typically involve sinusoidal functions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying a particular solution\n        particular_solution = MathTex(r\"u(x, t) = A \\cos(kx - \\omega t)\")\n        self.play(ReplacementTransform(equation, particular_solution))\n        self.wait(2)\n\n        # Explanation for a particular solution\n        explanation3 = Text(\"Where A is amplitude, k is wavenumber, and \u03c9 is angular frequency.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of demonstration!\", font_size=24).to_edge(UP)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains the one-dimensional wave equation, its general solution, and how it is influenced by initial and boundary conditions, with emphasis on the notion of propagation speed represented by 'c', using clear mathematical representations and annotations for better understanding?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            text = Text(\"Animations\").shift(UP*2.5)\n            self.play(Write(text))\n            self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that starts by presenting the classical wave equation, then adds a subtitle to indicate what it is, proceeds to introduce a consideration of a specific solution form, transitions to explaining the constants in the equation, displays how general solutions can be formed and concludes with a thank you message, all with appropriate pauses between the segments?",
        "answer": "\\n from manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        def update_label_text(object):\n            object.set(text=str(cnt))\n            object.next_to(dot, UP)\n            cnt += 1\n\n        cnt = 1\n        dot = Dot(ORIGIN)\n        label = Text(str(dot.get_x())).next_to(dot, UP)\n        label.add_updater(update_label_text)\n        self.add(label)\n        self.play(dot.animate.move_to(UL*3))\n        self.play(dot.animate.move_to(DOWN*3))"
    },
    {
        "query": "I would like an animated video tutorial that visually demonstrates the process of solving a triple integral. Start by showing the integral of xyz over the unit cube from 0 to 1. Then, in step by step fashion, first integrate with respect to z while providing a text explanation above, next integrate the resulting expression with respect to y with new text explanation, and finally integrate with respect to x with another text explanation. At each step, the previous mathematical expression should transform into the new one. End the tutorial by clearing the screen and presenting the final solution of the integral.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\", r\" \\Bigg|_0^2\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{3+1}\", r\" \\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution with bounds\n        integral_bound = MathTex(r\"= \\frac{x^4}{4} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(solution1, integral_bound))\n        self.wait(1)\n\n        # Evaluating the bounds\n        solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(integral_bound, solution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{16}{4} - 0\", \"=\", \"4\")\n        self.play(ReplacementTransform(solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to have an educational animation that visually explains the wave equation in physics. It should start by displaying the partial differential equation that represents the one-dimensional wave equation. After that, I want a brief text explanation to appear that explains this equation is indeed the wave equation. Next, the animation should replace the initial equation with its general solution and provide a simple text description indicating what the variables in the solution represent, specifically referring to displacement at some point and time. Following this, please show the specific solution to the wave equation assuming initial conditions, and accompany it with an explanation that identifies the functions representing these initial conditions. Lastly, clear all the previous content and conclude with a statement summarizing that the wave equation is fundamental to understanding how waves propagate. Please ensure that each step has a short pause so the information can be absorbed by viewers.",
        "answer": "\\n from manim import *\n\nclass SimpleHarmonicMotionScene(Scene):\n    def construct(self):\n        # Display the differential equation of a simple harmonic oscillator\n        equation = MathTex(r\"m \\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Write down the explanation for solving the equation\n        explanation1 = Text(\"We assume a solution of the form\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Display the assumed solution form\n        assumed_solution = MathTex(r\"x(t) = A \\cos(\\omega t) + B \\sin(\\omega t)\")\n        self.play(ReplacementTransform(equation.copy(), assumed_solution))\n        self.wait(2)\n\n        # Show explanation for angular frequency\n        explanation2 = Text(\"Where\", font_size=24).shift(UP * 3)\n        angular_frequency = MathTex(r\"\\omega = \\sqrt{\\frac{k}{m}}\", font_size=24).next_to(explanation2, DOWN)\n        self.play(Write(explanation2), Write(angular_frequency))\n        self.wait(2)\n\n        # Transform previous text into the explanation for general solution\n        explanation3 = Text(\"Giving the general solution to the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(1)\n\n        # Show the general solution for Simple Harmonic Motion\n        general_solution = MathTex(r\"x(t) = C_1 \\cos(\\sqrt{\\frac{k}{m}} t) + C_2 \\sin(\\sqrt{\\frac{k}{m}} t)\")\n        self.play(ReplacementTransform(assumed_solution, general_solution))\n        self.wait(2)\n\n        # Final explanation about the constants determination\n        explanation4 = Text(\"Constants C1 and C2 are determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(1)\n\n        # Clearing everything to conclude the scene\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"This is a simple harmonic motion solution!\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like to see an animated step-by-step visualization of solving a triple integral. The specific problem to solve should be the integral of 'xyz' over the unit cube, with integration first with respect to x, then y, and finally z. Could you show each integration step individually with a brief written explanation of what\u2019s happening at each stage? It would be great if the final answer is clearly displayed at the end.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ChangeSpeed\").shift(UP*2.5)), run_time=0.5)\n            d = Dot().shift(LEFT)\n            self.play(ChangeSpeed(d.animate.shift(RIGHT*2), speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1}, rate_func=linear))\n            self.remove(d)"
    },
    {
        "query": "I would like an animation that starts by displaying the integral of x squared from 0 to 1. Then, the animation should show a step-by-step explanation of how to use the power rule to solve this integral, including the addition of a constant. Next, show how to evaluate the definite integral from 0 to 1 using the power rule. Finally, reveal the result of the integral and conclude by stating the area under the parabola from 0 to 1 is a third. Can you create an educational math animation that covers these steps and concepts?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area we want to find\n        curve_text = MathTex(r\"y = x^2\", font_size=36)\n        curve_text.to_edge(UP)\n        self.play(Write(curve_text))\n        self.wait(1)\n\n        # Define the function and the area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 2])\n        shaded_area = area = self.get_area(curve, [0, 2])\n        \n        # Show the function and the shaded area\n        self.play(Create(curve), Create(shaded_area))\n        self.wait(2)\n\n        # Display the integral expression defining the shaded area\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        integral.next_to(curve_text, DOWN)\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Solving the integral\n        integral_solution = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^2\")\n        integral_solution.next_to(integral, DOWN)\n        self.play(Transform(integral, integral_solution))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        final_result.next_to(integral_solution, DOWN)\n        self.play(Transform(integral, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(curve), FadeOut(shaded_area), FadeOut(curve_text), FadeOut(integral))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that visually explains the process of solving a triple integral, specifically integrating the function xyz over the unit cube [0,1]\u00b3 with respect to x, then y, and lastly z, including step-by-step explanations for each integration stage?",
        "answer": "\\n from manim.utils.unit import Percent, Pixels\n\nclass UsefulUnits(Scene):\n    def construct(self):\n        for perc in range(5, 51, 5):\n            self.add(Circle(radius=perc * Percent(X_AXIS)))\n            self.add(Square(side_length=2*perc*Percent(Y_AXIS), color=YELLOW))\n\n        d = Dot()\n        d.shift(100 * Pixels * RIGHT)\n        self.add(d)"
    },
    {
        "query": "Could you create an educational animation using ManimCE that visually demonstrates how to solve a triple integration problem step by step? Start by displaying the triple integral of the function xyz within the bounds z from 0 to 3, x from 0 to 2, and y from 0 to 1 on the screen. For each step, begin by integrating with respect to z, followed by x, and lastly y. Include written explanations above each mathematical step indicating which variable we are integrating with respect to next. After calculating each integral, show the resulting expression before moving on to the next. Once the final answer is found, clear the screen and display only the final numerical solution prominently.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Explanation for the wave equation\n        explanation1 = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Discussing the solution form\n        solution_form = Text(\"Solutions take the form u(x, t) = f(x \\pm ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, solution_form))\n        self.wait(2)\n        \n        # Displaying the solution to the equation\n        solution = MathTex(r\"u(x, t) = f(x \\pm ct)\")\n        self.play(ReplacementTransform(equation, solution))\n        self.wait(1)\n        \n        # Discussing the influence of initial conditions\n        initial_conditions = Text(\"The form of f is determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, initial_conditions))\n        self.wait(2)\n        \n        # Conclusion with the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using Manim that introduces the concept of Fourier Series Decomposition, displays and explains the general formula of a Fourier series for a periodic function, highlights key components and how coefficients are calculated, emphasizes the significance of Fourier series in signal processing and electrical engineering, and finally, reiterates the formula at the conclusion of the presentation?",
        "answer": "\\n from colour import Color\nclass BasicAnimations(Scene):\n    def construct(self):\n        polys = VGroup(\n            *[RegularPolygon(5, radius=1, color=Color(hue=j/5, saturation=1, luminance=0.5), fill_opacity=0.5)\n              for j in range(5)]\n        ).arrange(RIGHT)\n        self.play(DrawBorderThenFill(polys), run_time=2)\n        self.play(\n            Rotate(polys[0], PI, rate_func=lambda t: t), # rate_func=linear\n            Rotate(polys[1], PI, rate_func=smooth),  # default behavior for most animations\n            Rotate(polys[2], PI, rate_func=lambda t: np.sin(t*PI)),\n            Rotate(polys[3], PI, rate_func=there_and_back),\n            Rotate(polys[4], PI, rate_func=lambda t: 1 - abs(1-2*t)),\n            run_time=2\n        )\n        self.wait()"
    },
    {
        "query": "Can you create an animated video that explains how to calculate the area under the curve for the function x squared between the values x equals 1 and x equals 3, including a step-by-step demonstration of evaluating the definite integral, and showing the final result?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Showing the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eq))\n        self.wait(2)\n\n        # Displaying solution form\n        solution_form = Text(\"Solutions can be of the form u(x, t) = f(x \\pm ct)\", font_size=24).to_edge(DOWN)\n        self.play(Write(solution_form))\n        self.wait(3)\n\n        # Displaying a specific solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(wave_eq, specific_solution))\n        self.wait(2)\n\n        # Explaining the parameters\n        parameters_explanation = Text(\"Here, A is amplitude, k is the wave number, and \u03c9 is the angular frequency\", font_size=24).to_edge(DOWN)\n        self.play(Transform(solution_form, parameters_explanation))\n        self.wait(3)\n\n        # Show boundary conditions\n        boundary_conditions = MathTex(r\"u(0, t) = u(L, t) = 0\")\n        self.play(FadeIn(boundary_conditions), FadeOut(specific_solution), FadeOut(solution_form))\n        self.wait(3)\n\n        # Clear the scene and show a conclusion\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"Wave equations model vibrations and waves.\", font_size=24).to_edge(UP)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion))"
    },
    {
        "query": "Can you create an educational animation that visually teaches how to calculate a basic definite integral, specifically from 1 to 3 for the function x squared, and includes an explanation of the fundamental theorem of calculus and the power rule, while clearly demonstrating each step of the integration process with written math equations and commentary, with each step appearing after the previous one completes, and ends by presenting the simplified final result of the definite integral calculation?",
        "answer": "\\n from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        li_ion = lithium_ion()\n        elctron = electron()\n        mtl_oxid = metal_oxid(4, 5)\n\n        # Place lithium ion at the top left corner\n        li_ion.move_to(UP + LEFT)\n\n        # Place electron at the bottom right corner\n        elctron.move_to(DOWN + RIGHT)\n\n        # Position metal oxide grid in the center\n        mtl_oxid.move_to(ORIGIN)\n\n        # Add to scene\n        self.add(li_ion, elctron, mtl_oxid)\n\n        # Move lithium ion and electron towards the metal oxide grid\n        self.play(\n            li_ion.animate.move_to(mtl_oxid[0].get_center()),\n            elctron.animate.move_to(mtl_oxid[-1].get_center()),\n            run_time=2\n        )\n\n        # Show a reaction happening\n        self.play(\n            Flash(mtl_oxid[0].get_center()),\n            Flash(mtl_oxid[-1].get_center()),\n            run_time=1\n        )\n\n        # Remove lithium ion and electron from the scene\n        self.play(\n            FadeOut(li_ion),\n            FadeOut(elctron),\n            run_time=1\n        )\n\n        # Highlight the change in the metal oxide grid after the reaction\n        self.play(\n            mtl_oxid.animate.set_opacity(0.5),\n            run_time=1\n        )\n\n        # Keep the final state for a while before ending the scene\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that illustrates and explains the heat equation, including how it represents the distribution of heat over time, provides an example of a specific solution, discusses the importance of initial and boundary conditions, and shows what a steady-state solution looks like?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title of the example\n        title = Text(\"Fourier Series Example\", font_size=36)\n        self.play(Write(title))\n        self.wait(2)\n        self.play(FadeOut(title))\n        \n        # Displaying Fourier Series Definition\n        fourier_series_def = MathTex(\n            r\"f(x) = a_0\",\n            r\"+ \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\"\n        )\n        self.play(Write(fourier_series_def))\n        self.wait(2)\n\n        # Coefficients explanation\n        coefficients_explanation = Text(\n            \"Coefficients are calculated based on function's periodicity\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Write(coefficients_explanation))\n        self.wait(3)\n        \n        # Transition to specific example\n        specific_example = Text(\n            \"For a square wave, coefficients have distinct values\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Transform(coefficients_explanation, specific_example))\n        self.wait(3)\n\n        # Displaying the square wave's Fourier Series\n        square_wave_fs = MathTex(\n            r\"f(x) = \\frac{4}{\\pi}\",\n            r\"\\sum_{n=1,3,5}^{\\infty} \\frac{(-1)^{(n-1)/2}}{n} \\sin(nx)\"\n        )\n\n        self.play(ReplacementTransform(fourier_series_def, square_wave_fs))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(square_wave_fs), FadeOut(specific_example))\n        self.wait(1)"
    },
    {
        "query": "I want an educational animation that visually explains the process of evaluating the definite integral of the function x cubed from 2 to 3. Start by simply displaying the integral problem. Then, introduce a step where the power rule for integration is explained, followed by demonstrating it with the generic power rule formula. Afterwards, show the calculation of the integral's limits. Next, display the evaluated integral with its limits substituted in. After that, I'd like a transition to an explanation that simplifies the result, breaking down the arithmetic simplification step by step. Eventually, present the final simplified answer, and conclude by clearing everything else away, leaving just the final integral value on the screen. The steps should build upon each other, each accompanied by a wait time to give viewers a moment to understand the content before moving on to the next step.",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer, EmbeddingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass VAECodeSnippetScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make image object\n            image = Image.open('images/image.jpeg')\n            numpy_image = np.asarray(image)\n            # Make Neural Network\n            nn = NeuralNetwork([\n                ImageLayer(numpy_image, height=1.2),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.2),\n            ], layer_spacing=0.1)\n            self.add(nn)\n            # Play animation\n            self.play(\n                nn.make_forward_pass_animation()\n            )\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            # background_stroke_color=WHITE,\n            insert_line_no=False,\n            background=\"window\",\n            # font=\"Monospace\",\n            style=\"one-dark\",\n            language=\"py\",\n        )\n        code.scale(0.2)\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\", point_radius=0.04).scale(\n            1.0\n        )\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.0),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.0),\n            ],\n            layer_spacing=0.1,\n        )\n\n        nn.scale(0.65)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.rotate(-PI / 2)\n        nn.all_layers[0].image_mobject.rotate(PI / 2)\n        # nn.all_layers[0].image_mobject.shift([0, -0.4, 0])\n        nn.all_layers[-1].image_mobject.rotate(PI / 2)\n        # nn.all_layers[-1].image_mobject.shift([0, -0.4, 0])\n        nn.shift([1.5, 0.0, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(1.9)\n        code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(), run_time=10)\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Neural Network\n    nn_scene = VAECodeSnippetScene()\n    nn_scene.render()"
    },
    {
        "query": "I would like to create an educational animation that explains the one-dimensional wave equation and its solutions. Can you show the wave equation first, followed by a textual explanation saying \"This is the one-dimensional wave equation\"? After that, replace the wave equation with its general solution and change the explanation to indicate that the solution represents waves traveling in opposite directions. Then, I'd like to move on to show an example of a specific sinusoidal wave solution and update the textual explanation accordingly. To wrap things up, could you clear the screen and then conclude by showing the specific sinusoidal wave solution once more?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and area to find\n        function = MathTex(r\"f(x) = 3 - x^2\")\n        area_problem = MathTex(r\"\\int_{-1}^{2} (3 - x^2) \\,dx\", color=BLUE)\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Transform(function, area_problem))\n        self.wait(1)\n\n        # Explain the graph\n        graph_explanation = Text(\"This represents the area under the curve \\nfrom x = -1 to x = 2\", font_size=24).to_edge(UP)\n        self.play(Write(graph_explanation))\n        self.wait(2)\n\n        # Show the graph\n        axes = Axes(x_range=[-3, 3], y_range=[-1, 4])\n        graph = axes.plot(lambda x: 3 - x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=[-1, 2], color=BLUE, opacity=0.3)\n        graph_group = VGroup(axes, graph, area)\n        self.play(FadeIn(graph_group))\n        self.wait(2)\n\n        # Perform the integration\n        integral_result = MathTex(r\"=\\left[3x - \\frac{x^3}{3}\\right]_{-1}^{2}\")\n        integral_value = MathTex(r\"= \\left[6 - \\frac{8}{3}\\right] - \\left[-3 + \\frac{1}{3}\\right]\")\n        solution = MathTex(r\"= \\frac{16}{3} - (-\\frac{8}{3})\")\n        final_solution = MathTex(r\"= \\frac{24}{3} = 8\")\n        \n        self.play(Write(integral_result))\n        self.wait(1)\n        self.play(Transform(integral_result, integral_value))\n        self.wait(1)\n        self.play(Transform(integral_result, solution))\n        self.wait(1)\n        self.play(Transform(integral_result, final_solution))\n        self.wait(1)\n\n        # Conclusion\n        self.clear()\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation that visually demonstrates how to evaluate a triple integral step by step. Start with the integral of r^2 sin(theta) from 0 to 1 with respect to r, then from 0 to pi with respect to theta, and finally from -1 to 1 with respect to z. Guide me through each integration stage with on-screen text explanations above the integral, showing how the integral simplifies at each stage. Once the final integration is done, please clear the screen and display the final evaluated result of the triple integral.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function f(x)\n        function_label = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_label))\n        self.wait(1)\n\n        # Show the area we want to find\n        area_description = Text(\"Find area under curve from x=0 to x=1\", font_size=24).to_edge(UP)\n        self.play(Write(area_description))\n        self.wait(2)\n\n        # Set up the curve and area\n        graph = FunctionGraph(lambda x: x**2, x_range=[0, 1], color=BLUE)\n        area = graph.get_riemann_rectangles(x_range=[0, 1], dx=0.1,\n                                            stroke_width=0.1, stroke_color=ORANGE,\n                                            fill_opacity=0.75)\n        self.play(Create(graph))\n        self.wait(1)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Display the definite integral\n        integral = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(ReplacementTransform(area_description, integral))\n        self.wait(2)\n\n        # Calculate the solution\n        solution = MathTex(r\"=\\frac{1}{3}x^3 \\bigg|_0^1\", \"=\", r\"\\frac{1}{3}\")\n        self.play(Write(solution))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that shows the step-by-step integration of the function e to the power of 2x? Begin by displaying the integral of e^(2x) with respect to x. Then, add a text explanation above that says \"Let u = 2x\". Next, show the transformed integral with the substitution u for 2x and a coefficient of 1/2 outside the integral. After that, replace the text with a new explanation \"Integrate with respect to u\". Finally, show the resulting expression of the integration, adding the constant of integration C, and then clear the screen to only display the final integrated solution. Make sure to pause briefly between each step to allow the viewers to follow along.",
        "answer": "\\n import numpy as np\nfrom manim import *\n\nMOON_ORBIT_WIDTH = 2.5\nMOON_ORBIT_HEIGHT = 0.3\nMOON_RATE = 0.15\nEARTH_DAY_START = 0.5\nMOON_PHASE_CHANGE_RATE = 1.2\nLUNAR_MONTH = 29.5\n\nclass MoonPhaseScene(Scene):\n    def construct(self):\n        # Earth setup\n        earth = Dot(point=ORIGIN, color=BLUE)\n        self.add(earth)\n        \n        # Moon orbit path setup\n        moon_orbit = Ellipse(width=MOON_ORBIT_WIDTH, height=MOON_ORBIT_HEIGHT, color=WHITE)\n        moon_path = moon_orbit.move_to(earth.get_center())\n        self.add(moon_path)\n        \n        # Moon setup\n        moon_tracker = ValueTracker(EARTH_DAY_START)\n        moon = Dot(color=WHITE)\n        moon.move_to(moon_orbit.point_from_proportion(EARTH_DAY_START))\n        \n        # Moon updater\n        def update_moon(m, dt):\n            phase_progress = (moon_tracker.get_value() / LUNAR_MONTH) % 1\n            m.become(Dot(point=moon_orbit.point_from_proportion(phase_progress), color=WHITE))\n            moon_tracker.increment_value(MOON_RATE * dt)\n        \n        moon.add_updater(update_moon)\n        self.add(moon)\n        \n        # Moon Phases\n        phases_group = VGroup()\n        for i in range(8):\n            phase_pos = moon_orbit.point_from_proportion(i / 8)\n            phase_dot = Dot(point=phase_pos, color=YELLOW).scale(0.5)\n            phases_group.add(phase_dot)\n        \n        self.add(phases_group)\n\n        moon_phase_names = [\n            \"New Moon\", \"Waxing Crescent\", \"First Quarter\", \"Waxing Gibbous\",\n            \"Full Moon\", \"Waning Gibbous\", \"Last Quarter\", \"Waning Crescent\",\n        ]\n\n        # Moon phase labels\n        for i, phase_name in enumerate(moon_phase_names):\n            label = Text(phase_name, font_size=20).next_to(phases_group[i], DOWN)\n            self.add(label)\n        \n        # Running the scene\n        self.wait(LUNAR_MONTH / MOON_PHASE_CHANGE_RATE)"
    },
    {
        "query": "Please create an educational animation using a graphical representation to explain the concept of the area under a curve. First, show a graph of a simple quadratic function, such as y = x^2, and highlight the area under the curve from x = 0 to x = 2. Then, add a label to the curve mentioning its equation. After that, overlay textual explanation indicating that this is the area under the curve. Finally, clear the animation to only keep the text explanation on the screen for further emphasis. Make sure the entire sequence is paced with pauses so that a viewer can follow along easily.",
        "answer": "\\n from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Create an atom with electrons orbiting around a nucleus made of protons and neutrons\n        nucleus = VGroup(*[self.proton() for _ in range(6)], *[self.neutron() for _ in range(6)]).arrange_in_grid(buff=0.1)\n        electron_orbit = Circle(color=BLUE).surround(nucleus)\n        electrons = VGroup(*[self.electron() for _ in range(6)]).move_to(electron_orbit.points[::int(len(electron_orbit.points)/6)])\n\n        atom = VGroup(nucleus, electron_orbit, electrons)\n        self.play(Create(nucleus), Create(electron_orbit), *([FadeIn(e) for e in electrons]))\n        self.wait(2)\n\n        # Make electrons orbit around the nucleus\n        orbits = self.get_orbit_animations(electrons, electron_orbit)\n        self.play(AnimationGroup(*orbits, lag_ratio=0.5))\n\n        self.wait(2)\n\n    def proton(self) -> Mobject:\n        return self.circle_with_text(\n            0.2, \"p$^+$\", RED_D, font_size=18, font_color=WHITE, stroke_width=2, fill_color=RED_D\n        )\n\n    def neutron(self) -> Mobject:\n        return self.circle_with_text(\n            0.2, \"n$^0$\", GREY_B, font_size=18, font_color=WHITE, stroke_width=2, fill_color=GREY_B\n        )\n\n    def electron(self) -> Mobject:\n        return self.circle_with_text(\n            0.15, \"e$^-$\", BLUE_E, font_size=24, font_color=BLACK, stroke_width=1, fill_color=BLUE_E\n        )\n\n    def circle_with_text(\n        self, r: float, txt: str, color, font_size: int, font_color, stroke_width: int, fill_color\n    ) -> Mobject:\n        c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color).move_to(c.get_center())\n        return VGroup(c, t)\n\n    def get_orbit_animations(self, electrons, orbit):\n        animations = []\n        for electron in electrons:\n            animations.append(Rotate(electron, angle=2*PI, about_point=orbit.get_center(), rate_func=linear))\n        return animations"
    },
    {
        "query": "Could you create an animation that visually demonstrates how to solve a triple integral step by step, particularly the integral of xyz from 0 to 1 with respect to x, y, and z? I'd like to see the integral displayed, then an explanation of integrating with respect to x first, followed by y, and then z, with each step showing the intermediate results. Finally, display the final solved value.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function\n        func_graph = self.get_graph(lambda x: x**2, color=WHITE)\n        area = self.get_area(func_graph, x_min=0, x_max=2)\n        \n        # Display the area text\n        area_text = MathTex(r\"\\int_0^2 x^2 \\,dx\").next_to(area, DOWN)\n        \n        # Show the function and area\n        self.play(Create(func_graph), FadeIn(area), Write(area_text))\n        self.wait(2)\n\n        # Show the area calculation\n        calculation = MathTex(r\"= \\frac{1}{3}x^3\\Big|_0^2\").to_edge(UP)\n        self.play(Write(calculation))\n        self.wait(1)\n\n        # Show calculated result\n        result = MathTex(r\"=\\frac{8}{3}\").next_to(calculation, DOWN)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear scene\n        self.play(FadeOut(func_graph), FadeOut(area), FadeOut(area_text), FadeOut(calculation), FadeOut(result))\n        self.wait(1)\n\n    def get_graph(self, function, color):\n        return FunctionGraph(function, color=color)\n\n    def get_area(self, graph, x_min, x_max):\n        return graph.get_area(x_min=x_min, x_max=x_max)"
    },
    {
        "query": "Can you create an educational animation using Manim that starts by writing the function f(x) = x^2 at the top of the screen? After showing the function, can it plot the graph of the function for x going from -2 to 2? Once the graph is displayed, I would like the animation to indicate the area under the curve specifically between x = 0 and x = 1 with a label showing the integral of x^2 from 0 to 1 written below the graph. Can the animation then fill this area with a gradient from blue to green while maintaining some transparency, followed by the transformation of the integral label into the exact value of the area calculated, which is 1/3, and placing this solution at the bottom of the screen? Lastly, can the animation clear the screen and display only the final solution for a brief moment before ending?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function to be integrated\n        function_tex = MathTex(r\"y = x^2\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Draw the graph\n        axes = Axes(\n            x_range=[-1, 3],\n            y_range=[-1, 9],\n            axis_config={\"color\": BLUE},\n        )\n\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Display the area problem\n        area_problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        area_problem.to_edge(UP)\n        self.play(Transform(function_tex, area_problem))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = axes.get_area(graph, x_range=(0, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Show the result of the integration\n        result = MathTex(r\"= \\frac{1}{3} x^3 \\Big|_0^2 = \\frac{8}{3}\")\n        self.play(Write(result))\n        self.wait(1)\n\n        # Clear the scene and display only the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(result))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video tutorial that explains how to solve a surface integral problem, including the steps of parameterizing the surface, computing the surface element, converting the integral into a more solvable form, and then finding the final solution? Specifically, can the video demonstrate solving the integral of a function over a spherical surface, starting with the integral of (x^2 + y^2) over a sphere, parameterizing the sphere using spherical coordinates (theta and phi), finding the expression for the surface element in these coordinates, substituting into the integral, and performing the integration to arrive at the final result? Additionally, can each step in the tutorial be accompanied by a written explanation on the screen that guides viewers through the problem-solving process?",
        "answer": "\\n from manim import *\n\nclass CircleToSquare(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        self.play(Create(circle))\n        self.wait(1)\n\n        # Transform the circle into a square\n        square = Square()\n        self.play(ReplacementTransform(circle, square))\n        self.wait(1)\n\n        # Animate the square changing color\n        self.play(square.animate.set_fill(BLUE, opacity=0.5))\n        self.wait(1)\n\n        # Rotate the square\n        self.play(Rotate(square, PI / 4))\n        self.wait(1)\n\n        # Clear the scene and fade in a text\n        self.clear()\n        final_text = Text(\"Transformation complete!\", font_size=36)\n        self.play(FadeIn(final_text))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an educational animation that visually explains the process for solving a quadratic equation using the quadratic formula. Could you show the quadratic equation, then introduce the quadratic formula, and finally display the possible solutions for the roots of the equation? Additionally, I want each step to be accompanied by brief explanations and the entire animation should end with a statement that highlights the concluded solutions.",
        "answer": "\\n class AnimateProblem(Scene):\n    def construct(self):\n        left_square = Square()\n        right_square = Square()\n        VGroup(left_square, right_square).arrange(RIGHT, buff=1)\n        self.add(left_square, right_square)\n        self.play(left_square.animate.rotate(PI), Rotate(right_square, PI), run_time=2)"
    },
    {
        "query": "Can you create an educational animation that explains the harmonic oscillator using simple mathematical equations, including the mass-spring system differential equation, its characteristic equation, the roots of the characteristic equation, and the general solution, with brief descriptions for each step?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation of the wave equation\n        explanation1 = Text(\"This is a second-order wave equation for u(x,t).\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution explanation\n        explanation2 = Text(\"The general solution is of the form u(x, t) = f(x - ct) + g(x + ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(1)\n\n        # Explanation for specific solution using initial conditions\n        explanation3 = Text(\"Specific solutions require initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude with the general solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates how to calculate the area under the curve of the function f(x) = 0.1x^2 from x=0 to x=2, using Riemann rectangles to approximate the area, and then step by step showing the exact calculation using the definite integral? I'd like to see the function plotted on a coordinate system, followed by the animated appearance of the Riemann rectangles, the writing of the definite integral on the screen, a step-by-step presentation of the integral's calculation, and finally the presentation of the numerical result of the area. After that, please clear the animation and then show only the graph with the shaded area under it as well as the final computed area value displayed.",
        "answer": "\\n from manim import *\n\nclass MoleculeAnimation(Scene):\n    def construct(self):\n        # Create an oxygen molecule\n        oxygen_molecule = self.create_oxygen_molecule()\n\n        # Center the oxygen molecule on the screen\n        oxygen_molecule.move_to(ORIGIN)\n\n        # Animate the construction of the molecule\n        self.play(FadeIn(oxygen_molecule))\n        self.wait(1)\n\n        # Rotate the molecule\n        self.play(Rotate(oxygen_molecule, angle=PI))\n        self.wait(1)\n\n        # Scale the molecule\n        self.play(oxygen_molecule.animate.scale(2))\n        self.wait(1)\n\n        # Disappearance of the molecule\n        self.play(FadeOut(oxygen_molecule))\n        self.wait(1)\n\n    def create_oxygen_molecule(self) -> Mobject:\n        # Draw two oxygen atoms\n        oxygen_atom_1 = self.create_atom('O', RED)\n        oxygen_atom_2 = self.create_atom('O', RED)\n\n        # Place the second oxygen to the right of the first\n        oxygen_atom_2.next_to(oxygen_atom_1, RIGHT, buff=1)\n\n        # Draw a double bond between atoms\n        bond_1 = Line(oxygen_atom_1.get_center(), oxygen_atom_2.get_center()).shift(UP*0.1)\n        bond_2 = Line(oxygen_atom_1.get_center(), oxygen_atom_2.get_center()).shift(DOWN*0.1)\n\n        # Create a VGroup for the oxygen molecule\n        oxygen_molecule = VGroup(oxygen_atom_1, oxygen_atom_2, bond_1, bond_2)\n        return oxygen_molecule\n\n    def create_atom(self, text, color) -> Mobject:\n        # Draw an atom as a circle with text inside\n        atom_circle = Circle(color=color).set_fill(color, opacity=0.5)\n        atom_text = Text(text, color=WHITE).scale(0.7)\n        atom = VGroup(atom_circle, atom_text)\n        return atom"
    },
    {
        "query": "Can you create an educational animation that visually walks through the process of solving the integral of e raised to the power of 2x using u-substitution including explanations at each step?",
        "answer": "\\n from manim import *\n\nclass CubicFunctionApproximation(Scene):\n    def construct(self):\n        axis = Axes(\n            x_range=[-3, 3],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Original function\n        original_function = axis.plot(lambda x: x**3, color=GREEN)\n        original_function_label = axis.get_graph_label(original_function, label='x^3')\n\n        self.play(Create(axis), Create(original_function), Write(original_function_label))\n        self.wait(2)\n\n        # Linear approximation\n        linear_approx = axis.plot(lambda x: 3*x - 2, color=RED)\n        linear_approx_label = axis.get_graph_label(linear_approx, label='3x-2', x_val=-2, direction=UP)\n\n        self.play(Create(linear_approx), Write(linear_approx_label))\n        self.wait(1)\n\n        # Quadratic approximation\n        quadratic_approx = axis.plot(lambda x: x**2 - 2*x + 1, color=ORANGE)\n        quadratic_approx_label = axis.get_graph_label(quadratic_approx, label='x^2-2x+1', x_val=0, direction=UP)\n\n        self.play(ReplacementTransform(linear_approx, quadratic_approx), Transform(linear_approx_label, quadratic_approx_label))\n        self.wait(1)\n\n        # Cubic approximation\n        cubic_approx = axis.plot(lambda x: 0.1*x**3 + 0.2*x**2 - 0.5*x - 1, color=PURPLE)\n        cubic_approx_label = axis.get_graph_label(cubic_approx, label='0.1x^3+0.2x^2-0.5x-1', x_val=-1, direction=UP)\n\n        self.play(ReplacementTransform(quadratic_approx, cubic_approx), Transform(quadratic_approx_label, cubic_approx_label))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion with the cubic approximation\n        self.play(Write(cubic_approx), Write(cubic_approx_label))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the concept of finding a tangent line to a parabola at a specific point. The animation should start by presenting the problem where we have the parabola described by the equation y = x^2 and we want to find the equation of the tangent line at the point P(2, 4). Show the graph of the parabola and highlight the point P in a distinct color. \n\nNext, draw the tangent line at point P and make sure that the line is visually distinct from the parabola. Accompany this process with explanatory text that guides viewers through using the derivative of the function to determine the slope of the tangent line. \n\nShow the mathematical steps for calculating the derivative of y = x^2, and indicate how we find the slope specifically at point P, x = 2, showcasing the slope calculation and substitution. \n\nOnce the slope is determined, present the equation of the tangent line in slope-intercept form. End the animation by clearly displaying the final equation of the tangent line on the screen alone. Make the explanation and visuals engaging and easy to understand for an audience unfamiliar with calculus or derivatives.",
        "answer": "\\n from manim import *\n\nclass SurfaceAreaPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} \\sqrt{1+r^2} r dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"=\\int_{0}^{2\\pi} \\left[\\frac{r}{2}\\sqrt{1+r^2}+\\frac{\\ln|r+\\sqrt{1+r^2}|}{2} \\right]_0^1 d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\\\(\\\\theta\\\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"=\\left[\\frac{\\theta}{2}\\left(\\sqrt{2}+\\ln(1+\\sqrt{2})\\right)\\right]_0^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\pi\\left(\\sqrt{2}+\\ln(1+\\sqrt{2})\\right)\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an educational animation that first displays the partial differential equation known as the wave equation. Then, I want to show a brief text description explaining that this equation describes the propagation of waves. After this, I want to transition to showing the general solution of the wave equation using arbitrary functions. It should be followed by another text description that clarifies that these arbitrary functions represent the waveforms. Lastly, I'd like to see an example solution to the wave equation involving a sine function to represent a monochromatic plane wave, finishing with a brief descriptive text about this specific example. All of this should be animated with enough time between each part so that viewers can clearly understand the information presented. Can you help me make this educational animation using Manim?",
        "answer": "\\n from manim import *\n\nclass ChemistryScene(Scene):\n    def construct(self):\n        oxygen_molecule = VGroup(oxygen(), oxygen()).arrange(RIGHT, buff=1)\n        electron_pair = electron()\n        carbon_molecule = carbon_layer()\n\n        self.play(AnimationGroup(\n            FadeIn(oxygen_molecule),\n            FadeIn(electron_pair, shift=DOWN),\n            FadeIn(carbon_molecule, shift=UP),\n            lag_ratio=0.5\n        ))\n        self.wait(1)\n\n        path = ArcBetweenPoints(oxygen_molecule[0].get_center(), carbon_molecule.get_center(), angle=-TAU/4)\n        self.play(MoveAlongPath(electron_pair, path), run_time=2)\n        self.wait(1)\n\n        reaction_product = VGroup(oxygen_molecule, carbon_molecule, electron_pair).arrange(DOWN)\n\n        self.play(TransformMatchingShapes(VGroup(oxygen_molecule, electron_pair, carbon_molecule), reaction_product))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that first shows the mathematical definition of a Fourier series, then provides a brief textual explanation of what Fourier series are, followed by an example using a square wave approximation, and finally mentions how increasing the number of terms improves the approximation? Also, can the animation clear the screen towards the end and then conclude by reiterating the square wave example?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and the area problem\n        function = MathTex(r\"f(x) = x^2\")\n        area_under_curve_text = MathTex(r\"\\int_0^2 x^2 \\,dx\").next_to(function, DOWN)\n        self.play(Write(function), Write(area_under_curve_text))\n        self.wait(1)\n\n        # Explanation for calculating the area\n        explanation1 = Text(\"Find the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"\\int_0^2 x^2 \\,dx = \\frac{x^3}{3} \\bigg|_0^2\")\n        self.play(ReplacementTransform(area_under_curve_text, integration_step))\n        self.wait(1)\n\n        # Explanation for definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3} = \\frac{8}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation demonstrating the calculation of the area under a quadratic curve. First, display the function f(x) = x^2. Then show the formula for the area A as the definite integral of x^2 from a to b. Next, visually represent the area under the curve between x = 0 and x = 2. After that, illustrate the integration process by transforming the area formula to the antiderivative form A = 1/3 x^3 evaluated from a to b. Subsequently, show the substitution of the limits into the antiderivative, which simplifies to A = 1/3 (b^3 - a^3). End the animation with a clear and final display of the simplified area formula. Afterward, clear the animation and show the final answer alone for emphasis.",
        "answer": "\\n from manim import *\n\nclass AreaUnderGraphExample(Scene):\n    def construct(self):\n        # Display the graph of the function\n        axes = Axes(\n            x_range=[0, 3],\n            y_range=[0, 4],\n            x_length=5,\n            y_length=3,\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        \n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Highlight the area under the graph\n        area = axes.get_area(graph, x_range=(0, 2), color=YELLOW, opacity=0.3)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Calculate the area under the graph\n        integral = MathTex(r\"\\int_0^2 x^2 \\, dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Show the integral result\n        integral_result = MathTex(r\"= [\\frac{1}{3}x^3]_0^2\")\n        self.play(Transform(integral, integral_result))\n        self.wait(2)\n\n        integral_value = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(Transform(integral_result, integral_value))\n        self.wait(2)\n\n        # Show the conclusion\n        conclusion = Text(\"The area under x^2 from 0 to 2 is 8/3\", font_size=24)\n        conclusion.to_edge(DOWN)\n\n        self.play(Write(conclusion))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final area value\n        self.play(Write(integral_value))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an educational animation that explains the process of solving a third-order linear homogeneous differential equation with constant coefficients. Can you illustrate the steps starting from the initial equation y''' - 3y'' + 3y' - y = 0, converting it into the characteristic equation r^3 - 3r^2 + 3r - 1 = 0, finding the roots of the characteristic equation, and then presenting the general solution to the original differential equation in the form y = (C_1 + C_2 x + C_3 x^2) e^x? Also, please include explanatory text for each step for clarity.",
        "answer": "\\n from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef add_to_back(self, *mobjects):\n    all_mobjects = [*self.mobjects]\n\n    self.remove(*self.mobjects)\n    self.add(*mobjects, *all_mobjects)\n\nclass GraphThree(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Lucro mensal em reais\", color=BLACK)\n        axes = Axes(\n            (0, 7), \n            (0, 9000, 1000), \n            x_length=7, \n            y_length=7, \n            axis_config={\"color\": BLACK, \"include_tip\": False},\n            y_axis_config={\"include_numbers\": True},\n            x_axis_config={\"numbers_to_include\": [1, 2, 3, 4, 5, 6]}\n        )\n        axes.y_axis.set(color=BLACK)\n        axes.x_axis.add_labels({\n            1: Tex(\"Janeiro\", color=BLACK),\n            2: Tex(\"Fevereiro\", color=BLACK),\n            3: Tex(\"Mar\u00e7o\", color=BLACK),\n            4: Tex(\"Abril\", color=BLACK),\n            5: Tex(\"Maio\", color=BLACK),\n            6: Tex(\"Junho\", color=BLACK)\n        }, font_size=24)\n        axes.shift(0.5 * RIGHT)\n        title.next_to(axes, UP, buff=0.3)\n        title.shift(0.5 * RIGHT)\n        auxiliary_lines = VGroup(\n            Line(axes.coords_to_point(0, 1000, 0), axes.coords_to_point(7, 1000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 2000, 0), axes.coords_to_point(7, 2000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 3000, 0), axes.coords_to_point(7, 3000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 4000, 0), axes.coords_to_point(7, 4000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 5000, 0), axes.coords_to_point(7, 5000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 6000, 0), axes.coords_to_point(7, 6000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 7000, 0), axes.coords_to_point(7, 7000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 8000, 0), axes.coords_to_point(7, 8000, 0), color=BLACK, stroke_width=1),\n            Line(axes.coords_to_point(0, 9000, 0), axes.coords_to_point(7, 9000, 0), color=BLACK, stroke_width=1)\n        )\n        points = VGroup(\n            Dot(axes.coords_to_point(1, 5000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(2, 3000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(3, 7000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(4, 8000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(5, 6000, 0), color=LIGHT_BLUE_COLOR),\n            Dot(axes.coords_to_point(6, 5000, 0), color=LIGHT_BLUE_COLOR)\n        )\n        lines = VGroup()\n\n        self.play(\n            Write(title),\n            Write(axes), \n            run_time=1\n        )\n        self.play(\n            LaggedStart(\n                *[Create(point) for point in points],\n                lag_ratio=0.2,\n                run_time=1\n            )\n        )\n\n        add_to_back(self, auxiliary_lines)\n        self.play(FadeIn(auxiliary_lines), run_time=0.5)\n\n        for i in range(5):\n            lines += Line(points[i], points[i + 1], color=LIGHT_BLUE_COLOR)\n            self.play(Create(lines[i]), run_time=0.2)\n\n        # Jan to Feb\n        self.play(\n            points[0].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[1].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            lines[0].animate.set(color=LIGHT_RED_COLOR),\n            run_time=0.5\n        )\n        self.wait(1.2)\n        self.play(\n            points[0].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[1].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            lines[0].animate.set(color=LIGHT_BLUE_COLOR),\n            run_time=0.5\n        )\n        # Feb to Apr\n        self.play(\n            points[1].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[2].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[3].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            lines[1].animate.set(color=LIGHT_RED_COLOR),\n            lines[2].animate.set(color=LIGHT_RED_COLOR),\n            run_time=0.5\n        )\n        self.wait(1.2)\n        self.play(\n            points[1].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[2].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[3].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            lines[1].animate.set(color=LIGHT_BLUE_COLOR),\n            lines[2].animate.set(color=LIGHT_BLUE_COLOR),\n            run_time=0.5\n        )\n        # Apr to June\n        self.play(\n            points[3].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[4].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            points[5].animate.set(color=LIGHT_RED_COLOR).scale(1.3),\n            lines[3].animate.set(color=LIGHT_RED_COLOR),\n            lines[4].animate.set(color=LIGHT_RED_COLOR),\n            run_time=0.5\n        )\n        self.wait(1.2)\n        self.play(\n            points[3].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[4].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            points[5].animate.set(color=LIGHT_BLUE_COLOR).scale(1/1.3),\n            lines[3].animate.set(color=LIGHT_BLUE_COLOR),\n            lines[4].animate.set(color=LIGHT_BLUE_COLOR),\n            run_time=0.5\n        )\n\n        self.play(FadeOut(Group(*self.mobjects)), run_time=0.7)"
    },
    {
        "query": "I would like to create an educational animation that visually represents the area under a curve for a simple quadratic function. Can you show the graph of y=0.1x\u00b2 from x=-1 to x=5, highlight the area under the curve from x=0 to x=4, and then step by step, present the integral calculation of that area on the same graph? After the calculation, can you simplify the result of the integration and finally clear the animation screen?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the given double integral\n        problem = MathTex(r\"\\int_0^1 \\int_{-1}^1 (x^2 + y^2) dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the integration with respect to y\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration over y\n        inner_integral = MathTex(r\"= \\int_0^1 \\left[\\frac{1}{3}y^3 + xy^2 \\right]_{-1}^1 dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explaining the integration with respect to x\n        explanation2 = Text(\"Now integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the inner integral\n        evaluated_inner = MathTex(r\"= \\int_0^1 \\left(\\frac{2}{3} + 2x\\right) dx\")\n        self.play(ReplacementTransform(inner_integral, evaluated_inner))\n        self.wait(1)\n\n        # Explaining the final integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution to the integral\n        final_solution = MathTex(r\"= \\left[ \\frac{2}{3}x + x^2 \\right]_0^1\")\n        self.play(ReplacementTransform(evaluated_inner, final_solution))\n        self.wait(2)\n\n        # Showing the result of the integral\n        result = MathTex(r\"= 2\")\n        self.play(Write(result))\n        self.wait(2)"
    },
    {
        "query": "Please create an educational animation that visualizes the process of integrating the function sin(x)cos(x) with respect to x. Start by showing the integral of sin(x)cos(x), then introduce the trigonometric identity that sin(2x) is equal to 2sin(x)cos(x), and use it to rewrite the integral. Perform the integration and show the result. Throughout the animation, include pauses to allow the viewer time to understand each step. After completing the integration, clear the screen and present the final integrated result again for emphasis.",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Convolutional2DLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork([\n            Convolutional2DLayer(1, 16, 5, filter_spacing=0.4),\n            Convolutional2DLayer(16, 32, 3, filter_spacing=0.4),\n            FeedForwardLayer(128),\n            FeedForwardLayer(64),\n            FeedForwardLayer(10),\n        ],\n        layer_spacing=0.3,\n        )\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)"
    },
    {
        "query": "Create an educational animation that explains how to calculate the area under the curve y=x^2 from x=0 to x=2 using definite integrals. Start by showing the function on a graph with labeled axes, and then highlight the area under the curve between these two points. Have a textual explanation appear that indicates this is the area under the curve. Then, step by step, go through the process of calculating the definite integral of x^2 from 0 to 2, showing the mathematical notation and the evaluation of the integral. Finally, present the result of the integral calculation on the screen and hold it there. Please ensure the explanation is clear and suitable for someone with a basic understanding of calculus.",
        "answer": "\\n from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef metal() -> Mobject:\n    return circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)"
    },
    {
        "query": "I would like an animated explanation of how to solve a third-order linear homogeneous differential equation with constant coefficients. The equation is y''' - 3y'' + 3y' - y = 0. I want the animation to begin by writing the given equation, followed by deriving the characteristic equation r^3 - 3r^2 + 3r - 1 = 0. Then, show the process of finding the roots of this characteristic equation, which happens to be a triple root of r=1. After that, I want the animation to present the general solution of the differential equation, which is y = C1e^x + C2xe^x + C3x^2e^x. Finally, conclude the animation by emphasizing that what is shown is the general solution to the original differential equation.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function\n        function_tex = MathTex(r\"f(x) = x^2 - 4x + 4\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Show the area problem\n        area_problem = MathTex(r\"\\text{Area} = \\int_0^2 (x^2 - 4x + 4) \\, dx\")\n        self.play(ReplacementTransform(function_tex, area_problem))\n        self.wait(2)\n\n        # Set up the definite integral\n        setup_integral = MathTex(r\"= \\left[ \\frac{x^3}{3} - 2x^2 + 4x \\right]_0^2\")\n        self.play(Transform(area_problem, setup_integral))\n        self.wait(2)\n\n        # Calculate the area\n        calculate_area = MathTex(r\"= \\left( \\frac{8}{3} - 8 + 8 \\right) - \\left( 0 - 0 + 0 \\right)\")\n        self.play(Transform(setup_integral, calculate_area))\n        self.wait(2)\n\n        # Final answer\n        final_area = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(calculate_area, final_area))\n        self.wait(1)\n\n        # Highlighting the final answer\n        self.play(FocusOn(final_area))\n        self.wait(1)\n\n        # Cleanup and show only the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_area))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that visually explains the solution to the differential equation for a simple harmonic oscillator. Start by displaying the equation m*d\u00b2x/dt\u00b2 + kx = 0, followed by a step-by-step explanation of assuming a solution of the form x(t) = A*cos(\u03c9t) + B*sin(\u03c9t), including an explanation on how the angular frequency \u03c9 is related to the equation's constants. Then, show the progression to the general solution involving new constants determined by initial conditions, and finally, close with a statement confirming the solution demonstrates simple harmonic motion.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Setup axes\n        axes = Axes(\n            x_range=[0, 3, 1],\n            y_range=[0, 6, 1],\n            axis_config={\"color\": BLUE},\n        )\n        # Setup function\n        func_graph = axes.plot(lambda x: x**2, color=RED)\n        func_label = axes.get_graph_label(func_graph, label='x^2')\n\n        # Display axes and function\n        self.play(Create(axes), Create(func_graph), Write(func_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = axes.get_area(func_graph, x_range=(0, 2), color=GREEN, opacity=0.3)\n        area_label = MathTex(r\"\\int_0^2 x^2 \\,dx\", color=WHITE).next_to(area, UP)\n        \n        self.play(FadeIn(area), Write(area_label))\n        self.wait(1)\n        \n        # Show the definite integral value\n        answer = MathTex(r\"\\frac{8}{3}\", color=WHITE).next_to(area_label, DOWN)\n        self.play(Write(answer))\n        self.wait(1)\n\n        # Fade out all elements\n        self.play(FadeOut(axes), FadeOut(func_graph), FadeOut(func_label), FadeOut(area), FadeOut(area_label), FadeOut(answer))\n        self.wait(1)"
    },
    {
        "query": "Create an educational animation that explains how to calculate the area under the curve of the function f(x) = x^2 from x=1 to x=2. Start by displaying the function and then introduce the concept of the definite integral to find the area. Step by step, write out the integral sign with limits a and b, specify the bounds as a=1 and b=2, and then replace a and b with the actual values in the integral. Show the intermediate steps of solving the integral, including evaluating from the lower to the upper limit, and then simplify the result to find the numerical value of the area. Conclude by presenting the final area value clearly and labeling the resulting area under the curve as 7/3 on the screen, with a written conclusion that appears at the bottom. Ensure the animation includes appropriate pauses between steps to allow the viewer to follow along.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define a curve function to integrate\n        curve = lambda x: x**2\n\n        # Represent the curve with a graph\n        graph = Axes(\n            x_range=[0, 2, 0.5],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        ).plot(curve, color=GREEN)\n\n        # Add label to the graph\n        graph_label = graph.get_graph_label(label=MathTex(\"x^2\"), x_val=1, direction=UP)\n        \n        # Make the area to fill under the curve\n        area = graph.get_area(graph, [0, 2])\n\n        # Display the graph\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Fill the area under the curve\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Display the integral representing the area\n        integral_text = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Calculate the area using the antiderivative\n        integral_solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\")\n        self.play(ReplacementTransform(integral_text, integral_solution))\n        self.wait(1)\n\n        solution = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integral_solution, solution))\n        self.wait(1)\n        \n        # Clear the scene and display the solution\n        self.clear()\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated video that introduces the exponential function, shows its formula, graphs it on a coordinate system, and then explains and displays its derivative. The video should include a title for each part, starting with the function itself and then the derivative. The graph should be clearly visible and colored blue, with the function being plotted across a reasonable range of x values. The video should also pause briefly after presenting each piece of information to give me time to understand what has been shown before moving on to the next part. Can you create that animation for me?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.center\").shift(UP*2.5)), run_time=0.5)\n            square = Square().shift(LEFT*2)\n            self.play(square.animate.center())\n            self.remove(square)"
    },
    {
        "query": "Can you create an educational animation that visually explains the wave equation and its solutions, including d'Alembert's formula? The animation should introduce the classic wave equation, show the general solution form, emphasize the role of arbitrary functions determined by initial conditions, and conclude with d'Alembert's formula as a special solution, while also highlighting what phenomena the wave equation models. Please include textual explanations alongside the mathematical expressions and ensure there are transitions between each step of the explanation.",
        "answer": "\\n from manim import *\n\nclass AnotherScene(Scene):\n    def construct(self):\n        square = Square(color=BLUE)\n        square.rotate(PI / 4)\n        self.play(Create(square))\n        self.wait(1)\n        self.play(Transform(square, Circle()))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the Pythagorean theorem by showing a right triangle with sides labeled 'a', 'b', and 'c' where 'c' is the hypotenuse? Alongside each side of the triangle, display a square with side lengths equal to the corresponding sides of the triangle, with the areas 'a^2', 'b^2', and 'c^2' labeled inside the squares. Finally, present the theorem's formula 'a^2 + b^2 = c^2' at the bottom of the screen and then clear everything after a short pause.",
        "answer": "\\n from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        # Create an electron\n        e = electron()\n        # Create an oxygen molecule\n        o2 = oxygen()\n        # Create a metal atom\n        metal_atom = metal()\n        # Create a positive ion\n        pos_ion = positive()\n        # Create a negative ion\n        neg_ion = negative()\n        # Create a metal oxide grid\n        metal_oxide_grid = metal_oxid(rows=3, cols=3)\n        # Create a lithium grid\n        li_grid = lithium_grid(rows=3, cols=3)\n        # Create a carbon grid\n        c_grid = carbon_grid(rows=3)\n        \n        # Creating and adding several elements to the scene\n        self.add(e)\n        self.add(o2.move_to(UP * 2))\n        self.add(metal_atom.move_to(UP * 2 + RIGHT * 2))\n        self.add(pos_ion.move_to(UP * 2 + RIGHT * 4))\n        self.add(neg_ion.move_to(UP * 2 + LEFT * 2))\n        self.add(metal_oxide_grid.move_to(DOWN * 2))\n        self.add(li_grid.move_to(DOWN * 2 + RIGHT * 4))\n        self.add(c_grid.move_to(DOWN * 2 + LEFT * 4))"
    },
    {
        "query": "Could you please create an educational animation for me that shows the area under the curve y = x^2, from x=0 to x=2, using a blue and green gradient to fill the area? Also, include a set of axes with blue lines, label the curve and the area, and have the elements fade out at the end. I'd like a step-by-step animation where the axes and the curve are drawn first, followed by the labels, then the area filled in, and finally everything fades out.",
        "answer": "\\n from manim import *\n\n\nclass HamiltonianCycle(Scene):\n    def construct(self):\n        dots = [Dot(z_index=30) for _ in range(20)]\n        for ind, dot in enumerate(dots[:5]):\n            dot.move_to(\n                3.75\n                * (\n                    np.cos(ind / 5 * TAU + TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU + TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[5:10]):\n            dot.move_to(\n                2.75\n                * (\n                    np.cos(ind / 5 * TAU + TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU + TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[10:15]):\n            dot.move_to(\n                1.5\n                * (\n                    np.cos(ind / 5 * TAU - TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU - TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[15:]):\n            dot.move_to(\n                0.75\n                * (\n                    np.cos(ind / 5 * TAU - TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU - TAU / 4) * UP\n                )\n            )\n        lines = (\n            [\n                Line(dots[k].get_center(), dots[(k + 1) % 5].get_center())\n                for k in range(5)\n            ]\n            + [Line(dots[k].get_center(), dots[5 + k].get_center()) for k in range(5)]\n            + [\n                Line(dots[5 + k].get_center(), dots[10 + (k + 2) % 5].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[5 + k].get_center(), dots[10 + (k + 3) % 5].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[10 + k].get_center(), dots[15 + k].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[15 + k].get_center(), dots[15 + (k + 1) % 5].get_center())\n                for k in range(5)\n            ]\n        )\n        vgroup = VGroup(*lines, *dots)\n        vgroup.move_to(ORIGIN)\n        self.play(*[ShowCreation(dot) for dot in dots])\n        self.play(*[ShowCreation(line) for line in lines])\n        self.wait(1)\n        cycle_ind = [\n            0,\n            1,\n            2,\n            7,\n            14,\n            6,\n            13,\n            5,\n            12,\n            9,\n            11,\n            16,\n            17,\n            18,\n            19,\n            15,\n            10,\n            8,\n            3,\n            4,\n        ]\n        cycle_lines = []\n        for k in range(len(cycle_ind)):\n            self.play(\n                dots[cycle_ind[k]].set_color, RED, run_time=0.3, rate_function=linear\n            )\n            new_line = Line(\n                dots[cycle_ind[k]].get_center(),\n                dots[cycle_ind[(k + 1) % len(cycle_ind)]].get_center(),\n                color=RED,\n                stroke_width=5,\n            )\n            cycle_lines.append(new_line)\n            self.play(ShowCreation(new_line), run_time=0.65)\n        self.wait(1)\n        self.play(VGroup(vgroup, *cycle_lines).shift, 3 * LEFT)\n        t1 = Tex(\"The graph\")\n        t1.next_to(vgroup, RIGHT)\n        self.play(Write(t1))\n        self.play(\n            ApplyFunction(\n                lambda obj: obj.scale(0.2).next_to(t1, RIGHT).shift(0.4 * UP),\n                VGroup(*lines, *dots).copy(),\n            )\n        )\n        t2 = Tex(\"has a Hamiltonian cycle.\")\n        t2.next_to(t1, DOWN)\n        t2.align_to(t1, LEFT)\n        self.play(Write(t2))\n        self.wait(1)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])"
    },
    {
        "query": "Could you create an animation that demonstrates the process of calculating the area under the parabola y=x^2 from x=0 to x=2, showing each step involved in evaluating the definite integral using calculus, along with explanatory text for each step?",
        "answer": "\\n from manim import *\n\nclass ChemicalElementScene(Scene):\n    def construct(self):\n        # Create an Oxygen atom using a predefined method from the example\n        oxygen_atom = oxygen()\n        \n        # Create a Carbon atom using a predefined method from the example\n        carbon_atom = carbon()\n        \n        # Set new positions for the atoms\n        oxygen_atom.to_edge(UP)\n        carbon_atom.to_edge(DOWN)\n        \n        # Create electron movement around Oxygen\n        electron_obj = electron()\n        electron_obj.move_to(oxygen_atom)\n        electron_movement = self.electron_orbit(oxygen_atom, electron_obj, 1, True)\n        \n        # Show everything on the screen\n        self.play(AnimationGroup(Create(oxygen_atom), Create(carbon_atom), *electron_movement, lag_ratio=0.5))\n        self.wait(2)\n        \n    def electron_orbit(self, around: Mobject, obj: Mobject, run_time: float, clockwise: bool = False) -> list[Animation]:\n        # Creating the orbit path\n        path = Circle(radius=0.5)\n        path.move_to(around)\n        \n        # Creating the Rotate animation for the electron\n        direction = 1 if clockwise else -1\n        electron_orbit_animation = Rotating(obj, radians=direction * TAU, about_point=around.get_center(), run_time=run_time, rate_func=smooth)\n\n        # Align electron to start from the rightmost side of the atom\n        obj.move_to(path.point_from_proportion(0))\n        \n        return [electron_orbit_animation]"
    },
    {
        "query": "Could you create an animated video that explains the concept of calculating a surface integral of a vector field, starting with displaying the surface integral equation, then showing the steps to solve it which includes finding the curl of the vector field, computing the dot product with a differential area element, and finally integrating over the surface to find the flux through the surface?",
        "answer": "\\n from manim import *\n\nclass HydrogenGrid(Scene):\n    def construct(self):\n        h_grid = self.create_hydrogen_grid(5, 7)\n        self.play(ShowCreation(h_grid))\n        self.wait(2)\n\n    def create_hydrogen_grid(self, rows: int, cols: int, scale=1.5) -> VGroup:\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                hydrogen_atom = self.hydrogen(i % 2 == 0).shift(RIGHT * i * scale + UP * j * scale)\n                grid.add(hydrogen_atom)\n        return grid\n\n    def hydrogen(self, isotope: bool) -> Mobject:\n        text = \"D\" if isotope else \"H\"\n        subscript = \"2\" if isotope else \"1\"\n        return Circle(color=BLUE_E).set_stroke(WHITE, 2).set_fill(GREEN_SCREEN, opacity=0.5)\\\n            .surround(Tex(f\"{text}_{{{subscript}}}$^+$\", color=WHITE))\n\nclass ElectronTransition(Scene):\n    def construct(self):\n        electron = Circle(color=YELLOW).scale(0.2)\n        electron.set_fill(YELLOW, opacity=0.8)\n        self.play(ShowCreation(electron))\n        path = Arc(radius=2, start_angle=-TAU/4, angle=-TAU/2)\n        self.play(MoveAlongPath(electron, path), run_time=2, rate_func=there_and_back) \n        self.wait(1) \n\nclass Proton(Scene):\n    def construct(self):\n        proton = Circle(color=RED_E).scale(0.5)\n        proton.set_fill(RED_E, opacity=1)\n        proton_text = Tex(\"p$^+$\", color=WHITE).scale(1.5)\n        proton_group = VGroup(proton, proton_text)\n        self.play(FadeIn(proton_group))\n        self.wait(2)\n        self.play(proton_group.animate.shift(UP*2), run_time=1.5)\n        self.play(proton_group.animate.shift(DOWN*2), run_time=1.5)\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using ManimCE that demonstrates the concept of a limit in calculus? I would like it to include a visual representation of a function, say f(x) = 1/(1+x^2), and show a point labeled 'x = a' moving closer to a particular value 'a' on the function's graph. Then, can you transition to show the mathematical expression of the limit of f(x) as x approaches a, followed by text explaining that we are observing the behavior of f(x) as x approaches the value of a. Finally, display a specific example where 'a' is equal to 2 and reveal the calculated limit of f(x) as x approaches 2 to be 1/5. After that, clear everything off the screen and just present the concluding result of the limit calculation. Make sure the steps are shown sequentially with short pauses for emphasis.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplifying inner integral result\n        inner_result = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, inner_result))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\\\(\\\\theta\\\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [ -\\frac{1}{3} \\cos(\\theta) ]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_result, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= -\\frac{1}{3} \\cos(\\pi) + \\frac{1}{3} \\cos(0)\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplifying final solution\n        solution_simplified = MathTex(r\"= -\\frac{1}{3}(-1) + \\frac{1}{3}(1) = \\frac{2}{3}\")\n        self.play(ReplacementTransform(final_solution, solution_simplified))\n        self.wait(2)\n\n        # Display final answer\n        final_answer = Text(\"Final Answer: \\( \\frac{2}{3} \\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated video that starts with the title \"Fourier Series Example\" that appears and then fades away? After that, I would like to see the general definition of a Fourier series displayed, followed by a brief explanation stating \"Coefficients are calculated based on function's periodicity\" at the bottom of the screen. Next, I want this explanation to transform into another text that says \"For a square wave, coefficients have distinct values\". Then, can you replace the general Fourier series definition with the specific Fourier series formula for a square wave? And to conclude, can all the items fade out, leaving the screen empty?",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillator(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem_text = r\"m\\frac{d^2 x}{dt^2} + kx = 0\"\n        problem = MathTex(problem_text)\n        self.play(FadeIn(problem))\n        self.wait(1)\n\n        # Oscillation equation description\n        description1 = Text(\"This represents a simple harmonic oscillator.\", font_size=24)\n        self.play(Write(description1))\n        self.wait(2)\n        self.play(FadeOut(description1))\n\n        # Explanation for converting to standard form\n        standard_form_expl = Text(\"Let's convert to standard form, where\", font_size=24).to_edge(UP)\n        omega_sq_text = r\"\\omega^2 = \\frac{k}{m}\"\n        omega_sq = MathTex(omega_sq_text)\n        self.play(Write(standard_form_expl))\n        self.play(Write(omega_sq))\n        self.wait(2)\n\n        # Standard form of equation\n        standard_form_text = r\"\\frac{d^2 x}{dt^2} + \\omega^2 x = 0\"\n        standard_form = MathTex(standard_form_text)\n        self.play(ReplacementTransform(problem, standard_form))\n        self.wait(1)\n\n        # Explanation for general solution\n        general_sol_expl = Text(\"Now, let's find the general solution.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(standard_form_expl, general_sol_expl))\n        self.wait(1)\n\n        # General solution of oscillation equation\n        general_solution_text = r\"x(t) = A \\cos(\\omega t) + B \\sin(\\omega t)\"\n        general_solution = MathTex(general_solution_text)\n        self.play(ReplacementTransform(standard_form, general_solution))\n        self.wait(1)\n\n        # Explanation for full solution\n        full_solution_expl = Text(\"A and B are determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(general_sol_expl, full_solution_expl))\n        self.wait(2)\n\n        # Conclusion\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(general_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains how to evaluate a double integral in polar coordinates, specifically the integral of r^2 sin(theta) with respect to r and theta, where r goes from 0 to 1 and theta from 0 to pi/2? I'm interested in seeing the process step by step, starting with the evaluation of the inner integral with respect to r, then simplifying it, and finally evaluating the outer integral with respect to theta to find the final answer. Include textual explanations for each step that animate into the scene, such as \"Inner integral w.r.t r\" before showing the calculation of the inner integral, and \"Outer integral w.r.t theta\" before showing the final integral calculation.",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass FigureTwo(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fig = VGroup(\n            VGroup(\n                Rectangle(height=2, width=1, stroke_color=BLACK),\n                VGroup(\n                    Rectangle(height=1, width=2, stroke_color=BLACK),\n                    Rectangle(height=1, width=2, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n                ).arrange(DOWN, buff=0),\n                Rectangle(height=2, width=1, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n            ).arrange(RIGHT, buff=0),\n            VGroup(\n                Rectangle(height=1, width=2, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n                Rectangle(height=1, width=2, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n            ).arrange(RIGHT, buff=0),\n            VGroup(\n                Rectangle(height=2, width=1, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n                Rectangle(height=2, width=1, stroke_color=BLACK),\n                VGroup(\n                    Rectangle(height=1, width=2, stroke_color=BLACK),\n                    Rectangle(height=1, width=2, stroke_color=BLACK, color=LIGHT_RED_COLOR, fill_opacity=1),\n                ).arrange(DOWN, buff=0)\n            ).arrange(RIGHT, buff=0)\n        ).arrange(DOWN, buff=0)\n        text = Text(\"123456\", font_size=36)\n        text.set_color(BLACK)\n        frac = MathTex(r\"\\frac{6}{10}\", color=BLACK)\n        frac.next_to(fig, RIGHT, buff=0)\n        frac.scale(1.4)\n        text[0].next_to(fig[0][1][1], ORIGIN, buff=0)\n        text[1].next_to(fig[0][2], ORIGIN, buff=0)\n        text[2].next_to(fig[1][0], ORIGIN, buff=0)\n        text[3].next_to(fig[1][1], ORIGIN, buff=0)\n        text[4].next_to(fig[2][0], ORIGIN, buff=0)\n        text[5].next_to(fig[2][2][1], ORIGIN, buff=0)\n        frac[0][0].set_color(LIGHT_RED_COLOR)\n        frac[0][0].shift(0.1 * DOWN)\n        frac[0][1].scale(1.5)\n        fig.shift(9 * RIGHT)\n\n        self.play(fig.animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(0.8)\n        self.play(Write(text), run_time=0.7)\n        self.play(\n            fig.animate.shift(LEFT), \n            text.animate.shift(LEFT), \n            run_time=0.6\n        )\n        self.play(Write(frac[0][:2]), run_time=0.5)\n        self.play(FadeOut(text), run_time=0.7)\n\n        text = Text(\"12345678910\", font_size=36)\n        text.set_color(BLACK)\n        text[0].next_to(fig[0][0], ORIGIN, buff=0)\n        text[1].next_to(fig[0][1][0], ORIGIN, buff=0)\n        text[2].next_to(fig[0][1][1], ORIGIN, buff=0)\n        text[3].next_to(fig[0][2], ORIGIN, buff=0)\n        text[4].next_to(fig[1][0], ORIGIN, buff=0)\n        text[5].next_to(fig[1][1], ORIGIN, buff=0)\n        text[6].next_to(fig[2][0], ORIGIN, buff=0)\n        text[7].next_to(fig[2][1], ORIGIN, buff=0)\n        text[8].next_to(fig[2][2][0], ORIGIN, buff=0)\n        text[9:].next_to(fig[2][2][1], ORIGIN, buff=0)\n\n        self.play(Write(text))\n        self.play(Write(frac[0][2:]), run_time=0.5)\n        self.play(FadeOut(text), run_time=0.7)\n        self.wait(0.3)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Can you create an educational animation that explains whether the harmonic series converges or diverges using visual aids and mathematical proofs with step-by-step demonstrations?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 6, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes and labels\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Function\n        function = axes.plot(lambda x: x**2, color=RED)\n        area = axes.get_riemann_rectangles(function, x_range=[0, 2], dx=0.1, color=PURPLE, fill_opacity=0.5)\n\n        # Display axes and function\n        self.play(Create(axes), Write(labels))\n        self.wait(1)\n\n        # Show function and area under curve\n        self.play(Create(function))\n        self.wait(1)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Title of the action\n        title = Text(\"Area under the curve f(x) = x^2 from x=0 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(title))\n        self.wait(2)\n\n        # Calculate the area under the curve\n        area_value = MathTex(r\"A = \\int_0^2 x^2 \\,dx\")\n        area_solution = MathTex(r\"A = \\left.\\frac{x^3}{3}\\right|_0^2\", r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(Write(area_value))\n        self.wait(1)\n        self.play(ReplacementTransform(area_value, area_solution))\n        self.wait(3)\n\n        # Conclusion\n        self.play(FadeOut(title), FadeOut(area_solution), FadeOut(area), FadeOut(function), FadeOut(axes), FadeOut(labels))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation using a program that can visualize mathematical concepts. The animation should show the process of calculating the area under the curve of a specific function, from x=0 to x=2. Can you demonstrate this with the function f(x) = x^2, including the steps of setting up the integral, computing the antiderivative, and then revealing the final area value as a numerical result? The explanation should be clear and easy to follow, with text that guides through each step of the process.",
        "answer": "\\n from manim import Scene, VGroup_x000D_\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer_x000D_\nfrom manim_ml.neural_network.animations import TrainNeuralNetwork_x000D_\n_x000D_\nclass TrainNNAnimation(Scene):_x000D_\n    def construct(self):_x000D_\n        layers = [_x000D_\n            FeedForwardLayer(4, stroke_width=2),_x000D_\n            FeedForwardLayer(7, stroke_width=2, fill_opacity=0.5),_x000D_\n            FeedForwardLayer(4, stroke_width=2)_x000D_\n        ]_x000D_\n_x000D_\n        neural_network = NeuralNetwork(layers, neuron_spacing=0.15)_x000D_\n        neural_network.center()_x000D_\n_x000D_\n        data_points = VGroup(_x000D_\n            *[_x000D_\n                neural_network.get_random_neuron_position(layer_index=0)_x000D_\n                for _ in range(5)_x000D_\n            ]_x000D_\n        )_x000D_\n_x000D_\n        training_animation = TrainNeuralNetwork(neural_network, data_points)_x000D_\n_x000D_\n        self.add(neural_network)_x000D_\n        self.play(training_animation)_x000D_\n        self.wait()"
    },
    {
        "query": "Can you create an animation that explains the wave equation, its general solution for waves moving in both directions, and shows a specific sinusoidal wave solution along with corresponding descriptive text for each part?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{\\sqrt{1-x^2}} xy\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Inner integral explanation\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral calculation\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{1}{2}xy^2\\right]_{0}^{\\sqrt{1-x^2}} dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Substitute limits for inner integral\n        substitute_limits = MathTex(r\"= \\int_{0}^{1} \\frac{1}{2}x(1-x^2) dx\")\n        self.play(ReplacementTransform(inner_integral, substitute_limits))\n        self.wait(1)\n\n        # Outer integral explanation\n        explanation2 = Text(\"Now integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{2} \\cdot \\frac{1}{2}x^2 - \\frac{1}{2} \\cdot \\frac{1}{4}x^4 \\right]_{0}^{1}\")\n        self.play(ReplacementTransform(substitute_limits, final_solution))\n        self.wait(1)\n\n        # Final evaluation\n        final_evaluation = MathTex(r\"= \\frac{1}{4} - \\frac{1}{8}\")\n        self.play(ReplacementTransform(final_solution, final_evaluation))\n        self.wait(1)\n\n        # Final result\n        result = MathTex(r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(final_evaluation, result))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation using math visualization software that shows the area under the curve of a simple quadratic function from x=2 to x=4, including the axes, function curve, and a labeled shaded area representing integral calculation? Also, after showing the graph, I would like a brief written explanation on-screen about how the area under the curve is related to definite integrals. Finally, end the animation with a clear and prominent message that reinforces the concept that the area calculated is the result of a definite integral.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(x_range=[0, 5, 1], y_range=[0, 6, 1], axis_config={\"color\": BLUE})\n\n        # Define the curve and the area under the curve\n        function = lambda x: 0.1 * (x - 2) ** 2 + 1\n        curve = axes.plot(function, color=RED)\n        shaded_area = axes.get_area(curve, x_range=[2, 4], color=BLUE, opacity=0.5)\n\n        # Labels for the curve and area under curve\n        curve_label = axes.get_graph_label(curve, label='y = f(x)')\n        area_label = Tex(\"Area under curve\").move_to(shaded_area).shift(DOWN * 0.5)\n\n        # Display axes, function curve, and area under curve\n        self.play(Create(axes), Create(curve))\n        self.wait(1)\n        self.play(FadeIn(shaded_area), Write(curve_label), Write(area_label))\n        self.wait(2)\n\n        # Explanation showing calculation of area\n        explanation = Text(\"Calculated as definite integral from a to b\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display a final message\n        final_message = Text(\"The calculated area is the definite integral\", font_size=32, color=GOLD)\n        self.play(Write(final_message))\n        self.wait(2)"
    },
    {
        "query": "I want to create an animation that visually demonstrates the concept of finding the area under a curve on a graph. The curve should represent a quadratic function. Start by showing the axes and the curve. Then, shade the area under the curve between x=0 and x=4. Also, include a label for the equation of the curve near it. After that, display a text description explaining that the shaded area represents the integral from 0 to 4. Next, I would like to see the integral formula appear to replace the equation of the curve. Finally, show the actual calculated value of the area, clear everything else away, and leave only the solution on the screen for a moment. Can this animation also include pauses for emphasis at certain points?",
        "answer": "\\n from manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        t = Text(\"Kiron\").shift(UP * 2).shift(LEFT)\n        t2 = Text(\"Tisha\").shift(DOWN * 2).shift(RIGHT)\n        a1 = Arrow(start=t.get_corner(DOWN), end=t2.get_corner(UP))\n        self.play(Write(t), GrowArrow(a1), Create(t2), run_time=3)\n        self.wait()\n        g1 = Group(t, t2, a1)\n        self.play(g1.animate.scale(1.5))\n        self.wait()\n        self.play(t2.animate.shift(UP * 2))\n        self.play(a1.animate.put_start_and_end_on(start=t.get_corner(DOWN), end=t2.get_corner(UP)))\n        self.wait()"
    },
    {
        "query": "I would like to create an animated video explaining the concept of Taylor series approximation for the exponential function e^x. The animation should start by displaying the function \"f(x) = e^x\", then introduce the Taylor series approximation at x=0 with text and the general formula. Afterward, I want to show the first few terms of the series expansion, specifically stopping at the fourth degree. The reasoning for this choice should be presented as text on the screen. Finally, the video should display a graph comparing the original function with the fourth-degree Taylor polynomial over a suitable range, highlighting the accuracy of the approximation. A legend should clearly label the original function and the approximation. After the explanatory part, please clear all elements from the scene and finish the video by showing the polynomial terms again briefly.",
        "answer": "\\n class WaveLikeMotionScene(Scene):\n    def construct(self):\n        def wave_motion(mobject, alpha):\n            wave_height = 2\n            wave_length = 5\n            speed = 3\n            \n            x = mobject.get_center()[0]\n            y = wave_height * np.sin(wave_length * alpha + speed * x)\n            mobject.move_to(mobject.get_center() + y * UP)\n        \n        square = Square(color=BLUE)\n        self.add(square)\n        self.play(UpdateFromAlphaFunc(square, wave_motion, run_time=2))\n        self.wait()"
    },
    {
        "query": "I would like to create an educational animation that explains the Heat Equation, an important partial differential equation used in physics to describe the distribution of heat (or variation in temperature) in a given region over time. The animation should show the Heat Equation itself, provide a basic explanation of what it represents, transition to discussing the general form of its solution and how heat distribution evolves, introduce the concept of separation of variables as a technique to solve it, and mention the significance of boundary conditions in finding specific solutions. Finally, conclude the animation by revisiting the separation of variables representation. Can you create a visualization like this?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area to find\n        function = MathTex(r\"f(x) = 3x^2 + 2\")\n        area_problem = MathTex(r\"\\text{Find the area under } f(x) \\text{ from } x=1 \\text{ to } x=2\")\n        self.play(Write(function), Write(area_problem))\n        self.wait(1)\n\n        # Graph the function\n        axes = Axes(\n            x_range=[0, 3],\n            y_range=[0, 20],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.get_graph(lambda x: 3 * x**2 + 2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='f(x)')\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n        \n        # Highlight the area under the curve\n        area = axes.get_area(graph, x_range=(1, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Apply definite integral to find the area\n        integral = MathTex(r\"A = \\int_{1}^{2} (3x^2 + 2) \\,dx\")\n        self.play(ReplacementTransform(area_problem, integral))\n        self.wait(2)\n\n        # Showing the antiderivative\n        antiderivative = MathTex(r\"A = \\left. x^3 + 2x \\right|_{1}^{2}\")\n        self.play(Write(antiderivative))\n        self.wait(1)\n\n        # Calculate the area value\n        area_value = MathTex(r\"A = (2^3 + 2 \\cdot 2) - (1^3 + 2 \\cdot 1) = 8+4-1-2\")\n        area_solution = MathTex(r\"A = 9\")\n        self.play(ReplacementTransform(antiderivative, area_value), run_time=2)\n        self.wait(1)\n        self.play(Transform(area_value, area_solution))\n        self.wait(1)\n\n        # Clear the scene and show the final area value\n        self.clear()\n        self.wait(1)\n        self.play(Write(area_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation that begins by writing Euler's formula \"e^(ix) = cos(x) + i*sin(x)\" on the screen. Following this, can you display a sentence above explaining that Euler's formula relates complex exponentials to trigonometric functions? Then visually transform the formula to show just the real part \"cos(x) = Re{e^(ix)}\" and after a short pause, to its imaginary part \"sin(x) = Im{e^(ix)}\". Next, can the animation morph Euler's formula into its polar form representation \"e^(i\u03b8) = cos(\u03b8) + i*sin(\u03b8)\"? Afterwards, I want to see a point on a circle that represents the polar form of complex numbers, along with a dashed line from the center to the point, and a small arc indicating the angle \u03b8. Could this be accompanied by a label for \u03b8? Finally, clear the animation and conclude by showing Euler's formula again on the screen. I would like pauses between the steps to give viewers enough time to understand each part.",
        "answer": "\\n from manim import *\n\nconfig.frame_size = (1080, 1920)\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nDARK_GREEN_COLOR = \"#2e8b57\"\nYELLOW_COLOR = \"#ffd700\"\nORANGE_COLOR = \"#ff8c00\"\nRED_COLOR = \"#ff0000\"\nPURPLE_COLOR = \"#800080\"\nAQUA_COLOR = \"#00ffff\"\n\ndef CreateCheckMark():\n    check_mark = VGroup()\n    check_mark.add(Line([0, 0, 0], [0.2, -0.2, 0]))\n    check_mark.add(Line([0.2, -0.2, 0], [0.6, 0.3, 0]))\n    check_mark.set_color(LIGHT_GREEN_COLOR)\n    check_mark.set_stroke(width=6)\n\n    return check_mark\n\ndef CreateXMark():\n    x_mark = VGroup()\n    x_mark.add(Line([-0.3, -0.3, 0], [0.3, 0.3, 0]))\n    x_mark.add(Line([-0.3, 0.3, 0], [0.3, -0.3, 0]))\n    x_mark.set_color(RED_COLOR)\n    x_mark.set_stroke(width=6)\n\n    return x_mark\n\ndef EquationCheck(expression, is_correct=True):\n    text = MathTex(expression, color=TEXT_COLOR).scale(2)\n    if is_correct:\n        symbol = CreateCheckMark()\n    else:\n        symbol = CreateXMark()\n\n    symbol.next_to(text, RIGHT)\n\n    return VGroup(text, symbol)\n\nclass VerifyEquations(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        eq1 = EquationCheck(\"2x + 1 = 5\", is_correct=True)\n        eq2 = EquationCheck(\"4y - 2 = 7\", is_correct=False)\n        eq3 = EquationCheck(\"3a^2 - 9 = 0\", is_correct=True)\n\n        VGroup(eq1, eq2, eq3).arrange(DOWN, buff=1)\n\n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(Write(eq2))\n        self.wait(1)\n        self.play(Write(eq3))\n        self.wait(2)\n\n        self.play(FadeOut(VGroup(eq1, eq2, eq3)))"
    },
    {
        "query": "I would like an educational animation that introduces the concept of simple harmonic motion. It should start by displaying the differential equation that describes the motion, and then proceed with text explanations for each component. First, I'd like a brief introduction stating that the equation represents a simple harmonic oscillator. Then, I want an explanation that the term \"omega\" in the equation stands for angular frequency. Next, the animation should show the general solution of the motion equation which involves cosine. Please include a note clarifying that the 'A' in the solution represents amplitude and 'phi' represents the phase of the motion. Finally, end the animation by clearing the explanations and focusing on the final solution of the differential equation. Can you make this visualization engaging and easy to follow for students learning physics?",
        "answer": "\\n from manim import *\n\nclass MainScene(Scene):\n    def construct(self):\n        grid = self.create_ion_grid(5, 5)\n        self.play(Create(grid))\n        self.wait()\n\n        path = self.create_complex_path()\n        electron_obj = electron()\n        self.play(Create(electron_obj))\n        self.wait()\n\n        animations = move_along_complex_path(\n            obj=electron_obj,\n            stop_indices=[1, 3],\n            points=path,\n            run_time=2\n        )\n        self.play(*animations)\n        self.wait()\n\n    def create_complex_path(self):\n        points = [\n            LEFT * 3,\n            UP * 2,\n            RIGHT * 4 + UP * 2,\n            RIGHT * 4 + DOWN * 3,\n            LEFT * 3 + DOWN * 3,\n            ORIGIN\n        ]\n        return points\n\n    def create_ion_grid(self, rows, cols):\n        grid = VGroup(*[\n            Circle(radius=0.2, color=BLUE if (i+j) % 2 == 0 else RED).move_to([i - rows//2, j - cols//2, 0])\n            for i in range(rows) for j in range(cols)\n        ])\n        return grid\n\n# Helper Functions\ndef electron():\n    electron_circle = Circle(radius=0.15, color=YELLOW_D).set_opacity(1).set_fill(YELLOW_D)\n    electron_text = Tex(\"e$^-$\", color=BLACK, font_size=24)\n    return VGroup(electron_circle, electron_text).set_z_index(1)\n\ndef move_along_complex_path(obj, stop_indices, points, run_time, rate_func=linear):\n    animations = []\n    paths = []\n    for i in range(len(points) - 1):\n        if i not in stop_indices:\n            paths.append(Line(points[i], points[i + 1]))\n\n    for path in paths:\n        animations.append(MoveAlongPath(obj, path, run_time=run_time / len(paths), rate_func=rate_func))\n    \n    return animations"
    },
    {
        "query": "Can you create an animated video that explains how to find the area under the curve of y equals x squared, from x equals 0 to x equals 2, using integration? I'd like the video to start by showing the equation of the function at the top of the screen. Then, can you plot the function and shade the area under the curve that we're interested in? After that, please display the integral expression that represents the area under the curve just below the function. Next, show the solution of the integral in steps right below the integral expression, and finally the numerical result of the integral. At the end of the video, can you clear the screen of all elements?",
        "answer": "\\n class ColorChangingCircles(Scene):\n    def construct(self):\n        def update_color(circle, dt):\n            color = color_gradient([BLUE, GREEN, YELLOW, RED], dt % 1)\n            circle.set_fill(color, opacity=0.5)\n\n        circle_group = VGroup(*[Circle(radius=0.2 + i * 0.1).shift(i * 0.3 * RIGHT) for i in range(10)])\n        self.add(circle_group)\n        self.play(AnimationGroup(*[UpdateFromFunc(circle, update_color) for circle in circle_group], lag_ratio=0.1))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation that visually explains how to evaluate the double integral in polar coordinates, specifically the integral from 0 to 2 of the integral from 0 to \u03c0 of r*sin(\u03b8) with respect to \u03b8 and then with respect to r, showing each step of the process and the final solution?",
        "answer": "\\n from manim import *\nfrom manim_physics import *\n\n# use a SpaceScene to utilize all specific rigid-mechanics methods\n\n\nclass TwoObjectsFalling(SpaceScene):\n    def construct(self):\n        circle = Circle().shift(UP)\n        circle.set_fill(RED, 1)\n        circle.shift(DOWN + RIGHT)\n\n        rect = Square().shift(UP)\n        rect.rotate(PI / 4)\n        rect.set_fill(YELLOW_A, 1)\n        rect.shift(UP * 2)\n        rect.scale(0.5)\n\n        ground = Line([-4, -3.5, 0], [4, -3.5, 0])\n        wall1 = Line([-4, -3.5, 0], [-4, 3.5, 0])\n        wall2 = Line([4, -3.5, 0], [4, 3.5, 0])\n        walls = VGroup(ground, wall1, wall2)\n        self.add(walls)\n\n        self.play(\n            DrawBorderThenFill(circle),\n            DrawBorderThenFill(rect),\n        )\n        self.make_rigid_body(rect, circle)  # Mobjects will move with gravity\n        self.make_static_body(walls)  # Mobjects will stay in place\n        self.wait(5)\n        # during wait time, the circle and rect would move according to the simulate updater"
    },
    {
        "query": "Could you create an educational animation that introduces the concept of Fourier series, shows the mathematical formula for it, explains what Fourier coefficients are, gives an example with integrals for calculating these coefficients, discusses the concept of orthogonality in sines and cosines, and mentions some applications of Fourier series in fields like signal processing and physics?",
        "answer": "\\n from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_YELLOW_COLOR = \"#fff5ba\"\nLIGHT_GREEN_COLOR = \"#94c973\"\nLIGHT_BLUE_COLOR = \"#5a8ef5\"\nLIGHT_ORANGE_COLOR = \"#ffad42\"\nLIGHT_PURPLE_COLOR = \"#b085f5\"\nDARK_GREEN_COLOR = \"#2e7d32\"\nDARK_BLUE_COLOR = \"#0033CC\"\n\ndef GummyBear():\n    body_color = LIGHT_YELLOW_COLOR\n    eye_color = DARK_BLUE_COLOR\n    nose_color = DARK_GREEN_COLOR\n    body = Ellipse(width=1, height=1.5, color=body_color, fill_opacity=1)\n    left_eye = Dot(color=eye_color).shift(LEFT*0.2 + UP*0.5)\n    right_eye = Dot(color=eye_color).shift(RIGHT*0.2 + UP*0.5)\n    nose = Dot(color=nose_color).shift(UP*0.2)\n    ears = VGroup(\n        Ellipse(width=0.3, height=0.5, color=body_color, fill_opacity=1).shift(LEFT*0.45 + UP*0.75),\n        Ellipse(width=0.3, height=0.5, color=body_color, fill_opacity=1).shift(RIGHT*0.45 + UP*0.75)\n    )\n    return VGroup(body, left_eye, right_eye, nose, ears)\n\nclass GummyBearCounting(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Let's Count Gummy Bears!\", color=TEXT_COLOR)\n        title.scale(1.2)\n        title.move_to(3 * UP)\n\n        gummy_bears = VGroup(*[GummyBear() for i in range(12)])\n        gummy_bears.arrange_in_grid(rows=3, cols=4, buff=0.5)\n        gummy_bears.center()\n        \n        total_count = Text(\"Total: 12 Bears\", color=LIGHT_GREEN_COLOR)\n        total_count.scale(0.8)\n        total_count.next_to(gummy_bears, DOWN)\n\n        self.play(Write(title))\n        self.play(LaggedStart(*[GrowFromCenter(gummy) for gummy in gummy_bears], lag_ratio=0.1, run_time=3))\n        self.wait(1)\n        self.play(Write(total_count))\n        self.wait(2)\n        self.play(FadeOut(gummy_bears), FadeOut(total_count), FadeOut(title))\n        self.wait(0.5)"
    },
    {
        "query": "Can you create an educational animation that walks me through the process of solving the definite integral of x squared from 1 to 3 step by step, including using the power rule, evaluating the integral at the boundaries, and simplifying the result to the final answer? I\u2019d like the animation to start by displaying the problem, then introduce and apply the power rule, and finally, demonstrate how to substitute the limits of integration and simplify to find the definite integral value.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowArrow\").shift(UP*2.5)), run_time=0.5)\n            arrow = Arrow()\n            self.play(GrowArrow(arrow))\n            self.remove(arrow)"
    },
    {
        "query": "I would like a step-by-step animated video that explains how to solve the integral of the square root of (1+x^2) using trigonometric substitution. Could you illustrate the process starting with the integral, introducing the substitution x=tan(theta), converting dx and the function under the square root to theta, and simplifying the resulting integral using a trigonometric identity? After simplification, can you mention that this requires advanced integration techniques such as reduction formulae and then show the final solution? Please ensure that each step appears sequentially and gives me some time to understand the changes before moving on to the next step.",
        "answer": "\\n from manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y'' + \\omega^2 y = 0\")\n        self.play(FadeIn(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation\n        char_eq = MathTex(r\"r^2 + \\omega^2 = 0\")\n        self.play(Transform(problem, char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solving for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = \\pm i \\omega\")\n        self.play(Transform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = A \\cos(\\omega x) + B \\sin(\\omega x)\")\n        self.play(FadeIn(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Conclusion with the general solution\n        self.play(FadeOut(explanation1), FadeOut(roots))\n        self.wait(1)\n        conclusion = Text(\"Simple harmonic motion equation.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion), FadeOut(general_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video using math visualizations that explains the process of integrating the trigonometric function sine of x times cosine of x, demonstrates the use of the trigonometric identity sin(2x) = 2sin(x)cos(x), shows step-by-step how to solve the integral, and concludes by displaying the final solution?",
        "answer": "\\n from manim import *\n\nfrom manim_physics import *\n\nclass RayExampleScene(Scene):\n    def construct(self):\n        lens_style = {\"fill_opacity\": 0.5, \"color\": BLUE}\n        a = Lens(-5, 1, **lens_style).shift(LEFT)\n        a2 = Lens(5, 1, **lens_style).shift(RIGHT)\n        b = [\n            Ray(LEFT * 5 + UP * i, RIGHT, 8, [a, a2], color=RED)\n            for i in np.linspace(-2, 2, 10)\n        ]\n        self.add(a, a2, *b)"
    },
    {
        "query": "Can you create an educational animation that visually illustrates how to solve a double integral in polar coordinates, specifically the integral from 0 to \u03c0 of the integral from 0 to 1 of r dA, by demonstrating the step-by-step process including converting dA to polar coordinates, integrating with respect to r, then integrating with respect to theta, and finally presenting the solution?",
        "answer": "\\n from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint_S (\\nabla \\times \\vec{F}) \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for curl of F\n        explanation1 = Text(\"First, find the curl of F\", font_size=24).to_edge(UP)\n        self.play(Transform(problem, explanation1))\n        self.wait(2)\n\n        # Replace with equation of curl of F\n        curl_f = MathTex(r\"\\nabla \\times \\vec{F} = (P, Q, R)\")\n        self.play(ReplacementTransform(problem, curl_f))\n        self.wait(1)\n\n        # Explanation for dot product with dS\n        explanation2 = Text(\"Now, compute the dot product with dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Replace with dot product computation\n        dot_product = MathTex(r\"(\\nabla \\times \\vec{F}) \\cdot d\\vec{S} = P\\,dydz + Q\\,dzdx + R\\,dxdy\")\n        self.play(ReplacementTransform(curl_f, dot_product))\n        self.wait(1)\n\n        # Explanation for final step of the surface integral\n        explanation3 = Text(\"Finally, integrate over the surface S\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral computation\n        final_integral = MathTex(r\"\\iint_S (P\\,dydz + Q\\,dzdx + R\\,dxdy)\")\n        self.play(ReplacementTransform(dot_product, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"\\iint_S (P\\,dydz + Q\\,dzdx + R\\,dxdy) = \\text{Flux through S}\")\n        self.play(Transform(final_integral, final_solution))\n        self.wait(3)"
    },
    {
        "query": "Could you please create an educational animation using Manim that visually explains the process of evaluating a double integral in polar coordinates? Specifically, I want to show the step-by-step solution to the integral from 0 to pi for theta and from 0 to 1 for r, of the function r dr dtheta. The steps should include: writing the problem, integrating with respect to r, simplifying, then integrating with respect to theta, and finally, presenting the numerical solution. Each step should be accompanied by a text explanation and animated transitions between steps.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Applying the definite integral limits\n        limits = MathTex(r\"\\Big |_2^3\")\n        self.play(Write(limits.next_to(power_rule, RIGHT)))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{3+1}\", r\"\\Big |_2^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for applying the Fundamental Theorem of Calculus\n        explanation2 = Text(\"Evaluate using the limits 2 and 3:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution after applying limits\n        final_solution = MathTex(r\"= \\frac{3^4}{4} - \\frac{2^4}{4}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(2)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= \\frac{81}{4} - \\frac{16}{4}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(1)\n\n        final_result = MathTex(r\"= \\frac{65}{4}\")\n        self.play(Transform(final_solution, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation where a pink circle turns into a yellow square with a text caption at the bottom saying \"A circle transforms into a square\" and both the square and the text fade away at the end?",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\nfrom manim import *\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass FigureOne(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fig = VGroup(\n            Triangle(stroke_color=BLACK, color=LIGHT_ORANGE_COLOR, fill_opacity=1),\n            Triangle(stroke_color=BLACK, color=LIGHT_ORANGE_COLOR, fill_opacity=1)\n                .rotate(PI),\n            Triangle(stroke_color=BLACK, color=LIGHT_ORANGE_COLOR, fill_opacity=1),\n            Triangle(stroke_color=BLACK)\n                .rotate(PI),\n            Triangle(stroke_color=BLACK)\n        )\n        fig.arrange(RIGHT, buff=0, aligned_edge=LEFT)\n        frac = MathTex(r\"\\frac{3}{5}\", color=BLACK)\n        frac.next_to(fig, DOWN, buff=0)\n        frac.scale(1.4)\n        text = Text(\"12345\", font_size=36)\n        text.set_color(BLACK)\n        text[0].next_to(fig[0], ORIGIN, buff=0)\n        text[0].shift(0.2 * DOWN)\n        text[1].next_to(fig[1], ORIGIN, buff=0)\n        text[1].shift(0.2 * UP)\n        text[2].next_to(fig[2], ORIGIN, buff=0)\n        text[2].shift(0.2 * DOWN)\n        text[3].next_to(fig[3], ORIGIN, buff=0)\n        text[3].shift(0.2 * UP)\n        text[4].next_to(fig[4], ORIGIN, buff=0)\n        text[4].shift(0.2 * DOWN)\n        fig.shift(9 * RIGHT)\n        frac[0][0].set_color(LIGHT_ORANGE_COLOR)\n        frac[0][0].shift(0.1 * DOWN)\n        frac[0][1].scale(2)\n        text[3:].shift(0.5 * UP)\n\n        self.play(fig.animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(0.5)\n        self.play(Write(text[0:3]), run_time=0.7)\n        self.play(\n            fig.animate.shift(0.5 * UP), \n            text[0:3].animate.shift(0.5 * UP), \n            run_time=0.6\n        )\n        self.play(Write(frac[0][:2]), run_time=0.7)\n        self.play(FadeOut(text[0:3]))\n        self.play(Write(text))\n        self.play(Write(frac[0][2:]), run_time=0.7)\n        self.play(FadeOut(text))\n        self.wait(0.3)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "I would like an educational animation that illustrates the concept of the one-dimensional wave equation using math formulas. Start with the wave equation itself, then provide a brief explanation that this represents a one-dimensional wave equation. Next, show an important aspect of seeking solutions for this wave equation where the solutions take the form of two functions, one moving forward and one moving backward in time. Transition to the general form of the wave solution that combines these two functions. Lastly, mention that in the case of harmonic waves, these functions could be sine or cosine. Allow brief pauses between each step to let viewers digest the information, and clear the screen towards the end before presenting the final wave solution one more time for emphasis.",
        "answer": "\\n from manim import *\n\nclass CalculateSeries(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\sum_{n=1}^{\\infty}\\frac{1}{n^2}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for convergence test\n        explanation1 = Text(\"Convergence test using p-series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Test setup\n        test_setup = MathTex(r\"p=2\", r\"\\ \\text{is larger than 1, so the series converges}\")\n        self.play(Write(test_setup))\n        self.wait(1)\n\n        # Show convergence explanation\n        explanation2 = Text(\"Since p > 1, the p-series converges\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Partial sum explanation\n        partial_sum_explanation = Text(\n            \"Consider the partial sum S_m\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, partial_sum_explanation))\n        self.wait(2)\n\n        # Displaying partial sum\n        partial_sum = MathTex(r\"S_m = \\sum_{n=1}^{m} \\frac{1}{n^2}\")\n        self.play(ReplacementTransform(problem.copy(), partial_sum))\n        self.wait(1)\n\n        # Explanation for limiting behavior\n        explanation3 = Text(\n            \"Evaluate the limit of partial sums as m approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Limit of partial sums\n        limit_of_sums = MathTex(r\"\\lim_{m \\to \\infty}\", r\"S_m\")\n        self.play(ReplacementTransform(partial_sum, limit_of_sums))\n        self.wait(1)\n\n        # Result\n        result = MathTex(\n            r\"= \\frac{\\pi^2}{6}\", r\"\\ \\text{(Basel problem solution)}\")\n        self.play(FadeIn(result, shift=DOWN))\n        self.wait(1)\n\n        # Clear the scene and show only result\n        self.clear()\n        self.play(Write(result))\n        self.wait(1)"
    },
    {
        "query": "Create an educational animation that explains how to solve the double integral in polar coordinates, where the integral is the double integral of r squared times sine of theta over the region from 0 to pi for theta and from 0 to 1 for r. Start by showing the integral formula, then show step-by-step how to integrate with respect to r first, including evaluating the antiderivative at the limits of integration. Next, show how to integrate what's left with respect to theta. Finally, display the conclusion that the value of the polar double integral is zero and conclude with a message stating that the polar double integral evaluates to zero. Make sure the animation includes pauses for emphasis and the steps are clearly explained with text messages.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[ \\frac{1}{2} r^2 \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate inner integral\n        evaluated_inner = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{2} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, evaluated_inner))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ \\frac{1}{2} \\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(evaluated_inner, final_solution))\n        self.wait(1)\n\n        # Display final answer\n        final_answer = MathTex(r\"= \\frac{\\pi}{2}\")\n        self.play(Transform(final_solution, final_answer))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation that explains the process of integrating the trigonometric function sin(x)cos(x) by using a trigonometric identity to simplify the integral and then solve it step-by-step?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title of the topic\n        title = Text(\"Fourier Series Decomposition\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Move title to the top\n        self.play(title.animate.to_edge(UP))\n        self.wait(1)\n\n        # Displaying the Fourier series formula for a periodic function f\n        fourier_series_formula = MathTex(\n            r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left[a_n \\cos\\left(\\frac{2\\pi nx}{P}\\right) + b_n \\sin\\left(\\frac{2\\pi nx}{P}\\right)\\right]\"\n        )\n        self.play(Write(fourier_series_formula))\n        self.wait(2)\n\n        # Explanation of the components of the formula\n        explanation1 = Text(\n            \"Here, P is the period of function f.\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation2 = Text(\n            \"The coefficients a_0, a_n, and b_n are calculated using integrals.\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Example of calculating a coefficient\n        coefficient_calculation = MathTex(\n            r\"a_n = \\frac{2}{P} \\int_{0}^{P} f(x) \\cos\\left(\\frac{2\\pi nx}{P}\\right)dx\"\n        )\n        self.play(ReplacementTransform(fourier_series_formula, coefficient_calculation))\n        self.wait(2)\n\n        # The importance of the Fourier series in signal processing\n        importance_text = Text(\n            \"Fourier series play a crucial role in signal processing and electrical engineering.\",\n            font_size=24\n        ).next_to(coefficient_calculation, DOWN)\n        self.play(Write(importance_text))\n        self.wait(2)\n\n        # Clean up the scene\n        self.clear()  # Clear the screen\n        self.wait(1)\n\n        # Conclusion with the Fourier series formula displayed again\n        self.play(Write(fourier_series_formula))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation illustrating the steps to solve a double integral in polar coordinates, specifically the integral of r^2 sin(theta) with the limits for r going from 0 to 1 and for theta from 0 to pi/2? It should include the integration first with respect to r, showing the intermediate steps, and then integration with respect to theta, until reaching the final numeric solution. Also, include textual explanations for each step of the process.",
        "answer": "\\n from manim import *\n\nclass WaterScene(Scene):\n    def construct(self):\n        # Create water molecule (H2O)\n        oxygen_center = oxygen()\n        hydrogen1 = circle_with_text(0.1, 'H', color=WHITE, font_size=18, font_color=BLACK, stroke_width=1, fill_color=WHITE)\n        hydrogen2 = circle_with_text(0.1, 'H', color=WHITE, font_size=18, font_color=BLACK, stroke_width=1, fill_color=WHITE)\n        \n        hydrogen1.next_to(oxygen_center, UP+LEFT, buff=0)\n        hydrogen2.next_to(oxygen_center, UP+RIGHT, buff=0)\n        \n        water_molecule = VGroup(oxygen_center, hydrogen1, hydrogen2)\n        \n        # Animate creation of the water molecule\n        self.play(Create(water_molecule))\n        self.wait(1)\n        \n        # Rotate water molecule\n        self.play(Rotate(water_molecule, angle=2*PI), run_time=2)\n        self.wait(1)\n        \n        # Dissociation of water molecule\n        self.play(\n            hydrogen1.animate.shift(LEFT*3),\n            hydrogen2.animate.shift(RIGHT*3),\n        )\n        self.wait(1)\n        \n        # Recombination of hydrogen and oxygen to form water\n        self.play(\n            hydrogen1.animate.next_to(oxygen_center, UP+LEFT, buff=0),\n            hydrogen2.animate.next_to(oxygen_center, UP+RIGHT, buff=0)\n        )\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that explains the one-dimensional wave equation and its general solution concept, shows the transformation from the wave equation to its general solution, discusses the concept of characteristic lines in the context of the wave equation, and also mentions the importance of initial and boundary conditions in solving the wave equation?",
        "answer": "\\n from manim import *\n\nclass VariousShapes(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle(radius=1, color=BLUE)\n        circle.shift(LEFT*2)\n\n        # Create a rectangle\n        rectangle = Rectangle(height=2, width=3, color=GREEN)\n        rectangle.next_to(circle, RIGHT, buff=1)\n\n        # Create an ellipse\n        ellipse = Ellipse(width=3, height=1, color=RED)\n        ellipse.next_to(rectangle, RIGHT, buff=1)\n\n        # Add shapes to the scene\n        self.add(circle, rectangle, ellipse)\n\n        # Show animation\n        self.play(\n            GrowFromCenter(circle),\n            FadeIn(rectangle),\n            GrowFromEdge(ellipse, UP)\n        )\n        self.wait(2)"
    },
    {
        "query": "I would like an educational animation that illustrates the convergence of the series \\sum_{n=1}^{\\infty} \\frac{1}{n^2} using the p-test. First, show the series on-screen, then introduce the p-test and explain that since p equals 2, which is greater than 1, the series converges. Then, shift the explanation to a comparison with a known convergent integral and demonstrate that if the integral from 1 to infinity of 1/x^2 dx converges, so does our series. Finally, conclude with a statement that therefore the series converges, and then clear the screen. The explanations should be in text and easy to understand, with each step of the process appearing one after the other.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series\n        series_formula = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} a_n \\cos(nx) + b_n \\sin(nx)\")\n        self.play(Write(series_formula))\n        self.wait(2)\n\n        # Explanation for Fourier series\n        explanation1 = Text(\"This is the formula for a Fourier series.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Fourier series representation\n        representation = Text(\"It represents periodic functions as infinite sums of sines and cosines.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, representation))\n        self.wait(2)\n\n        # Displaying partial sum notation\n        partial_sum = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^{N} a_n \\cos(nx) + b_n \\sin(nx)\")\n        self.play(ReplacementTransform(series_formula, partial_sum))\n        self.wait(2)\n\n        # Explanation for partial sums\n        partial_explanation = Text(\"Here, \\(S_N(x)\\) is the N-th partial sum of the series.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, partial_explanation))\n        self.wait(2)\n\n        # Clear the scene and finish\n        self.clear()\n        self.wait(1)\n        self.play(Write(partial_sum))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animated video explaining Fourier Series using simple visual elements. The video should start by showing the mathematical definition of a Fourier Series. Then, there should be a brief explanation that Fourier Series decompose periodic functions. Next, I'd like to see an example function that simplifies to only its cosine components. Following that, I want to highlight the cosine terms in yellow to emphasize their importance and add a text that explains how coefficients influence the shape of the function. Afterward, show just a single term of the Fourier Series to focus on the generic form of the cosine terms. Conclude with a statement about the applications of Fourier Series in various fields like signal processing. Finally, end the animation with a closing slide that says \"End of Demonstration\". Can you create such an animated sequence?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import layers\nfrom manim_ml.neural_network import NeuralNetwork\n\nclass NeuralNetworkSceneV2(Scene):\n    def construct(self):\n        # Define neural network layers\n        network_layers = [\n            layers.InputLayer(4),\n            layers.FullyConnectedLayer(10),\n            layers.ActivationLayer(\"ReLU\"),\n            layers.FullyConnectedLayer(2),\n            layers.ActivationLayer(\"Sigmoid\")\n        ]\n        \n        # Create the neural network object\n        neural_network = NeuralNetwork(network_layers)\n        \n        # Position the network in the center of the scene\n        neural_network.move_to(ORIGIN)\n        \n        # Animate the creation of the neural network\n        self.play(Create(neural_network))\n        \n        # Run forward propagation animation with activation visualized\n        forward_prop_anim = neural_network.get_forward_pass_animation(\n            layer_time=2, activation_time=1, show_activations=True\n        )\n        \n        self.wait(1)\n        self.play(forward_prop_anim)\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually explains how to find the area under the curve of f(x) = x^2 from x=0 to x=2, including the integration steps and the final solution?",
        "answer": "\\n from manim import *\n\nclass TextAnimations(Scene):\n    def construct(self):\n        title = Text(\"Writing Text Animation\").to_edge(UP)\n        self.play(Write(title))\n        \n        paragraph = Text(\n            \"Manim makes elaborate animations with text \"\n            \"quite straightforward to program!\"\n        ).scale(0.7).next_to(title, DOWN)\n        self.play(Write(paragraph, run_time=2))\n        \n        self.wait(1)\n        \n        self.play(Unwrite(paragraph, run_time=2))\n        conclusion = Text(\"And just as easy to erase!\").scale(0.7).next_to(title, DOWN)\n        self.play(Transform(title, conclusion))\n        \n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that shows how to find the area under the curve of the function x^2 from x=1 to x=3, including the steps of calculating the integral, plugging in the upper and lower limits, evaluating those, and then presenting the final solution?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying a function f(x)\n        function_tex = MathTex(r\"f(x) = \\sin(x)\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explanation for Fourier Series\n        explanation1 = Text(\"Fourier Series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Fourier Series formula\n        fourier_series_formula = MathTex(r\"f(x) \\approx a_0 + \\sum_{n=1}^{\\infty}(a_n\\cos(nx) + b_n\\sin(nx))\")\n        self.play(ReplacementTransform(function_tex, fourier_series_formula))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation2 = Text(\"The coefficients are determined by the function's shape\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Coefficients for sin(x)\n        coefficients = MathTex(r\"a_0=0, \\ a_n=0, \\ b_n=\\frac{2}{\\pi(1-n^2)} \\ for \\ n\\ odd\")\n        self.play(ReplacementTransform(fourier_series_formula, coefficients))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show approximation of sin(x) using first 3 non-zero terms of the Fourier Series\n        approximation = MathTex(r\"f(x) \\approx \\frac{4}{\\pi} (\\sin(x) - \\frac{\\sin(3x)}{9} + \\frac{\\sin(5x)}{25})\")\n        self.play(Write(approximation))\n        self.wait(1)"
    },
    {
        "query": "Create an educational animation that explains the concept of the quadratic equation and how to determine the nature of its roots using the discriminant. Start by displaying the generic form of a quadratic equation and then introduce the discriminant. Afterward, explain and show the different types of possible roots depending on the value of the discriminant. Conclude with presenting the formula for calculating the actual roots of the quadratic equation. Include written explanations for each step and ensure the transitions between different parts of the lesson are clear and smooth. The animation should be concise but informative, suitable for a mathematics education setting.",
        "answer": "\\n from manim import *\n\nclass TrigonometricFunctionScene(Scene):\n    def construct(self):\n        # Display the trigonometric function\n        trig_func = MathTex(r\"f(x) = \\sin(x) + \\cos(x)\")\n        self.play(Write(trig_func))\n        self.wait(2)\n\n        # Display the trigonometric identity\n        identity = Text(\"Use a trigonometric identity\", font_size=24).to_edge(UP)\n        self.play(FadeIn(identity))\n        self.wait(2)\n\n        # Apply the identity to rewrite the function\n        rewritten_func = MathTex(r\"f(x) = \\sqrt{2}\\sin(x + \\frac{\\pi}{4})\")\n        self.play(Transform(trig_func, rewritten_func))\n        self.wait(2)\n\n        # Visualize the function's graph\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-2, 2],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: np.sin(x) + np.cos(x), color=WHITE)\n        graph_label = axes.get_graph_label(graph, label=\"f(x)\")\n\n        self.play(Create(axes), Write(graph_label))\n        self.play(ShowCreation(graph))\n        self.wait(2)\n\n        # Clear the scene and display only the graph\n        self.clear()\n        self.play(Create(axes), Write(graph_label), ShowCreation(graph))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually explains how to solve the basic definite integral problem step by step, including the application of the power rule, and evaluating the final expression using the given limits? Specifically, I'd like the animation to show the problem \"integrate x cubed from 0 to 2\", then present the general power rule for integration, transform the problem into its integrated form applying the limits of 0 and 2, and finally evaluate the expression to arrive at the numerical answer, all with accompanying text explanations and pauses for digestion of the material.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the curve and the area under the curve\n        curve = FunctionGraph(lambda x: 0.1 * (x - 3) ** 2 + 1, x_range=[0, 5])\n        area = area = Integral(curve, (x, 0, 5), fill_opacity=0.5)\n\n        # Displaying the problem\n        problem = MathTex(r\"Find \\, \\int_{0}^{5} 0.1 (x - 3)^2 + 1 \\, dx\")\n        problem.to_edge(UP)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Draw curve and area\n        self.play(DrawBorderThenFill(curve))\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Explanation for the area under the curve\n        explanation = Text(\"The shaded region represents the area\", font_size=24)\n        explanation.next_to(area, DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Computing the area\n        computation_step1 = MathTex(r\"= \\frac{0.1}{3} (x - 3)^3 \\Big|_0^5 + 5\")\n        computation_step1.next_to(problem, DOWN)\n        self.play(Write(computation_step1))\n        self.wait(2)\n\n        computation_step2 = MathTex(r\"= \\frac{0.1}{3} ((5-3)^3-(0-3)^3) + 5\")\n        computation_step2.next_to(computation_step1, DOWN)\n        self.play(Write(computation_step2))\n        self.wait(2)\n\n        computation_step3 = MathTex(r\"= \\frac{0.1}{3} (8 - (-27)) + 5\")\n        computation_step3.next_to(computation_step2, DOWN)\n        self.play(Write(computation_step3))\n        self.wait(2)\n\n        computation_step4 = MathTex(r\"= \\frac{0.1}{3} (35) + 5 = \\frac{35}{30} + 5\")\n        computation_step4.next_to(computation_step3, DOWN)\n        self.play(Write(computation_step4))\n        self.wait(2)\n\n        final_area = MathTex(r\"= \\frac{7}{6} + 5\")\n        final_area.next_to(computation_step4, DOWN)\n        self.play(Transform(computation_step4, final_area))\n        self.wait(1)\n\n        # Clear the scene and show the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_area))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains how to solve the indefinite integral of e to the negative x power from 2 to infinity, including setting it up as a limit for the improper integral, performing the integration, evaluating the limit, and presenting the final solution?",
        "answer": "\\n from manim import *\n\nclass InfiniteSeriesExample(Scene):\n    def construct(self):\n        # Displaying the series problem\n        series_problem = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for testing for convergence\n        explanation1 = Text(\"Test for convergence using integral test\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integral test setup\n        integral_test = MathTex(r\"\\int_1^\\infty \\frac{1}{x^2} \\,dx\")\n        self.play(ReplacementTransform(series_problem, integral_test))\n        self.wait(1)\n\n        # Showing that the integral is convergent\n        convergent_statement = Text(\"Since the integral is convergent,\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, convergent_statement))\n        self.wait(2)\n\n        # Conclusion that the series is convergent\n        series_conclusion = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2}\", r\"\\ \\text{converges}\")\n        self.play(ReplacementTransform(integral_test, series_conclusion))\n        self.wait(1)\n\n        # Explanation on known result\n        explanation2 = Text(\"This is a known convergent series: Basel problem\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{\\pi^2}{6}\")\n        self.play(ReplacementTransform(series_conclusion, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"Thus, the infinite series equals \")), Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that explains the step-by-step process of solving a triple integral? Specifically, I want the visualization to illustrate the integration of the function xyz over the unit cube, starting from integrating x from 0 to 1, then y from 0 to 1, and finally z from 0 to 1. Additionally, after each integration step, I'd like a brief written explanation to appear, clarifying which variable we're integrating with respect to, followed by the intermediate results. Once all integrations are complete, I want the final solution to be displayed clearly, and conclude the animation with a statement indicating the result of the triple integral.",
        "answer": "\\n from manim import *\n\nclass CreateGraphScene(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        dotted_line = DashedVMobject(axes.get_vertical_line_to_graph(1, graph, color=YELLOW))\n\n        self.play(Create(axes), Create(graph))\n        self.play(FadeIn(graph_label), Create(dotted_line))\n        self.wait(2)\n        \n        derivative = axes.plot_derivative_graph(graph, color=PURPLE)\n        self.play(Create(derivative))\n        self.wait(2)"
    },
    {
        "query": "Please create an animated math video that explains the process of evaluating the definite integral of sine from 0 to pi. Start by displaying the integral problem, then show the steps to compute the integral with the antiderivative of sine, and evaluate it at the upper and lower bounds. Include on-screen text to guide me through the evaluation of the antiderivative at the bounds. Finally, display the simplified solution and present the final result separately before ending the video.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Broadcast\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(Broadcast(triangle))\n            self.remove(triangle)"
    },
    {
        "query": "How can I create an educational animation using a tool that illustrates the one-dimensional wave equation, its general solution, and briefly touches on particular solutions with accompanied explanations, pausing between each step to allow the content to be absorbed?",
        "answer": "\\n from manim import *\n\nclass ConceptOfLimitExample(Scene):\n    def construct(self):\n        # Display the function and a point approaching a value\n        func_graph = MathTex(r\"f(x) = \\frac{1}{1+x^2}\")\n        point_label = MathTex(r\"x = a\")\n        self.play(Write(func_graph))\n        self.wait(1)\n\n        # Moving the point on the function graph\n        self.play(Write(point_label))\n        self.wait(2)\n\n        # Expression for the limit\n        limit_expr = MathTex(r\"\\lim_{x \\to a} f(x)\")\n        self.play(Transform(func_graph, limit_expr))\n        self.wait(2)\n\n        # Explanation of the limit's meaning\n        explanation = Text(\"We observe f(x) as x approaches a\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Show a value for 'a' and the corresponding limit value\n        a_value = MathTex(r\"a = 2\")\n        limit_value = MathTex(r\"\\lim_{x \\to 2} \\frac{1}{1+x^2} = \\frac{1}{5}\")\n        self.play(Write(a_value))\n        self.play(Transform(limit_expr, limit_value))\n        self.wait(2)\n\n        # Clear the scene and show the final limit value\n        self.clear()\n        self.play(Write(limit_value))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that demonstrates the process of calculating a definite integral. Specifically, it should show the integration of x cubed from 0 to 2. The animation should begin by presenting the integration problem, then explain how to apply the power rule for definite integration. Next, it should show the step-by-step process of integrating x cubed, starting with the application of the power rule and finishing with the evaluation of the integral at the boundaries 0 and 2. Finally, the animation should conclude by clearly showing the numeric solution to the integral. Can you create an animation like this for a classroom setting that helps students understand the concept visually?",
        "answer": "\\n from manim import *\n\nclass MagneticFieldLines(Scene):\n    def construct(self):\n        magnet = Rectangle(color=BLUE)\n        north_pole = Tex(\"N\").next_to(magnet, UP)\n        south_pole = Tex(\"S\").next_to(magnet, DOWN)\n\n        self.play(Create(magnet), Write(north_pole), Write(south_pole))\n        self.wait(1)\n\n        field_lines = StreamLines(\n            lambda p: np.array([-p[1], p[0], 0]) / (p[0]**2 + p[1]**2),\n            color=BLUE,\n            max_anchors_per_line=30,\n            padding=1\n        )\n\n        self.play(Create(field_lines), run_time=3)\n        self.wait(2)"
    },
    {
        "query": "Could you please create an educational animation that visually demonstrates how to find the area under the curve of the function y = x^2 from x = 0 to x = 2? Begin by showing the function itself, then draw the graph on a set of axes, and include a label for the curve. Afterward, display the integral expression for the area under the curve and highlight the actual area under the graph between those two points. Once the area is highlighted, show the calculated result of the integral. Finally, clear everything else away and leave only the final result of the integration on the screen.",
        "answer": "\\n from manim import *\n\nclass HydrogenAnimation(Scene):\n    def construct(self):\n        hydrogen = self.create_hydrogen()\n        self.play(FadeIn(hydrogen))\n        self.play(Rotate(hydrogen, angle=2 * PI), run_time=2)\n        self.play(FadeOut(hydrogen))\n\n    def create_hydrogen(self) -> Mobject:\n        circle = Circle(radius=0.3, color=BLUE)\n        text = Tex(\"H\", font_size=30, color=WHITE)\n        electron = self.create_electron()\n\n        hydrogen = VGroup(circle, text, electron)\n        hydrogen.arrange(RIGHT)\n\n        return hydrogen\n\n    def create_electron(self) -> Mobject:\n        orbit = Ellipse(width=0.8, height=0.5, stroke_color=RED)\n        dot = Dot(color=RED)\n        elec = VGroup(orbit, dot)\n\n        return elec.rotate_in_place(PI/2)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the process of solving the integral of the square root of 1 minus x squared using trigonometric substitution, including the steps of introducing the substitution, replacing the original integral, simplifying using a trigonometric identity, integrating the simplified integral, and then back-substituting to get the final answer in terms of x? Please ensure the animation introduces each step with text explanations and transitions smoothly between the steps.",
        "answer": "\\n from manim import *\n\nclass VectorFieldGraph(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        field = ArrowVectorField(lambda p: np.array([-p[1], p[0], 0]), x_range=[-5, 5], y_range=[-5, 5])\n        \n        self.play(Create(plane))\n        self.play(Create(field))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that starts by displaying the mathematical function sin(x) on the screen, then walks me through what Fourier Series is by showing text that it decomposes periodic functions into simpler trigonometric functions? After that, replace the sin(x) function with the general formula for a Fourier Series, and follow up with an explanation that the coefficients of the series depend on the shape of the function being decomposed. Next, show the specific coefficients for the Fourier Series representation of sin(x) and clear the screen. Finish by showing an approximation of sin(x) using the first three non-zero terms of its Fourier Series expansion.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale(scale_factor=1.5))\n            self.remove(square)"
    },
    {
        "query": "I would like to create an animated video using ManimCE to explain the process of integrating the sine function from 0 to pi/2. The animation should include the following steps:\n\n1. Display the integral of sin(x) with respect to x from 0 to pi/2 on the screen.\n2. Add a textual explanation above the integral that says \"Integrate the sine function.\"\n3. Show the next step in the integration by replacing the integral with the antiderivative, which is negative cosine, evaluated from 0 to pi/2.\n4. Transform the antiderivative into the evaluation form by showing the cosine of pi/2 and 0.\n5. Update the textual explanation to say \"Evaluate the cosine values at the bounds.\"\n6. Replace the evaluation form with the actual numerical results of the evaluation, simplifying it step by step until reaching the final result.\n7. After reaching the final simplified result as a number, clear the screen and then display the final result prominently followed by a brief pause.\n\nPlease ensure that there is a small waiting time between each step so the viewer can follow the calculations easily.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem of a definite integral\n        problem = MathTex(r\"\\int_2^4 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule with limits of integration\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left.\\frac{x^{n+1}}{n+1}\\right|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step with the specific limits\n        solution1 = MathTex(r\"= \\left.\\frac{x^{3+1}}{4}\\right|_2^4\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Applying the Fundamental Theorem of Calculus\n        evaluated_integral = MathTex(r\"= \\frac{4^{4}}{4} - \\frac{2^{4}}{4}\")\n        self.play(ReplacementTransform(solution1, evaluated_integral))\n        self.wait(1)\n\n        # Simplify the evaluation step\n        simplified_evaluation = MathTex(r\"= 64 - 4\")\n        self.play(Transform(evaluated_integral, simplified_evaluation))\n        self.wait(1)\n\n        # Final solution of the definite integral\n        final_solution = MathTex(r\"= 60\")\n        self.play(Transform(evaluated_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final confirmed solution\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that shows how Fourier series can be used to approximate functions, starting by displaying the title \"Fourier Series Demo,\" then showing the general equation of a Fourier series, followed by transforming it into a partial sum equation, adding an explanatory text at the top about approximating functions, and then showing a specific example of a three-term approximation of the series with coefficients a_0, a_1, a_2, b_1, b_2, b_3, and finally fading everything out?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{1}^{3} 2x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation = Text(\"Compute the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Performing the integration steps\n        integral_steps = MathTex(\n            r\"\\int 2x \\,dx\",\n            r\"= x^2 + C\\bigg|_1^3\",\n            r\"= 3^2 - 1^2\",\n            r\"= 9 - 1\",\n            r\"= 8\",\n        )\n\n        # Align and animate the steps\n        integral_steps.arrange(DOWN, center=False, aligned_edge=LEFT)\n        for step in integral_steps:\n            self.play(Write(step))\n            self.wait(2)\n        \n        # Clear the screen\n        self.clear()\n        self.wait(1)\n\n        # Display final result\n        final_result = MathTex(r\"\\int_{1}^{3} 2x \\,dx = 8\")\n        self.play(FadeIn(final_result))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational math animation that visually explains the concept of finding the area under a curve using definite integration. The animation should start by displaying the integral of x squared from 0 to 3. Then, there should be a highlight around the x squared function to emphasize it. Following this, I'd like the animation to include a sentence that mentions the definite integral represents the area under the curve. Next, the animation should show the process of integrating x squared from 0 to 3, step by step, and end by calculating the exact area value numerically. After the calculation is complete, clear everything away and just show the final numerical answer. Can this all be done in an animated sequence that's easy to follow and educational?",
        "answer": "\\n from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the differential equation\n        diff_eq = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Explanation for separation of variables\n        explanation1 = Text(\"Separate the variables\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Separated equation\n        sep_eq = MathTex(r\"\\frac{dy}{dx} = 3y\")\n        self.play(ReplacementTransform(diff_eq.copy(), sep_eq))\n        self.wait(1)\n\n        # Integrating both sides\n        explanation2 = Text(\"Integrate both sides\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integrated equation\n        integrated_eq = MathTex(r\"\\ln|y| = 3x + C\")\n        self.play(ReplacementTransform(sep_eq, integrated_eq))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"y = C e^{3x}\")\n        self.play(Write(final_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clean up the scene\n        self.play(FadeOut(integrated_eq), FadeOut(explanation1))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the proof of the Pythagorean Theorem. The animation should start by displaying the equation 'a^2 + b^2 = c^2' and then show a triangle with its sides labeled 'a', 'b', and 'c'. Next, I would like to see squares constructed on each side of the triangle and arrows pointing from the terms in the equation to their corresponding squares. Finally, the animation should end with the text 'Pythagorean Theorem Proved!' displayed on the screen. Can this be created in a way that would help visually explain the theorem to students learning about it for the first time?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral representing area under the curve\n        integral_equation = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral_equation))\n        self.wait(1)\n\n        # Give an explanation for the area under the curve\n        explanation1 = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(1)\n\n        # Calculating the antiderivative\n        antiderivative = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(ReplacementTransform(integral_equation.copy(), antiderivative))\n        self.wait(1)\n\n        # Substituting the limits\n        substituting_limits = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\")\n        self.play(ReplacementTransform(antiderivative, substituting_limits))\n        self.wait(1)\n\n        # Final solution showing the area\n        solution = MathTex(r\"= \\frac{1}{3}(8 - 0)\")\n        self.play(ReplacementTransform(substituting_limits, solution))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(solution, final_answer))\n        self.wait(1)\n\n        # Clearing the scene\n        self.play(FadeOut(explanation1), FadeOut(final_answer))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that explains the concept of Fourier Series. The animation should start by displaying the mathematical formula for the Fourier Series. Then, it should include a brief text description stating that Fourier Series can represent periodic functions, followed by another text indicating the significance of the coefficients a_n and b_n in determining the function's shape. Next, show the formulas for calculating these coefficients in relation to the function. Afterwards, include an explanation that as the number of terms n increases, the series converges to the actual function f(x). Finally, conclude the animation by emphasizing that Fourier Series decompose periodic functions into their harmonic components. Can you design this animation in a way that suits a beginner's understanding, with clear text and equations?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1}\\int_{0}^{1} \\frac{1}{2}x^2yz \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{4}x^2yz^2 \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n        \n        # Explanation for the outermost integral\n        explanation3 = Text(\"Lastly, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{4}x^2y\\frac{z^3}{3} \\bigg|_{0}^{1}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(2)\n\n        # Calculating the definite integral\n        definite_integral = MathTex(r\"= \\frac{1}{12}\")\n        self.play(Transform(final_solution, definite_integral))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(explanation1), FadeOut(final_solution))\n        self.wait(1)\n        self.play(Write(definite_integral))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an educational animation that visually explains how to evaluate the definite integral of x cubed from 0 to 2 using the power rule for integration. The animation should include the following steps: display the problem, write an explanation of applying the power rule, demonstrate the power rule itself, perform the integration step by step, evaluate the integral with the given bounds, show the final solution, and finally, conclude by clearly presenting the final numerical result. Can you make this animation engaging, with each step appearing in sequence and with appropriate pauses to allow viewers to follow along?",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef ThoughtBubble(**kwargs):\n    gp = VGroup(\n        Ellipse(width=4, height=3),\n        Polygram([\n            [-4/3, -3 + 0.45, 0], \n            [-4/2.6, -3 + 0.9, 0], \n            [-4/2.6 + 0.85, -3 + 0.9, 0]\n        ]),\n        Dot([-4/2.6 + 1.35, -3 + 0.9, 0], radius=0.1),\n        Dot([-4/2.6 + 1.6, -3 + 0.75, 0], radius=0.1),\n        Dot([-4/2.6 + 1.85, -3 + 0.6, 0], radius=0.1)\n    )\n\n    return Union(*gp, **kwargs)\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass GreatestCommonDivisor(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        math_student = ImageMobject(\"./assets/math_student.png\")\n        math_student.scale(0.7)\n        math_student.to_edge(DOWN)\n        \n        thought = ThoughtBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_BLUE_COLOR)\n        thought.next_to(math_student, UP+LEFT, buff=0.3)\n        \n        gcd_text = VGroup(\n            Text(\"Qual \u00e9 o MDC\", color=WHITE),\n            Text(\"de 48 e 64?\", color=WHITE)\n        )\n        gcd_text.scale(0.7)\n        gcd_text.arrange(DOWN, buff=0.1)\n        gcd_text.move_to(thought.get_center_of_mass() + 0.3*UP + 0.4*RIGHT)\n        \n        self.play(FadeIn(math_student))\n        self.play(Create(thought), Write(gcd_text))\n        self.wait(2)\n        \n        answer_text = VGroup(\n            Text(\"MDC(48, 64) = 16\", color=WHITE)\n        )\n        answer_text.scale(0.7)\n        answer_text.to_edge(UP)\n        \n        self.play(ReplacementTransform(gcd_text, answer_text))\n        self.wait(2)\n        \n        self.play(FadeOut(math_student), FadeOut(thought), FadeOut(answer_text))"
    },
    {
        "query": "Can you create an animated video that visually represents the process of solving a triple integral, step by step? Start with the integral of the function xyz over the unit cube, where the integration is performed first with respect to x, then y, and finally z. Display each integration step with a text explanation above it, and show the simplification until the final answer is reached. Clear the screen before showing the final result again at the end.",
        "answer": "\\n from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the differential equation\n        diff_eq = MathTex(r\"\\frac{dy}{dx} + 3y = x\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n        \n        # Displaying the integrating factor\n        int_factor = Text(\"Integrating factor: \", font_size=24).to_edge(UP)\n        mu = MathTex(r\"\\mu(x) = e^{3x}\")\n        self.play(Write(int_factor))\n        self.play(Write(mu))\n        self.wait(2)\n        \n        # Multiply the differential equation by integrating factor\n        modified_eq = MathTex(r\"e^{3x}\\frac{dy}{dx} + 3e^{3x}y = xe^{3x}\")\n        self.play(ReplacementTransform(diff_eq.copy(), modified_eq))\n        self.wait(1)\n        \n        # General solution before integration\n        gen_sol_before = Text(\"General solution (before integration):\", font_size=24).to_edge(UP)\n        self.play(Transform(int_factor, gen_sol_before))\n        self.wait(2)\n        \n        # Integrate both sides\n        gen_sol_after = MathTex(r\"y(x) = \\frac{e^{-3x}}{3}\\int xe^{3x}\\,dx + Ce^{-3x}\")\n        self.play(ReplacementTransform(modified_eq, gen_sol_after))\n        self.wait(1)\n        \n        # Final general solution\n        final_gen_sol = MathTex(r\"y = \\frac{1}{3}x - \\frac{1}{9} + Ce^{-3x}\")\n        self.play(Write(final_gen_sol))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Solution to the first-order ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(int_factor, conclusion))\n        self.wait(2)\n        \n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_gen_sol))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that explains the concept of calculating the surface area of a parametric surface in multivariable calculus, starting with the surface integral symbol and then showing the parametric equation of a surface? Then can you illustrate the formula for the surface area element in terms of the partial derivatives of the surface with respect to its parameters, and show how this formula is substituted into the integral? Finally, can you conclude by indicating that solving the resulting double integral will yield the surface area, but leave the actual solution as an exercise for the viewer?",
        "answer": "\\n class ValueTrackerPlot(Scene):\n    def construct(self):\n        a = ValueTracker(1)\n        ax = Axes(x_range=[-2, 2, 1], y_range=[-8.5, 8.5, 1], x_length=4, y_length=6)\n        parabola = ax.plot(lambda x: a.get_value() * x**2, color=RED)\n        parabola.add_updater(\n            lambda mob: mob.become(ax.plot(lambda x: a.get_value() * x**2, color=RED))\n        )\n        a_number = DecimalNumber(\n            a.get_value(),\n            color=RED,\n            num_decimal_places=3,\n            show_ellipsis=True\n        )\n        a_number.add_updater(\n            lambda mob: mob.set_value(a.get_value()).next_to(parabola, RIGHT)\n        )\n        self.add(ax, parabola, a_number)\n        self.play(a.animate.set_value(2))\n        self.play(a.animate.set_value(-2))\n        self.play(a.animate.set_value(1))"
    },
    {
        "query": "I would like an educational animation that introduces the quadratic equation \"ax^2 + bx + c = 0\", demonstrates the formula to find its roots \"x = (-b \u00b1 \u221a(b\u00b2 - 4ac)) / (2a)\", explains the discriminant \"D = b\u00b2 - 4ac\", shows that the nature of the quadratic equation's roots depends on the value of the discriminant, provides an example with a positive discriminant, and concludes with the significance of a positive discriminant indicating two distinct real roots.",
        "answer": "\\n import math\nfrom manim import *\n\nclass ShapesScene(Scene):\n    def construct(self):\n        # Create a background color gradient rectangle\n        background = Rectangle(width=config.frame_width, height=config.frame_height)\n        background.set_fill(BLUE_D, opacity=1)\n        background.set_stroke(BLUE_E, width=6)\n\n        # Display the background on the scene\n        self.play(FadeIn(background))\n        self.wait(1)\n\n        # Adding a square on the screen\n        square = Square(side_length=3)\n        square.set_stroke(color=YELLOW, width=3)\n        square.set_fill(YELLOW, opacity=0.5)\n\n        # Display and move the square on the scene\n        self.play(Create(square))\n        self.wait(1)\n        self.play(square.animate.shift(UP + RIGHT))\n        self.wait(1)\n\n        # Adding a circle overlapping the square\n        circle = Circle(radius=1.5)\n        circle.set_stroke(color=GREEN, width=3)\n        circle.set_fill(GREEN, opacity=0.5)\n        \n        # Display and move the circle on the scene\n        self.play(Create(circle))\n        self.wait(1)\n        self.play(circle.animate.next_to(square, UP))\n        self.wait(1)\n\n        # Group both shapes and animate them together\n        shapes = VGroup(square, circle)\n        self.play(shapes.animate.shift(LEFT * 2))\n        self.wait(1)\n        \n        # Fade out everything\n        self.play(FadeOut(VGroup(background, shapes)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually explains the process of calculating a double integral in polar coordinates, specifically showing the step-by-step integration of r^2 sin(theta) with respect to r from 0 to 1 and then with respect to theta from 0 to pi, including the intermediate steps and the final solution?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function to be integrated\n        function = MathTex(r\"f(x) = 3 - x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Display the integral\n        integral = MathTex(r\"\\int_{-1}^{2} (3 - x^2) \\,dx\")\n        self.play(Transform(function, integral))\n        self.wait(1)\n\n        # Show the graph of the function\n        graph = FunctionGraph(lambda x: 3 - x**2, x_range=[-1, 2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Fill the area under the curve\n        area = graph.get_area(-1, 2)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Calculate the antiderivative\n        antiderivative = MathTex(r\"= [\\frac{3x}{1} - \\frac{x^3}{3}]_{-1}^{2}\")\n        self.play(Transform(integral, antiderivative))\n        self.wait(1)\n\n        # Evaluating the integral at bounds\n        bounds_evaluation = MathTex(r\"= (6 - \\frac{8}{3}) - (-3 - \\frac{-1}{3})\")\n        self.play(ReplacementTransform(antiderivative, bounds_evaluation))\n        self.wait(1)\n\n        # Show the result\n        result = MathTex(r\"= \\frac{18}{3} - \\frac{8}{3} + 3 + \\frac{1}{3}\", r\"= 14\")\n        self.play(ReplacementTransform(bounds_evaluation, result))\n        self.wait(1)\n\n        # Clear the scene and show only the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(result))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that illustrates the following mathematical concept: Begin by showing the function f(x) = 3 - x^2 on the screen. Once displayed, introduce a question that asks to find the area under the curve of this function from x = -1 to x = 2. Afterwards, demonstrate how to set up the corresponding definite integral to solve for the area. Then, show the steps to calculate the integral and the antiderivative from -1 to 2. Finally, present the computed area as a fraction and emphasize the final answer by stating \"Area under the curve is 7/3\" at the bottom edge of the screen. Clear everything else off and end by just showing the final solution again for clarity.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve1 = MathTex(r\"f(x) = 3x + 2\").to_edge(UP)\n        curve2 = MathTex(r\"g(x) = x^2 - 1\").next_to(curve1, DOWN)\n\n        self.play(Write(curve1))\n        self.wait(1)\n        self.play(Write(curve2))\n        self.wait(1)\n\n        problem = MathTex(r\"\\int_1^3\", r\"(3x + 2)\", r\"-\", r\"(x^2 - 1)\", r\"dx\")\n        self.play(Write(problem))\n        self.wait(2)\n\n        integral_setup = MathTex(r\"= \\int_1^3\", r\"2x - x^2 + 3\", r\"dx\")\n        self.play(ReplacementTransform(problem, integral_setup))\n        self.wait(2)\n\n        evaluation = MathTex(r\"= [x^2 - \\frac{1}{3}x^3 + 3x]_1^3\")\n        self.play(ReplacementTransform(integral_setup, evaluation))\n        self.wait(2)\n\n        final_answer = MathTex(r\"= (9 - \\frac{1}{3}(27) + 9)\", r\"-\", r\"(1 - \\frac{1}{3}(1) + 3)\")\n        self.play(ReplacementTransform(evaluation, final_answer))\n        self.wait(2)\n\n        simplified = MathTex(r\"= (9 - 9 + 9)\", r\"-\", r\"(1 - \\frac{1}{3} + 3)\")\n        self.play(ReplacementTransform(final_answer, simplified))\n        self.wait(2)\n\n        result = MathTex(r\"= 9 - 0 +\", r\"2\\frac{2}{3}\")\n        self.play(ReplacementTransform(simplified, result))\n        self.wait(2)\n\n        self.play(FadeOut(curve1), FadeOut(curve2), FadeOut(result))\n        self.wait(1)\n\n        conclusion = Text(\"The area between f(x) and g(x) from x=1 to x=3 is 11 2/3\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually shows the area under the curve of y = x^2 from x=0 to x=2, includes the integral symbol with the corresponding limits, demonstrates the calculation of the definite integral, and then displays the final numerical result of the integral calculation? Additionally, after showing the final result, can you make sure that all elements are cleared from the screen?",
        "answer": "\\n from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        grid = self.create_ionic_grid(3, 3)\n        self.play(Create(grid))\n        self.wait()\n        ion_path = self.generate_ion_path(grid)\n        lithium_ion_obj = lithium_ion()\n        self.play(FadeIn(lithium_ion_obj))\n        ion_animations = move_along_complex_path(lithium_ion_obj, [1, 3], ion_path, run_time=2)\n        self.play(*ion_animations)\n        self.wait(2)\n\n    def create_ionic_grid(self, rows: int, cols: int) -> VGroup:\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    ion = oxygen().shift(RIGHT * j + UP * i)\n                else:\n                    ion = metal().shift(RIGHT * j + UP * i)\n                grid.add(ion)\n        grid.move_to(ORIGIN)\n        return grid\n    \n    def generate_ion_path(self, grid: VGroup) -> List[Point]:\n        # Starting from the center of the grid, create a complex path\n        path_points = []\n        center = grid.get_center()\n        path_points.append(center)\n        offset = RIGHT + UP\n\n        for _ in range(4):\n            new_point = center + offset\n            path_points.append(new_point)\n            center = new_point\n            offset.rotate(PI/2)\n        \n        return path_points\n\n# Helper function as defined in user's sample code\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color=color, stroke_width=stroke_width).set_fill(fill_color, opacity=1)\n    t = Tex(txt, font_size=font_size, color=font_color).set_z_index(1)\n    return VGroup(c, t)\n\n# Other helper functions would be included as they are from the user's sample\ndef oxygen() -> Mobject:\n    # function definition from user's sample\n\ndef metal() -> Mobject:\n    # function definition from user's sample\n\ndef lithium_ion() -> Mobject:\n    # function definition from user's sample\n\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n    # function definition from user's sample\n\n# Other Manim scene construction would continue as usual..."
    },
    {
        "query": "I would like to create an educational animation video that explains what a Fourier series is and how it can be used to approximate a simple function like x squared. The animation should start by presenting the concept with a title, then show the actual function being considered, and gradually introduce the general formula for the Fourier series, highlighting the coefficients involved. After that, it needs to demonstrate a specific example of the Fourier series by considering a partial sum up to the fifth term. Lastly, I'd like to remove all other elements and focus only on this fifth partial sum to emphasize the approximation. Can you create such an animation for me?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Plotting the graph of the function\n        graph = FunctionGraph(\n            lambda x: x**2,\n            x_range=[-3, 3],\n        )\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Highlighting the area under the curve from x=0 to x=2\n        area = area = Integral(graph, (0, 2), color=BLUE)\n        area_label = MathTex(r\"\\int_0^2 x^2 \\,dx\", color=BLUE).next_to(area, UP+RIGHT)\n        \n        self.play(FadeIn(area, area_label))\n        self.wait(2)\n\n        # Calculating the area\n        calculation = MathTex(r\"= \\left[ \\frac{1}{3}x^3 \\right]_0^2\")\n        calculation.to_edge(RIGHT, buff=1)\n        self.play(Write(calculation))\n        self.wait(1)\n\n        # Showing the value of the definite integral\n        value = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\")\n        self.play(Transform(calculation, value))\n        self.wait(1)\n\n        result = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(calculation, result))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(result))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that introduces the one-dimensional wave equation, shows its general solution for waves traveling in opposite directions, and gives an example of a specific solution in the form of a sine wave? Include textual explanations for each step and conclude by highlighting the sine wave solution.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.space_out_submobjects\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            star = Star()\n            circle.add(star)\n            self.play(circle.animate.space_out_submobjects(factor=2))\n            self.remove(circle,star)"
    },
    {
        "query": "Can you create an educational animation that shows the process of calculating the definite integral of the function x cubed from 0 to 2? Start by displaying the integral problem, then explain the use of the power rule for integration, followed by demonstrating it. Subsequently, perform the integration step by step. Finally, reveal the numerical result after evaluating at the boundaries, and conclude the animation with the final answer to the integral.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Evaluate by using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Applying definite integral bounds\n        definite_bounds = MathTex(r\"\\Big|_2^3\")\n        self.play(Write(definite_bounds.next_to(power_rule, RIGHT)))\n        self.wait(2)\n\n        # Showing the next step for evaluation\n        step1 = MathTex(r\"= \\frac{3^4}{4} - \\frac{2^4}{4}\")\n        self.play(ReplacementTransform(problem.copy(), step1.shift(DOWN)))\n        self.wait(1)\n\n        # Showing simplification process\n        explanation2 = Text(\"Simplify the result\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{81}{4} - \\frac{16}{4}\")\n        self.play(ReplacementTransform(step1, final_solution))\n        self.wait(1)\n\n        # Calculate the final numeric result\n        numeric_result = MathTex(r\"= \\frac{65}{4}\")\n        self.play(ReplacementTransform(final_solution, numeric_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the numeric result\n        self.play(Write(numeric_result))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that illustrates the process of finding the area under the curve f(x) = x^2 - 4x + 4 from x=0 to x=2, including the integral setup and the step-by-step calculation of the area, ending with a clear display of the final answer. Can you highlight the answer at the end before showing it by itself?",
        "answer": "\\n         self.play(Transform(text,Text(\"TracedPath\").shift(UP*2.5)), run_time=0.5)\n        dot = Dot(color=RED)\n        trace = TracedPath(dot.get_center)\n        self.add(dot, trace)\n        self.wait(0.5)\n        self.play(dot.animate.shift(UP), run_time=0.5)\n        self.play(dot.animate.shift(LEFT), run_time=0.5)\n        self.play(dot.animate.shift(DOWN+RIGHT), run_time=0.5)\n        self.remove(dot, trace)"
    },
    {
        "query": "Could you create an educational animation that illustrates the step-by-step process of evaluating a double integral in polar coordinates, starting from the initial problem statement of the integral of (r^2 sin(theta)) with respect to 'r' and 'theta', and showing each transformation of the integral until the final solution is derived?",
        "answer": "\\n from manim import *\n\nclass ThirdOrderODEExample(Scene):\n    def construct(self):\n        # Display the differential equation\n        diff_eq = MathTex(r\"y''' - 3y'' + 3y' - y = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Introduce the characteristic equation\n        char_eq_intro = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(char_eq_intro))\n        self.wait(2)\n\n        # Display the characteristic polynomial\n        char_poly = MathTex(r\"r^3 - 3r^2 + 3r - 1 = 0\")\n        self.play(ReplacementTransform(diff_eq, char_poly))\n        self.wait(2)\n\n        # Show how to solve the characteristic polynomial\n        solve_char_eq = Text(\"Solve the cubic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_intro, solve_char_eq))\n        self.wait(2)\n\n        # Solve the polynomial\n        polynomial_roots = MathTex(r\"r = 1\")\n        self.play(ReplacementTransform(char_poly, polynomial_roots))\n        self.wait(2)\n\n        # Display the general solution to the differential equation\n        general_solution = MathTex(r\"y = C_1 e^{x} + C_2 x e^{x} + C_3 x^2 e^{x}\")\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Explain the general solution\n        general_solution_explanation = Text(\"General solution to the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_intro, general_solution_explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Restate the general solution at the end\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you please create an animation that shows the process of finding the derivative of the function f(x) = x^3 + 3x^2 + 2x + 1, demonstrates the calculation of the derivative step by step, and then identifies the critical points of the derived function? The animation should start by writing the original function on the screen, then move the function to the top and show a text below saying \"Calculating the derivative\". Then, replace the original function with its derivative, simplify it to show \"f'(x) = 3x^2 + 6x + 2\", and then change the text to \"Find critical points\". Afterwards, replace the simplified derivative with the critical points \"x=-2, x=-1/3\" and then clear the screen and conclude by showing the critical points again to emphasize the result.",
        "answer": "\\n from manim import *\n\nclass SquareWithText(Scene):\n    def construct(self):\n        square = Square(side_length=3, fill_color=BLUE, fill_opacity=0.5)\n        text = Text(\"Manim\", color=WHITE, font_size=24)\n        group = VGroup(square, text).move_to(ORIGIN)\n        self.play(Create(group))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that illustrates the process of calculating the area under the curve of the function f(x) = e^(-x^2) from x = 0 to x = 2, includes a numerical approximation of that area, and provides a visual explanation using Riemann rectangles as well as displaying the approximate numerical value of the integral at the end?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the function and the area to be shaded\n        func = lambda x: 0.1 * (x - 3)**2 + 1\n        area = [1, 5]\n\n        # Displaying the function graph\n        graph = FunctionGraph(func, x_range=[0, 6])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Displaying the area under the curve\n        shaded_area = area_under_curve = self.get_area(graph, x_range=area)\n        self.play(FadeIn(shaded_area))\n        self.wait(1)\n\n        # Showing the bounds of the integral\n        bounds = MathTex(r\"a = 1, b = 5\")\n        self.play(Write(bounds))\n        self.wait(1)\n\n        # Showing the integral expression\n        integral_expr = MathTex(r\"\\int_{a}^{b} f(x) \\,dx\")\n        self.play(Transform(bounds, integral_expr))\n        self.wait(2)\n\n        # Calculate the value\n        result = MathTex(r\"\\approx 10.67\")\n        self.play(ReplacementTransform(integral_expr, result))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(result))\n        self.wait(1)\n        \n    # Function to get area under curve between two x values\n    def get_area(self, graph, x_range):\n        return self.camera.background_plane.get_riemann_rectangles(\n            graph, x_range=x_range, dx=0.1, stroke_width=0.1\n        )"
    },
    {
        "query": "I would like to create an educational animation illustrating the step-by-step process of solving a triple integral. Start by showing the integral of the function xyz over the unit cube with limits from 0 to 1 for all variables. Then gradually integrate with respect to z, y, and finally x, each time updating the visual with the new integral expression after evaluating the previous variable. In between each step, have a short written explanation appear at the top saying which variable we're integrating with respect to next. After the final integration, display the numeric answer on the screen. Once the solution is shown, clear the screen momentarily before showing the final answer again. Can you create this animation in a smooth and understandable manner for teaching calculus students?",
        "answer": "\\n from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the equation of the ODE\n        ode = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Display the process of solving the ODE\n        solve_ode = Text(\"Solve the differential equation\", font_size=24).to_edge(UP)\n        self.play(Write(solve_ode))\n        self.wait(2)\n\n        # Display the integrating factor\n        int_factor = MathTex(r\"\\mu(x) = e^{3x}\")\n        self.play(Write(int_factor))\n        self.wait(1)\n\n        # Replace the Text with the next step\n        method_step = Text(\"Use the integrating factor\", font_size=24).to_edge(UP)\n        self.play(Transform(solve_ode, method_step))\n        self.wait(2)\n\n        # Multiply through by integrating factor and solve\n        solution = MathTex(r\"y = Ce^{3x}\")\n        self.play(ReplacementTransform(int_factor, solution))\n        self.wait(2)\n\n        # Show the general solution\n        general_solution = MathTex(r\"y(x) = Ce^{3x}\")\n        general_solution.to_edge(DOWN)\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explain the general solution\n        explanation = Text(\"General solution of the first-order ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(solve_ode, explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Highlight general solution for the ODE\n        self.play(Write(general_solution.scale(1.5)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that shows the process of integrating the trigonometric expression sin(x) cos(x) using a trigonometric identity, with clear steps and explanations included in the animation?",
        "answer": "\\n from manim import *\n\nclass ExampleSurfaceIntegral(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\iint_S (x^2 + y^2) \\, dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        explanation1 = Text(\"Use the parametrization of the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        surface_param = MathTex(r\"S(r, \\theta) = \\left< r\\cos\\theta, r\\sin\\theta, z(r,\\theta) \\right>\", r\"\\\\ 0 \\leq r \\leq 1\", r\",\\ 0 \\leq \\theta \\leq 2\\pi\")\n        self.play(Write(surface_param))\n        self.wait(2)\n\n        explanation2 = Text(\"Convert to polar coordinates\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        polar_conversion = MathTex(r\"\\iint_S (x^2 + y^2) \\, dS = \\int_0^{2\\pi} \\int_0^1 r^2 \\cdot r \\, dr \\, d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), polar_conversion))\n        self.wait(1)\n\n        explanation3 = Text(\"Evaluate the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        integral_solution = MathTex(r\"= \\int_0^{2\\pi} \\left[ \\frac{r^4}{4} \\right]_{0}^{1} \\, d\\theta = \\frac{1}{4} \\int_0^{2\\pi} d\\theta = \\frac{\\pi}{2}\")\n        self.play(ReplacementTransform(polar_conversion, integral_solution))\n        self.wait(1)\n\n        self.clear()\n        self.wait(1)\n\n        final_solution = MathTex(r\"\\iint_S (x^2 + y^2) \\, dS = \\frac{\\pi}{2}\")\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually represents the area under the curve of the function 0.1(x-3)^2 from x=0 to x=5, and then goes through the steps of calculating the definite integral of that function? Include the graph of the function, the integral problem statement, and a step-by-step solution, ending with clearing everything but the final result.",
        "answer": "\\n from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Create an electron\n        electron_object = electron()\n        self.play(FadeIn(electron_object))\n        self.wait(1)\n\n        # Create an oxygen atom\n        oxygen_object = oxygen()\n        self.play(Transform(electron_object, oxygen_object))\n        self.wait(1)\n\n        # Create grid of metal oxides\n        metal_oxide_grid = metal_oxid(3, 3)\n        self.play(FadeTransform(oxygen_object, metal_oxide_grid))\n        self.wait(1)\n\n        # Create a single carbon atom\n        carbon_object = carbon()\n        self.play(FadeIn(carbon_object))\n        self.wait(1)\n\n        # Move the carbon atom along a complex path\n        complex_path = [UP, UP + RIGHT, RIGHT, DOWN + RIGHT, DOWN, DOWN + LEFT, LEFT, UP + LEFT, UP]\n        stop_indices = [2, 5]\n        animations = move_along_complex_path(carbon_object, stop_indices, complex_path, run_time=2, rate_func=smooth)\n        self.play(*animations)  # Play all the animations together\n        self.wait(2)\n\n        # Final fade out of all objects\n        all_objects = VGroup(electron_object, metal_oxide_grid, carbon_object)\n        self.play(FadeOut(all_objects))"
    },
    {
        "query": "Could you create an educational animation that visually demonstrates how to calculate the area under the curve of the function x squared from 0 to 2, including labeling the function, shading the area under the curve, and displaying the calculated value of the definite integral below the shaded area, all using colored graphical elements to enhance understanding?",
        "answer": "\\n from manim import *\n\n\nclass ChemicalScene(Scene):\n    def construct(self):\n        # Create an electron\n        e = electron()\n\n        # Create an oxygen atom\n        o_atom = oxygen()\n\n        # Create a metallic atom\n        metal_atom = metal()\n\n        # Create a positive ion\n        pos_ion = positive()\n\n        # Create a negative ion\n        negative_ion = negative()\n\n        # Create a metal oxide grid\n        metal_oxide_grid = metal_oxid(3, 3)\n        \n        # Create a carbon layer\n        c_layer = carbon_layer()\n\n        # Create a complex moving electron\n        electron_path = [LEFT * 3, LEFT * 2 + UP * 2, RIGHT * 2 + UP * 2, RIGHT * 3]\n        stop_indices = [1, 2]  # Stop at the first and second index positions\n        complex_move = move_along_complex_path(e.copy(), stop_indices, electron_path, run_time=2)\n\n        # Arrange atoms in a grid\n        atoms_group = VGroup(e, o_atom, metal_atom, pos_ion, negative_ion).arrange_in_grid(1, 5, buff=1)\n\n        # Animate all elements\n        self.play(LaggedStart(*[FadeIn(atom) for atom in atoms_group], lag_ratio=0.5))\n        self.wait(1)\n        self.play(Transform(atoms_group, metal_oxide_grid))\n        self.wait(1)\n        self.play(Transform(atoms_group, c_layer))\n        self.wait(1)\n        self.play(*complex_move)\n        self.wait(2)"
    },
    {
        "query": "Can you create an animated educational video segment that shows how to calculate the definite integral of x cubed from 0 to 2, including an explanation of the power rule for integrals, and ending with a clear presentation of the final answer?",
        "answer": "\\n from manim import *\n\nfrom manim_physics import *\n# use a SpaceScene to utilize all specific rigid-mechanics methods\nclass TwoObjectsFalling(SpaceScene):\n    def construct(self):\n        circle = Circle().shift(UP)\n        circle.set_fill(RED, 1)\n        circle.shift(DOWN + RIGHT)\n\n        rect = Square().shift(UP)\n        rect.rotate(PI / 4)\n        rect.set_fill(YELLOW_A, 1)\n        rect.shift(UP * 2)\n        rect.scale(0.5)\n\n        ground = Line([-4, -3.5, 0], [4, -3.5, 0])\n        wall1 = Line([-4, -3.5, 0], [-4, 3.5, 0])\n        wall2 = Line([4, -3.5, 0], [4, 3.5, 0])\n        walls = VGroup(ground, wall1, wall2)\n        self.add(walls)\n\n        self.play(\n            DrawBorderThenFill(circle),\n            DrawBorderThenFill(rect),\n        )\n        self.make_rigid_body(rect, circle)  # Mobjects will move with gravity\n        self.make_static_body(walls)  # Mobjects will stay in place\n        self.wait(5)\n        # during wait time, the circle and rect would move according to the simulate updater"
    },
    {
        "query": "Can you create an educational animation that visually shows the calculation of the area under the curve y = x^2 from x=0 to x=2, including the graph, the shaded area, and step by step integration to find the exact area, with transitions between each step of the explanation?",
        "answer": "\\n from manim import *\n\nclass GrowingCircles(Scene):\n    def construct(self):\n        circle_array = VGroup(*[Circle(radius=i*0.3, color=BLUE, fill_opacity=0.5) for i in range(1, 6)])\n        circle_array.arrange_in_grid(rows=1, buff=1)\n        self.play(AnimationGroup(*(GrowFromCenter(circle) for circle in circle_array), lag_ratio=0.5))\n        self.wait(1)\n\n        for i in range(len(circle_array) - 1, 0, -1):\n            circle_to_swap = circle_array[i - 1]\n            self.play(\n                circle_array[i].animate.move_to(circle_to_swap.get_center()),\n                circle_to_swap.animate.move_to(circle_array[i].get_center()),\n                run_time=0.5\n            )\n            circle_array[i - 1], circle_array[i] = circle_array[i], circle_array[i - 1]\n            self.wait(0.1)\n\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visually explains the concept of a damped harmonic oscillator in physics, starting by showing the differential equation that describes its motion, followed by an introduction to what a damped harmonic oscillator is, then showing the associated characteristic equation of the system, calculating its roots, gradually moving to present the different cases for the general solution depending on the discriminant value, and concluding with a focus on the critical damping case, ensuring each part has its own written explanation displayed on the screen with a pause allowing viewers to understand each step before moving on to the next?",
        "answer": "\\n from manim import *\n\nclass HydrogenMolecule(VGroup):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.add(hydrogen_atom())\n        self.add(hydrogen_atom().next_to(self[0], RIGHT, buff=0.5))\n        self.add(Bond(self[0], self[1]))\n\ndef hydrogen_atom() -> Mobject:\n    return circle_with_text(0.2, \"H\", WHITE, 24, BLACK, 1, WHITE)\n\nclass Bond(Line):\n    def __init__(self, start_mobj, end_mobj, **kwargs):\n        start = start_mobj.get_center()\n        end = end_mobj.get_center()\n        super().__init__(start, end, buff=start_mobj.width/2, **kwargs)\n\nclass HydrogenMoleculeScene(Scene):\n    def construct(self):\n        molecule = HydrogenMolecule()\n        self.play(Create(molecule))\n        self.wait()\n\n        # Let's make the molecule move in a square path\n        square_path = [UP, RIGHT, DOWN, LEFT]\n        path_points = [molecule.get_center() + dir * 2 for dir in square_path]\n        path_points.append(molecule.get_center())  # Closing the loop\n\n        animations = move_along_complex_path(molecule, [3], path_points, run_time=4)\n        self.play(*animations)\n        self.wait()\n\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n    animations = []\n    paths = []\n    for i in range(len(points) - 1):\n        if i not in stop_indices:\n            paths.append(Line(points[i], points[i + 1]))\n\n    for i in range(len(paths)):\n        animations.append(MoveAlongPath(obj, paths[i], run_time=run_time / len(paths), rate_func=rate_func))\n\n    return animations"
    },
    {
        "query": "Can you create an animated video that visually explains the process of calculating a double integral in polar coordinates, specifically the integral of r^2 sin(theta) with respect to r and theta, where r goes from 0 to 1 and theta goes from 0 to pi? I would like the animation to show the problem statement, then step-by-step solve the integral by first integrating with respect to r and then with respect to theta. During each step, I want text explanations to appear that guide me through the process, ending with the final evaluated answer of the integral.",
        "answer": "\\n from manim import *\n\n\nclass Lens(Scene):\n    def construct(self):\n        lens_height = 3\n        lens_width = 0.5\n        focal_length = 4\n\n        lens = VGroup()\n        lens.add(\n            Line(\n                UP * lens_height / 2 + LEFT * lens_width / 2,\n                UP * lens_height / 2 + RIGHT * lens_width / 2,\n            )\n        )\n        lens.add(\n            Line(\n                DOWN * lens_height / 2 + LEFT * lens_width / 2,\n                DOWN * lens_height / 2 + RIGHT * lens_width / 2,\n            )\n        )\n        lens_angle = TAU / 3 - 1.3\n        left_arc = (\n            Arc(start_angle=-lens_angle / 2, angle=lens_angle)\n            .rotate(PI)\n            .set_height(lens_height)\n            .align_to(lens[0], LEFT)\n        )\n        left_arc.shift(LEFT * left_arc.get_width())\n        lens.add(left_arc)\n        right_arc = (\n            Arc(start_angle=-lens_angle / 2, angle=lens_angle)\n            .set_height(lens_height)\n            .align_to(lens[0], RIGHT)\n        )\n        right_arc.shift(RIGHT * right_arc.get_width())\n        lens.add(right_arc)\n\n        original_dist_color = YELLOW\n        image_dist_color = BLUE\n\n        # Update the original.\n        original_arrow = Arrow(ORIGIN, UP, buff=0).shift(3 * LEFT)\n        original_arrow_tracker = ValueTracker(original_arrow.get_x())\n\n        def update_original_arrow(mob):\n            time = original_arrow_tracker.get_value()\n            x_offset = RIGHT * (-4 + np.sin(time * 1.3))\n            mob.move_to(x_offset)\n\n        original_arrow.add_updater(update_original_arrow)\n\n        # Update the arrow indicating the distance to the original.\n        original_dist_arrow = Arrow(\n            ORIGIN, RIGHT * original_arrow_tracker.get_value()\n        ).set_color(original_dist_color)\n\n        def update_original_dist_arrow(mob):\n            original_arrow_x_offset = original_arrow.get_center()[0]\n            mob.put_start_and_end_on(ORIGIN, RIGHT * original_arrow_x_offset)\n            mob.shift(diagram_shift)\n\n        original_dist_arrow.add_updater(update_original_dist_arrow)\n\n        # Update the image arrow.\n        image_arrow = Arrow(\n            ORIGIN,\n            DOWN,\n            buff=0,\n        ).shift(3 * RIGHT)\n\n        def update_image(mob):\n            object_lens_dist = original_arrow.get_center()[0]\n            image_lens_dist = 1 / (1 / focal_length - 1 / object_lens_dist)\n            magnification = image_lens_dist / object_lens_dist\n\n            arrow_tip_height = mob.submobjects[0].get_height()\n            new_arrow = Line(\n                RIGHT * image_lens_dist + diagram_shift,\n                RIGHT * image_lens_dist\n                + UP * (magnification + arrow_tip_height)\n                + diagram_shift,\n            )\n            mob.submobjects[0].next_to(new_arrow, DOWN, buff=0)\n            new_arrow.add(mob.submobjects[0])\n            mob.become(new_arrow)\n\n        image_arrow.add_updater(update_image)\n\n        # Update the arrow indicating the distance to the image.\n        object_lens_dist = original_arrow.get_center()[0]\n        image_lens_dist = 1 / (1 / focal_length - 1 / object_lens_dist)\n        image_dist_arrow = Arrow(ORIGIN, RIGHT * image_lens_dist).set_color(\n            image_dist_color\n        )\n\n        def update_image_dist_arrow(mob):\n            object_lens_dist = original_arrow.get_center()[0]\n            image_lens_dist = 1 / (1 / focal_length - 1 / object_lens_dist)\n            start = ORIGIN + diagram_shift\n            end = RIGHT * image_lens_dist + diagram_shift\n            mob.put_start_and_end_on(start, end)\n\n        image_dist_arrow.add_updater(update_image_dist_arrow)\n\n        self.add(original_arrow, image_arrow)\n        self.add(lens)\n\n        \"\"\"\n        v = 1 / (1 / f - 1 / u)\n        1 / u + 1 / v = (n - 1)(1 / R1 - 1 / R2 + (n-1)d / (n*R1*R2))\n        (1 / u + 1 / v)/ (n-1) = 1 / R1 - 1 / R2 + (n-1)d / (n*R1*R2)\n        (1 / u + 1 / v)/ (n-1) - 1/R1 + 1/R2 = (n-1)d / (n*R1*R2)\n        (1/u + 1/v) / (n-1)^2 - (1/R1 + 1/R2)/(n-1) = d/(n*R1*R2)\n        (n*R1*R2) * (1/u + 1/v) / (n-1)^2 - (1/R1 + 1/R2)/(n-1) = d\n        \"\"\"\n\n        image_lens_dist = 10  # This is only to set the arrow size.\n        diagram_shift = DOWN * 0.5\n\n        original_dist_arrow.add_updater(update_original_dist_arrow)\n        self.add(original_dist_arrow)\n\n        # Indicate the distance to the image arrow.\n\n        self.add(image_dist_arrow)\n\n        VGroup(\n            lens, original_arrow, image_arrow, original_dist_arrow, image_dist_arrow\n        ).shift(diagram_shift)\n\n        description = (\n            Tex(\n                \"The distance between an object and its projected \\\\\\\\\"\n                \"image is given by the thin lens equation: \"\n            )\n            .scale(0.7)\n            .to_edge(UP)\n        )\n        thin_lens_equation = (\n            MathTex(\n                \"\\\\frac{1}{u}\",\n                \"+\",\n                \"\\\\frac{1}{v}\",\n                \"=\",\n                \"\\\\frac{1}{f}\",\n            )\n            .scale(0.7)\n            .next_to(description, DOWN)\n        )\n        # Color the distance variables.\n        thin_lens_equation[0][2].set_color(original_dist_color)\n        thin_lens_equation[2][2].set_color(image_dist_color)\n        u_label = MathTex(\"u\", fill_color=original_dist_color).shift(LEFT + DOWN)\n        v_label = MathTex(\"v\", fill_color=image_dist_color).shift(RIGHT + DOWN)\n\n        self.play(\n            original_arrow_tracker.animate.set_value(3.5),\n            Write(description),\n            rate_func=linear,\n            run_time=3.5,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(4),\n            rate_func=linear,\n            run_time=0.5,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(5.5),\n            Write(thin_lens_equation),\n            Write(VGroup(u_label, v_label)),\n            rate_func=linear,\n            run_time=1.5,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(6.5),\n            FadeOut(description),\n            rate_func=linear,\n            run_time=1,\n        )\n\n        image_dist_arrow.set_color(GRAY)\n        v_label.set_color(GRAY)\n        thin_lens_equation[2][2].set_color(GRAY)\n        fixed_distance_explanation = (\n            Tex(\n                \"If the distance to the image is fixed, the distance to the original \"\n                \"will still change according to the lensmaker equation:\"\n            )\n            .scale(0.7)\n            .to_edge(UP)\n        )\n        self.wait(0.5)\n        self.play(Write(fixed_distance_explanation))\n\n        lens_width_color = RED\n        lensmaker_equation = (\n            MathTex(\n                \"(n-1)\",\n                \"\\\\left[\",\n                \"\\\\frac{1}{R_1}\",\n                \"-\",\n                \"\\\\frac{1}{R_2}\",\n                \"+\",\n                \"\\\\frac{(n-1)d}{nR_1R_2}\",\n                \"\\\\right]\",\n            )\n            .scale(0.7)\n            .next_to(thin_lens_equation[3], RIGHT)\n        )\n        lensmaker_equation[6][5].set_color(lens_width_color)\n        target = thin_lens_equation.generate_target()\n        target.submobjects[4] = lensmaker_equation\n        target.shift(RIGHT * -target.get_center()[1])\n\n        distance_label = (\n            DoubleArrow(\n                LEFT * lens.get_width() / 2, RIGHT * lens.get_width() / 2, buff=0\n            )\n            .next_to(lens, UP, buff=SMALL_BUFF)\n            .set_color(lens_width_color)\n        )\n        self.play(\n            MoveToTarget(\n                thin_lens_equation,\n            ),\n            FadeIn(distance_label),\n        )\n\n        self.play(FadeOut(fixed_distance_explanation))\n        distance_explanation = (\n            Tex(\n                \"If the \",\n                \"thickness of the lens\",\n                \" is allowed to vary with the distance to the object \"\n                \"the image can be preserved at a fixed distance.\",\n            )\n            .scale(0.7)\n            .to_edge(UP)\n        )\n        distance_explanation[1].set_color(lens_width_color)\n        image_dist_arrow.clear_updaters()\n        image_arrow.clear_updaters()\n\n        def update_image_2(mob):\n            object_lens_dist = original_arrow.get_center()[0]\n            image_lens_dist = 1 / (1 / focal_length - 1 / object_lens_dist)\n            magnification = image_lens_dist / object_lens_dist\n\n            original_top = mob.get_top()\n\n            arrow_tip_height = mob.submobjects[0].get_height()\n            new_arrow = Line(\n                original_top,\n                original_top + UP * (magnification + arrow_tip_height),\n            )\n            mob.submobjects[0].next_to(new_arrow, DOWN, buff=0)\n            new_arrow.add(mob.submobjects[0])\n            mob.become(new_arrow)\n\n        image_arrow.add_updater(update_image_2)\n\n        initial_x_offset = original_arrow.get_center()[0]\n\n        def update_lens_thickness(mob):\n            original_arrow_x_offset = original_arrow.get_center()[0]\n            new_width = lens_width / original_arrow_x_offset * initial_x_offset\n            original_lens_center = mob.get_center()\n            lens = VGroup()\n            lens.add(\n                Line(\n                    UP * lens_height / 2 + LEFT * new_width / 2,\n                    UP * lens_height / 2 + RIGHT * new_width / 2,\n                )\n            )\n            lens.add(\n                Line(\n                    DOWN * lens_height / 2 + LEFT * new_width / 2,\n                    DOWN * lens_height / 2 + RIGHT * new_width / 2,\n                )\n            )\n            lens_angle = TAU / 3 - 1.3\n            right_arc = (\n                Arc(start_angle=-lens_angle / 2, angle=lens_angle)\n                .set_height(lens_height)\n                .align_to(lens[0], RIGHT)\n            )\n            right_arc.shift(RIGHT * right_arc.get_width())\n            lens.add(right_arc)\n            left_arc = (\n                Arc(start_angle=-lens_angle / 2, angle=lens_angle)\n                .rotate(PI)\n                .set_height(lens_height)\n                .align_to(lens[0], LEFT)\n            )\n            left_arc.shift(LEFT * left_arc.get_width())\n            lens.add(left_arc)\n            lens.move_to(original_lens_center)\n            mob.become(lens)\n\n            # Update width label.\n            arrow_y_offset = distance_label.get_start()[1]\n            distance_label.put_start_and_end_on(\n                LEFT * lens.get_width() / 2 + UP * arrow_y_offset,\n                RIGHT * lens.get_width() / 2 + UP * arrow_y_offset,\n            )\n\n        lens.add_updater(update_lens_thickness)\n\n        self.play(\n            original_arrow_tracker.animate.set_value(8),\n            Write(distance_explanation),\n            run_time=1.5,\n            rate_func=linear,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(10.5),\n            run_time=2.5,\n            rate_func=linear,\n        )\n        for mob in self.mobjects:\n            mob.clear_updaters()\n        self.play(\n            FadeOutAndShift(\n                VGroup(*[m for m in self.mobjects if isinstance(m, VMobject)]), UP\n            )\n        )\n        #\n        #\n        # class Eye(Scene):\n        #     def construct(self):\n        def get_eye():\n            lens_height = 2\n            lens_width = 0.6\n\n            lens = Ellipse(\n                width=lens_width,\n                height=lens_height,\n                fill_opacity=1,\n                stroke_color=BLUE,\n                fill_color=\"#EEEEEE\",\n            )\n\n            cilliary_muscle_length = 0.2\n            cilliary_muscle = VGroup(\n                Line(\n                    lens.get_top(),\n                    lens.get_top() + cilliary_muscle_length * UP,\n                    stroke_width=8,\n                ).set_color(RED_E),\n                Line(\n                    lens.get_bottom(),\n                    lens.get_bottom() + cilliary_muscle_length * DOWN,\n                    stroke_width=8,\n                ).set_color(RED_E),\n            )\n\n            vitreous_chamber_angle = 0.8 * TAU\n            vitreous_chamber_back = Arc(\n                angle=vitreous_chamber_angle,\n                fill_opacity=1,\n                fill_color=BLUE_C,\n                stroke_color=RED_B,\n            )\n            angle_to_rotate = (vitreous_chamber_angle - TAU) / 2\n            vitreous_chamber_back.rotate(\n                PI - angle_to_rotate, about_point=ORIGIN\n            ).scale(2).shift(RIGHT * 1.7)\n\n            # retina = Arc(\n            #     0.8 * TAU,\n            #     stroke_color=RED_B,\n            # )\n            # retina.rotate(PI - angle_to_rotate, about_point=ORIGIN,).scale(\n            #     2\n            # ).shift(RIGHT * 1.7)\n\n            aqueous_humor_angle = TAU - vitreous_chamber_angle\n            aqueous_humor = (\n                Arc(angle=aqueous_humor_angle, fill_opacity=1, stroke_opacity=0)\n                .set_color(BLUE_A)\n                .rotate(PI - aqueous_humor_angle / 2, about_point=ORIGIN)\n                .scale(2.05)\n                .next_to(vitreous_chamber_back, LEFT, buff=0)\n            )\n\n            cornea_angle = 0.4 * TAU\n            cornea = Arc(\n                angle=cornea_angle,\n                stroke_color=\"#EEEEEE\",\n                stroke_opacity=0.5,\n                fill_color=BLUE_A,\n                fill_opacity=1,\n                stroke_width=14,\n            )\n            cornea.rotate(PI - cornea_angle / 2, about_point=ORIGIN)\n            cornea.next_to(vitreous_chamber_back, LEFT, buff=0)\n            cornea.scale(1.2)\n\n            eye = VGroup(\n                # retina,\n                cornea,\n                vitreous_chamber_back,\n                aqueous_humor,\n                cilliary_muscle,\n                lens,\n            )\n            eye.lens = lens\n            eye.shift(-eye.get_center())\n            return eye\n\n        eye = get_eye()\n        eye_text = Tex(\"Eye\").scale(1.5).next_to(eye, UP)\n        self.play(\n            FadeInFrom(eye_text, UP),\n            FadeInFrom(eye, UP),\n        )\n        self.wait(0.5)\n\n        saved_eye = eye.generate_target()  # Save the eye to restore later.\n        target_eye = eye.generate_target()\n        target_eye.submobjects[0].shift(LEFT * 2)  # cornea\n        target_eye.submobjects[2].shift(LEFT * 2)  # aqueous humor\n        target_eye.submobjects[4].shift(RIGHT * 0.7)  # lens\n        target_eye.submobjects[1].shift(RIGHT * 2)  # vitreous_chamber_back\n        target_eye.submobjects[3].shift(LEFT * 0.5)  # cilliary_muscle\n        self.play(\n            MoveToTarget(eye),\n            FadeOutAndShift(eye_text, UP),\n        )\n\n        cornea_label = Tex(\"Cornea\").scale(0.8).next_to(target_eye.submobjects[0], LEFT)\n        aqueous_humor_label = (\n            Tex(\"Aqueous Humor\").scale(0.8).next_to(target_eye.submobjects[2], DOWN)\n        )\n        lens_label = (\n            Tex(\"Lens\", fill_color=BLUE)\n            .scale(0.8)\n            .next_to(target_eye.submobjects[4], DOWN)\n        )\n        vitreous_chamber_label = (\n            Tex(\"Vitreous\\\\\\\\Chamber\")\n            .scale(0.8)\n            .move_to(target_eye.submobjects[1].get_center())\n        )\n        cilliary_muscle_label = (\n            Tex(\"Cilliary\\\\\\\\Muscle\").scale(0.8).next_to(target_eye.submobjects[3], UP)\n        )\n        retina_label = (\n            Tex(\"Retina\", fill_color=YELLOW)\n            .scale(0.8)\n            .next_to(target_eye.submobjects[1], RIGHT)\n        )\n        self.play(\n            FadeIn(\n                VGroup(\n                    cornea_label,\n                    aqueous_humor_label,\n                    lens_label,\n                    vitreous_chamber_label,\n                    cilliary_muscle_label,\n                    retina_label,\n                )\n            ),\n        )\n\n        eye_lens_explanation = Tex(\n            \"This is how the \",\n            \"lenses\",\n            \" in our eyes focus light on our \",\n            \"retinas\",\n        ).scale(0.9)\n        eye_lens_explanation[1].set_color(BLUE)\n        eye_lens_explanation[3].set_color(YELLOW)\n        eye_lens_explanation.shift(\n            UP\n            * (\n                target_eye.submobjects[1].get_bottom()[1]\n                - eye_lens_explanation.get_top()[1]\n                - 0.8\n            )\n        )\n        eye_lens_explanation_2 = (\n            Tex(\"which are always a fixed distance away.\")\n            .scale(0.9)\n            .next_to(eye_lens_explanation, DOWN, buff=SMALL_BUFF)\n        )\n        self.play(Write(eye_lens_explanation))\n        self.wait(0.5)\n\n        eye.target = saved_eye\n        self.play(\n            MoveToTarget(eye),\n            FadeOut(\n                VGroup(\n                    cornea_label,\n                    aqueous_humor_label,\n                    lens_label,\n                    vitreous_chamber_label,\n                    cilliary_muscle_label,\n                    retina_label,\n                )\n            ),\n        )\n        self.play(eye.animate.shift(3 * RIGHT), run_time=0.7)\n\n        original_arrow = Arrow(ORIGIN, UP * 0.8, buff=0).shift(3 * LEFT)\n        image_arrow = Arrow(ORIGIN, DOWN * 0.7, buff=0).shift(4.8 * RIGHT)\n        focal_axis = Line(\n            original_arrow.get_bottom(),\n            image_arrow.get_top(),\n            stroke_width=3,\n            stroke_color=GREY_B,\n        )\n        self.play(FadeIn(VGroup(original_arrow, image_arrow)))\n        self.play(ShowCreation(focal_axis), run_time=0.7)\n\n        original_arrow_tracker = ValueTracker()\n\n        # Update the original arrow.\n        original_arrow_starting_position = original_arrow.get_center()\n\n        def update_original(mob):\n            time = original_arrow_tracker.get_value()\n            x_offset = 1.5 * RIGHT * np.sin(time * 1.5)\n            mob.move_to(original_arrow_starting_position + RIGHT * x_offset)\n\n        original_arrow.add_updater(update_original)\n\n        lens = eye.submobjects[4]\n        original_image_height = image_arrow.get_height()\n        object_lens_dist = lens.get_center()[0] - original_arrow.get_center()[0]\n        image_lens_dist = image_arrow.get_center()[0] - lens.get_center()[0]\n        original_magnification = image_lens_dist / object_lens_dist\n        magnification_offset_ratio = original_image_height / original_magnification\n\n        def update_image(mob):\n            lens = eye.submobjects[4]\n            object_lens_dist = lens.get_center()[0] - original_arrow.get_center()[0]\n            image_lens_dist = image_arrow.get_center()[0] - lens.get_center()[0]\n            magnification = image_lens_dist / object_lens_dist\n            magnification *= magnification_offset_ratio\n            image_arrow_base = image_arrow.get_top()\n\n            arrow_tip_height = mob.submobjects[0].get_height()\n            new_arrow = Line(\n                image_arrow_base,\n                image_arrow_base + DOWN * (magnification - arrow_tip_height),\n            )\n            mob.submobjects[0].next_to(new_arrow, DOWN, buff=0)\n            new_arrow.add(mob.submobjects[0])\n            mob.become(new_arrow)\n\n        image_arrow.add_updater(update_image)\n\n        # Update the thickness of the lens.\n        starting_lens_dist = eye.lens.get_center()[0] - original_arrow.get_center()[0]\n\n        def update_lens(mob):\n            original_lens_dist = (\n                eye.lens.get_center()[0] - original_arrow.get_center()[0]\n            )\n            mob.stretch_to_fit_width(0.6 * starting_lens_dist / original_lens_dist)\n\n        lens = eye.lens\n        lens.add_updater(update_lens)\n\n        def update_axis(mob):\n            new_axis = Line(\n                original_arrow.get_bottom(),\n                image_arrow.get_top(),\n                stroke_width=3,\n                stroke_color=GREY_B,\n            )\n            mob.become(new_axis)\n\n        focal_axis.add_updater(update_axis)\n\n        self.play(\n            Write(eye_lens_explanation_2),\n            original_arrow_tracker.animate.set_value(1),\n            rate_func=linear,\n            run_time=1,\n        )\n        self.play(\n            original_arrow_tracker.animate.set_value(6),\n            rate_func=linear,\n            run_time=5,\n        )"
    },
    {
        "query": "Can you create an educational animation that visually explains how to calculate the area under the curve of y = x^2 from x = 0 to x = 2? I'd like to see a coordinate system with labeled axes and the curve graphed in green. Then, can you show the area under the curve shaded in green with a lower opacity, and have an integral symbol with the limits and the function appear in the upper right corner? Following that, display the result of the integral as a calculation next to the integral symbol, first showing the formula for the antiderivative evaluated at the boundaries, and then the final numerical answer. The process should unfold step-by-step with the mathematical expressions written out as they would be on a blackboard, and each step should remain on screen for a couple of seconds before moving to the next.",
        "answer": "\\n class ShapesAndColors(Scene):\n    def construct(self):\n        # Create a square, a circle, and a triangle\n        square = Square(side_length=1, color=PURPLE)\n        circle = Circle(radius=1, color=ORANGE)\n        triangle = Triangle(color=TEAL)\n\n        # Position the shapes in a group\n        shape_group = VGroup(square, circle, triangle)\n        shape_group.arrange(RIGHT, buff=1)\n        shape_group.to_edge(LEFT)\n\n        # Add the group of shapes to the scene\n        self.add(shape_group)\n\n        # Create rectangles of various colors\n        rectangles = VGroup(*[Rectangle(width=0.4, height=1, color=random_color()) for _ in range(5)])\n        rectangles.arrange(RIGHT, buff=0.2)\n        rectangles.next_to(shape_group, DOWN, buff=1)\n\n        # Add the rectangles to the scene\n        self.add(rectangles)\n\n        # Create pentagons in a grid\n        pentagons = VGroup(*[RegularPolygon(n=5, color=random_color(), fill_opacity=0.5).scale(0.3) for _ in range(15)])\n        pentagons.arrange_in_grid(3, 5, buff=0.25)\n        pentagons.next_to(rectangles, DOWN, buff=1)\n\n        # Add the pentagons to the scene\n        self.add(pentagons)"
    },
    {
        "query": "Could you create an educational animation that illustrates the concept of Simple Harmonic Motion (SHM), starting with the display of its differential equation, followed by an explanation and introduction of angular frequency, and then showing how the equation is rewritten using angular frequency? Additionally, can you demonstrate the general solution of the equation involving cosine function, explain the meaning of phase difference within the context, and finally clear the scene to focus on the final solution?",
        "answer": "\\n from manim import *\n\nclass CustomAnimationScene(Scene):\n    def construct(self):\n        # Create an electron\n        electron_item = electron()\n\n        # Create an oxygen atom\n        oxygen_item = oxygen()\n\n        # Create a metal atom\n        metal_item = metal()\n\n        # Create a positive ion\n        positive_item = positive()\n\n        # Create a negative ion\n        negative_item = negative()\n\n        # Arrange elements in a grid\n        grid = VGroup(electron_item, oxygen_item, metal_item, positive_item, negative_item)\n        grid.arrange_in_grid(rows=1, cols=5, buff=1.0)\n\n        # Animate the additions\n        self.play(AnimationGroup(*[FadeIn(atom) for atom in grid], lag_ratio=0.5))\n\n        # Animate movement along a complex path\n        complex_path = [UP*2, UP+RIGHT*2, DOWN+RIGHT*2, DOWN*2, LEFT*4]\n        electron_animations = move_along_complex_path(electron_item, [0, 2], complex_path, run_time=2)\n        self.play(*electron_animations)\n\n        # Fade everything out\n        self.play(FadeOut(grid))"
    },
    {
        "query": "Create an educational video animation that explains step-by-step how to calculate the surface area of the upper hemisphere of a unit sphere using spherical coordinates. Start the video by displaying the function of the hemisphere, followed by a statement defining the problem. Then show how to set up the surface area integral in spherical coordinates and explain why we are using these particular limits of integration. Proceed to integrate the function with respect to the phi variable first, explaining each step, and then integrate the resulting expression with respect to theta. Finally, show the calculation of the definite integrals to find the surface area and conclude with the final result stating that the surface area of the hemisphere is 4\u03c0. Ensure that each step is clearly written out and that each new concept and calculation is introduced with a brief explanation in text form, suitable for an audience that might be new to calculus or spherical coordinates.",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for integration step\n        explanation1 = Text(\"Integrate by reversing the power rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"\\int e^{2x} \\,dx = \\frac{1}{2}e^{2x}\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(1)\n\n        # Explanation for the constant of integration\n        explanation2 = Text(\"Don't forget the constant of integration\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"\\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that starts with the text \"Let's learn about quadratic functions!\" then transitions to showing the general quadratic formula \"f(x) = ax^2 + bx + c\"? After that, could you replace it with a specific example of a quadratic function, say \"f(x) = 2x^2 - 3x + 1\", and graph this specific function? Lastly, can you highlight the vertex of the parabola and conclude with showing the formula to find the vertex of a quadratic function?",
        "answer": "\\n from manim import *\n\nclass TrigonometricFunctionScene(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"\\sin(x) + \\cos(x) = 1\")\n        self.play(FadeIn(function))\n        self.wait(1)\n\n        # Display properties\n        properties = Text(\"This is not an identity!\", font_size=24).to_edge(UP)\n        self.play(Write(properties))\n        self.wait(2)\n\n        # Correcting the function\n        correct_function = MathTex(r\"\\sin^2(x) + \\cos^2(x) = 1\")\n        self.play(Transform(function, correct_function))\n        self.wait(1)\n\n        # Identity property explanation\n        identity_explanation = Text(\"This is the Pythagorean trigonometric identity.\", font_size=24).to_edge(UP)\n        self.play(Transform(properties, identity_explanation))\n        self.wait(2)\n\n        # Graphical representation\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1.5, 1.5, 1])\n        sin_curve = axes.plot(lambda x: np.sin(x), color=BLUE)\n        cos_curve = axes.plot(lambda x: np.cos(x), color=RED)\n        sin_label = axes.get_graph_label(sin_curve, label='\\\\sin(x)')\n        cos_label = axes.get_graph_label(cos_curve, label='\\\\cos(x)')\n\n        graph_group = VGroup(axes, sin_curve, cos_curve, sin_label, cos_label).scale(0.6).to_edge(DOWN)\n        self.play(FadeIn(graph_group))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(correct_function), FadeIn(identity_explanation))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated visual explanation showing the steps to evaluate the triple integral of the function xyz over the cube with bounds 0 to 1 for all variables? Include the step-by-step process, starting with the integration with respect to x, then y, and finally z, showing the intermediate results up to the final answer.",
        "answer": "\\n from manim import *\n\nclass DerivativeExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\frac{d}{dx} (x^2 + 3x + 2)\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using power rule\n        explanation1 = Text(\"Use the power rule for derivatives\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Derivative step\n        derivative_step = MathTex(r\"2x + 3\")\n        self.play(ReplacementTransform(problem.copy(), derivative_step))\n        self.wait(1)\n\n        # Explanation for final form\n        explanation2 = Text(\"The derivative is a linear function\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution shown\n        final_solution = MathTex(r\"f'(x) = 2x + 3\")\n        self.play(ReplacementTransform(derivative_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(Text(\"That's the derivative!\", font_size=24).to_edge(UP)))\n        self.wait(2)"
    },
    {
        "query": "I would like an animation that demonstrates how to solve a basic definite integral step by step. Start by showing the integral of x squared from 0 to 1. Afterwards, I'd like a written explanation that we're evaluating this definite integral to appear, followed by the general power rule for integrals displayed. Next, show the actual calculations with the limits of 0 and 1 being applied to the integral. Continue with transforming this into the solution after substituting the limits. Finally, present the final answer and end with the explanation that this value represents the area under the curve between 0 and 1. Once the calculation is complete, clear everything and then bring back only the final solution along with the explanation for a strong conclusion.",
        "answer": "\\n from manim import *\n\nclass MovingShapes(Scene):\n    def construct(self):\n        squares = VGroup(\n            *[Square(side_length=1, color=Color(hue=i/7, saturation=1, luminance=0.5), fill_opacity=0.5)\n              for i in range(7)]\n        ).arrange_in_grid(rows=1, cols=7, col_width=2)\n        self.play(Create(squares), run_time=2)\n        self.play(\n            squares.animate.shift(UP * 2),\n            rate_func=smooth,\n            run_time=2\n        )\n        self.play(\n            squares[0].animate.rotate(PI/2),\n            squares[1].animate.rotate(PI).scale(0.5),\n            squares[2].animate.rotate(PI).scale(2),\n            squares[3].animate.rotate(PI/2).set_opacity(0.2),\n            squares[4].animate.rotate(-PI/2).set_color(RED),\n            squares[5].animate.rotate(PI).set_fill(YELLOW, opacity=0.75),\n            squares[6].animate.rotate(PI/4).set_stroke(BLUE, width=4),\n            run_time=2\n        )\n        self.wait()"
    },
    {
        "query": "I would like an animated explanation of how to evaluate the double integral of r^2 in polar coordinates over a unit circle from 0 to 2\u03c0 in the angle \u03b8 and from 0 to 1 in the radius r. The animation should start by displaying the mathematical problem, then step by step show the solution. Begin by integrating with respect to r, explaining that we do the inner integral first, followed by a transformation to the next step which evaluates the result of this inner integral. Then, it should indicate transitioning to integrate with respect to \u03b8 now and proceed to evaluate the outer integral. Finally, the animation should show the result of the outer integral, simplify it, and then display the simplified final solution.",
        "answer": "\\n from manim import *\n\nclass HydrogenGridScene(Scene):\n    def construct(self):\n        grid = self.create_hydrogen_grid(5, 5)\n        self.play(FadeIn(grid))\n        self.wait(2)\n\n    def create_hydrogen_grid(self, rows: int, cols: int) -> VGroup:\n        group = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                hydrogen = self.create_hydrogen().move_to(np.array([i - rows // 2, j - cols // 2, 0]))\n                group.add(hydrogen)\n        return group\n\n    def create_hydrogen(self) -> Mobject:\n        return Circle(radius=0.2, color=WHITE).set_fill(color=WHITE, opacity=0.5).add(\n            Tex('H').set_color(BLACK).scale(0.5)\n        )"
    },
    {
        "query": "Please create an animation that explains step by step how to solve a triple integral, specifically the integral of the function xyz with respect to z, then x, and finally y, over the ranges from 0 to 3 for z, from 0 to 2 for x, and from 0 to 1 for y. Include written explanations for each step as the integral is being solved, and present the final answer clearly at the end.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_coord\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.set_coord(-1,0))\n            self.remove(square)"
    },
    {
        "query": "I want to create an educational animation that visually explains why the harmonic series diverges. First, I'd like to see the series itself displayed. Then, can you show some text that states the series diverges? After that, demonstrate with the terms of the series by grouping them in a way that helps illustrate why the sum can't be finite. Finally, highlight the conclusion that the harmonic series indeed diverges. Can the explanation start by showing the problem, then visually transforming the terms to show their divergence, and end with a clear statement of the conclusion? Also, please ensure there are appropriate pauses for viewers to follow along.",
        "answer": "\\n from manim import *\n\nclass TrigSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        problem = MathTex(r\"\\int \\sqrt{1-x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using substitution\n        explanation1 = Text(\"Use trigonometric substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Substitution step\n        subst_step = MathTex(r\"x = \\sin(\\theta)\")\n        self.play(FadeIn(subst_step, shift=UP))\n        self.wait(1)\n\n        # Substituted integral\n        substituted_integral = MathTex(r\"\\int \\sqrt{1-\\sin^2(\\theta)} \\cos(\\theta) \\,d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), substituted_integral))\n        self.wait(1)\n\n        # Simplify using Pythagorean identity\n        explanation2 = Text(\"Simplify using Pythagorean identity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Simplified integral\n        simplified_integral = MathTex(r\"\\int \\cos^2(\\theta) \\,d\\theta\")\n        self.play(ReplacementTransform(substituted_integral, simplified_integral))\n        self.wait(1)\n\n        # Integrate\n        explanation3 = Text(\"Integrate\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{\\theta}{2} + \\frac{\\sin(2\\theta)}{4} + C\")\n        self.play(ReplacementTransform(simplified_integral, final_solution))\n        self.wait(1)\n\n        # Resubstitute x back into the solution\n        explanation4 = Text(\"Resubstitute to get x back\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final solution with x\n        final_solution_x = MathTex(r\"= \\frac{1}{2}\\arcsin(x) + \\frac{x\\sqrt{1-x^2}}{4} + C\")\n        self.play(ReplacementTransform(final_solution, final_solution_x))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution_x))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that explains the concept of Fourier series in mathematics. Could you show a sequence of animated visuals that starts by displaying the general form of the Fourier series, proceeds to explain the Fourier coefficients with their mathematical expressions, then introduces the idea of a partial sum approximation of the series, and finally talks about the convergence of the Fourier series with a visual demonstration for a specific number of terms? I'm looking for simple text explanations to accompany the mathematical formulas, and I want each step to be presented clearly and one after the other for easy understanding.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Showing the integral problem\n        integral_problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r^2 dr d\\theta\")\n        self.play(Write(integral_problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        inner_explanation = Text(\"Inner integral with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(inner_explanation))\n        self.wait(2)\n\n        # Inner integral solution\n        inner_solution = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{3}r^3]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(integral_problem, inner_solution))\n        self.wait(1)\n\n        # Replace explanation for outer integral\n        outer_explanation = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(inner_explanation, outer_explanation))\n        self.wait(2)\n\n        # Outer integral solution\n        final_solution = MathTex(r\"= [\\frac{1}{3}\\theta]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_solution, final_solution))\n        self.wait(1)\n\n        # Conclusion text\n        conclusion_text = Text(\"The area is \\(\\frac{2\\pi}{3}\\).\", font_size=24).to_edge(UP)\n        self.play(Transform(inner_explanation, conclusion_text))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that demonstrates the process of evaluating the Gaussian integral using the substitution of polar coordinates, ending with the final result of the square root of pi? The animation should start by showing the problem on the integral of e to the power of negative x squared from negative infinity to infinity, followed by each step that includes explaining the switch to polar coordinates, setting up the integral in polar form over a circular region, carrying out the integration in polar coordinates, and then taking the square root of the result. Each step should be presented clearly with explanations and transformations of the mathematical expressions, and a pause at each step to let the viewers understand. Finally, the animation should clear the previous steps and conclude by emphasizing the final solution.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(2)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(2)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution[1]))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually walks through the process of solving a double integral in polar coordinates. The specific double integral problem to demonstrate is the integral from 0 to \u03c0/2 of the integral from 0 to 1 of \u03c1\u00b2 sin(\u03c6) d\u03c1 d\u03c6. First, the problem should be presented, and then the animation should show the step-by-step process. It should start by integrating with respect to \u03c1, including replacing the \u03c1 terms with the limits of integration and simplifying the expression. Next, display a message about integrating the resulting expression with respect to \u03c6. Finally, show that work and the calculation of the final numerical result, which should come out to 2/3. Arrange all the parts of this explanation in a clear way, one after the other, and use pauses to allow time to understand each step. Can you make an animation like this that would be useful in a mathematics classroom?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right]_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left. \\frac{x^{3+1}}{4} \\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the integral from 0 to 2:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluation steps\n        evaluation = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, evaluation))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluation, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that explains the concept of simple harmonic motion using the mass-spring system? Start by displaying the differential equation that represents the motion, explain what each variable means, then show the formation of the characteristic equation from the differential equation. Afterwards, please show the characteristic roots and then present the general solution to the system. Finally, clear the scene and conclude with a text \"Visualizing Simple Harmonic Motion\" along with the general solution equation displayed once more.",
        "answer": "\\n from manim import *\n\nclass CalculateAreaUnderCurve(Scene):\n    def construct(self):\n        # Display the integral\n        integral = MathTex(r\"\\int_1^3\", r\"x^2\\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Set up the integral calculation\n        setup = Text(\"Calculating the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(setup))\n        self.wait(2)\n\n        # Show integration steps\n        integration_steps = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^3\")\n        self.play(ReplacementTransform(integral.copy(), integration_steps))\n        self.wait(2)\n\n        # Evaluation part\n        evaluation = Text(\"Substitute the upper and lower bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(setup, evaluation))\n        self.wait(2)\n        \n        # Showing final calculation\n        final_calculation = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= \\frac{27}{3} - \\frac{1}{3}\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_steps, final_calculation))\n        self.wait(1)\n\n        # Clear the scene and show the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_calculation))\n        self.wait(1)"
    },
    {
        "query": "I want to create an educational animation that visually demonstrates the process of integrating the exponential function e to the power of 2x with respect to x. Can you show the initial problem, explain why we substitute u for 2x, show the integration step by step including the substitution, and then present the final integrated function with the constant of integration C? Also, after each step, can you hold for a moment before moving on to the next step so the viewer has time to follow along? Once the final answer is revealed, clear everything from the screen and display the final solution again for emphasis.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 3x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule and evaluate:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integrating using the power rule\n        integration = MathTex(r\"= \\left. \\frac{3x^{2+1}}{2+1} \\right|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integration))\n        self.wait(2)\n\n        # Showing integration results\n        integrated = MathTex(r\"= \\frac{3 \\cdot 2^3}{3} - \\frac{3 \\cdot 0^3}{3}\")\n        self.play(ReplacementTransform(integration, integrated))\n        self.wait(2)\n\n        # Simplifying the result\n        solution = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(integrated, solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.play(FadeOut(explanation1), FadeOut(solution))\n        self.wait(1)\n\n        # Conclude with the final answer\n        final_answer = Text(\"The area under the curve from 0 to 2 is 8.\", font_size=24)\n        self.play(Write(final_answer))\n        self.wait(2)"
    },
    {
        "query": "I'd like an educational animation that visually explains how to calculate the definite integral of the function x^3 from 0 to 2. Start by displaying the integral problem on the screen. Then, show the power rule of integration for n-th powers of x, followed by the actual integration step of our specific problem, using the power rule. After integrating, demonstrate how to evaluate the definite integral, step by step. Conclude by simplifying the final answer and present a clean view of the final solution to the viewer.",
        "answer": "\\n class SecondExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=(-3, 3), y_range=(-3, 3))\n        curve = ax.plot(lambda x: (x+2)*x*(x-2)/2, color=RED)\n        area = ax.get_area(curve, (-2, 0))\n        self.add(ax, curve, area)"
    },
    {
        "query": "I would like an animation that visually explains the steps involved in computing a surface integral over a particular surface, including parameterizing the surface, calculating the differential area element, setting the limits of integration, and finally, evaluating the integrals to find the solution. Can you also include relevant mathematical equations and some textual explanation at each step to make it educational and easy to understand?",
        "answer": "\\n from manim import *\n\nclass TaylorSeriesApproximation(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = e^x\").to_edge(UP)\n        self.play(Write(function))\n        self.wait(1)\n\n        # Display nth Taylor Polynomial at 0\n        taylor_polynomial = MathTex(r\"P_n(x) = 1 + x + \\frac{x^2}{2!} + \\cdots + \\frac{x^n}{n!}\")\n        self.play(Write(taylor_polynomial))\n        self.wait(1)\n\n        # Display its graph\n        graph = FunctionGraph(lambda x: np.exp(x), color=WHITE)\n        graph_label = MathTex(r\"y = e^x\").next_to(graph, UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Explanation calculating taylor polynomial\n        explanation1 = Text(\"Calculating the 4th Taylor Polynomial\", font_size=24).to_edge(UP)\n        self.play(Transform(function, explanation1))\n        self.wait(1)\n\n        # Show 4th Taylor Polynomial\n        taylor_4th_poly = MathTex(r\"P_4(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!}\")\n        self.play(Transform(taylor_polynomial, taylor_4th_poly))\n        self.wait(1)\n\n        # Graph for 4th Taylor Polynomial\n        taylor_4th_graph = FunctionGraph(\n            lambda x: 1 + x + x**2 / math.factorial(2) + x**3 / math.factorial(3) + x**4 / math.factorial(4),\n            color=BLUE\n        )\n        taylor_label = MathTex(r\"P_4(x)\").next_to(taylor_4th_graph, UP)\n        self.play(Create(taylor_4th_graph), Write(taylor_label))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The blue curve represents the 4th Taylor Polynomial of e^x\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Fade out everything\n        self.play(FadeOut(taylor_label), FadeOut(taylor_4th_graph), FadeOut(conclusion), FadeOut(graph), FadeOut(graph_label), FadeOut(taylor_polynomial), FadeOut(function))\n        self.wait(1)"
    },
    {
        "query": "Create an educational animation that illustrates the concept of calculating the area under a curve using integration. Start by displaying the integral formula for the area, then show a graph of a quadratic function. Highlight the specific area under the curve between two points on the x-axis, and explain that the integral calculates this exact area. End by showing the calculation of the definite integral for the area between those two points and provide the numerical value of the calculated area. Make sure the animation includes labels, is colorful, and pauses at appropriate moments to allow for explanation.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Describe the wave equation\n        desc1 = Text(\"This is the classical wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(desc1))\n        self.wait(2)\n\n        # Explanation of wave speed\n        explain_speed = Text(\"Here, c represents the wave speed.\", font_size=24).to_edge(UP)\n        self.play(Transform(desc1, explain_speed))\n        self.wait(2)\n\n        # Displaying the one-dimensional solution\n        one_dim_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, one_dim_solution))\n        self.wait(2)\n\n        # Explanation for the one-dimensional solution\n        explain_one_dim = Text(\"General solution for the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Transform(desc1, explain_one_dim))\n        self.wait(2)\n\n        # Clear the scene and conclude with the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(one_dim_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the concept of finding the area under a curve on a graph. Specifically, I want to illustrate the area under the curve of the function f(x) = x^2 between the range of x from 0 to 2. The graph should be plotted with axes and labeled appropriately. I would like the area under the curve to be highlighted and shaded in green to emphasize the region we are considering.\n\nAdditionally, it would be helpful to accompany the visual with the corresponding mathematical representation of the integral from 0 to 2 of x^2 dx. I want to show the process of solving this integral step by step in the animation. First, present the problem statement of the integral. Second, show the antiderivative function. Then, compute the definite integral by evaluating the antiderivative at the upper and lower bounds of the interval. Finally, present the exact numerical result of the integral.\n\nAlso, the animation should start with an introduction of the graph and function, followed by the shading of the area, then proceed with the mathematical calculations in a clear and systematic way, and conclude by presenting the final value of the area under the curve.\n\nCould you assist in creating such an animation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.replace\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            star = Star().shift(RIGHT)\n            self.add(circle, star)\n            self.play(circle.animate.replace(star))\n            self.remove(circle,star)"
    },
    {
        "query": "Can you create an educational animation explaining how to integrate the sine function from 0 to \u03c0/2, show the mathematical steps, and conclude with the final result?",
        "answer": "\\n from manim import *\n\nclass AtomAnimation(Scene):\n    def construct(self):\n        # Create an atom with electrons orbiting around the nucleus\n        nucleus = Dot(radius=0.2, color=RED)\n        electron_orbit = Circle(radius=0.5)\n        electron_orbit.set_stroke(WHITE, 2)\n        electrons = VGroup(*[Dot(radius=0.05, color=BLUE).move_to(electron_orbit.point_from_proportion(i/3)) for i in range(3)])\n        \n        atom = VGroup(nucleus, electron_orbit, electrons)\n        \n        # Show creation of the atom\n        self.play(FadeIn(nucleus), ShowCreation(electron_orbit), FadeIn(electrons))\n        \n        # Animate electrons\n        electron_animations = [\n            Rotate(electron, about_point=nucleus.get_center(), angle=2*PI, run_time=4, rate_func=linear)\n            for electron in electrons\n        ]\n        self.play(*electron_animations, rate_func=linear)\n        \n        # Move atom to the side\n        self.play(atom.animate.to_edge(LEFT))\n        \n        # Create another atom and move it to the opposite side\n        second_atom = atom.copy()\n        self.add(second_atom)\n        self.play(second_atom.animate.to_edge(RIGHT))\n        \n        # Fade out everything\n        self.play(FadeOut(VGroup(atom, second_atom)))"
    },
    {
        "query": "Could you create an animation that visually explains how to solve a triple integral, specifically the integral of the function xyz from z=0 to z=2, x=-1 to x=1, and y=0 to y=1? The animation should first display the integral problem, then step-by-step walk through the integration process by first integrating with respect to z, then x, and finally y. For each integration step, I would like a brief explanatory text that appears stating which variable is being integrated, followed by the updated integral expression. The final frame should show the evaluated result of the integral. Can this all be done with smooth transitions between steps and pauses that allow time for each part to be understood?",
        "answer": "\\n from manim import *\n\nclass TriangleToSquare(Scene):\n    def construct(self):\n        triangle = Triangle()\n        square = Square()\n\n        # Playing animation.\n        self.play(Create(triangle))\n        self.play(triangle.animate.rotate(PI/2))\n        self.play(Transform(triangle, square), run_time=3)\n        self.play(FadeOut(triangle))"
    },
    {
        "query": "Please create an educational animation that visually describes the concept of Fourier series. Start by showing the formula of the Fourier series on the screen. Then, provide a text explanation stating that a Fourier series decomposes periodic functions. Afterward, update the text to indicate that the coefficients in the series are specific to the function's shape. Replace the initial formula with the formula for calculating the coefficients of the Fourier series. Next, change the text again to clarify that as the number of terms in the series increases, the approximation of the function improves, converging to the actual function. Finally, clear the screen and conclude by displaying the coefficients formula once more to reinforce the concept. Make sure each part of the explanation stays visible for long enough to be understood before moving on to the next.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the curve\n        ax = Axes(\n            x_range=[0, 4],\n            y_range=[0, 2],\n            axis_config={\"color\": BLUE},\n        )\n        curve = ax.plot(lambda x: 0.25 * x**2, color=YELLOW)\n        area = ax.get_area(curve, x_range=(0, 4), color=GREEN_A, opacity=0.5)\n        self.play(Create(ax), Create(curve))\n        self.wait(1)\n        \n        # Announce the problem\n        problem_text = Text(\"Find the area under y = 0.25x^2 from x=0 to x=4\", font_size=24)\n        problem = problem_text.to_edge(UP)\n        self.play(Write(problem))\n        self.wait(2)\n        \n        # Show the area\n        self.play(FadeIn(area))\n        self.wait(2)\n        \n        # Calculate the area\n        area_calculation = MathTex(r\"A = \\int_{0}^{4} 0.25x^2 \\,dx\")\n        area_calculation.next_to(problem, DOWN)\n        self.play(Write(area_calculation))\n        self.wait(1)\n        \n        # Show the solution\n        solution = MathTex(r\"A = \\left. \\frac{0.25x^3}{3} \\right|_0^4\")\n        solution.next_to(area_calculation, DOWN)\n        self.play(Write(solution))\n        self.wait(1)\n\n        final_value = MathTex(r\"A = \\frac{0.25 \\cdot 4^3}{3} - \\frac{0.25 \\cdot 0^3}{3}\")\n        final_value.next_to(solution, DOWN)\n        self.play(Write(final_value))\n        self.wait(2)\n\n        final_value_simplified = MathTex(r\"A = \\frac{16}{3}\")\n        final_value_simplified.next_to(final_value, DOWN)\n        self.play(Transform(final_value, final_value_simplified))\n        self.wait(2)\n\n        # Clear the scene and show a concluding text\n        self.clear()\n        conclusion_text = Text(\"Area under the curve is 16/3 square units\", font_size=24)\n        self.wait(1)\n        self.play(Write(conclusion_text))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that demonstrates how to calculate the area between two curves, specifically between f(x) = 3x + 2 and g(x) = x^2 - 1, from x=1 to x=3. I want the animation to show the two equations and then step by step, display the integration process, including setting up the integral, performing the algebra to simplify the functions, evaluating the definite integral by calculating the area under each curve, and finally subtracting them to get the result. Can you also include the intermediate steps of the algebraic simplification and finally display the exact numerical value of the area in a clear and engaging way?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the partial differential equation\n        pde = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(pde))\n        self.wait(1)\n\n        # Explanation for what kind of PDE it is\n        explanation1 = Text(\"This is the wave equation, a second-order linear PDE.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution format\n        explanation2 = Text(\"The general solution depends on initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution form\n        general_solution = MathTex(r\"u(x, t) = F(x - ct) + G(x + ct)\")\n        self.play(ReplacementTransform(pde, general_solution))\n        self.wait(1)\n\n        # Explanation for d'Alembert's formula\n        explanation3 = Text(\"For the 1D wave equation, this is known as d'Alembert's Formula.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude with d'Alembert's formula\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates a linear algebra concept, specifically how a 2D vector is transformed by a matrix. The animation should start by displaying a 2x2 matrix at the top of the screen and then show a title saying \"Linear transformation effect\". After that, there should be a grid representing the 2D plane and a yellow vector starting from the origin. This vector should then be transformed according to the matrix, changing its color to red to highlight the effect of the transformation. Finally, the animation should end with a text at the bottom saying \"Transformed Vector\" to emphasize the result. Can the animation also include a small pause between each step to give viewers time to understand what's happening, and then clear the screen at the end?",
        "answer": "\\n from manim import *\n\nclass TaylorSeriesApprox(Scene):\n    def construct(self):\n        # Display the function to be approximated\n        function = MathTex(r\"f(x) = e^x\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Introduction to Taylor Series\n        taylor_explanation = Text(\"Approximate using Taylor Series at x=0:\", font_size=24).to_edge(UP)\n        self.play(Write(taylor_explanation))\n        self.wait(2)\n\n        # Taylor Series formula\n        taylor_formula = MathTex(r\"f(x) \\approx f(0) + f'(0)x + \\frac{f''(0)}{2!}x^2 + \\dots + \\frac{f^{(n)}(0)}{n!}x^n\")\n        self.play(Write(taylor_formula))\n        self.wait(2)\n\n        # Calculating the first few terms\n        first_terms = MathTex(r\"1 + x + \\frac{x^2}{2} + \\frac{x^3}{6} + \\frac{x^4}{24}\")\n        self.play(ReplacementTransform(taylor_formula, first_terms))\n        self.wait(1)\n\n        # Explanation for stopping at 4th degree\n        taylor_stop_explanation = Text(\"Stopping at the 4th-degree polynomial\", font_size=24).to_edge(UP)\n        self.play(Transform(taylor_explanation, taylor_stop_explanation))\n        self.wait(2)\n\n        # Show graph of the function and the approximation\n        axes = Axes(\n            x_range=[-2, 2],\n            y_range=[0, 8],\n            axis_config={\"color\": BLUE},\n        )\n        original_graph = axes.plot(lambda x: np.exp(x), color=GREEN)\n        approx_graph = axes.plot(lambda x: 1 + x + x**2 / 2 + x**3 / 6 + x**4 / 24, color=RED)\n        graphs = VGroup(axes, original_graph, approx_graph).scale(0.6).to_edge(DOWN)\n\n        # Display the graphs on the scene\n        self.play(Write(axes), Write(original_graph), Write(approx_graph))\n        self.wait(2)\n\n        # Legend\n        legend = VGroup(\n            original_graph.copy().set_color(WHITE),\n            Text(\"Original function\", font_size=18),\n            approx_graph.copy().set_color(WHITE),\n            Text(\"4th-degree approximation\", font_size=18)\n        ).arrange(DOWN, aligned_edge=LEFT).next_to(axes, RIGHT, aligned_edge=UP)\n        self.play(Write(legend))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(first_terms))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually explains each step of solving a triple integral math problem. The problem is the triple integral of the function xyz over the unit cube with limits from 0 to 1 for each variable x, y, and z. I want the animation to start by introducing the problem, then show the process of integrating with respect to x, followed by y, and then z. Each step of integration should include an on-screen text explanation of which variable is currently being integrated, and the integral should update to reflect the completion of that integration step. After all integrations have been performed, I want the final numerical answer to the triple integral to be revealed. Lastly, I'd like all the text and the calculation to fade out, leaving only the final numerical value on the screen. Can you help me create an animation like this?",
        "answer": "\\n class SweepingLine(Scene):\n    def construct(self):\n        growing_circle = Circle(radius=0.001)\n\n        moving_line = Line([-7, -5, 0], [-6, 5, 0])\n        moving_line.normal_vector = moving_line.copy().rotate(90*DEGREES).get_vector()\n\n        def opacity_updater(obj):\n            if (  # check whether dot is inside circle\n                sum((growing_circle.points[0] - growing_circle.get_center())**2)\n                >= sum((obj.get_center() - growing_circle.get_center())**2)\n                #  round(  # more general winding number approach!\n                #      get_winding_number(growing_circle.get_anchors() - obj.get_center())\n                #  ) > 0\n            ):\n                obj.set_fill(BLUE, opacity=1)\n                obj.clear_updaters()  # removes opacity_updater, ...\n                obj.add_updater(color_updater)  # and attaches the color_updater function\n                self.add_sound(\"assets/click.wav\")\n\n        def color_updater(obj):\n            if (  # check whether point is *right* of the line\n                np.dot(obj.get_center(), moving_line.normal_vector)\n                < np.dot(moving_line.get_start(), moving_line.normal_vector)\n            ):\n                if obj.color != Color(BLUE):\n                    obj.set_color(BLUE)\n                    self.add_sound(\"assets/click.wav\")\n            else:  # otherwise point is *left* of the line\n                if obj.color != Color(YELLOW):\n                    obj.set_color(YELLOW)\n                    self.add_sound(\"assets/click.wav\")\n\n        self.add(growing_circle)\n\n        for _ in range(30):\n            p = Dot(fill_opacity=0.6)\n            p.move_to([random.uniform(-6, 6), random.uniform(-4, 4), 0])\n            p.add_updater(opacity_updater)\n            self.add(p)\n\n        self.play(\n            growing_circle.animate.scale_to_fit_width(1.5*config.frame_width),\n            run_time=5\n        )\n        self.play(Create(moving_line))\n        self.play(moving_line.animate.shift(14*RIGHT), run_time=5)\n        self.play(moving_line.animate.shift(14*LEFT), run_time=5)"
    },
    {
        "query": "\"Can you create an educational animation demonstrating the steps involved in calculating the triple integral of xyz over the region defined by 0 \u2264 x \u2264 3, 0 \u2264 y \u2264 2, and 0 \u2264 z \u2264 1, with each step of integrating with respect to x, y, and then z explained sequentially and the solution presented at the end?\"",
        "answer": "\\n class AnimateSyntax(Scene):\n    def construct(self):\n        s = Square(color=GREEN, fill_opacity=0.5)\n        c = Circle(color=RED, fill_opacity=0.5)\n        self.add(s, c)\n        self.play(s.animate.shift(UP), c.animate.shift(DOWN))\n        self.play(VGroup(s, c).animate.arrange(RIGHT))\n        self.play(c.animate(rate_func=linear).shift(RIGHT).scale(2))\n        self.wait()"
    },
    {
        "query": "Please create an educational animation that explains the process of calculating the surface area of a 3D shape using a surface integral. The animation should start by displaying the mathematical expression for a surface integral and then proceed step-by-step to show how to parameterize the surface, compute the cross product of partial derivatives, take the dot product with the vector field, and finally evaluate the double integral to find the surface area. Each step should be accompanied by both written explanations and the corresponding mathematical expressions. Additionally, include a summary statement at the end that reinforces the surface area is determined by the evaluated integral.",
        "answer": "\\n from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        self.add(Text(\"Chemical Reaction Simulation\").shift(UP * 3))\n\n        # Create electron, oxygen and metal objects\n        e = electron()\n        o = oxygen()\n        m = metal()\n\n        # Position the objects on the screen\n        e.move_to(LEFT * 4)\n        o.move_to(LEFT * 2)\n        m.move_to(RIGHT * 2)\n\n        # Display the objects with animations\n        self.play(FadeIn(e))\n        self.play(FadeIn(o))\n        self.play(FadeIn(m))\n        self.wait(1)\n\n        # Run a reaction animation\n        self.play(e.animate.move_to(o.get_center()))\n        self.play(ReplacementTransform(e, o))\n        self.wait(0.5)\n\n        # Move metal closer to oxygen\n        self.play(m.animate.move_to(o.get_center()))\n        self.wait(0.5)\n\n        # Bond the metal and oxygen together to create a metal oxide\n        mo = VGroup(m, o)\n        self.play(ReplacementTransform(VGroup(m, o), mo))\n        self.wait(1)\n\n        # Creating a lattice structure of metal oxide\n        lattice = metal_oxid(3, 3)\n        self.play(Transform(mo, lattice))\n        self.wait(2)\n\n        # Conclude the scene\n        self.play(FadeOut(mo))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visualizes Euler's Formula, where it starts by displaying the title \"Euler's Formula\", then moves it to the top of the screen and introduces the formula \"e^(i\u03b8) = cos(\u03b8) + i*sin(\u03b8)\" in the center? Then, can you show a complex plane and illustrate an angle \u03b8 traced by a line from the origin to the edge of a circle, with a dot marking the end of the line, to demonstrate how as \u03b8 varies, the expression traces out the unit circle in the complex plane? After completing one full rotation, can you then briefly clear the screen and conclude by re-displaying only Euler's Formula at the end? The narration and explanation for each step of the animation would be added later, just provide the visual elements and the sequence of events.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Restore\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            square = Square(fill_opacity=1).set_fill(RED).shift(DOWN+RIGHT)\n            self.play(Create(circle), run_time=0.5)\n            circle.save_state()\n            self.wait(0.5)\n            self.play(Transform(circle,square), run_time=0.3)\n            self.play(circle.animate.shift(RIGHT), run_time=0.3)\n            self.play(circle.animate.rotate(0.5), run_time=0.4)\n            self.wait(0.5)\n            self.play(Restore(circle))\n            self.wait(0.2)\n            self.remove(circle,square)"
    },
    {
        "query": "Can you create an educational animation that visually illustrates the process of approximating a cubic function using different polynomial degrees, starting with a linear function and progressing through to a cubic one? The animation should begin by displaying a set of axes and plotting the original cubic function x^3 in green. Afterward, it should graph a linear approximation 3x-2 in red, followed by a quadratic approximation x^2-2x+1 in orange, and finally a more accurate cubic approximation 0.1x^3+0.2x^2-0.5x-1 in purple. Each new approximation should replace the previous one, and all functions should be accurately labeled. At the end of the animation, I'd like to briefly clear the screen before concluding with just the most accurate cubic approximation displayed. Please ensure each step is paced for clear comprehension and visual appeal.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int_2^3\", r\"x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Display explanation for setting up the integration\n        explanation1 = Text(\"Find the area under the curve from 2 to 3\", font_size=24).shift(UP * 3)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show integration steps\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_2^3\")\n        self.play(ReplacementTransform(problem[1].copy(), integration_step.next_to(problem[0], RIGHT)))\n        self.wait(1)\n\n        # Showing explanation for evaluating the boundaries\n        explanation2 = Text(\"Evaluate at the boundaries\", font_size=24).shift(UP * 3)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing final answer\n        final_answer = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(2)^3\", r\"= 9 - \\frac{8}{3}\", r\"= \\frac{19}{3}\")\n        self.play(ReplacementTransform(integration_step, final_answer))\n        self.wait(1)\n\n        # Cleaning the scene and showing the conclusion\n        self.play(FadeOut(explanation1), FadeOut(problem))\n        self.wait(1)\n        conclusion = Text(\"The area under the curve is 19/3 units\", font_size=24).shift(UP * 3)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an educational animation that explains the concept of an infinite geometric series. Could you please show the formula for an infinite geometric series, provide a step-by-step visual explanation on how the formula is derived for cases where the common ratio is less than 1, and give a concrete example using actual numbers to demonstrate how the series converges to a sum? Make sure to include written explanations to accompany each step of the derivation and the example for clarity.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve = FunctionGraph(lambda x: 0.1 * (x - 3) ** 2, x_range=[0, 5])\n        area = Rectangle(width=5, height=3, color=BLUE, fill_opacity=0.5)\n        \n        equation = MathTex(r\"A = \\int_{a}^{b} f(x) \\,dx\")\n        equation.to_edge(UP)\n\n        self.play(Write(equation))\n        self.wait(1)\n        \n        self.play(DrawBorderThenFill(area))\n        self.play(Create(curve))\n        self.wait(1)\n        \n        shaded_area_text = Text(\"Shaded Area represents A\", font_size=24)\n        shaded_area_text.next_to(area, DOWN)\n\n        self.play(Write(shaded_area_text))\n        self.wait(2)\n\n        a_brace = BraceLabel(area, \"a\", DOWN)\n        b_brace = BraceLabel(area, \"b\", DOWN)\n        self.play(GrowFromCenter(a_brace), GrowFromCenter(b_brace))\n        self.wait(1)\n        \n        final_text = Text(\"Area under the curve from a to b\", font_size=24).to_edge(DOWN)\n        self.play(Transform(shaded_area_text, final_text))\n        self.wait(1)\n\n        # Clear the scene\n        self.play(FadeOut(area), FadeOut(curve), FadeOut(equation),\n                  FadeOut(a_brace), FadeOut(b_brace), FadeOut(shaded_area_text))\n        self.wait(1)\n\n        # Show the concluding text\n        concluding_text = Text(\"Visualization Complete!\", font_size=36)\n        self.play(Write(concluding_text))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational math animation that visually explains the process of computing the definite integral of the function \\(x^2\\) from 1 to 3. It should display the integral equation at the top, show the curve and the corresponding shaded area under the curve, step by step calculate the integral using the fundamental theorem of calculus and evaluate the integral to a numerical answer. Can you also ensure that the final answer is emphasized, and the complete solution is neatly positioned in a corner at the end, summarizing the steps and results?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.surround\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            star = Star().shift(RIGHT)\n            self.add(circle,star)\n            self.play(circle.animate.surround(star))\n            self.remove(circle,star)"
    },
    {
        "query": "Can you create an educational video animation that shows the area under the curve of the function f(x) = e^(-x^2) from 0 to 2, demonstrates how to set up the corresponding integral, and explains why a numerical approximation is necessary because the integral can\u2019t be solved with elementary functions? Also, can the video end by showing the numerical value of the approximation as a conclusion?",
        "answer": "\\n from manim import Scene, VGroup_x000D_\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer_x000D_\nfrom manim_ml.neural_network.animations.dropout import DropoutAnimation_x000D_\n_x000D_\nclass DropoutScene(Scene):_x000D_\n    def construct(self):_x000D_\n        # Create a neural network_x000D_\n        nn = NeuralNetwork([_x000D_\n            FeedForwardLayer(4),_x000D_\n            FeedForwardLayer(6),_x000D_\n            FeedForwardLayer(6),_x000D_\n            FeedForwardLayer(3),_x000D_\n        ], layer_spacing=0.5)_x000D_\n        _x000D_\n        # Position the neural network in the center_x000D_\n        nn.move_to(ORIGIN)_x000D_\n_x000D_\n        # Create a group to hold our animations_x000D_\n        animations = VGroup()_x000D_\n        _x000D_\n        # Create a dropout animation for each layer of the neural network_x000D_\n        for layer in nn.layers[1:]:  # Skip the input layer_x000D_\n            animations.add(DropoutAnimation(layer, p=0.2))_x000D_\n_x000D_\n        # Add the neural network to the scene_x000D_\n        self.add(nn)_x000D_\n_x000D_\n        # Play the dropout animations_x000D_\n        self.play(*animations)_x000D_\n        _x000D_\n        # End the scene_x000D_\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that demonstrates the concept of finding the area under a curve using integration. Specifically, I want to show the graph of \\( x^2 \\) along with its plot, then visually display the area under the curve between 0 and 1.5. Following that, I want to introduce the integral symbol and expression that represents the computation of this area. Can you illustrate the step-by-step process of solving the integral, ultimately revealing the numerical value of the area? Finally, clear everything and just present the final numerical solution on the screen.",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using substitution\n        explanation1 = Text(\"Use substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Substitution step\n        sub_step = MathTex(r\"u = 2x\", r\"\\quad\", r\"\\frac{du}{dx}=2\", r\"\\quad\", r\"dx=\\frac{du}{2}\")\n        self.play(Write(sub_step))\n        self.wait(2)\n\n        # Rewrite integral with substitution\n        integral_sub = MathTex(r\"\\int e^u \\frac{du}{2}\")\n        self.play(ReplacementTransform(problem.copy(), integral_sub))\n        self.wait(2)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(integral_sub, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(sub_step), FadeOut(explanation1), FadeOut(final_solution))\n        self.wait(1)\n        conclusion = Text(\"Thus, the integral is solved.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation in which you graph the function y=x^2 using an x and y axes range from 0 to 4, highlight the area under the curve from x=0 to x=2, label the curve with its equation, display a statement at the top that says \"Area under y=x^2 from x=0 to x=2\", and conclude the animation with a lower-thirds text that states \"Area is 8/3\"? Additionally, please make sure the axes are colored blue and the graph of the function is green.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        curve_label = MathTex(r\"f(x) = 3 - \\frac{1}{2}x^2\", font_size=24)\n        self.play(Write(curve_label))\n        self.wait(1)\n\n        curve_graph = FunctionGraph(\n            lambda x: 3 - 0.5 * x**2,\n            x_range=[-3, 3],\n            color=BLUE\n        )\n        self.play(Create(curve_graph))\n        self.wait(1)\n\n        area_label = Text(\"Area from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Transform(curve_label, area_label))\n        self.wait(1)\n\n        shaded_area = area = Integral(curve_graph, (1, 2))\n        self.play(FadeIn(shaded_area))\n        self.wait(1)\n\n        area_value = MathTex(r\"Area = \\int_1^2 (3 - \\frac{1}{2}x^2) \\,dx\", font_size=24)\n        self.play(ReplacementTransform(area_label, area_value))\n        self.wait(2)\n\n        final_answer = MathTex(r\"= \\left[ 3x - \\frac{1}{6}x^3 \\right]_1^2 = \\frac{7}{3}\", font_size=24)\n        self.play(ReplacementTransform(area_value, final_answer))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video that visually explains how to calculate the definite integral of the function x cubed from the limits 2 to 4 by following these steps: First, display the integral problem on the screen. Then, write a text that says \"Using the power rule of integration\" at the top. Show the general power rule formula for integration and its application to the definite integral with the given limits. Replace the integral display with the first step of the solution, incorporating the power rule. Next, change the text at the top to \"Evaluate at the limits\" and show the result of substituting the upper and lower limits into the integrated function. Simplify these calculations on-screen and show the final value of the definite integral. Conclude the animation by clearing everything and displaying just the final numerical solution to the definite integral. Can you do that in a simple and educational way that would be easy for students to follow?",
        "answer": "\\n from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for getting started\n        explanation1 = Text(\"Let's solve this first-order ODE\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Transform the ODE to separate variables\n        separated_variables = MathTex(r\"\\frac{dy}{dx} = 3y\")\n        self.play(ReplacementTransform(problem.copy(), separated_variables))\n        self.wait(1)\n\n        # Explanation for separation of variables\n        explanation2 = Text(\"We separate the variables\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integrating both sides\n        integral_form = MathTex(r\"\\int{\\frac{1}{y}dy} = \\int{3dx}\")\n        self.play(Transform(separated_variables, integral_form))\n        self.wait(1)\n\n        # Explanation for integration\n        explanation3 = Text(\"Integrate both sides\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # The solution after integration\n        ln_solution = MathTex(r\"\\ln{|y|} = 3x + C\")\n        self.play(ReplacementTransform(integral_form, ln_solution))\n        self.wait(1)\n\n        # Explanation for exponential form\n        explanation4 = Text(\"Convert to exponential form\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # General solution in exponential form\n        general_solution = MathTex(r\"y = Ae^{3x}\")\n        self.play(ReplacementTransform(ln_solution, general_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation5 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation5))\n        self.wait(2)\n\n        # Clear the scene and conclude with the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation where a trigonometric function composed of the sine and cosine functions is shown. First, display the function \"f(x) = sin(x) + cos(x)\" on the screen. Then, introduce the idea of a trigonometric identity with a text saying \"Use a trigonometric identity\" at the top of the screen. After that, use the identity to transform the original function into \"f(x) = \u221a2 sin(x + \u03c0/4)\" and show this process on the screen. Next, I want to see the graph of the original function, so please include axes and plot the function \"f(x) = sin(x) + cos(x)\", with the graph labeled as \"f(x)\". Finally, clear everything except the graph of the function from the screen and display it once more for emphasis. The animation should allow some time between steps for viewers to understand each part, so include brief pauses as needed.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        wave_explanation = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(wave_explanation))\n        self.wait(2)\n\n        # General solution for the wave equation\n        wave_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(wave_eq, wave_solution))\n        self.wait(2)\n\n        # Explanation of general solution\n        solution_explanation = Text(\"The general solution can be expressed as two moving waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(wave_explanation, solution_explanation))\n        self.wait(2)\n\n        # Displaying initial conditions\n        initial_conditions = MathTex(r\"u(x, 0) = f(x) + g(x)\", r\"\\quad\", r\"\\frac{\\partial u}{\\partial t}\\Big|_{t=0} = -cf'(x) + cg'(x)\")\n        initial_conditions_arranged = VGroup(initial_conditions[0], initial_conditions[2]).arrange(DOWN)\n        self.play(FadeOut(wave_solution), Write(initial_conditions_arranged))\n        self.wait(2)\n\n        # Boundary condition explanation\n        boundary_explanation = Text(\"The specific solution also depends on initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(solution_explanation, boundary_explanation))\n        self.wait(2)\n\n        # Final message\n        final_message = Text(\"The propagation speed is denoted by c.\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_message))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of demonstration\", font_size=36)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates how to calculate the derivative of the cubic function f(x) = x^3 + 3x^2 + 3x + 1 step by step using the power rule, including both the initial mathematical function and the simplified form of its derivative, while also providing textual explanations for the calculation process and simplification? Additionally, ensure that the animation is clear by cleaning up the scene before presenting the final simplified derivative.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.stretch_to_fit_height\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.stretch_to_fit_height(3))\n            self.remove(square)"
    },
    {
        "query": "I would like an animated video explanation of the triple integral problem where we integrate the function xyz over the bounds from 0 to 2 with respect to z, from -1 to 1 with respect to y, and from 0 to 1 with respect to x. Can you show this step by step, starting with the integration with respect to z, followed by y, and finishing with x? Display each integral and intermediate step on the screen, accompanied by a written statement explaining which variable we're integrating with respect to next. Also, please show the final solution at the end after all integrations are performed.",
        "answer": "\\n from manim import *\n\nclass ChargeTransferScene(Scene):\n    def construct(self):\n        # Creating an electron, a lithium ion, and a metal atom\n        e = electron()\n        li = lithium_ion()\n        m = metal()\n\n        # Positioning the objects on screen\n        e.move_to(LEFT * 2)\n        li.move_to(ORIGIN)\n        m.move_to(RIGHT * 2)\n\n        # Moving the electron to the lithium ion\n        electron_transfer = move_along_complex_path(\n            obj=e, \n            stop_indices=[0, 2], \n            points=[e.get_center(), li.get_center(), m.get_center()], \n            run_time=2\n        )\n\n        # Moving the lithium ion to the metal atom\n        lithium_transfer = move_along_complex_path(\n            obj=li, \n            stop_indices=[0, 2], \n            points=[li.get_center(), m.get_center(), e.get_center()],\n            run_time=2\n        )\n\n        # Playing the animations of charge transfer\n        self.play(*electron_transfer)\n        self.play(*lithium_transfer)\n\n        # Creating a grid of metal_oxid\n        grid = metal_oxid(rows=3, cols=3)\n\n        self.play(FadeIn(grid))\n        self.wait(2)\n\n        # Fade everything out\n        self.play(FadeOut(VGroup(e, li, m, grid)))\n        self.wait()"
    },
    {
        "query": "Can you create an educational math animation that visually demonstrates how to calculate the area under a parabolic curve between two points, including the display of the definite integral formula and the calculated area result? Specifically, I'm looking for the curve defined by the equation 0.1(x - 3)^2, calculated between x = 1 and x = 4. I'd like the animation to begin by writing the integral equation at the top, followed by the drawing of the curve itself, then highlighting the area under the curve we're interested in, and finally showing the calculation and the exact value of this area below the highlighted section.",
        "answer": "\\n from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Form the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation step\n        char_eq = MathTex(r\"r - 3 = 0\")\n        self.play(ReplacementTransform(problem.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solve for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solving the characteristic equation\n        roots = MathTex(r\"r = 3\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = C e^{3x}\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Show particular solution\n        particular_solution = MathTex(r\"y = e^{3x}\")\n        self.play(Write(particular_solution))\n        self.wait(1)\n\n        # Explanation for particular solution\n        explanation4 = Text(\"A particular solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(particular_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that illustrates the concept of finding the area under the curve of the function f(x) = e^(-x^2) using numerical methods, specifically showing the area between x = -1 and x = 1, and ultimately displaying the estimated numerical value of this area?",
        "answer": "\\n from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series_problem = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for convergence test\n        explanation1 = Text(\"Use the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Convergence condition\n        condition = MathTex(r\"p > 1\")\n        self.play(ReplacementTransform(series_problem.copy(), condition))\n        self.wait(1)\n\n        # Applying the p-test\n        p_test_application = MathTex(r\"\\text{Since } p = 2 > 1, \\text{ the series converges.}\")\n        self.play(ReplacementTransform(condition, p_test_application))\n        self.wait(1)\n\n        # Explanation for p-test result\n        explanation2 = Text(\"The series converges by the p-test\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Closing conclusion\n        final_conclusion = MathTex(r\"\\therefore \\sum_{n=1}^{\\infty} \\frac{1}{n^2} \\text{ is convergent}\")\n        self.play(ReplacementTransform(p_test_application, final_conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_conclusion))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visually explains how to find the area under the curve of the function f(x) = x^2 from x=1 to x=3, by demonstrating the process of setting up the integral, evaluating it step by step, and concluding with the exact numerical value of the area?",
        "answer": "\\n from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        atom = self.create_atom()\n        electrons = self.create_electron_orbit(atom)\n        self.play(FadeIn(atom))\n        self.play(AnimationGroup(*[\n            MoveAlongPath(e, orbit) for e, orbit in electrons\n        ], lag_ratio=0.5))\n        self.wait(2)\n\n    def create_atom(self) -> Mobject:\n        nucleus = Dot(radius=0.2, color=BLUE).set_fill(BLUE_E, opacity=1)\n        protons = Tex(r'8p$^+$').set_color(WHITE).scale(0.5)\n        neutrons = Tex(r'8n').next_to(protons, DOWN, buff=0.1).set_color(WHITE).scale(0.5)\n        return VGroup(nucleus, protons, neutrons)\n\n    def create_electron_orbit(self, atom: Mobject) -> List[Tuple[Mobject, VMobject]]:\n        electrons = []\n        for i in range(1, 3):  # Creating 2 orbits\n            orbit = Ellipse(width=2*i, height=1*i, color=GREY).shift(atom.get_center())\n            num_electrons = 2 * i\n            for _ in range(num_electrons):\n                electron = Dot(radius=0.05, color=RED).set_fill(RED_D, opacity=1)\n                electrons.append((electron, orbit))\n        return electrons\n\n    @staticmethod\n    def position_electrons_on_orbit(electrons: List[Tuple[Mobject, VMobject]], angle_offset: float = 0):\n        for i, (electron, orbit) in enumerate(electrons):\n            num_electrons = len(orbit)\n            angle = (TAU / num_electrons) * i + angle_offset\n            direction = orbit.point_at_angle(angle)\n            electron.move_to(direction)"
    },
    {
        "query": "I would like to create an educational animation that visually explains how to calculate the area under the curve of the function f(x) = 3 - x^2 from x=1 to x=2. Can you show the function as a written expression, indicate the specific range for the area we're interested in, and display the process of setting up and solving the definite integral step by step? Finally, show the final result of the area calculation and declare the area value in square units before clearing everything and presenting the conclusion again.",
        "answer": "\\n from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_BLUE_COLOR = \"#16b0b5\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nORANGE_COLOR = \"#fc5922\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nDARK_PURPLE_COLOR = \"#5157b9\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef MathOperation(path, expression_text):\n    image = ImageMobject(path)\n    expression = Tex(expression_text, color=BLACK)\n    expression.scale(1.8)\n    group = Group(image, expression)\n    group.arrange(RIGHT, buff=0.25)\n\n    return group\n\nclass AlgebraOne(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        operation_1 = MathOperation(\"./assets/Asset 1.png\", \"+ 6 = 12\")\n        operation_2 = Tex(r\"\\textbf{6} + 6 = 12\", color=BLACK)\n        operation_2[0][0].set(color=ORANGE_COLOR)\n        operation_2.scale(1.8)\n        conclusion_1 = MathOperation(\"./assets/Asset 1.png\", \"= 6\")\n        conclusion_1.scale(0.8)\n        Group(\n            operation_1,\n            operation_2,\n            conclusion_1\n        ).arrange(DOWN, buff=0.7)\n        \n\n        self.play(operation_1.shift(9 * RIGHT).animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(1)\n        self.play(Transform(operation_1[1].copy(), operation_2))\n        self.wait(1)\n        self.play(SpinInFromNothing(conclusion_1))\n        self.wait(1)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Create an educational animation that explains the concept of the harmonic series and demonstrates why it diverges. Start by showing the mathematical expression of the harmonic series. Then, provide a textual statement that the harmonic series does not converge. Next, illustrate the concept of partial sums in relation to the series and animate the idea that as the number of terms goes to infinity, the sum approaches infinity, thereby showing the series' divergence. Include an introduction of the comparison test as part of the explanation for why the harmonic series diverges, and show a simple inequality that's used in the comparison test. Finally, end the animation with a clear statement that confirms the harmonic series does not converge. Make sure the animation is suitable for an audience learning about series convergence for the first time.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Finally, integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step and evaluation\n        final_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\frac{1}{2} d\\theta\")\n        integral_value = MathTex(r\"= \\frac{1}{2} [ \\theta ]_{0}^{2\\pi}\")\n        final_solution = MathTex(r\"= \\pi\")\n\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n        self.play(ReplacementTransform(final_integral, integral_value))\n        self.wait(1)\n        self.play(ReplacementTransform(integral_value, final_solution))\n        self.wait(2)"
    },
    {
        "query": "I would like an educational animation that visually demonstrates how to calculate the area under the graph of the function x squared from 0 to 2. Please include the following steps: \n\n1. Display a set of blue axes with an x-range from 0 to 3 and a y-range from 0 to 4, with the axes measuring 5 units along the x-axis and 3 units along the y-axis.\n2. Plot the function x squared on these axes, coloring the graph green, and label the graph with its equation.\n3. Highlight the area under the graph from 0 to 2 using a yellow color with some transparency.\n4. Write out the integral expression that represents the area under the graph using proper mathematical notation.\n5. Transition the integral expression to its antiderivative evaluated between 0 and 2.\n6. Show the final calculation step with the numerical result of the integral, which should be 8/3.\n7. Add that numerical result at the bottom as a conclusion statement, stating \"The area under x squared from 0 to 2 is 8/3,\" and ensure this statement is placed effectively at the bottom of the screen.\n8. After showing all the previous steps, clear the screen.\n9. Lastly, display only the final numerical integral value as a separate and clear concluding message.\n\nThe animation should be paced with pauses after each major step to allow the viewer some time to understand the content.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create Graph\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        area = axes.get_area(graph, x_range=(0, 2), color=GREEN, opacity=0.5)\n\n        # Displaying the area under the curve\n        curve_text = Text(\"Area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(curve_text))\n        self.play(Write(axes), Write(graph), Write(graph_label))\n        self.wait(1)\n\n        # Coloring the area under the curve\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Calculating the area using definite integral\n        integral = MathTex(r\"\\int_0^2 x^2 \\, dx\")\n        integral.to_edge(UP+LEFT)\n        self.play(Transform(curve_text, integral))\n        self.wait(1)\n\n        integral_result = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        integral_result.next_to(integral, DOWN)\n        self.play(Write(integral_result))\n        self.wait(1)\n\n        evaluate_integral = MathTex(r\"=\\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", \"=\", r\"\\frac{8}{3}\")\n        evaluate_integral.next_to(integral_result, DOWN)\n        self.play(Write(evaluate_integral))\n        self.wait(2)\n\n        # Clear the scene and display only the final result\n        self.clear()\n        final_result = MathTex(r\"\\text{Area} = \\frac{8}{3}\")\n        self.play(Write(final_result))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animated explanation of how to determine if the mathematical series sum of 1 over n squared from n equals 1 to infinity converges, including an illustration of the p-test for convergence and the value the series converges to, which is the result of the Basel problem?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Applying the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Explanation for definite integral\n        definite_integral_explanation = Text(\"Evaluate it from the lower to the upper limit:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, definite_integral_explanation))\n        self.wait(2)\n\n        # Setting up the integral solution\n        solution1 = MathTex(r\"\\left.\\frac{x^{3+1}}{3+1}\\right|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for calculating the definite integral\n        explanation2 = Text(\"Calculate the values at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculating the definite integral at the bounds\n        solution2 = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(Transform(solution1, solution2))\n        self.wait(2)\n\n        # Simplifying the result\n        final_answer = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(solution2, final_answer))\n        self.wait(2)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final answer to the problem\n        self.play(Write(final_answer))\n        self.wait(2)"
    },
    {
        "query": "Please create an educational animation that explains the process of evaluating a basic definite integral in calculus. Start by showing the integral of x cubed from 0 to 2. Then, demonstrate step by step how to apply the power rule of integration. After that, show how to evaluate the integral from the lower limit to the upper limit, finishing by calculating the specific values at the bounds. Conclude by simplifying the results to display the final numerical answer. Include textual explanations for each step and ensure that the transition between each part of the solution is clear and easy to follow.",
        "answer": "\\n from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyingTwoSteps(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{4}{8}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{1}{2}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{5}{10}\", color=TEXT_COLOR).scale(2)\n        ).arrange(RIGHT, buff=2)\n        arrow_up_1 = ArcBetweenPoints(\n            fractions[0].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[1].get_top() + 0.2 * UP + 0.1 * LEFT, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down_1 = ArcBetweenPoints(\n            fractions[0].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * LEFT, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up_1 = Tex(r\"Dividido por 4\", color=LIGHT_BLUE_COLOR)\n        text_up_1.scale(0.7)\n        text_up_1.next_to(arrow_up_1, UP)\n        text_down_1 = Tex(r\"Dividido por 4\", color=LIGHT_BLUE_COLOR)\n        text_down_1.scale(0.7)\n        text_down_1.next_to(arrow_down_1, DOWN)\n        equal_1 = MathTex(r\"=\", color=LIGHT_BLUE_COLOR)\n        equal_1.shift(1.5 * LEFT)\n        equal_1.scale(2)\n        arrow_up_2 = ArcBetweenPoints(\n            fractions[1].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[2].get_top() + 0.2 * UP, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down_2 = ArcBetweenPoints(\n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[2].get_bottom() + 0.2 * DOWN, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up_2 = Tex(r\"Multiplicado por 5\", color=LIGHT_BLUE_COLOR)\n        text_up_2.scale(0.7)\n        text_up_2.next_to(arrow_up_2, UP, buff=0.2)\n        text_down_2 = Tex(r\"Multiplicado por 5\", color=LIGHT_BLUE_COLOR)\n        text_down_2.scale(0.7)\n        text_down_2.next_to(arrow_down_2, DOWN, buff=0.2)\n        equal_2 = MathTex(r\"=\", color=LIGHT_BLUE_COLOR)\n        equal_2.shift(1.1 * RIGHT)\n        equal_2.scale(2)\n\n        self.play(Write(fractions), run_time=0.5)\n        self.play(\n            Write(arrow_up_1),\n            Write(text_up_1, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down_1),\n            Write(text_down_1, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal_1), run_time=0.5)\n        self.wait(0.5)\n        self.play(\n            FadeOut(arrow_up_1), \n            FadeOut(arrow_down_1), \n            FadeOut(text_up_1), \n            FadeOut(text_down_1), \n            run_time=0.7\n        )\n        self.play(\n            Write(arrow_up_2),\n            Write(text_up_2, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down_2),\n            Write(text_down_2, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal_2), run_time=0.5)\n        self.wait(0.5)\n        self.play(\n            FadeOut(arrow_up_2), \n            FadeOut(arrow_down_2), \n            FadeOut(text_up_2), \n            FadeOut(text_down_2), \n            run_time=0.7\n        )\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects)), run_time=0.7)"
    },
    {
        "query": "Please create an educational animation that explains the steps involved in computing a surface integral of the function f(x, y, z) = x^2 + y^2 + z^2 over a spherical surface S. Begin with presenting the integral problem and then show how to parameterize the surface using spherical coordinates. Next, I'd like the animation to display the substitution of this parameterization into the surface integral and simplify the expression by taking advantage of the symmetry of the sphere. Afterward, guide me through the integration process by integrating with respect to \u03b8 first and then \u03c6, showing each step. Finally, present the solution to the integral after evaluating it completely.",
        "answer": "\\n from manim import *\n\n# Define colors\nGREEN_SCREEN_COLOR = \"#00FF00\"\nDARK_YELLOW_COLOR = \"#d7c000\"\nDARK_GREEN_COLOR = \"#008000\"\nLIGHT_BROWN_COLOR = \"#996633\"\nDARK_BROWN_COLOR = \"#662400\"\n\n# Geometry constants\nSANDWICH_HEIGHT = 0.3\nSANDWICH_LENGTH = 3\nBREAD_HEIGHT = 0.5\n\ndef Bread():\n    return Rectangle(\n        height=BREAD_HEIGHT, \n        width=SANDWICH_LENGTH, \n        color=LIGHT_BROWN_COLOR, \n        fill_opacity=1\n    )\n\ndef Lettuce():\n    return Ellipse(\n        width=SANDWICH_LENGTH + 0.5, \n        height=SANDWICH_HEIGHT, \n        color=DARK_GREEN_COLOR, \n        fill_opacity=1\n    ).shift(SANDWICH_HEIGHT * DOWN)\n\ndef Cheese():\n    return Rectangle(\n        height=SANDWICH_HEIGHT, \n        width=SANDWICH_LENGTH + 0.2, \n        color=DARK_YELLOW_COLOR, \n        fill_opacity=1\n    ).shift(SANDWICH_HEIGHT * 0.5 * DOWN)\n\ndef Sandwich():\n    return VGroup(\n        Bread().shift(SANDWICH_HEIGHT * 0.5 * UP),\n        Lettuce(),\n        Cheese(),\n        Bread().shift(SANDWICH_HEIGHT * 0.5 * DOWN)\n    )\n\nclass SandwichScene(Scene):\n    def construct(self):\n        self.camera.background_color = GREEN_SCREEN_COLOR\n        \n        sandwich = Sandwich()\n        sandwich_group = VGroup(*[sandwich.copy() for _ in range(4)])\n        sandwich_group.arrange(DOWN, buff=0.5)\n\n        self.play(\n            AnimationGroup(\n                *[FadeIn(sandwich, shift=UP) for sandwich in sandwich_group],\n                lag_ratio=0.1\n            ),\n            run_time=2\n        )\n\n        self.wait(1)\n\n        bite_marks = []\n        for i, sandwich in enumerate(sandwich_group):\n            bite = Arc(\n                radius=0.5, \n                start_angle=PI, \n                angle=-3*PI/4,\n                color=DARK_BROWN_COLOR\n            ).shift(SANDWICH_LENGTH / 2 * LEFT + (i - 1.5) * BREAD_HEIGHT * UP)\n            self.play(DrawBorderThenFill(bite))\n            bite_marks.append(bite)\n\n        self.wait(1)\n\n        self.play(\n            *[sandwich.animate.shift(LEFT * 3) for sandwich in sandwich_group],\n            *[bite_mark.animate.shift(LEFT * 3) for bite_mark in bite_marks],\n            run_time=1.5\n        )\n\n        self.wait(0.5)\n\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects],\n            run_time=1\n        )\n\n        self.wait(0.5)"
    },
    {
        "query": "I would like to create an educational animation that explains Simple Harmonic Motion (SHM). The video should start with the title \"Simple Harmonic Motion\" appearing on the screen. Then, I want to introduce the differential equation that represents the motion, m*d\u00b2x/dt\u00b2 + kx = 0, where 'm' stands for mass, the second derivative of x with respect to time represents acceleration, and 'k' is the spring constant. Afterward, I'd like an explanation of what the constants and symbols mean to appear below the equation. Next, please show the transformation of this equation into a characteristic equation, and explain that '\u03c9' is the square root of 'k/m'. Then, present the general solution to this equation using sines and cosines, with 'A' and 'B' as arbitrary constants, followed by a short explanation of what this solution represents. Lastly, clear everything off the screen and only display the general solution again with a final text explaining that this is the representation of the position x(t) over time. Could you do such an animation?",
        "answer": "\\n class ShapesComposition(Scene):\n    def construct(self):\n        square = Square(color=RED)\n        circle = Circle(color=BLUE).next_to(square, RIGHT)\n        triangle = Triangle(color=YELLOW).next_to(square, UP)\n        shape_group = VGroup(square, circle, triangle)\n        shape_group.to_edge(LEFT)\n        self.add(shape_group)\n\n        rectangles = VGroup(*[Rectangle(height=0.4, width=0.6) for _ in range(5)])\n        rectangles.arrange(DOWN, buff=0.3)\n        self.add(rectangles)\n\n        polygons = VGroup(*[RegularPolygon(n, color=ORANGE, fill_opacity=0.5).scale(0.4) for n in range(3, 8)])\n        polygons.arrange_in_grid(2, 3, buff=0.3)\n        self.add(polygons)"
    },
    {
        "query": "Can you create an educational animation using ManimCE that visually explains how to calculate the area under the curve y = x^2 between x = 1 and x = 2, including writing out the problem, explaining the concept of a definite integral, showing the steps to calculate the antiderivative, plugging in the bounds of the integral, and finally presenting the solution?",
        "answer": "\\n from manim import *\n\nclass Spiral3D(ThreeDScene):\n    def construct(self):\n        spiral = ParametricFunction(\n            lambda u: np.array([\n                1.5 * np.cos(u),\n                1.5 * np.sin(u),\n                u / (2 * PI)\n            ]),\n            t_range=[0, 4 * PI],\n            color=RED\n        )\n        axes = ThreeDAxes()\n\n        self.set_camera_orientation(phi=60 * DEGREES, theta=-45 * DEGREES)\n        self.play(Create(axes), Create(spiral))\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(6)"
    },
    {
        "query": "Can you create an animated step-by-step visualization of solving a triple integral problem where the integral is first taken with respect to z, showing the intermediate result, then with respect to y, and finally with respect to x, including brief textual explanations before each integration step?",
        "answer": "\\n from manim import *\n\nclass MObjectShowcase(Scene):\n    def construct(self):\n        title = Text(\"A Showcase of MObjects\").to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        \n        mobject_grid = VGroup(*[\n            VGroup(\n                Square(),\n                Circle(),\n                Triangle(),\n                Annulus(),\n                Ellipse(),\n                Dot(),\n                Arrow(),\n                Star()\n            ),\n            VGroup(\n                Text(\"Text\"),\n                MathTex(r\"\\int_a^b f(x)\\,dx\"),\n                Integer(42),\n                DecimalNumber(3.14),\n                BulletedList(\"First\", \"Second\", \"Third\"),\n                Code(\"print('Hello, World!')\", language=\"Python\")\n            )\n        ]).arrange(DOWN, buff=LARGE_BUFF)\n        \n        for submobjects in mobject_grid:\n            submobjects.arrange(RIGHT, buff=LARGE_BUFF)\n        \n        mobject_grid.scale(0.5)\n        mobject_grid.move_to(ORIGIN)\n        \n        self.play(LaggedStart(*[FadeIn(mobj, shift=DOWN) for mobj in mobject_grid], lag_ratio=0.2))\n        self.wait(2)\n\n        self.play(LaggedStart(*[ApplyWave(mobj) for mobj in mobject_grid[0]], lag_ratio=0.2))\n        self.play(LaggedStart(*[Indicate(mobj) for mobj in mobject_grid[1]], lag_ratio=0.2))\n        self.wait()\n\n        self.play(FadeOut(mobject_grid), FadeOut(title))\n        self.wait()"
    },
    {
        "query": "I'd like an animation that introduces the exponential function f(x) = e^x by first showing the function's formula, followed by its graph on a coordinate plane with labeled axes and the function plotted in green. Then the animation should transform this graph to demonstrate the function f(x) = e^(2x), changing the original graph to red and adjusting the formula accordingly. To finish, I want a final display of the new graph with a concluding text that mentions the growth rate of exponential functions without showing any of the previous components.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the graph\n        ax = Axes(\n            x_range=[0, 2],\n            y_range=[0, 2],\n            axis_config={\"color\": BLUE},\n        )\n        self.add(ax)\n\n        # Define the function and its graph\n        def func(x):\n            return x**2\n\n        graph = ax.plot(func, color=WHITE)\n        self.play(Create(graph))\n\n        # Display the problem of finding the area under the curve\n        problem_text = MathTex(r\"\\text{Area under } y=x^2 \\text{ from } x = 0 \\text{ to } x = 2\")\n        problem_text.to_edge(UP)\n        self.play(Write(problem_text))\n        self.wait(2)\n\n        # Fill area under curve\n        area = ax.get_riemann_rectangles(graph, x_range=[0, 2], color=BLUE, opacity=0.5)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Calculation step\n        calc_step = MathTex(r\"A = \\int_{0}^{2} x^2 \\,dx\")\n        self.play(Write(calc_step))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"A = \\left[ \\frac{1}{3}x^3 \\right]_{0}^{2}\")\n        self.play(ReplacementTransform(calc_step.copy(), final_solution))\n        self.wait(2)\n\n        # Calculate the definite integral value\n        def_integral_val = MathTex(r\"A = \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3 = \\frac{8}{3}\")\n        self.play(Write(def_integral_val))\n        self.wait(2)\n\n        # Show the numerical result\n        numerical_result = Tex(r\"The area is approximately 2.67 square units\")\n        numerical_result.next_to(def_integral_val, DOWN)\n        self.play(Write(numerical_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Write final answer\n        self.play(Write(Tex(r\"The final area is $\\frac{8}{3}$ square units\")))\n        self.wait(1)"
    },
    {
        "query": "I want an animation that starts by writing the formula for the area of a circle on the screen. Then, a blue circle should appear with a yellow radius labeled 'r' emerging from its center. After that, the formula should transform to highlight the radius part 'r' in the area formula. Next, calculate the circle's area using a specific radius value, let's say r=2, and replace the general area formula on the screen with this specific calculation. Following that, the calculated area should move to a different position while the formula at the original position also changes to show the calculated area. Finally, clear the screen and end the animation with the text \"The area of the circle is 4 pi\" written out. The whole animation should have pauses to let the viewer follow along.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r\\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[ \\frac{1}{2} r^2 \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ \\frac{1}{2} \\\\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Final numerical solution\n        numerical_solution = MathTex(r\"= \\frac{\\pi}{2}\")\n        self.play(ReplacementTransform(final_solution, numerical_solution))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"The area inside a semicircle of radius 1\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        self.play(FadeOut(problem), FadeOut(explanation1), FadeOut(numerical_solution), FadeOut(conclusion))"
    },
    {
        "query": "Can you create an animated video that explains how to find the area under the curve of the function x squared minus 2x plus 1 between x equals 2 and x equals 4, including writing the integral, explaining the integrand function, showing the antiderivative, evaluating the antiderivative at the bounds, calculating the final result, and then clearing everything to present the final answer?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShowIncreasingSubsets\").shift(UP*2.5)), run_time=0.5)\n            circles = VGroup(\n                Circle().shift(UP*0.5),\n                Circle().shift((DOWN+LEFT)*0.5),\n                Circle().shift((DOWN+RIGHT)*0.5)\n            )\n            self.play(ShowIncreasingSubsets(circles))\n            self.wait()\n            self.remove(circles)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the step-by-step process of solving a triple integral, specifically integrating the function xyz over the ranges z from 0 to 3, x from 0 to 2, and y from 0 to 1, including textual explanations before each integration step and the final solution?",
        "answer": "\\n from manim import *\n\nclass DerivativeExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = 3x^2 + 2x + 1\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Explaining the concept of derivative\n        explanation = Text(\"Let's compute the derivative of the function with respect to x.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Computing the derivative\n        derivative = MathTex(r\"f'(x) = 6x + 2\")\n        self.play(Transform(function, derivative))\n        self.wait(2)\n\n        # Showing the slope at a point\n        point_explanation = Text(\"The derivative at x=1 is the slope of the tangent line there\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, point_explanation))\n        self.wait(2)\n\n        # Calculating the derivative at x = 1\n        derivative_at_1 = MathTex(r\"f'(1) = 6(1) + 2 = 8\")\n        self.play(Write(derivative_at_1))\n        self.wait(1)\n\n        # Graphing the function and its tangent line\n        graph = self.get_graph(function)\n        tangent_line = self.get_tangent_line(1, graph, length=4, color=YELLOW)\n        self.play(Create(graph), ShowCreation(tangent_line))\n        self.wait(2)\n\n        # Concluding by showing all steps\n        self.clear()\n        self.play(Write(function), Write(derivative), Write(derivative_at_1))\n        self.play(Create(graph), ShowCreation(tangent_line))\n        self.wait(2)\n\n    def get_graph(self, function_tex):\n        # A method for creating a graph from the given function\n        function = lambda x: 3*x**2 + 2*x + 1\n        graph = FunctionGraph(function, color=WHITE, x_range=[-3,3])\n        return graph\n\n    def get_tangent_line(self, x, graph, dx=0.01, **kwargs):\n        # A method for creating a tangent line given a graph at x\n        x0 = x - dx\n        x1 = x + dx\n        y0 = graph.underlying_function(x0)\n        y1 = graph.underlying_function(x1)\n        line = Line([x0, y0, 0], [x1, y1, 0], **kwargs)\n        return line"
    },
    {
        "query": "I'd like an educational animation that explains the classic wave equation and its concepts. Start by showing the wave equation itself. Then, give a brief written explanation of what the wave equation is, followed by an explanation of the characteristics of its solutions and how they represent waveforms in time and space. Next, show a particular solution of the wave equation that represents a harmonic wave, including textual descriptions of the terms amplitude, wavenumber, and angular frequency. After that, clear the screen and introduce the concept of boundary conditions affecting the solutions of the wave equation, with visual examples showcasing different boundary conditions. The animation should be slow enough to allow the concepts to be absorbed by the viewer.",
        "answer": "\\n from manim import *\n\nclass CreateMolecules(Scene):\n    def construct(self):\n        molecule = VGroup(\n            oxygen().shift(LEFT * 2),\n            electron().next_to(oxygen(), UP),\n            metal().shift(RIGHT * 2),\n            positive().next_to(metal(), UP),\n            negative().next_to(electron(), RIGHT * 2),\n        )\n\n        self.play(Create(oxygen()))\n        self.play(Create(electron()))\n        self.play(Create(metal()))\n        self.play(Create(positive()))\n        self.play(Create(negative()))\n        self.play(FadeIn(molecule))\n        self.wait()\n\n        grid = metal_oxid(3, 3)\n        self.play(ReplacementTransform(molecule, grid))\n        self.wait()\n\n        carbon_struct = carbon_grid(3)\n        self.play(Transform(grid, carbon_struct))\n        self.wait()\n\n        self.play(grid.animate.scale(0.5).to_corner(UL))\n\n        electron_path = [LEFT, LEFT + UP, UP, RIGHT + UP, RIGHT, RIGHT + DOWN, DOWN, LEFT + DOWN]\n        self.play(*move_along_complex_path(electron(), [0, 2, 4, 6], electron_path, run_time=3, rate_func=smooth))\n\n        self.wait()"
    },
    {
        "query": "Can you create an animated math video step-by-step showing how to solve the double integral of r multiplied by e to the power of r theta, with r going from 0 to 1 and theta from 0 to pi, using polar coordinates? Include text explanations for each phase of the integration process and visualize the final answer at the end.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 4, 1],\n            y_range=[0, 2, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Labels for axes\n        labels = ax.get_axis_labels(x_label=\"x\", y_label=\"y\")\n\n        # Function graph\n        graph = ax.plot(lambda x: 0.25 * x ** 2, color=GREEN)\n        graph_label = ax.get_graph_label(graph, label='y = 0.25x^2')\n\n        # Display the graph\n        self.play(Create(ax), Write(labels), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Create area under graph\n        area = ax.get_area(graph, x_range=(0, 2), color=YELLOW, opacity=0.5)\n        area_label = Tex(\"Area under curve\").next_to(area, DOWN)\n\n        # Show area and label\n        self.play(FadeIn(area), Write(area_label))\n        self.wait(2)\n\n        # Show the integral form\n        integral = MathTex(r\"\\int_0^2 0.25x^2 \\,dx\")\n        integral.to_edge(UP)\n        self.play(Transform(area_label, integral))\n        self.wait(1)\n\n        # Calculate the area with the integral value\n        integral_value = MathTex(\"= \\\\frac{1}{3}x^3\\Big|_0^2 =\", \" \\\\frac{8}{3}\")\n        integral_value.next_to(integral, DOWN)\n\n        # Show the calculation result\n        self.play(Write(integral_value))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final area value\n        self.play(Write(integral_value[1]))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation explaining how to calculate the area under the curve of the function 4 - x^2 from x=0 to x=4, including the concept of definite integrals. It should start by displaying the integral problem, followed by a step-by-step visual demonstration of the graph of the function, shading the area under the curve, calculating the integral to find the area, and concluding with the final numerical answer. The explanation should be clear with on-screen text guiding through each step of the process.",
        "answer": "\\n from manim import *\nimport random\n\nclass PiApproximationByMonteCarlo(Scene):\n    def construct(self):\n        num_points = 1000\n        circle = Circle(radius=1)\n        square = Square(side_length=2).move_to(circle.get_center())\n        inside_circle = 0\n\n        points_inside_circle = VGroup()\n        points_outside_circle = VGroup()\n\n        pi_estimate = always_redraw(lambda: DecimalNumber((inside_circle / num_points) * 4).next_to(circle, DOWN, buff=0.5))\n\n        self.add(square, circle, pi_estimate)\n        for _ in range(num_points):\n            x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n            if x**2 + y**2 <= 1:\n                inside_circle += 1\n                points_inside_circle.add(Dot(point=(x, y, 0), color=BLUE))\n            else:\n                points_outside_circle.add(Dot(point=(x, y, 0), color=RED))\n            self.play(\n                FadeIn(points_inside_circle.copy(), scale=0.5),\n                FadeIn(points_outside_circle.copy(), scale=0.5),\n                ChangeDecimalToValue(pi_estimate, (inside_circle / num_points) * 4),\n                run_time=0.1,\n                rate_func=linear\n            )\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains how to convert an infinite geometric series into its closed form, then apply that formula to a specific example such as the sum of 1/2 to the nth power from n equals 0 to infinity? The animation should first display the general formula for an infinite geometric series, then show how to rewrite it as a closed form, and afterwards, demonstrate the process using the specific example. Finally, it should calculate the sum of the series and clearly present the final answer.",
        "answer": "\\n from manim import *\n\nclass PythagoreanTheorem(Scene):\n    def construct(self):\n        # Creating the initial right triangle\n        triangle = RightTriangle().scale(2)\n        a_label = Tex(\"a\").next_to(triangle, LEFT)\n        b_label = Tex(\"b\").next_to(triangle, DOWN)\n        c_label = Tex(\"c\").next_to(triangle.get_hypotenuse(), RIGHT, buff=0.5)\n\n        self.play(Create(triangle))\n        self.play(Write(a_label), Write(b_label), Write(c_label))\n        self.wait(1)\n\n        # Explanation\n        explanation = Tex(\"In a right triangle, the square of the hypotenuse\\\\\\\\\",\n                          \"is equal to the sum of the squares of the other two sides.\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Creating squares on each side\n        a_square = Square().scale(0.5).next_to(triangle, LEFT)\n        b_square = Square().scale(0.5).next_to(triangle, DOWN)\n        c_square = Square().scale(0.7).align_to(triangle.get_hypotenuse(), RIGHT)\n\n        self.play(Create(a_square), Create(b_square), Create(c_square))\n        self.wait(1)\n\n        # Final proof animation\n        proof_text = Tex(\"a^2 + b^2 = c^2\").to_edge(DOWN)\n        self.play(Write(proof_text))\n        self.wait(2)"
    },
    {
        "query": "I would like an educational animation that shows how to calculate the area under the curve of the function f(x) = x^2 between the points x=2 and x=3. The animation should start by showing the integral of x^2 from 2 to 3 and then proceed by illustrating the steps of the integration process. After finding the indefinite integral, it should demonstrate how to evaluate it at the boundaries 2 and 3. Once the evaluation is done, I want the animation to display the final numerical answer. To aid understanding, please include textual explanations above the mathematical steps that guide the viewer through setting up the integral, integrating, evaluating the boundaries, and concluding the result. The explanations should appear sequentially in simple language suitable for someone who is learning integration for the first time.",
        "answer": "\\n from manim import *\n\nclass HarmonicSeries(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n}\")\n        self.play(Write(series))\n        self.wait(1)\n        \n        # Verbal explanation\n        explanation_text = Text(\"The harmonic series diverges\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation_text))\n        self.wait(2)\n        \n        # Illustrating partial sums\n        partial_sum = MathTex(r\"s_n = \\sum_{n=1}^{N} \\frac{1}{n}\")\n        self.play(ReplacementTransform(series.copy(), partial_sum))\n        self.wait(1)\n        \n        # Show divergence\n        divergence = MathTex(r\"\\lim_{N \\to \\infty} s_N =\", r\"\\infty\")\n        self.play(Transform(partial_sum, divergence))\n        self.wait(2)\n        \n        # Discussion of the comparison test\n        explanation_test = Text(\"By the comparison test\", font_size=24).next_to(explanation_text, DOWN)\n        self.play(Write(explanation_test))\n        self.wait(2)\n        \n        # Using comparison test\n        comparison = MathTex(r\"\\frac{1}{n} > \\frac{1}{n+1}\")\n        self.play(Write(comparison))\n        self.wait(2)\n        \n        # Clear and conclude\n        self.clear()\n        self.play(Write(Text(\"Thus, the harmonic series does not converge.\", font_size=24)))\n        self.wait(3)"
    },
    {
        "query": "I would like an educational math animation that shows visually how to find the area under the curve of the function y = x^2, specifically between the x-values of 1 and 3. Start the animation by displaying the equation of the curve, then present the goal of calculating the definite integral of this function from 1 to 3 to find the area underneath. I want the animation to then show the integral symbol with the limits of integration, followed by the steps of integration, including evaluating the integrated function at the bounds. Finally, display the result of the area calculation and then clear all the elements from the screen.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the area problem\n        area_problem = MathTex(r\"\\text{Area under } f(x) = e^{-x} \\text{ from } x = 0 \\text{ to } x = 1\")\n        self.play(Write(area_problem))\n        self.wait(1)\n\n        # Explaining the definite integral representation\n        explanation1 = Text(\"Represent as a definite integral\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Definite integral setup\n        integral_setup = MathTex(r\"\\int_0^1 e^{-x} \\,dx\")\n        self.play(ReplacementTransform(area_problem, integral_setup))\n        self.wait(1)\n\n        # Showing antiderivative\n        antiderivative_step = MathTex(r\"= [-e^{-x}]_0^1\")\n        self.play(ReplacementTransform(integral_setup, antiderivative_step))\n        self.wait(1)\n\n        # Explaining the evaluation of the antiderivative at the bounds\n        explanation2 = Text(\"Evaluate from 0 to 1\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution calculation\n        final_solution = MathTex(r\"= -(e^{-1} - e^{0}) = 1 - \\frac{1}{e}\")\n        self.play(ReplacementTransform(antiderivative_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that introduces the wave equation from physics, explains its significance as a second-order linear partial differential equation (PDE), illustrates the general solution format, describes the meaning of the constant c in the equation, and concludes with the implications of initial conditions on the solution of the wave equation?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Define the area under the curve y=x^2 within the interval [0,3]\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 3], color=YELLOW)\n        area = area = Integral(curve, (x, 0, 3), fill_opacity=0.3, fill_color=BLUE)\n\n        # Display the curve\n        curve_label = MathTex(\"y = x^2\").next_to(curve, UP)\n        self.play(Create(curve), Write(curve_label))\n        self.wait(1)\n\n        # Show the area under the curve\n        self.play(Create(area))\n        self.wait(1)\n\n        # Problem statement\n        problem = MathTex(r\"\\int_0^3 x^2 \\,dx\")\n        problem.to_edge(UP + LEFT)   # Positioning the problem statement\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of integration\n        explanation1 = Text(\"The area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration result before evaluation\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^3\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Evaluate at the bounds\n        explanation2 = Text(\"Evaluate at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_solution = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(0)^3\", r\"= 9\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(2)\n\n        # Conclusion\n        self.clear()\n        conclusion = Text(\"The definite integral represents the area under the curve.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animated video that guides me through the steps of solving the definite integral of the function x squared from 0 to 3, including the calculation of the area under the curve and evaluating the integral to find the exact numerical answer?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2} x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation = Text(\"Evaluate the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Performing the integration step (indefinite integral)\n        indefinite = MathTex(r\"\\int x^2 \\,dx = \\frac{x^{3}}{3} + C\")\n        self.play(ReplacementTransform(problem.copy(), indefinite))\n        self.wait(2)\n\n        # Applying the bounds of the integral\n        bounds = MathTex(r\"\\left. \\frac{x^{3}}{3} \\right|_{0}^{2}\")\n        self.play(ReplacementTransform(indefinite, bounds))\n        self.wait(2)\n\n        # Evaluating at bounds\n        evaluation = MathTex(r\"= \\frac{2^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(Write(evaluation))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(evaluation, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the evaluated definite integral\n        conclusion = Text(\"The evaluated integral is \\\\( \\\\frac{8}{3} \\\\)\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visually demonstrates how to calculate the area under the curve of the function f(x) = 3 - x^2 from x = -1 to x = 2? First, show the function itself, then display the integral of the function within the given bounds. Next, plot the function's graph and highlight the area under the curve. After that, show the antiderivative of the function and demonstrate how to evaluate the definite integral by substituting the upper and lower bounds. Finally, display the numerical result of the integral's evaluation, and conclude by showing only the result on the screen.",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        colors = [\n            LIGHT_BLUE_COLOR, \n            LIGHT_RED_COLOR, \n            LIGHT_ORANGE_COLOR, \n            AQUA_GREEN_COLOR, \n            LIGHT_PURPLE_COLOR\n        ]\n        sequence = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n        directions = [DOWN, RIGHT, UP, LEFT]\n        corners = [UR, UL, DL, DR]\n        angles = [PI, 3 * PI / 2, 2 * PI, PI / 2]\n        animations = []\n        squares = Group(\n            FibonacciSquare(sequence[0], colors[2]),\n            FibonacciSquare(sequence[1], colors[3]),\n            FibonacciSquare(sequence[2], colors[1]),\n            FibonacciSquare(sequence[3], colors[0]),\n            FibonacciSquare(sequence[4], colors[4]),\n            FibonacciSquare(sequence[5], colors[3]),\n            FibonacciSquare(sequence[6], colors[2]),\n            FibonacciSquare(sequence[7], colors[1]),\n            FibonacciSquare(sequence[8], colors[0])\n        )\n        squares.shift(1.5 * RIGHT + 2.5 * UP)\n\n        for i in range(8):\n            squares[i + 1].next_to(squares[i], directions[(i + 1) % 4], 0, directions[i % 4])\n\n        for square in squares:\n            animations.append(Create(square[0]))\n            animations.append(Write(square[1]))\n\n        self.play(LaggedStart(*animations, lag_ratio=0.2))\n\n        for i in range(9):\n            if i != 0: \n                self.remove(dot)\n\n            arc_angle = ValueTracker(0.0)\n            arc = always_redraw(\n                lambda: Arc(\n                    radius=sequence[i] / 5, \n                    arc_center=squares[i].get_corner(corners[i % 4]), \n                    color=TEXT_COLOR, \n                    start_angle=angles[i % 4], \n                    angle=arc_angle.get_value()\n                )\n            )\n            dot = always_redraw(\n                lambda: Dot(radius=0.05, color=TEXT_COLOR)\n                    .move_to(arc.get_end())\n            )\n\n            self.add(arc, dot)\n            self.play(\n                arc_angle.animate.set_value(PI / 2), \n                rate_func=linear, \n                run_time=max(0.3, sequence[i] / 34)\n            )\n            arc.clear_updaters()\n        \n        self.wait(0.5)\n        self.play(*[FadeOut(mobject) for mobject in self.mobjects[:19]], FadeOut(dot))\n        self.wait(1.5)\n        self.play(FadeOut(Group(*self.mobjects)))"
    },
    {
        "query": "Can you create an animated video that visually explains how to calculate the area under the curve of the function f(x) = 3x^2 - 2x + 1 from x=1 to x=3 by performing integration, including writing out the function, transforming it into an integral, showing the step-by-step integration process, simplifying the result, and evaluating the final answer?",
        "answer": "\\n from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass TenDivisors(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(10, 1)\n        by_one.scale(1.3)\n        by_two = Division(10, 2)\n        by_two.scale(1.3)\n        by_three = Division(10, 3)\n        by_three.scale(1.3)\n        by_four = Division(10, 4)\n        by_four.scale(1.3)\n        by_five = Division(10, 5)\n        by_five.scale(1.3)\n        by_six = Division(10, 6)\n        by_six.scale(1.3)\n        by_seven = Division(10, 7)\n        by_seven.scale(1.3)\n        by_eight = Division(10, 8)\n        by_eight.scale(1.3)\n        by_nine = Division(10, 9)\n        by_nine.scale(1.3)\n        by_ten = Division(10, 10)\n        by_ten.scale(1.3)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two,\n                by_three\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_four,\n                by_five,\n                by_six\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_seven,\n                by_eight,\n                by_nine\n            ).arrange(RIGHT, buff=0.5),\n            by_ten\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_two, color=LIGHT_RED_COLOR)\n        square3 = SurroundingRectangle(by_five, color=LIGHT_RED_COLOR)\n        square4 = SurroundingRectangle(by_ten, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            FadeIn(by_six),\n            FadeIn(by_seven),\n            FadeIn(by_eight),\n            FadeIn(by_nine),\n            FadeIn(by_ten),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            Create(square3),\n            Create(square4),\n            lag_ratio=0.3,\n            run_time=2.5\n        ))\n        self.wait(2)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(square3), \n            FadeOut(square4), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)"
    },
    {
        "query": "Can you create an educational video animation that starts by writing the mathematical function for e to the power of x at the top of the screen, followed by showing the general form of its nth Taylor polynomial? After that, can you visually display the function's graph with its label and then present an explanation for calculating the 4th Taylor polynomial, also modifying the previously shown general polynomial to the specific 4th polynomial? Next, can you show the graph of this 4th Taylor polynomial in blue with its label, and conclude by stating that the blue curve represents the 4th Taylor Polynomial of e to the x? Finally, end the video by fading out all elements from the screen.",
        "answer": "\\n from manim import Scene, Create\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nclass FeedForwardNetworkScene(Scene):\n    def construct(self):\n        # Define the neural network structure\n        nn = NeuralNetwork([\n                FeedForwardLayer(4),\n                FeedForwardLayer(6),\n                FeedForwardLayer(4),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.5,\n        )\n\n        # Center the neural network\n        nn.move_to(ORIGIN)\n\n        # Create the neural network on the scene\n        self.play(Create(nn))\n\n        # Make a forward pass animation through the layers\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)"
    },
    {
        "query": "Can you create an educational animation that explains the concept of calculating a surface integral of a vector field over a surface S, including the steps of parametrizing the surface, finding the normal vector, and rewriting the integral with the parametrization?",
        "answer": "\\n from manim import *\n\nclass SineWaveApproximation(Scene):\n    def construct(self):\n        axes = Axes(x_range=[0, 10, 1], y_range=[-2, 2, 1])\n        sine_curve = axes.plot(lambda x: np.sin(x), color=BLUE)\n        self.play(Create(axes), Create(sine_curve))\n        self.wait(1)\n\n        text = MathTex(r\"\\text{Sine wave approximation with polynomials}\")\n        text.to_edge(UP)\n        self.play(Write(text))\n        self.wait(1)\n\n        polynomial_curve = axes.plot(lambda x: x - (x**3)/6, color=GREEN)\n        self.play(Create(polynomial_curve))\n        self.wait(1)\n\n        dot_at_pi = Dot(color=RED).move_to(axes.c2p(np.pi, np.sin(np.pi)))\n        self.play(FadeIn(dot_at_pi))\n        self.wait(1)\n\n        line_approx = DashedLine(start=axes.c2p(np.pi, 0), end=axes.c2p(np.pi, np.sin(np.pi)), color=YELLOW)\n        self.play(Create(line_approx))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animated video that explains the process of solving the integral of sin(x) cos(x) with respect to x using the substitution method? In the video, first display the integral, then add text about using the substitution method at the top, show the chosen substitution with 'u' for sin(x) and 'du' for cos(x) dx, rewrite the integral in terms of 'u', solve it, back-substitute to get the answer in terms of x, and finally clear the screen and display only the final solved integral.",
        "answer": "\\n class AllUpdaterTypes(Scene):\n    def construct(self):\n        red_dot = Dot(color=RED).shift(LEFT)\n        pointer = Arrow(ORIGIN, RIGHT).next_to(red_dot, LEFT)\n        pointer.add_updater( # place arrow left of dot\n            lambda mob: mob.next_to(red_dot, LEFT)\n        )\n        \n        def shifter(mob, dt): # make dot move 2 units RIGHT/sec\n            mob.shift(2*dt*RIGHT)\n        red_dot.add_updater(shifter)\n        \n        def scene_scaler(dt): # scale mobjects depending on distance to origin\n            for mob in self.mobjects:\n                mob.set(width=2/(1 + np.linalg.norm(mob.get_center())))\n        self.add_updater(scene_scaler)\n        \n        self.add(red_dot, pointer)\n        # scene has to update initially to fix first frame:\n        # first mobject updaters are called, then scene updaters\n        self.update_self(0)\n        self.wait(5)"
    },
    {
        "query": "I would like an educational animation that visualizes the concept of finding the area under a curve using integration. Can you create a video that starts by displaying the function f(x) = x^2, then shows the corresponding integral from 0 to 2, followed by drawing the function\u2019s curve and shading the area under the curve between 0 and 2? After that, can you show the steps of calculating the integral, displaying the integration result, and concluding with the final numerical value of the area? Also, make sure to clear the screen and recap the final answer at the end of the animation.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Set up the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Show the integral bounds\n        bounds = MathTex(r\"x=0 \\quad \\text{and} \\quad x=2\")\n        self.play(Write(bounds))\n        self.wait(2)\n        \n        # Explain the fundamental theorem of calculus\n        explanation1 = Text(\"Using the Fundamental Theorem of Calculus\", font_size=24)\n        explanation1.to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Integrate the function\n        integral = MathTex(r\"\\int x^3 \\,dx = \\frac{x^{4}}{4}\")\n        self.play(Write(integral))\n        self.wait(2)\n        \n        # Apply the bounds\n        solution_step = MathTex(r\"\\left. \\frac{x^{4}}{4} \\right|_0^2\")\n        self.play(ReplacementTransform(integral.copy(), solution_step))\n        self.wait(1)\n        \n        # Explanation for evaluating the bounds\n        explanation2 = Text(\"Evaluate at bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Final result\n        final_result = MathTex(r\"=\\frac{2^{4}}{4} - \\frac{0^{4}}{4}\")\n        self.play(ReplacementTransform(solution_step, final_result))\n        self.wait(1)\n        \n        # Simplify the final result\n        simplified_result = MathTex(r\"=4\")\n        self.play(ReplacementTransform(final_result, simplified_result))\n        self.wait(1)\n        \n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        \n        # Conclude with the simplified solution\n        final_solution = MathTex(r\"\\int_0^2 x^3 \\,dx = 4\")\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create a short animation video using 2D shapes, where a circle transforms into a square. The video should start with a circle appearing on screen, then after a moment, the circle should seamlessly morph into a square. Once the square appears, I want it to change to a blue color with some transparency. After that, can the square rotate 45 degrees? Finally, clear everything off the screen and display the phrase \"Transformation complete!\" in the center. Can you make this sequence of animations for me?",
        "answer": "\\n from manim import *\n\nclass NeuralNetworkArchitectureScene(Scene):\n    def construct(self):\n        # Define the size and style of the neural network layers\n        layer_sizes = [4, 8, 6, 8, 4]\n        layer_style = {\"stroke_color\": BLUE, \"fill_color\": GREEN, \"fill_opacity\": 0.5}\n        \n        # Create the neural network layers\n        layers = VGroup(*[\n            Rectangle(height=0.2, width=size, **layer_style) for size in layer_sizes\n        ]).arrange(DOWN, buff=0.5)\n\n        # Update the positions to be centered at ORIGIN\n        layers.move_to(ORIGIN)\n\n        # Create the neural network edges (connections)\n        edges = VGroup()\n        for i in range(len(layer_sizes) - 1):\n            edges.add(*[\n                Line(layers[i][j].get_bottom(), layers[i + 1][k].get_top())\n                for j in range(layer_sizes[i])\n                for k in range(layer_sizes[i + 1])\n            ])\n\n        # Set the edge style\n        edges.set_stroke(WHITE, 0.5)\n\n        # Create a neural network group\n        neural_network = VGroup(layers, edges)\n\n        # Animate the construction of the neural network\n        self.play(ShowCreation(edges), run_time=2)\n        self.play(FadeIn(layers, shift=DOWN), run_time=2)\n\n        # Display the neural network\n        self.wait(1)\n        self.play(FadeOut(neural_network), run_time=2)"
    },
    {
        "query": "I would like an animated video that explains how to find the sum of a geometric series. Start by displaying the general formula for the sum of the first n terms of a geometric series. Then, introduce the well-known geometric sum formula and show how it applies to the series by transforming the initial formula into the geometric sum formula. Next, explain what happens to the sum when the absolute value of the common ratio is less than one and we let the number of terms grow indefinitely, meaning as n approaches infinity. Show this transition on screen. Finally, evaluate the infinite sum to obtain the simplified formula and clear all the previous work to end the video with just the final evaluated sum visible onscreen.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r^2 \\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[ \\frac{1}{3}r^3 \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate the inner integral bounds\n        evaluated_inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\frac{1}{3} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, evaluated_inner_integral))\n        self.wait(1)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\left[ \\frac{1}{3} \\theta \\right]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(evaluated_inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3} \\cdot 2\\pi\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n\n        # Simplify the final solution\n        simplified_solution = MathTex(r\"= \\frac{2\\pi}{3}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create a step-by-step animated math video explanation showing how to solve the integral of x times e to the power of x using integration by parts, including the problem statement, the integration by parts formula, the process of choosing u and dv, computing du and v, applying the formula, and finally presenting the solution with a constant of integration?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}yz]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Lastly, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}z^2]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that illustrates how to find the area under the curve of the function f(x) = 3 - x^3/3 from x=0 to x=2, including the steps to calculate the definite integral of that function, as well as the final numeric result of the integral, with the entire process visually demonstrated step by step?",
        "answer": "\\n from manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Displaying the motion equation\n        motion_eq = MathTex(r\"m\\frac{d^2x}{dt^2} = -kx\")\n        self.play(Write(motion_eq))\n        self.wait(1)\n\n        # Explanation for the differential equation\n        explanation1 = Text(\"Differential equation for SHM\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Dividing both sides by m\n        reduced_eq = MathTex(r\"\\frac{d^2x}{dt^2} = -\\frac{k}{m}x\")\n        self.play(ReplacementTransform(motion_eq, reduced_eq))\n        self.wait(1)\n\n        # Explanation for angular frequency\n        explanation2 = Text(\"Introduce angular frequency\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Angular frequency equation\n        omega_eq = MathTex(r\"\\omega^2 = \\frac{k}{m}\")\n        self.play(Write(omega_eq))\n        self.wait(1)\n\n        # Final form equation of motion\n        final_eq = MathTex(r\"\\frac{d^2x}{dt^2} = -\\omega^2 x\")\n        self.play(ReplacementTransform(reduced_eq, final_eq))\n        self.wait(1)\n\n        # Explanation for solution\n        explanation3 = Text(\"Solution for x(t)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Solution of the equation\n        solution = MathTex(r\"x(t) = A \\cos(\\omega t + \\phi)\")\n        self.play(Write(solution))\n        self.wait(1)\n\n        # Concluding text\n        conclusion = Text(\"Simple Harmonic Motion Equation\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Fade everything out\n        self.play(FadeOut(solution), FadeOut(conclusion), FadeOut(explanation1))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational video animation that initially shows the graph of the function y = 0.25x^2 on a set of axes ranging from 0 to 4 on the x-axis and from 0 to 2 on the y-axis, with the axes in blue and the curve in yellow? After the graph is displayed, can you add a text that introduces the problem \"Find the area under y = 0.25x^2 from x=0 to x=4\", and then visually demonstrate the area under the curve by shading it in green with a 50% opacity from x=0 to x=4? Following the visual, can you animate the process of setting up the integral to solve for the area under the curve, showing the integral formula, the antiderivative, the substitution of the limits of integration, and simplify the calculations to get a final numerical answer for the area? To conclude, can you clear the animation and display a closing text that states \"Area under the curve is 16/3 square units\"?",
        "answer": "\\n from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for separation of variables\n        explanation1 = Text(\"Separate the variables\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Separation of variables step\n        sep_eq = MathTex(r\"\\frac{1}{y} dy = 3 dx\")\n        self.play(ReplacementTransform(problem.copy(), sep_eq))\n        self.wait(1)\n\n        # Explanation for integrating\n        explanation2 = Text(\"Integrate both sides\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integrating both sides\n        integration = MathTex(r\"\\ln|y| = 3x + C\")\n        self.play(ReplacementTransform(sep_eq, integration))\n        self.wait(1)\n\n        # Explanation for solving for y\n        explanation3 = Text(\"Solve for y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Solve for y to find the general solution\n        general_solution = MathTex(r\"y = Ce^{3x}\")\n        self.play(ReplacementTransform(integration, general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation4 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that first displays the classic wave equation for a scalar field u, explains what the equation is, mentions that the constant c represents the wave speed, transitions to showing a specific harmonic wave solution of this equation, and then removes everything to focus on the specific solution? Additionally, I'd like the explanations to be written in text at the top of the screen and the equations to be prominently displayed in the center.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series\n        fourier_series = MathTex(r\"f(x) \\approx a_0 + \\sum_{n=1}^{\\infty} \\left( a_n \\cos(nx) + b_n \\sin(nx) \\right)\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Explanation for Fourier series\n        explanation1 = Text(\"This is a Fourier series expansion for a periodic function.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1, shift=UP))\n        self.wait(2)\n\n        # Coefficients explanation\n        explanation2 = Text(\"The coefficients a_n and b_n are calculated from the function.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the coefficient formulas\n        coefficients = MathTex(r\"a_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\cos(nx) \\, dx\", r\"\\\\\", \n                               r\"b_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\sin(nx) \\, dx\")\n        self.play(ReplacementTransform(fourier_series, coefficients))\n        self.wait(1)\n\n        # Explanation for harmonics\n        explanation3 = Text(\"Each cosine and sine term corresponds to a harmonic of the base frequency.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation2, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(coefficients), FadeOut(explanation3))\n        self.wait(1)"
    },
    {
        "query": "Could you please create an educational animation that visually explains how to calculate the area under the curve of the function f(x) = x^2 from x=1 to x=3 by showing the integral on screen, performing the integration step by step, and displaying the final answer, along with explanatory text at each step of the process?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function_text = MathTex(r\"f(x) = x^2\", font_size=36)\n        self.play(Write(function_text))\n        self.wait(1)\n\n        # Explanation for Fourier series decomposition\n        explanation1 = Text(\"Decompose using Fourier series:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Fourier series formula\n        fourier_series = MathTex(r\"f(x) \\sim a_0 + \\sum_{n=1}^\\infty \\left( a_n\\cos(2\\pi nx) + b_n\\sin(2\\pi nx) \\right)\")\n        self.play(Transform(function_text, fourier_series))\n        self.wait(3)\n\n        # Explanation for calculating coefficients\n        explanation2 = Text(\"Calculate coefficients a_n and b_n\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Coefficients for a specific n\n        coefficients = MathTex(r\"a_n = ???\", r\"\\quad\", r\"b_n = ???\", font_size=36)\n        self.play(Write(coefficients))\n        self.wait(3)\n\n        # First few terms of the series\n        first_terms = MathTex(r\"f(x) \\sim a_0 + a_1\\cos(2\\pi x) + b_1\\sin(2\\pi x) + \\ldots\", font_size=36)\n        self.play(ReplacementTransform(fourier_series, first_terms))\n        self.wait(2)\n\n        # Explanation for approximation\n        explanation3 = Text(\"This is an approximation for the Fourier series\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear scene and display a graph\n        self.clear()\n        self.wait(1)\n\n        # Graph of the function\n        graph_axes = Axes(x_range=[-3, 3], y_range=[-1, 9])\n        graph = graph_axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = graph_axes.get_graph_label(graph, label='x^2')\n\n        # Display the graph\n        self.play(Create(graph_axes), Create(graph), Write(graph_label))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that illustrates the concept of the area under a curve as represented in calculus. It should show a simple parabolic function on a graph, and I want to visualize the area between the curve and the x-axis, from a starting point 'a' to an ending point 'b'. Along with the graphical representation, I want to include the integral symbol with the limits 'a' and 'b' as seen in integral calculus. The animation should start by displaying the integral formula at the top of the frame, followed by drawing a blue shaded rectangle that represents the area under the curve, even though the curve itself is not exactly matching the rectangle's shape. Once the area is shaded, I would like the actual curve to be drawn on top. Next to the shaded area, there should be a text annotation that says \"Shaded Area represents A\". I would like this text to be updated later in the animation to \"Area under the curve from a to b\". At the bottom of the rectangle representing the area, I need a couple of braces that label the starting point 'a' and the ending point 'b'. After some time, the animation should clear everything from the screen and conclude with the text \"Visualization Complete!\" appearing in the center. This should be designed for someone with no prior knowledge of ManimCE or animation coding.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FadeTransform\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(BLUE)\n            star = Star(fill_opacity=1).set_fill(YELLOW)\n            self.play(FadeTransform(square,star))\n            self.remove(square,star)"
    },
    {
        "query": "I would like to create an animated video that explains how to solve a triple integral step by step. The triple integral I want to solve is the integral from 0 to 1 in all three dimensions, of the product x*y*z with respect to z, y, and then x. Can you show the problem statement first, then write an explanation text of each step as we solve the integral one variable at a time, starting with z, then y, and finally x? After each explanation, can you show the integration process and the intermediate results until we reach the final solution? And after completing the calculations, can we clear the screen and then show the final solution once more?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_dim_size\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().scale(2)\n            square = Square()\n            self.add(circle,square)\n            self.play(square.animate.match_dim_size(circle, 0))\n            self.remove(square,circle)"
    },
    {
        "query": "Can you create an animated video using ManimCE that explains how to solve a first-order ordinary differential equation (ODE) using an integrating factor? I would like the video to include: \n\n1. The initial display of the ODE: dy/dx + 3y = x.\n2. A description and display of the integrating factor: mu(x) = e^(3x).\n3. The equation being multiplied by the integrating factor resulting in: e^(3x)*dy/dx + 3e^(3x)*y = xe^(3x).\n4. An announcement that we're looking at the general solution before integration, without actually displaying the integration step.\n5. The general solution after the integration of both sides: y(x) = (e^(-3x)/3)\u222bxe^(3x)dx + Ce^(-3x).\n6. The final general solution presented neatly: y = (1/3)x - (1/9) + Ce^(-3x).\n7. Then conclude by stating that we have solved the ODE and display the final solution again after clearing all previous writing off the screen. \n\nPlease ensure the transitions are smooth and allow for moments where the viewer can take in the information before moving on to the next step.",
        "answer": "\\n from manim import *\n\nclass DiceRollSimulation(Scene):\n    def construct(self):\n        die_face = 0\n        roll_counts = [0] * 6  # List to hold counts of each face\n        roll_count_text = [\n            always_redraw(lambda i=i: Text(f\"{roll_counts[i]}\").next_to(die_face_mob, DOWN).shift(RIGHT * (i - 2.5) * 0.6))\n            for i in range(6)\n        ]\n\n        die_face_mob = Square(side_length=1)\n        die_face_label = always_redraw(lambda: Text(str(die_face)).move_to(die_face_mob.get_center()))\n        die_face_group = VGroup(die_face_mob, die_face_label)\n\n        self.add(die_face_group)\n        self.add(*roll_count_text)\n\n        for i in range(6):\n            self.play(FadeIn(roll_count_text[i]))\n\n        for _ in range(100):\n            die_face = random.randint(1, 6)\n            roll_counts[die_face - 1] += 1\n            self.play(\n                Transform(die_face_label, Text(str(die_face)).move_to(die_face_mob.get_center())),\n                run_time=0.1\n            )\n\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that illustrates the principles of circular motion and tension involved, starting with the general equation of motion under gravity, explaining the relevant terms, then transforming it into a circular motion specific equation and finally discussing tension in that context, all while providing visual aids and textual explanations on screen?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[0, 10, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        curve = axes.plot(lambda x: 0.1 * x**2, color=GREEN)\n        area = axes.get_area(curve, x_range=(0, 4), color=YELLOW, opacity=0.5)\n\n        problem = MathTex(r\"A=\\int_{0}^{4} 0.1x^2 \\,dx\", color=WHITE)\n        problem.to_corner(UL)\n\n        self.play(Write(problem))\n        self.wait(1)\n\n        self.play(Create(axes), Create(curve))\n        self.wait(1)\n\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(1)\n\n        solution = MathTex(r\"A=\\dfrac{1}{3}0.1\\cdot 4^3\", color=WHITE)\n        solution.next_to(problem, DOWN)\n\n        self.play(ReplacementTransform(area, solution))\n        self.wait(1)\n\n        self.play(FadeOut(axes), FadeOut(curve), FadeOut(solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated educational video that visually demonstrates the graph of the cosine function and its derivative and antiderivative. The animation should have the following features:\n\n1. Start by showcasing the cosine graph with proper axes labeled, ranging from -4 to 4 on the x-axis and -2 to 2 on the y-axis. The axes should be in blue color.\n\n2. Label the cosine graph with the mathematical notation '\\cos(x)'. The actual graph should be in white color.\n\n3. After displaying the cosine graph for a short time, introduce its derivative. The derivative graph should be in green color and labeled accordingly.\n\n4. Next, I want to show the antiderivative of the cosine function. Transform the original cosine graph into the antiderivative, display it in pink color, and update the label.\n\n5. Once the graphs have been shown, clear the screen and conclude the video with a textual message saying \"This is the graph of cosine and its derivatives\" on the screen, ensuring that the text is easily readable.\n\n6. The video should allow for short pauses so viewers can comprehend each section before moving on to the next.\n\nPlease create this animation in a way that those without knowledge of advanced mathematics or coding can understand and appreciate the relationships between the cosine function and its derivative and antiderivative.",
        "answer": "\\n class BasicScene(ThreeDScene):\n\n    def construct(self):\n        # Your code goes here\n        text = Text(\"Your first scene!\")\n        self.add(text)"
    },
    {
        "query": "Could you create an educational animation that visually demonstrates how to find the area under the curve of the function y = x^2 from x = 0 to x = 1? I'd like the animation to include the following elements: \n\n1. Begin by displaying the integral expression for the area we're looking for.\n2. Add some text that explains we are going to use the power rule to find the antiderivative of x^2.\n3. Transform the integral expression to show the antiderivative, which is x^3/3, and denote the evaluation from 0 to 1.\n4. Replace the explanation text with a new one that instructs evaluating the antiderivative at the boundaries of the integration interval.\n5. Show the calculation of the final value of the integral by evaluating the antiderivative at the upper and lower limits and find the difference.\n6. Once we have the numerical result, transition to a graphical representation, with an x-y axis system, plotting the function y = x^2.\n7. Shade the area under the curve between x = 0 and x = 1, and label the function.\n8. Finally, clear the graph and just show the final numerical answer for the area under the curve on its own.\n\nCould you make the transitions smoothly and include brief pauses so the concepts can be absorbed by the viewers?",
        "answer": "\\n from manim import *\n\n\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef carbon_grid(rows: int) -> Mobject:\n    list = []\n    for i in range(rows):\n        list.append(carbon_layer().set_y(i * 1.5))\n    return VGroup(*list).set_x(0).set_y(0)\n\n\ndef carbon(small: int = False) -> Mobject:\n    return circle_with_text(\n        0.285 if small == 0 else (0.225 if small == 1 else 0.25),\n        \"C\",\n        GRAY_B,\n        30 if small == 0 else (24 if small == 1 else 27),\n        WHITE,\n        1,\n    ).set_z_index(5 if small == 1 else 10)\n\n\ndef carbon_layer() -> Mobject:\n    list = []\n    positions = [\n        [-1.2, 0, 0],\n        [-0.45, 0.4, 0],\n        [0.45, 0.4, 0],\n        [1.2, 0, 0],\n        [0.55, -0.3, 0],\n        [-0.55, -0.3, 0],\n    ]\n    small = [2, 1, 1, 2, 0, 0]\n    for i in range(len(positions)):\n        list.append(Line(positions[i], positions[i - 1], color=GREY_B).set_z_index(4))\n        list.append(carbon(small[i]).set_x(positions[i][0]).set_y(positions[i][1]))\n    list.append(Polygon(*positions, color=WHITE).set_fill(WHITE, 0.075).set_z_index(-1))\n    return VGroup(*list)"
    },
    {
        "query": "I would like to create an educational animation that visually explains how to solve the double integral of r dr d\u03b8 over a polar coordinate system, where the limits for r are from 0 to 1 and for \u03b8 are from 0 to \u03c0. The animation should display the initial problem, walk me through the solution step by step\u2014first integrating with respect to r, then with respect to \u03b8\u2014and finally show the numerical result of \u03c0/2, demonstrating that the integral represents the area inside a semicircle of radius 1. Additionally, include supportive text that guides me through the integration process.",
        "answer": "\\n class Disperse(Animation):\n    def __init__(self, mobject, dot_radius=0.05, dot_number=100, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.dot_radius = dot_radius\n        self.dot_number = dot_number\n    \n    def begin(self):\n        dots = VGroup(\n            *[Dot(radius=self.dot_radius).move_to(self.mobject.point_from_proportion(p))\n              for p in np.linspace(0, 1, self.dot_number)]\n        )\n        for dot in dots:\n            dot.initial_position = dot.get_center()\n            dot.shift_vector = 2*(dot.get_center() - self.mobject.get_center())\n        dots.set_opacity(0)\n        self.mobject.add(dots)\n        self.dots = dots\n        super().begin()\n        \n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        scene.remove(self.dots)\n\n    def interpolate_mobject(self, alpha):\n        alpha = self.rate_func(alpha)  # manually apply rate function\n        if alpha <= 0.5:\n            self.mobject.set_opacity(1 - 2*alpha, family=False)\n            self.dots.set_opacity(2*alpha)\n        else:\n            self.mobject.set_opacity(0)\n            self.dots.set_opacity(2*(1 - alpha))\n            for dot in self.dots:\n                dot.move_to(dot.initial_position + 2*(alpha-0.5)*dot.shift_vector)\n            \n            \n\nclass CustomAnimationExample(Scene):\n    def construct(self):\n        st = Star(color=YELLOW, fill_opacity=1).scale(3)\n        self.add(st)\n        self.wait()\n        self.play(Disperse(st, dot_number=200, run_time=4))"
    },
    {
        "query": "I would like an educational animation that visually explains the concept of a damped harmonic oscillator in physics. Show the mathematical equation that represents this system and then provide a step-by-step guide among the following lines:\n\n1. Start with the second-order ordinary differential equation (ODE) of a damped harmonic oscillator. Display the equation prominently on the screen.\n2. Add a brief explanation immediately below the ODE that this equation represents a damped harmonic oscillator. Leave this on the screen for a couple of seconds for viewers to read.\n3. Then, transition to explaining that the second-order ODE can be converted into a system of first-order ODEs. Replace the original explanation text with this new piece of information.\n4. Transform the displayed second-order ODE into the corresponding system of first-order equations. Keep the transition smooth and easy to follow.\n5. Introduce the initial conditions for the system just below the first-order equations. Shift the focus from the first-order equations slightly to accommodate the initial conditions.\n6. After displaying the initial conditions, present the concept of the damping ratio. Display its formula without the explanation text but keep the system of equations on screen.\n7. Follow that by showing what the solution to the system looks like for an under-damped oscillator. Before presenting the solution, indicate with a text that the upcoming expression is the solution for an under-damped system.\n8. Fade in the actual mathematical solution to the under-damped harmonic oscillator scenario.\n9. At the end, clean up the screen of all previous text and equations, and then conclude by only displaying the general solution once more for a lasting impression.\n\nThe animation should be clear, educational, and engaging, with a smooth progression from one concept to the other, allowing learners to follow the logical flow of the topic.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}\\theta]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        final_value = MathTex(r\"= \\pi\")\n        self.play(Write(final_value))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains the solution to the heat equation using mathematics and on-screen text descriptions? I want the video to start by displaying the partial differential equation used for modeling the distribution of heat in a given region over time. Then, add some text to explain that this is the heat equation. Follow this up with a detailed explanation of what a steady-state solution is and transform the original equation to represent the steady-state condition where the time derivative is zero. Next, I would like to see the general solution for the steady-state heat equation displayed on the screen. Afterwards, include a comment about how boundary conditions can determine the specific values of the constants in the solution. Finally, conclude the animation with a statement that solving the heat equation requires considering the specific scenario and constraints of the problem. Can all of this be visually clear, paced with time for the viewer to understand each part, and presented in an organized way?",
        "answer": "\\n from manim import *\n\nclass DampedOscillator(Scene):\n    def construct(self):\n        # Introduce the differential equation\n        ode = MathTex(r\"y'' + 2\\gamma y' + \\omega^2 y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Add an explanation for the type of equation\n        explanation1 = Text(\"Damped harmonic oscillator equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the characteristic equation\n        char_eq = MathTex(r\"r^2 + 2\\gamma r + \\omega^2 = 0\")\n        self.play(ReplacementTransform(ode.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for solutions of the characteristic equation\n        explanation2 = Text(\"Characteristic equation solutions\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = -\\gamma \\pm \\sqrt{\\gamma^2 - \\omega^2}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # Display the general solution\n        general_solution = MathTex(r\"y = e^{-\\gamma x}(C_1 \\cos(\\sqrt{\\omega^2 - \\gamma^2}x) + C_2 \\sin(\\sqrt{\\omega^2 - \\gamma^2}x))\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation3 = Text(\"General solution of the damped oscillator\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(explanation1), FadeOut(general_solution))\n        self.wait(1)\n\n        # Restate the general solution\n        final_solution = MathTex(r\"y = e^{-\\gamma x}(A \\cos(\\sqrt{\\omega^2 - \\gamma^2}x) + B \\sin(\\sqrt{\\omega^2 - \\gamma^2}x))\")\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation that explains the concept of a harmonic oscillator in physics. Start by showing the equation of motion for a mass-spring system, and then visually go through the steps of solving the second-order ordinary differential equation. Transform the equation of motion, present a characteristic equation and its roots, and finally, display the general solution for the position as a function of time. Conclude with an informative text that summarizes how the motion of a harmonic oscillator is sinusoidal in nature. Can you also ensure that each step is highlighted and explained with text that appears at the top of the screen? Additionally, between each step, please pause briefly to give viewers time to understand the content.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Setting up the integral problem\n        problem = MathTex(r\"\\int_1^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the use of the Fundamental Theorem of Calculus\n        explanation1 = Text(\"Apply the Fundamental Theorem of Calculus:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Showing the anti-derivative\n        antiderivative = MathTex(r\"F(x) = \\frac{x^{4}}{4}\")\n        self.play(Write(antiderivative))\n        self.wait(2)\n\n        # Showing the evaluation of bounds\n        evaluation = MathTex(r\"F(2) - F(1) = \\frac{2^4}{4} - \\frac{1^4}{4}\")\n        self.play(Transform(problem, evaluation))\n        self.wait(1)\n\n        # Explanation for performing subtraction\n        explanation2 = Text(\"Calculate the difference for definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing final solution\n        final_solution = MathTex(r\"= \\frac{16}{4} - \\frac{1}{4} = \\frac{15}{4}\")\n        self.play(ReplacementTransform(problem, final_solution))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n\n        # Restating the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated explanation video that shows how to integrate the sine function from 0 to pi, including the steps of integrating, evaluating the definite integral, and concluding with the result of the integration?",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillator(Scene):\n    def construct(self):\n        # Presenting the differential equation\n        diff_eq = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n        \n        # Display the meaning\n        meaning = Text(\"Harmonic Oscillator Equation\", font_size=24).to_edge(UP)\n        self.play(Write(meaning))\n        self.wait(2)\n        \n        # Forming the characteristic equation from the given differential equation\n        char_eq_text = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(meaning, char_eq_text))\n        char_eq = MathTex(r\"mr^2 + k = 0\")\n        self.play(ReplacementTransform(diff_eq.copy(), char_eq))\n        self.wait(1)\n        \n        # Solving the characteristic equation\n        solve_char_eq = Text(\"Solve for r\", font_size=24).to_edge(UP)\n        self.play(Transform(meaning, solve_char_eq))\n        roots = MathTex(r\"r = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n        \n        # General solution for the motion\n        gen_sol_text = Text(\"General Harmonic Motion Solution\", font_size=24).to_edge(UP)\n        self.play(Transform(meaning, gen_sol_text))\n        general_solution = MathTex(r\"x(t) = A\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + B\\sin\\left(\\sqrt{\\frac{k}{m}}t\\right)\")\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Clear scene and show the final solution only\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "I need to create an educational animation that explains the first part of the Fundamental Theorem of Calculus. The animation should start by showing the mathematical expression of the theorem, displaying the derivative of the integral from a to x of a function f(t) with respect to x equals f(x). After presenting the theorem, there should be a textual explanation labeling it as \"Fundamental Theorem of Calculus, Part 1\" at the top of the screen. Next, I want the initial formula to transform into another expression that reinforces the concept, showing that f(x) equals the derivative of F(x) with respect to x. Along with that, I need to update the explanation at the top to emphasize that the function f(x) must be continuous on the interval [a, b]. Finally, please include a note stating that \"F(x) is an antiderivative of f(x)\" below the second expression. To wrap up the animation, I would like to clear all of the content from the screen and then redraw the original theorem to reinforce the learning. The pace should be slow enough to allow the viewer to follow along but not too slow so they lose interest. Can you animate this concept for me in a visually appealing way?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left[ \\frac{x^{n+1}}{n+1} \\right]_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Showing the substitution step\n        substitution = MathTex(r\"= \\left[ \\frac{x^{3+1}}{4} \\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), substitution))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the bounds and subtract:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution before simplification\n        before_simplification = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(substitution, before_simplification))\n        self.wait(1)\n\n        # Final solution after simplification\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(before_simplification, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an animated video that explains how to solve a triple integral, step by step, using a specific example of integrating the function xyz over the unit cube with bounds from 0 to 1. The animation should include on-screen text guiding through each step of the integration: first integrating with respect to z, then y, and finally x, showing the evaluated antiderivatives and results after each integration. After the calculation, display the final numerical answer clearly. The explanations should appear at the top of the screen and the mathematical steps should be shown in the center. Please ensure that each step is presented in a clear and easy-to-understand manner, and let there be pauses between steps so the viewer can follow along.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesVisual(Scene):\n    def construct(self):\n        # Introduction to Fourier Series\n        title = Text(\"Fourier Series Representation\", font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.wait()\n\n        # Example of a square wave\n        square_wave_text = Text(\"Square Wave\", font_size=28).to_edge(UP).shift(DOWN)\n        square_wave = Square(color=BLUE).scale(2)\n        self.play(Write(square_wave_text))\n        self.wait(0.5)\n        self.play(ShowCreation(square_wave))\n        self.wait()\n\n        # Display Fourier Series Equation\n        fourier_series_text = MathTex(\n            \"f(x) = a_0 + \\sum_{n=1}^\\infty (a_n \\cos(nx) + b_n \\sin(nx))\"\n        ).next_to(square_wave, DOWN)\n        self.play(ReplacementTransform(square_wave_text, fourier_series_text))\n        self.wait(2)\n\n        # Explanation for Fourier Analysis\n        explanation_fourier = Text(\"Fourier analysis breaks down\",\n                                   \"periodic functions into a sum of sine and cosine functions.\",\n                                   font_size=24).next_to(fourier_series_text, DOWN)\n        self.play(FadeIn(explanation_fourier, UP))\n        self.wait(2)\n\n        # Clear the scene for partial sum\n        self.clear()\n        self.wait()\n\n        # Fourier Series Partial Sum Equation\n        partial_sum_title = Text(\"Fourier Series Partial Sum\", font_size=36).to_edge(UP)\n        partial_sum_eq = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^N (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(partial_sum_title))\n        self.wait()\n        self.play(Write(partial_sum_eq))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"As N approaches infinity,\", \n                          \"the partial sum converges to the function\", font_size=24).next_to(partial_sum_eq, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clear the scene at the end\n        self.play(FadeOut(partial_sum_title), FadeOut(partial_sum_eq), FadeOut(conclusion))\n        self.wait()"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the concept of finding the area under a curve, specifically the area under the graph of \\(x^2\\) from 0 to 2, and also show the calculation of the definite integral of \\(x^2\\) from 0 to 2 using ManimCE? The animation should include the graph of the function, the shaded area under the curve, the step-by-step integral calculation, and finally display the numerical value of the area. Also, ensure that the elements are introduced in a sequence that aids understanding and that there is a clear statement of the final result. After the conclusion, please fade out all elements from the scene.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Function to graph\n        curve = lambda x: 0.1 * (x - 3) ** 2\n\n        # Displaying the function\n        graph = FunctionGraph(curve, x_range=[0, 5])\n        graph_label = MathTex(\"f(x) = 0.1(x - 3)^2\").next_to(graph, UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Indicate the area under the curve\n        area = area = self.get_area(graph, [1, 4])\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Problem to solve\n        problem = MathTex(r\"\\int_1^4 0.1(x - 3)^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the definite integral\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Evaluation of integral\n        evaluation = MathTex(r\"= [\\frac{0.1}{3}(x - 3)^3]_1^4\")\n        self.play(ReplacementTransform(problem.copy(), evaluation))\n        self.wait(2)\n\n        # Final solution\n        solution = MathTex(r\"= \\frac{0.1}{3}(4 - 3)^3 - \\frac{0.1}{3}(1 - 3)^3\", r\"= \\frac{0.1}{3}\")\n        self.play(ReplacementTransform(evaluation, solution))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated educational presentation using ManimCE that explains the classical wave equation, displays the equation, provides a brief commentary that it's the classical wave equation, suggests one solution form of the equation, and finally presents the general solution with two arbitrary functions involved? Additionally, can it include smooth transitions, such as the transformation of the wave equation into the solution and replacing one piece of commentary text with another, before concluding by clearly showing the final solution to the wave equation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"DrawBorderThenFill\").shift(UP*2.5)), run_time=0.5)\n            square = Square(color=BLUE, fill_opacity=1).set_fill(YELLOW)\n            self.play(DrawBorderThenFill(square))\n            self.remove(square)"
    },
    {
        "query": "I would like to see an animation that starts with a circular path, defined by a sine and cos function, appearing on the screen in red. Then an arrow, representing the derivative at the top of the circle, should appear, pointing in the direction tangent to the circle with a yellow color. Next to the arrow, there should be a label with the derivative symbol. After that, a green tangent line should be drawn at the same point where the derivative arrow starts. Then a blue dot should appear exactly where the circle and the tangent intersect, and below the dot, there should be a label showing its coordinates. Finally, clear everything else from the screen and only show the red circular path, the blue dot, and the coordinate label. Can you create an animation like this for a presentation I'm working on?",
        "answer": "\\n from manim import *\n\nclass TracedPathExample(Scene):\n    def construct(self):\n        square = Square(color=PURPLE)\n        trace_path = TracedPath(square.get_center)\n        self.add(square, trace_path)\n        self.play(square.animate.shift(RIGHT*3), run_time=2)\n        self.wait(0.5)\n        self.play(square.animate.shift(UP*3), run_time=2)\n        self.wait(0.5)\n        self.play(square.animate.shift(LEFT*3), run_time=2)\n        self.wait(0.5)\n        self.play(square.animate.shift(DOWN*3), run_time=2)\n        self.remove(square, trace_path)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates how to find the area under a quadratic curve using integration, specifically for the function y = 0.1x^2 between the limits -2 and 2, complete with mathematical notation and step-by-step calculation of the integral, followed by displaying the final result clearly, and concluding the video by leaving the final solution on the screen?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [\\frac{1}{2} xz^2y]_{0}^{2} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2} x^2z^2y]_{-1}^{1} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2} y^2]_{0}^{1}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates how to solve a double integral in polar coordinates. The specific problem should be the integral from 0 to pi with respect to theta and from 0 to 1 with respect to r of the function r dr d\u03b8. The animation should start by showing the integral equation and then proceed step by step. First, show the integration with respect to r with appropriate text explaining that we are integrating r first. Then, display the result of this first integration before moving on to integrate with respect to theta, again with explanatory text. Lastly, present the final solution to the integral. Each step should be clearly written out and transitions between steps should give viewers enough time to follow along. Can you create an animation like that?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate w.r.t. x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate w.r.t. y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate w.r.t. z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} \\frac{1}{2}z \\,dz\", r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and show the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create a step-by-step educational animation that visually demonstrates how to solve a triple integral, specifically the integral of xyz over the unit cube from 0 to 1 for each variable, with corresponding explanations at each stage of the integration process?",
        "answer": "\\n from manim import *\n\nclass LinearAlgebraScene(Scene):\n    def construct(self):\n        # Display the matrix\n        matrix = MathTex(r\"\\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix}\")\n        self.play(Write(matrix))\n        self.wait(1)\n\n        # Display the determinant calculation\n        det_text = Text(\"Determinant of the matrix\", font_size=24).to_edge(UP)\n        self.play(FadeIn(det_text))\n        self.wait(1)\n\n        # Show the determinant formula\n        det_formula = MathTex(r\"\\det(A) = ad - bc\")\n        self.play(Transform(matrix.copy(), det_formula))\n        self.wait(2)\n\n        # Calculate the determinant\n        det_value = MathTex(r\"\\det(A) = 1 \\cdot 4 - 2 \\cdot 3 = -2\")\n        self.play(ReplacementTransform(det_formula, det_value))\n        self.wait(2)\n\n        # Explain the inverse of a matrix\n        inverse_text = Text(\"Inverse of the matrix\", font_size=24).to_edge(UP)\n        self.play(Transform(det_text, inverse_text))\n        self.wait(2)\n\n        # Inverse of the matrix\n        inverse_matrix = MathTex(r\"A^{-1} = \\frac{1}{\\det(A)} \\begin{bmatrix} d & -b \\\\ -c & a \\end{bmatrix}\")\n        self.play(ReplacementTransform(det_value, inverse_matrix))\n        self.wait(3)\n\n        # Clear the scene and conclude with a final message\n        self.clear()\n        final_message = Text(\"That's how you compute a determinant and an inverse!\", font_size=24)\n        self.play(Write(final_message))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually explains the steps to solve a first-order ordinary differential equation, such as y' - 3y = 0? I would like it to begin by displaying the equation, then show the process of rearranging the terms to isolate y', followed by an explanation and application of an integrating factor. Afterward, demonstrate how to find the general solution, and conclude with the function that solves the ODE. Can you also make sure each new step and explanation appears clearly on the screen one at a time with pauses in between so the viewer can follow along?",
        "answer": "\\n         self.play(Transform(text,Text(\"Circumscribe\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Look Here\")\n        self.add(some_text)\n        self.play(Circumscribe(some_text))\n        self.play(Circumscribe(some_text, Circle))\n        self.remove(some_text)"
    },
    {
        "query": "Can you create an animation of a blue semi-transparent ball bouncing five times with decreasing height each time it bounces, and then fade out both the ball and the line representing the ground?",
        "answer": "\\n class SecondExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=(-3, 3), y_range=(-3, 3))\n        curve = ax.plot(lambda x: (x+2)*x*(x-2)/2, color=RED)\n        area = ax.get_area(curve, x_range=(-2, 0))\n        self.play(Create(ax, run_time=2), Create(curve, run_time=5))\n        self.play(FadeIn(area))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation that shows how to solve the integral of the square root of (1 minus x squared) using trigonometric substitution, with step-by-step explanations and transformations, ending with the final answer in terms of x?",
        "answer": "\\n from manim import *\n\nclass PendulumScene(Scene):\n    def construct(self):\n        pendulum = Pendulum(\n            initial_theta=0.3,\n            damping=0.1,\n            length=3,\n            gravity=9.81,\n            bob_mass=2\n        )\n        pendulum.start_swinging()\n\n        path = TracedPath(pendulum.get_bob().get_center, stroke_color=RED, stroke_width=4)\n        self.add(pendulum, path)\n        \n        self.wait(10)"
    },
    {
        "query": "Can you create an educational animation that illustrates how the sum of the harmonic series diverges as n approaches infinity? Start by displaying the formula for the partial sum of the series, proceed with a visual narration explaining that we're considering the limit as n goes to infinity, then show the mathematical expression of the limit of the series, followed by a text explanation that this series is known as the harmonic series and it diverges. Conclude by showing the mathematical result that the limit of the series equals infinity.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} \\frac{1}{2}y z \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Then, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{4} z \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that explains the concept of simple harmonic motion (SHM) by illustrating the step-by-step derivation of the SHM equation, starting with the basic differential equation, introducing and explaining the concept of angular frequency, and finally showing the solution to the equation as a function of time. Include brief explanatory texts that describe each step and conclude with a text that states \"Simple Harmonic Motion Equation\". Make sure each step of the equation transformation is animated and that there is a pause after each explanation so that viewers have time to understand the material.",
        "answer": "\\n from manim import *\n\nclass ChemicalAnimation(Scene):\n    def construct(self):\n        # Create a grid of metal and oxygen\n        grid = self.metal_oxid(4, 4)\n        self.play(Create(grid))\n        self.wait(1)\n        \n        # Animate an electron moving along a complex path\n        electron_particle = self.electron()\n        self.add(electron_particle)\n        complex_path = [\n            UP * 2 + LEFT * 2,\n            UP * 2 + RIGHT * 2,\n            DOWN * 2 + RIGHT * 2,\n            DOWN * 2 + LEFT * 2,\n            UP * 2 + LEFT * 2,\n        ]\n        animations = self.move_along_complex_path(electron_particle, [0, 3], complex_path, run_time=2)\n        self.play(*animations)\n        self.wait(2)\n\n        # Fade out all elements\n        self.play(FadeOut(grid), FadeOut(electron_particle))\n\n    def electron(self) -> Mobject:\n        return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)\n\n    def metal_oxid(self, rows: int, cols: int, scale=1.5) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                if (j + i) % 2 == 0:\n                    list.append(self.oxygen().move_to(np.array([i, j, 0]) / scale))\n                else:\n                    list.append(self.metal().move_to(np.array([i, j, 0]) / scale))\n        return VGroup(*list)\n\n    def oxygen(self) -> Mobject:\n        o_atom = circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1)\n        o_atom.set_z_index(1)\n        return o_atom\n\n    def metal(self) -> Mobject:\n        co_atom = circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n        co_atom.set_z_index(1)\n        return co_atom\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        paths = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                paths.append(Line(points[i], points[i + 1], color=WHITE).set_opacity(0.5))\n\n        for i in range(len(paths)):\n            animations.append(MoveAlongPath(obj, paths[i], run_time=run_time / len(paths), rate_func=rate_func))\n            if i in stop_indices:\n                animations.append(AnimationGroup(Wait(run_time / len(paths))))\n\n        return animations\n\ndef circle_with_text(\n    r: float, txt: str, color=WHITE, font_size: int = 10, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE\n) -> Mobject:\n    c = Circle(radius=r, color=color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)"
    },
    {
        "query": "Could you create an educational animation that teaches how to find the derivative of the function f(x) = x^3 + 3x^2 + 2x using the power rule, show the step-by-step process, including simplifying the expression to its final form, and then conclude by clearly displaying the final derivative on the screen?",
        "answer": "\\n from manim import *\nimport random\nimport math\n\n\nclass BinarySearchTree(VGroup):\n    def __init__(\n        self,\n        scene,\n        levels=3,\n        base_offset=0.5,\n        node_radius=0.5,\n        child_offset_factor=1.2,\n        label_scale_factor=1,\n        color_nodes=False,\n        max_value=16,\n        animation_runtime=0.2,\n        insertion_initial_offset=1,\n    ):\n        super().__init__()\n        self.scene = scene\n        self.empty = True\n        self.child_down_offset = DOWN * child_offset_factor\n        self.child_left_offset = LEFT * base_offset * 2 * math.log2(levels)\n        self.node_radius = node_radius\n        self.label_scale_factor = label_scale_factor\n        self.color_nodes = color_nodes\n        self.max_value = max_value\n        self.animation_runtime = animation_runtime\n        self.insertion_initial_offset = insertion_initial_offset\n\n        self.root = self.get_node(None)\n        self.add(self.root)\n\n    def get_node(self, value):\n        node = VDict(\n            {\n                \"node\": Circle(radius=self.node_radius, color=WHITE),\n                \"label\": MathTex(\"\\\\varnothing\" if value is None else str(value)).scale(\n                    self.label_scale_factor\n                ),\n            }\n        )\n        if self.label_scale_factor != 0:\n            node[\"label\"] = MathTex(\n                \"\\\\varnothing\" if value is None else str(value)\n            ).scale(self.label_scale_factor)\n        if value is not None:\n            node_color = interpolate_color(BLUE, RED, value / self.max_value)\n            node.set_stroke(node_color)\n            if self.color_nodes:\n                node.set_fill(node_color, opacity=1)\n            node.color = node_color\n        node.value = value\n        node.left_child = None\n        node.right_child = None\n        return node\n\n    def insert(self, value):\n        node = self.get_node(value)\n        if self.root.value is None:\n            node.move_to(self.root.get_center())\n            self.scene.play(\n                FadeInFrom(node, UP * self.insertion_initial_offset),\n                FadeOut(self.root),\n                run_time=self.animation_runtime,\n            )\n            self.remove(self.root)\n            self.root = node\n            self.add(node)\n            self.empty = False\n            return\n\n        node.move_to(self.root.get_center() + UP * self.insertion_initial_offset)\n        cur_node = self.root\n        child_left_offset = self.child_left_offset.copy()\n        while cur_node is not None:\n            if node.value <= cur_node.value:\n                self.scene.play(\n                    node.move_to,\n                    cur_node.get_center() + 2 * cur_node[\"node\"].radius * LEFT,\n                    run_time=self.animation_runtime,\n                )\n                if cur_node.left_child is not None:\n                    cur_node = cur_node.left_child\n                else:\n                    child_location = (\n                        cur_node.get_center()\n                        + self.child_down_offset\n                        + child_left_offset\n                    )\n                    parent_child_vector = normalize(\n                        child_location - cur_node.get_center()\n                    )\n\n                    edge_start = (\n                        cur_node.get_center() + parent_child_vector * self.node_radius\n                    )\n                    edge_end = child_location - parent_child_vector * self.node_radius\n                    edge = Line(edge_start, edge_end, stroke_color=node.color)\n\n                    self.scene.play(\n                        node.move_to,\n                        child_location,\n                        FadeIn(edge),\n                        run_time=self.animation_runtime,\n                    )\n                    cur_node.left_child = node\n                    self.add(node, edge)\n                    break\n            else:\n                self.scene.play(\n                    node.move_to,\n                    cur_node.get_center() + 2 * cur_node[\"node\"].radius * RIGHT,\n                    run_time=self.animation_runtime,\n                )\n                if cur_node.right_child is not None:\n                    cur_node = cur_node.right_child\n                else:\n                    child_location = (\n                        cur_node.get_center()\n                        + self.child_down_offset\n                        - child_left_offset\n                    )\n                    parent_child_vector = normalize(\n                        child_location - cur_node.get_center()\n                    )\n\n                    edge_start = (\n                        cur_node.get_center() + parent_child_vector * self.node_radius\n                    )\n                    edge_end = child_location - parent_child_vector * self.node_radius\n                    edge = Line(edge_start, edge_end, stroke_color=node.color)\n\n                    self.scene.play(\n                        node.move_to,\n                        child_location,\n                        FadeIn(edge),\n                        run_time=self.animation_runtime,\n                    )\n                    cur_node.right_child = node\n                    self.add(node, edge)\n                    break\n            child_left_offset /= 2\n\n\nclass DraftScene(Scene):\n    def construct(self):\n        tree = BinarySearchTree(self, base_offset=0.75, max_value=16).shift(UP * 2)\n        self.add(tree)\n        label = (\n            Text(\"Great for storing structured data.\").scale(0.8).to_edge(UP, buff=0.1)\n        )\n        self.add(label)\n\n        nums = [8, 4, 2, 1, 3, 6, 5, 7, 12, 10, 9, 11, 14, 13, 15]\n        for i in nums:\n            tree.insert(i)\n\n        self.wait(0.5)\n        self.play(FadeOut(tree))\n        self.remove(label)\n\n        # tree = BinarySearchTree(\n        #     self,\n        #     base_offset=0.9,\n        #     node_radius=0.05,\n        #     child_offset_factor=0.8,\n        #     label_scale_factor=0,\n        #     color_nodes=True,\n        #     max_value=31,\n        #     animation_runtime=0.05,\n        #     insertion_initial_offset=0.6\n        # ).shift(UP * 2.5 + LEFT * 0.5)\n        # self.add(tree)\n        # self.add(\n        #     Text(\"Though random data can get ugly.\").scale(0.8).to_edge(UP, buff=0.1)\n        # )\n\n        # # Though random data can get ugly.\n        # nums = [i + 1 for i in range(31)]\n        # random.seed(0)\n        # random.shuffle(nums)\n        # for i in nums:\n        #     tree.insert(i)\n\n        # self.wait()"
    },
    {
        "query": "Can you create an educational animation that illustrates the convergence of a mathematical series using the p-test? The animation should display the series sum from n=1 to infinity of 1/n^2, then introduce the concept of the p-test for convergence with the condition p > 1. Afterwards, it should show that for our series p equals 2, which satisfies the p-test, leading to the conclusion that the series converges. Each step of this process should be accompanied by a visual text or mathematical notation on the screen, with pauses between each step for emphasis. The final conclusion should stand out clearly and the entire sequence should be clear and engaging for students learning about series convergence for the first time.",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass EqualDivisions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Dividida em partes iguais\", color=BLACK)\n        title.scale(1.5)\n        title.shift(4 * UP)\n        title[0][10:].set_color(\"#a346eb\")\n        rect = Rectangle(color=LIGHT_RED_COLOR, height=3, width=4, fill_opacity=0.3)\n        rect_vdiv = Line(rect.get_top(), rect.get_bottom(), color=LIGHT_RED_COLOR)\n        rect_hdiv = Line(rect.get_left(), rect.get_right(), color=LIGHT_RED_COLOR)\n        circ = Circle(1.5, color=LIGHT_GREEN_COLOR, fill_opacity=0.3)\n        circ_div = Line(circ.get_top(), circ.get_bottom(), color=LIGHT_GREEN_COLOR)\n        rect_divisions = VGroup(\n            rect_vdiv.copy().shift(RIGHT),\n            rect_vdiv.copy(),\n            rect_vdiv.copy().shift(LEFT),\n            rect_hdiv.copy().shift(1/2 * UP),\n            rect_hdiv.copy().shift(- 1/2 * UP)\n        )\n        circ_divisions = VGroup(*[circ_div.copy().rotate(i * 45 * DEGREES) for i in range(8)])\n        circ_n_rect = VGroup(\n            VGroup(rect, rect_divisions), \n            VGroup(circ, circ_divisions)\n        )\n        circ_n_rect.arrange(DOWN, buff=1)\n\n        self.play(\n            Create(rect),\n            Create(circ),\n            run_time=1.5\n        )\n        self.play(Create(rect_divisions))\n        self.play(Create(circ_divisions), run_time=1.8)\n        self.play(circ_n_rect.animate.shift(DOWN), run_time=0.2)\n        self.play(Write(title), run_time=0.8)\n        self.wait(0.5)\n        self.play(\n            circ_n_rect.animate.shift(9 * LEFT), \n            title.animate.shift(9 * LEFT),\n            run_time=0.8\n        )\n        self.remove(circ_n_rect, title)"
    },
    {
        "query": "I would like to create an educational animation that demonstrates the concept of finding the area under the curve for the function f(x) = x^2 between the limits of 0 and 2. The animation should begin by drawing a graph of the function with labeled axes and the curve in green. Next, it should fill the area under the curve with a color to highlight it. After that, the animation should display the integral of the function from 0 to 2, and then show the antiderivative method step by step to calculate the exact area. Finally, the animation should present the calculated area as a fraction and a decimal value while removing all other elements from the screen. Can you create this educational animation for me?",
        "answer": "\\n from manim import *\n\nclass VariousShapes(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        ellipse = Ellipse(width=3, height=1, color=RED)\n        rectangle = Rectangle(width=2, height=3, color=GREEN)\n        triangle = Triangle(color=YELLOW)\n        \n        shapes = VGroup(circle, ellipse, rectangle, triangle)\n        \n        shapes.arrange_in_grid(rows=2, cols=2)\n        \n        self.add(shapes)"
    },
    {
        "query": "I need an educational animation that visually demonstrates the integration of the trigonometric function sin(x)cos(x) step by step. Can you create a video that shows the following: Start by presenting the integral of sin(x)cos(x), then explain using a trigonometric identity to simplify the problem by equating sin(2x) to 2sin(x)cos(x), followed by applying this identity to transform the original integral. Proceed by showing the integration of sin(2x), and finally display the integrated result with the constant of integration C. Make sure the steps are clear, properly sequenced, and each part of the explanation appears one after the other with time for the viewer to follow along.",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#1e1e1e\"\nTEXT_COLOR = \"#dddddd\"\nCOLOR_ONE = \"#e07a5f\"\nCOLOR_TWO = \"#3d405b\"\nCOLOR_THREE = \"#81b29a\"\nCOLOR_FOUR = \"#f2cc8f\"\n\ndef ease_in_quad(t):\n    return rate_functions.ease_in_quad(t)\n\ndef GoldenRectangle(width, height, color):\n    rect = Rectangle(width=width, height=height, color=color)\n\n    text = Tex(f\"{width}: {height}\", color=color)\n    text.scale(0.75 * min(width, height) / 2)\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass GoldenSpiral(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        colors = [\n            COLOR_ONE,\n            COLOR_TWO,\n            COLOR_THREE,\n            COLOR_FOUR\n        ]\n        \n        ratio = (1 + 5 ** 0.5) / 2 # Golden ratio\n        widths = [1, ratio]\n        heights = [1, 1]\n\n        for _ in range(6):\n            widths.append(widths[-2] + widths[-1])\n            heights.append(heights[-2] + heights[-1])\n\n        directions = [RIGHT, UP, LEFT, DOWN]\n        rectangles = Group()\n\n        for i in range(len(widths)):\n            rectangles.add(GoldenRectangle(widths[i], heights[i], colors[i % 4]))\n            if i == 0:\n                continue\n            rectangles[i].next_to(rectangles[i - 1], directions[i % 4], buff=0)\n\n        animations = []\n        for rectangle in rectangles:\n            animations.append(Create(rectangle[0]))\n            animations.append(Write(rectangle[1]))\n\n        self.play(LaggedStart(*animations, lag_ratio=0.2))\n\n        angle_tracker = ValueTracker(0)\n        last_rect = rectangles[-1]\n        start_angle = 0\n        arc_radius = 1\n\n        for _ in range(4):\n            arc = always_redraw(\n                lambda: Arc(\n                    radius=arc_radius,\n                    arc_center=last_rect.get_corner(DL),\n                    start_angle=start_angle,\n                    angle=angle_tracker.get_value(),\n                    color=TEXT_COLOR\n                )\n            )\n            self.add(arc)\n            self.play(\n                angle_tracker.animate.set_value(TAU),\n                rate_func=ease_in_quad,\n                run_time=2\n            )\n            start_angle += TAU / 2\n            arc_radius *= ratio\n\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects), run_time=2))"
    },
    {
        "query": "Can you create an educational animation that visually explains how to find the area under the curve y=0.1x^2 between x=-3 and x=0, including the steps to calculate the definite integral of the function and simplifying the result to a numerical value?",
        "answer": "\\n from manim import *\n\nclass DerivativeExample(Scene):\n    def construct(self):\n        # Displaying the function to differentiate\n        function = MathTex(r\"f(x) = x^3 + 3x^2 + 2x + 1\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Moving to the top of the screen\n        function_to_diff = function.to_edge(UP)\n\n        # Explanation for calculating derivative\n        explanation1 = Text(\"Calculating the derivative\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Derivative step\n        derivative_step = MathTex(r\"f'(x) = 3x^2 + 6x + 2\")\n        self.play(ReplacementTransform(function.copy(), derivative_step))\n        self.wait(1)\n\n        # Explanation for finding critical points\n        explanation2 = Text(\"Find critical points\", font_size=24).to_edge(DOWN)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Critical points solution\n        critical_points_solution = MathTex(r\"x=-2, x=-\\frac{1}{3}\")\n        self.play(ReplacementTransform(derivative_step, critical_points_solution))\n        self.wait(1)\n\n        # Clearing the scene and concluding\n        self.clear()\n        self.wait(1)\n        self.play(Write(critical_points_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated step-by-step explanation of how to evaluate the triple integral of the function xyz over the unit cube, with integrations performed in the order dz, dy, then dx. Can you show the integrations one by one, accompanied by brief textual explanations of each step, and also display the final numeric solution to the integral at the end?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Applying the power rule for definite integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        integral_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left[\\frac{x^{n+1}}{n+1}\\right]_a^b\")\n        self.play(Write(integral_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integral_step = MathTex(r\"= \\left[\\frac{x^{3+1}}{3+1}\\right]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integral_step))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Evaluating the integral from 0 to 2:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution before evaluation\n        before_evaluation = MathTex(r\"= \\left[\\frac{x^4}{4}\\right]_0^2\")\n        self.play(ReplacementTransform(integral_step, before_evaluation))\n        self.wait(1)\n\n        # Evaluating the definite integral\n        evaluation = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(Transform(before_evaluation, evaluation))\n        self.wait(2)\n\n        # Simplified final solution\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluation, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final evaluated integral\n        final_result = MathTex(r\"\\int_0^2 x^3 \\,dx = 4\")\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation that explains the concept of harmonic oscillators. Start by displaying the differential equation m(d^2x/dt^2) + kx = 0, then introduce the concept of angular frequency with the formula omega^2 = k/m, and relate it to the differential equation. After that, show a possible solution approach by assuming a solution of the form x(t) = A*cos(omega*t) + B*sin(omega*t). Finally, conclude with the general solution of the harmonic oscillator by focusing on this assumed solution. Please ensure that each part of the animation is displayed clearly before moving on to the next, with short pauses for the viewer to absorb the information.",
        "answer": "\\n class MultipleTransformations(Scene):\n    def construct(self):\n        t = Triangle()\n        self.add(t)\n        self.play(Rotate(t, PI/2), Transform(t, Circle()), run_time=3)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates how one can calculate the area under a parabola. The graph should be of the function f(x) = x^2, and the specific area from x = -2 to x = 2 needs to be shaded to represent the area being calculated. Initially, a blue curve represents the function, and the related mathematical integral equation should also appear next to it. The equation should then move to the top of the screen while the area gets shaded in blue beneath the curve. Thereafter, I want the animation to show the step-by-step calculation of the integral, including writing the antiderivative, evaluating the definite integral at the boundaries, and simplifying the final answer. Each mathematical step should replace the previous one in a clear and understandable manner. Finally, when the full calculation is complete, the animation should clear all content except for the final solution, and then re-display that solution for emphasis. Can you create an animation like this for my mathematics students to help them visualize the integration process?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eqn = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eqn))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution format\n        explanation2 = Text(\"The general solution can be written as u(x, t) = F(x - ct) + G(x + ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = F(x - ct) + G(x + ct)\")\n        self.play(ReplacementTransform(wave_eqn, general_solution))\n        self.wait(1)\n\n        # Explanation for specific solutions\n        explanation3 = Text(\"Specific solutions are derived from initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude with the wave solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an educational animation that explains how a sine curve is related to a unit circle. The animation should start by showing a unit circle and a sine curve graph simultaneously. Then, I would like to see a dot traveling around the perimeter of the circle at a steady pace. As the dot moves, I want a vertical line to trace the sine curve, clearly showing the relationship between the dot's position on the circle and the sine value at that angle. The tracing should continue until the dot has made half a revolution on the circle. After that, stop the motion and add a label that reads \"Sine Curve\" below the graph of the sine curve. Finally, I'd like the complete scene to be cleared, only to show a static image of the sine curve with its label again at the end.",
        "answer": "\\n from manim import *\n\nclass WaterFormation(Scene):\n    def construct(self):\n        # Create hydrogen atoms\n        h1 = self.create_hydrogen_atom().to_edge(UP + LEFT)\n        h2 = self.create_hydrogen_atom().to_edge(UP + RIGHT)\n        \n        # Create oxygen atom\n        o = self.create_oxygen_atom().to_edge(DOWN)\n        \n        # Animate the formation of water by moving hydrogen atoms to oxygen\n        self.play(\n            h1.animate.move_to(o.get_center() + np.array([-1, 1, 0])),\n            h2.animate.move_to(o.get_center() + np.array([1, 1, 0])),\n            run_time=3\n        )\n\n        # Group atoms to a single water molecule\n        water_molecule = VGroup(h1, o, h2)\n        \n        # Show the formation of the water molecule\n        self.play(\n            Rotate(water_molecule, PI), \n            water_molecule.animate.scale(0.5).move_to(ORIGIN), \n            run_time=3\n        )\n        \n        # Keep the molecule on screen\n        self.wait(2)\n    \n    def create_hydrogen_atom(self):\n        # Creates a hydrogen atom with a plus sign\n        proton = Circle(color=BLUE, fill_opacity=1).scale(0.2)\n        plus = Tex(\"+\").move_to(proton.get_center())\n        return VGroup(proton, plus)\n    \n    def create_oxygen_atom(self):\n        # Creates an oxygen atom with an O\n        electron_cloud = Circle(color=RED, fill_opacity=1).scale(0.5)\n        oxygen_text = Tex(\"O\").move_to(electron_cloud.get_center()).set_color(WHITE)\n        return VGroup(electron_cloud, oxygen_text)"
    },
    {
        "query": "Please create an educational animation for me that visually demonstrates how to calculate the area under a curve, specifically using the example of the curve x squared from x equals 0 to x equals 2. Show the function graph and the area under it, then display the corresponding integral notation, followed up with a step-by-step solution of the integral. Explain what the shaded area represents in terms of definite integrals, and conclude by providing the value of the definite integral for this example. After the explanation, clear everything except the final solution and leave that on the screen for a moment before ending the animation.",
        "answer": "\\n from manim import *_x000D_\n_x000D_\n_x000D_\nclass ChemicalReactionsScene(Scene):_x000D_\n    def construct(self):_x000D_\n        oxygen_molecule = self.create_oxygen_molecule()_x000D_\n        electron = electron()_x000D_\n        electron_path = self.get_electron_path(oxygen_molecule)_x000D_\n_x000D_\n        self.play(Create(oxygen_molecule))_x000D_\n        self.play(*move_along_complex_path(electron, [2, 5], electron_path, 2))_x000D_\n        self.play(FadeOut(oxygen_molecule), FadeOut(electron))_x000D_\n_x000D_\n    def create_oxygen_molecule(self) -> Mobject:_x000D_\n        oxygen_atom_1 = oxygen().shift(LEFT)_x000D_\n        oxygen_atom_2 = oxygen().shift(RIGHT)_x000D_\n        bond = Line(oxygen_atom_1.get_center(), oxygen_atom_2.get_center())_x000D_\n        return VGroup(oxygen_atom_1, oxygen_atom_2, bond)_x000D_\n_x000D_\n    def get_electron_path(self, molecule: Mobject) -> List:_x000D_\n        path_points = [_x000D_\n            molecule.get_left() + LEFT,_x000D_\n            molecule.get_top() + UP,_x000D_\n            molecule.get_right() + RIGHT,_x000D_\n            molecule.get_bottom() + DOWN_x000D_\n        ]_x000D_\n        return path_points_x000D_\n_x000D_\n_x000D_\ndef oxygen() -> Mobject:_x000D_\n    list = []_x000D_\n    for angle in (0, PI / 2, PI, (3 * PI) / 2):_x000D_\n        start = 0.3 * np.array([np.cos(angle), np.sin(angle), 0])_x000D_\n        end = 0.6 * np.array([np.cos(angle), np.sin(angle), 0])_x000D_\n        list.append(Line(start=start, end=end).set_opacity(0.7))_x000D_\n    return VGroup(circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)_x000D_\n_x000D_\n_x000D_\ndef circle_with_text(_x000D_\n    r: int, txt: str, color=BLACK, font_size: int = 10,_x000D_\n    font_color=BLACK, stroke_width: int = 2, fill_color=BLACK_x000D_\n) -> Mobject:_x000D_\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)_x000D_\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)_x000D_\n    return VGroup(c, t)_x000D_\n_x000D_\n_x000D_\ndef electron() -> Mobject:_x000D_\n    return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)_x000D_\n_x000D_\n_x000D_\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):_x000D_\n    animations = []_x000D_\n    paths = []_x000D_\n    for i in range(len(points) - 1):_x000D_\n        if i not in stop_indices:_x000D_\n            paths.append(Line(points[i], points[i + 1]))_x000D_\n_x000D_\n    for i in range(len(paths)):_x000D_\n        animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))_x000D_\n_x000D_\n    return animations"
    },
    {
        "query": "I would like to create an educational animation that explains how to solve a simple first-order linear ordinary differential equation (ODE) step by step. The equation is y' - 3y = 0. The animation should start by displaying the equation, then show how to form the characteristic equation from it, which is r - 3 = 0. After that, it should demonstrate solving this characteristic equation for r, and then display the general solution, y = C e^{3x}, to the ODE. Finally, present a particular solution, y = e^{3x}, on the screen and discuss the difference between the general and the particular solutions briefly. Can this be done in a visually engaging way that alternates between written equations and explanatory text, with pauses for the viewer to understand each step? Also, I'd like the animation to end by clearing the screen and then revisiting the particular solution once more before concluding.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.arrange\").shift(UP*2.5)), run_time=0.5)\n            t1 = Text(\"3\").shift(LEFT)\n            t2 = Text(\"1\")\n            t3 = Text(\"2\").shift(RIGHT)\n            vg = VGroup(t2,t3,t1)\n            self.add(t2,t3,t1)\n            self.wait(0.5)\n            self.play(vg.animate.arrange(buff=1.0))\n            self.remove(t1,t2,t3)"
    },
    {
        "query": "I would like to create an animated educational video that explains the process of solving a first-order linear ordinary differential equation (ODE) using separation of variables and integration. The video should include the following sequential elements:\n\n1. Present the differential equation y' - 3y = 0 visually on the screen.\n2. Add a text that says \"Separate the variables\" and place it at the top of the screen after the equation is shown.\n3. Transform the original equation to show the separation of variables as dy/dx = 3y.\n4. Change the text at the top of the screen to \"Integrate both sides\" while the separated equation is displayed.\n5. Replace the separated equation with the integrated form ln|y| = 3x + C.\n6. Introduce the final solution y = Ce^(3x) and add new text that says \"General solution of the ODE\", replacing the previous text.\n7. Finally, fade out the previous elements except for the final solution and display it prominently.\n\nPlease ensure that each visual step is introduced with smooth transitions and that there are pauses between steps to allow viewers to follow along. The equation and text should be clear and easily readable.",
        "answer": "\\n from manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using the power rule\n        explanation1 = Text(\"Use the power rule for integration\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integral_step = MathTex(r\"\\int_0^2 x^2 \\,dx = \\frac{x^3}{3} \\Bigg|_0^2\")\n        self.play(Transform(problem, integral_step))\n        self.wait(2)\n\n        # Explanation for solving the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\frac{2^3}{3} - \\frac{0^3}{3} = \\frac{8}{3}\")\n        self.play(ReplacementTransform(integral_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an animated video that shows how to test if an infinite series converges or not using the p-test. Start by displaying the sum of 1 over n squared from n equals 1 to infinity. Next, introduce text explaining we will apply the p-test and then show that p, in this case, is 2 which is greater than 1. Then, replace the initial text with a statement that concludes the series is convergent. Finally, clear the screen and end with the statement that the series is convergent being written once more. Can you make this animation engaging and easy to understand?",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorExample(Scene):\n    def construct(self):\n        # Displaying the equation of motion\n        equation = MathTex(r\"m\\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Describing the system\n        system_description = Text(\"This represents a simple harmonic oscillator.\", font_size=24)\n        system_description.to_edge(UP)\n        self.play(Write(system_description))\n        self.wait(2)\n\n        # Explaining terms\n        terms_explanation = Text(\"Where m is mass, k is the spring constant.\", font_size=24)\n        terms_explanation.to_edge(UP)\n        self.play(Transform(system_description, terms_explanation))\n        self.wait(2)\n\n        # Displaying the solution\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(equation, solution))\n        self.wait(1)\n\n        # Explaining the solution\n        solution_explanation = Text(\"A is amplitude, \u03c9 is angular frequency, and \u03d5 is phase.\", font_size=24)\n        solution_explanation.to_edge(UP)\n        self.play(Transform(system_description, solution_explanation))\n        self.wait(2)\n\n        # Conclusion statement\n        conclusion = Text(\"Simple harmonic motion is periodic and sinusoidal.\", font_size=24)\n        conclusion.to_edge(UP)\n        self.play(Transform(system_description, conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        conclusion.set_opacity(0)  # Hide conclusion without removal animation\n        self.play(FadeIn(solution))\n        self.wait(1)"
    },
    {
        "query": "I'd like an educational animation that visually expresses the step-by-step process of solving a triple integral. Begin with the problem statement of integrating the function xyz over the ranges of z from 0 to 2, y from -1 to 1, and x from 0 to 1. First, show the integration with respect to z and display the result. Then, proceed to integrate the resulting expression with respect to y, and illustrate this on-screen. Lastly, integrate the final result with respect to x to obtain the final solution to the triple integral. I would appreciate if each integration step could be accompanied by a brief text explanation indicating which variable is being integrated, and the entire animation should conclude by displaying the final numerical value of the triple integral.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.rotate_about_origin\").shift(UP*2.5)), run_time=0.5)\n            star = Star().shift(RIGHT*2)\n            self.play(star.animate.rotate_about_origin(PI))\n            self.remove(star)"
    },
    {
        "query": "Can you create an educational animation that illustrates the process of calculating a basic definite integral for me, complete with visual aids such as the problem statement, a step-by-step explanation of the integration rule used, and the calculation of the integral for the specific example of integrating x squared from 2 to 3? Please include written explanations and the algebraic steps to clearly show how one would apply the integration rule, evaluate the expression at the bounds, simplify the result, and display the final answer. Additionally, could you ensure that each step is introduced sequentially with enough time for a viewer to follow along and then conclude by presenting only the final result clearly on the screen?",
        "answer": "\\n class ValueTrackerMove(Scene):\n    def construct(self):\n        line = NumberLine(x_range=[-5, 5])\n        position = ValueTracker(0)\n        pointer = Vector(DOWN)\n        pointer.add_updater(\n            lambda mob: mob.next_to(\n                line.number_to_point(position.get_value()), UP\n            )\n        )\n        pointer.update()\n        self.add(line, pointer)\n        self.wait()\n        self.play(position.animate.set_value(4))\n        self.play(position.animate.set_value(-2))"
    },
    {
        "query": "I would like to create an educational math animation that introduces the quadratic equation and then demonstrates how to solve it using the quadratic formula. It should display the standard form of a quadratic equation on screen, followed by a text that says \"Solve using the quadratic formula\". After that, the actual quadratic formula should be written out for the viewer. Subsequently, I want the initial equation to fade away and be replaced by the formula, which then gets transformed into the two possible solutions for x. In the end, there should be a brief text conclusion about the solutions, then fade everything out and show the solutions once more before ending the animation. Can you help me with that?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Display the triple integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} \\left[\\frac{1}{2}xyz^2\\right]_{0}^{3} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} \\left[\\frac{9}{2}xy^2\\right]_{0}^{2} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{9}{2}y^3\\right]_{0}^{1}\", r\"= \\frac{9}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I want to create an educational animation explaining the convergence of the infinite series sum from n equals 1 to infinity of 1 over n squared using the integral test. Begin by displaying the series on the screen, followed by a statement that we will test for convergence using the integral test. Transform the series into the equivalent integral from 1 to infinity of 1 over x squared, then indicate that since the integral is convergent, the series is convergent as well. After that, reveal that this series is a known convergent series referred to as the Basel problem, and conclude the animation by showing that the series equals pi squared over 6. Make sure there are pauses between the steps for better understanding, and clear the scene before presenting the final conclusion.",
        "answer": "\\n from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_BLUE_COLOR = \"#16b0b5\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nORANGE_COLOR = \"#fc5922\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nDARK_PURPLE_COLOR = \"#5157b9\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef MathOperation(path, expression_text):\n    image = ImageMobject(path)\n    expression = Tex(expression_text, color=BLACK)\n    expression.scale(1.8)\n    group = Group(image, expression)\n    group.arrange(RIGHT, buff=0.25)\n\n    return group\n\nclass AlgebraThree(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        operation_1 = MathOperation(\"./assets/Asset 3.png\", \"* 6 = 24\")\n        operation_2 = Tex(r\"\\textbf{a} * 6 = 24\", color=BLACK)\n        operation_2[0][0].set(color=ORANGE_COLOR)\n        operation_2.scale(1.8)\n        operation_3 = Tex(r\"\\textbf{4} * 6 = 24\", color=BLACK)\n        operation_3[0][0].set(color=ORANGE_COLOR)\n        operation_3.scale(1.8)\n        conclusion_1 = MathOperation(\"./assets/Asset 3.png\", \"= 4\")\n        conclusion_2 = Tex(r\"\\textbf{a} = 4\", color=BLACK)\n        conclusion_2[0][0].set(color=ORANGE_COLOR)\n        conclusion_1.scale(0.8)\n        conclusion_2.scale(1.8)\n        Group(\n            operation_1,\n            operation_2,\n            operation_3,\n            Group(conclusion_1, conclusion_2).arrange(RIGHT, buff=0.5)\n        ).arrange(DOWN, buff=0.7)\n        \n\n        self.play(operation_1.shift(9 * RIGHT).animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(1)\n        self.play(Transform(operation_1[1].copy(), operation_2))\n        self.wait(1)\n        self.play(Transform(operation_2.copy(), operation_3))\n        self.wait(1)\n        self.play(\n            SpinInFromNothing(conclusion_1),\n            SpinInFromNothing(conclusion_2)\n        )\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Please create an animation that shows a blue, semi-transparent ball bouncing across the floor, making a total of four bounces before it comes to a stop and everything fades away. The floor should be a simple line, and the ball should start above the ground on the left side of the screen. Each bounce should be smaller than the last, and the ball should move slightly to the right with each bounce. Also ensure that the ball appears to descend and ascend at an angle as it bounces rather than straight up and down. After the final bounce, the ball should rest for a moment before the entire scene fades out.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int_1^3 3x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Showing the general solution\n        general_solution = MathTex(r\"= \\left[ \\frac{3x^{2+1}}{2+1} \\right]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), general_solution))\n        self.wait(2)\n        \n        # Evaluation step 1\n        evaluation1 = MathTex(r\"= \\left[ x^3 \\right]_1^3\")\n        self.play(ReplacementTransform(general_solution, evaluation1))\n        self.wait(2)\n        \n        # Evaluation from the upper bound to the lower bound\n        evaluation2 = MathTex(r\"= 3^3 - 1^3\")\n        self.play(ReplacementTransform(evaluation1, evaluation2))\n        self.wait(1)\n\n        # Final value after calculation\n        final_value = MathTex(r\"= 27 - 1 = 26\")\n        self.play(ReplacementTransform(evaluation2, final_value))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final answer\n        self.play(Write(final_value))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains how to evaluate the definite integral of x^3 from 0 to 2 using the power rule for integration, including the simplification of the final expression?",
        "answer": "\\n class TransformShapes(Scene):\n    def construct(self):\n        t = Triangle(color=BLUE, fill_opacity=0.5)\n        r = Rectangle(color=YELLOW, fill_opacity=0.5)\n        self.add(t, r)\n        self.play(t.animate.shift(LEFT), r.animate.shift(RIGHT))\n        self.play(t.animate.rotate(PI/4), r.animate.rotate(-PI/4))\n        self.play(Transform(t, r), ReplacementTransform(r.copy(), t))\n        self.wait()"
    },
    {
        "query": "How would you create a step-by-step animated explanation of solving the integral of e^(2x) using u-substitution, with text instructions and the final solution, utilizing a mathematical animation tool?",
        "answer": "\\n from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Mention test to be used\n        test_info = Text(\"Using p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(test_info))\n        self.wait(2)\n        \n        # Show p-test criterion\n        p_test = MathTex(r\"p > 1 \\Rightarrow \\text{Convergent}\")\n        self.play(Write(p_test))\n        self.wait(1)\n\n        # Apply the test to the series\n        apply_test = MathTex(r\"p = 2 > 1 \\Rightarrow \\text{Convergent}\")\n        self.play(ReplacementTransform(p_test, apply_test))\n        self.wait(2)\n        \n        # Show convergence of the series\n        series_convergence = MathTex(r\"\\Rightarrow \\sum_{n=1}^{\\infty} \\frac{1}{n^2} \\text{ converges}\")\n        self.play(Transform(apply_test, series_convergence))\n        self.wait(1)\n\n        # Mention the value it converges to (Basel problem)\n        convergence_value = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2} = \\frac{\\pi^2}{6}\")\n        self.play(Write(convergence_value))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"The series converges to \\\\(\\\\frac{\\\\pi^2}{6}\\\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n\n        # Clear everything\n        self.clear()\n        self.wait(1)\n\n        # Show the conclusion one more time\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video that explains the process of finding the surface area of a parametric surface, including the formula for the surface integral and the steps to compute it?",
        "answer": "\\n from manim import *\n\nclass BasicIntegralExample(Scene):\n    def construct(self):\n        # Introduce the function to be integrated\n        equation = MathTex(r\"f(x) = e^{x}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Display the integral problem\n        integral_problem = MathTex(r\"\\int e^{x} \\,dx\")\n        self.play(Transform(equation, integral_problem))\n        self.wait(2)\n\n        # Explain the integral rule for e^x\n        integration_rule_text = Text(\"The integral of e^x is e^x + C\", font_size=24).to_edge(UP)\n        self.play(Write(integration_rule_text))\n        self.wait(2)\n\n        # Show the solution using the rule\n        integral_solution = MathTex(r\"= e^{x} + C\")\n        self.play(ReplacementTransform(integral_problem, integral_solution))\n        self.wait(2)\n\n        # Highlight the constant of integration\n        constant_of_integration = MathTex(r\"+ C\").set_color(YELLOW)\n        self.play(Transform(integral_solution[-2:], constant_of_integration))\n        self.wait(1)\n\n        # Clean up the scene to show just the final result\n        self.play(FadeOut(integration_rule_text))\n        self.wait(1)\n\n        # Show the final conclusive solution\n        final_solution = MathTex(r\"\\int e^{x} \\,dx = e^{x} + C\").move_to(UP)\n        self.play(Transform(integral_solution, final_solution))\n        self.wait(2)\n        \n        # End the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that walks through the process of solving a surface integral in vector calculus, including the steps of parameterizing the surface, computing the dot product with the normal vector, and evaluating the double integral over a region? The animation should include written explanations and mathematical expressions for each step, and it should conclude by showing the formula representing the total flux across a surface.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function_tex = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explaining the area calculation\n        explanation1 = Text(\"Calculate the area under the curve from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the integral\n        integral = MathTex(r\"\\int_1^2 x^2 \\,dx\")\n        self.play(Transformation(function_tex, integral))\n        self.wait(1)\n\n        # Integration step\n        integration_result = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_1^2\")\n        self.play(ReplacementTransform(integral, integration_result))\n        self.wait(2)\n\n        # Evaluate the definite integral\n        evaluate_integral = MathTex(r\"= \\frac{2^3}{3} - \\frac{1^3}{3}\")\n        self.play(Write(evaluate_integral.move_to(integration_result)))\n        self.wait(1)\n\n        # Simplifying the result\n        simplified_result = MathTex(r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(evaluate_integral, simplified_result))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"The area is \\frac{7}{3}\")\n        self.play(Transform(simplified_result, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video that explains how to integrate the exponential function e^(2x) using the u-substitution method with step-by-step visuals and on-screen text instructions?",
        "answer": "\\n from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        grid = metal_oxid(3, 3)\n        self.add(grid)\n\n        electron_particle = electron()\n        self.add(electron_particle)\n\n        path_points = [UP * 2 + LEFT * 2, UP * 2 + RIGHT * 2, DOWN * 2 + RIGHT * 2, DOWN * 2 + LEFT * 2, UP * 2 + LEFT * 2]\n        stop_indices = [1, 3]\n        run_time = 2\n\n        animations = move_along_complex_path(electron_particle, stop_indices, path_points, run_time)\n        self.play(AnimationGroup(*animations, lag_ratio=1))"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates how to compute a triple integral step-by-step. Specifically, I want to show the triple integral of the function xyz over the unit cube [0, 1] for each variable (x, y, z). The animation should start by presenting the triple integral problem, then proceed by first integrating with respect to x, followed by y, and then z. After each integration step, the result should be displayed before moving to the next step. Can you include some written explanations before each step to clarify what is being integrated next? Finally, once the triple integral is fully evaluated, I'd like the full solution to be displayed before clearing the screen and concluding the animation.",
        "answer": "\\n import numpy as np\nfrom manim import *\n\nORBIT_WIDTH = 3.2\nORBIT_HEIGHT = 0.4\nPATH_SCALE_FACTOR = 0.5\nORBIT_RATE = 0.23\nWAIT_TIME = 20\nEARTH_START_PROPORTION = 0.738\nSUN_MOVEMENT_RATE = 1.1\nCAMERA_LAG_TIME = 3.4\nDIAGRAM_STROKE_WIDTH = 2\n# EARTH_SUN_X_DISPLACEMENT_MIN = -1.637\nEARTH_SUN_X_DISPLACEMENT_MIN = -1.6094\n# EARTH_SUN_X_DISPLACEMENT_MAX = 1.561\nEARTH_SUN_X_DISPLACEMENT_MAX = 1.5904\nLABEL_SCALE_FACTOR = 0.35\nARROW_SCALE_FACTOR = 0.4\n\n\ndef normalize(v):\n    norm = np.linalg.norm(v)\n    if norm == 0:\n        return v\n    return v / norm\n\n\nclass DraftScene(MovingCameraScene):\n    def construct(self):\n        # Earth\n        orbit_path = Ellipse(\n            width=ORBIT_WIDTH,\n            height=ORBIT_HEIGHT,\n            stroke_opacity=0,\n        )\n        self.add(orbit_path)  # TODO: Remove this\n\n        v = ValueTracker()\n        earth = Dot(color=BLUE, stroke_opacity=0).move_to(\n            orbit_path.point_from_proportion(EARTH_START_PROPORTION)\n        )\n\n        def orbit(earth):\n            alpha = (EARTH_START_PROPORTION + v.get_value() * ORBIT_RATE) % 1\n            earth.move_to(orbit_path.point_from_proportion(alpha))\n\n        earth.add_updater(orbit)\n        self.add(earth)\n\n        # Earth trail\n        last_earth_sun_distance = 0\n\n        def trail_earth(path, dt):\n            path.add_line_to(earth.get_center())\n\n            # Update the camera here, since updaters can't be added to the\n            # camera.\n            if v.get_value() >= CAMERA_LAG_TIME:\n                self.camera_frame.shift(\n                    normalize(sun_shift_direction) * SUN_MOVEMENT_RATE * dt\n                )\n\n            earth_sun_x_displacement = (sun.get_center() - earth.get_center())[0]\n\n            # if (\n            #     abs(earth_sun_x_displacement - EARTH_SUN_X_DISPLACEMENT_MIN) < 0.001\n            #     or abs(earth_sun_x_displacement - EARTH_SUN_X_DISPLACEMENT_MAX) < 0.0015\n            # ):\n            if (\n                earth_sun_x_displacement < EARTH_SUN_X_DISPLACEMENT_MIN\n                or earth_sun_x_displacement > EARTH_SUN_X_DISPLACEMENT_MAX\n            ):\n                diagram = VGroup()\n                ellipse = Ellipse(\n                    width=ORBIT_WIDTH,\n                    height=ORBIT_HEIGHT,\n                    stroke_opacity=1,\n                    stroke_color=WHITE,\n                    stroke_width=DIAGRAM_STROKE_WIDTH,\n                ).move_to(orbit_path.get_center())\n\n                sun_dot = Dot(\n                    color=WHITE, fill_opacity=0, stroke_width=DIAGRAM_STROKE_WIDTH\n                ).move_to(ellipse.get_center())\n\n                sun_shine = VGroup()\n                for theta in np.linspace(0, 2 * PI, num=8, endpoint=False):\n                    shine = Line(\n                        start=sun_dot.get_center() + sun_dot.radius * RIGHT,\n                        end=sun_dot.get_center() + (sun_dot.radius + 0.07) * RIGHT,\n                        stroke_width=DIAGRAM_STROKE_WIDTH,\n                    )\n                    shine.rotate(theta, about_point=sun_dot.get_center())\n                    sun_shine.add(shine)\n\n                earth_dot = Dot(\n                    color=WHITE, fill_opacity=0, stroke_width=DIAGRAM_STROKE_WIDTH\n                ).move_to(earth.get_center())\n\n                earth_axis_tilt_direction = normalize(UP * 1.5 + LEFT)\n                earth_axis = Line(\n                    start=earth.get_center() + earth_axis_tilt_direction * 0.15,\n                    end=earth.get_center() - earth_axis_tilt_direction * 0.15,\n                    stroke_width=DIAGRAM_STROKE_WIDTH,\n                )\n                self.add(earth_axis)\n\n                earth_label = VGroup()\n                if earth_sun_x_displacement < 0:\n                    date_tex = Tex(\n                        \"JUNE 21\", tex_template=TexFontTemplates.american_typewriter\n                    )\n                    earth_tex = Tex(\n                        \"EARTH\", tex_template=TexFontTemplates.american_typewriter\n                    ).next_to(date_tex, DOWN)\n                    earth_label.add(date_tex, earth_tex)\n                    earth_label.scale(LABEL_SCALE_FACTOR)\n                    earth_label.next_to(earth, RIGHT, buff=0.1)\n                else:\n                    earth_tex = Tex(\n                        \"EARTH\", tex_template=TexFontTemplates.american_typewriter\n                    )\n                    date_tex = Tex(\n                        \"DEC 21\", tex_template=TexFontTemplates.american_typewriter\n                    ).next_to(earth_tex, DOWN)\n                    earth_label.add(date_tex, earth_tex)\n                    earth_label.scale(LABEL_SCALE_FACTOR)\n                    earth_label.next_to(earth, LEFT, buff=0.1)\n                earth_north = (\n                    Tex(\"N\", tex_template=TexFontTemplates.american_typewriter)\n                    .scale(LABEL_SCALE_FACTOR)\n                    .next_to(earth_dot, earth_axis_tilt_direction, buff=0.1)\n                )\n                earth_north.shift(RIGHT * 0.15)\n\n                sun_label = (\n                    Tex(\"SUN\", tex_template=TexFontTemplates.american_typewriter)\n                    .scale(LABEL_SCALE_FACTOR)\n                    .next_to(sun, LEFT, buff=0.04)\n                )\n                sun_label.shift(UP * 0.07)\n\n                arrows = VGroup()\n                right_arrow = Arrow(\n                    start=LEFT, end=RIGHT * 0.3, stroke_width=DIAGRAM_STROKE_WIDTH\n                )\n                VMobject.scale(right_arrow, ARROW_SCALE_FACTOR)\n                right_arrow.next_to(ellipse, DOWN, buff=0.1)\n                right_arrow.shift(RIGHT * 0.1)\n                arrows.add(right_arrow)\n\n                left_arrow = Arrow(\n                    start=RIGHT, end=LEFT * 0.3, stroke_width=DIAGRAM_STROKE_WIDTH\n                )\n                VMobject.scale(left_arrow, ARROW_SCALE_FACTOR)\n                left_arrow.next_to(ellipse, UP, buff=0.1)\n                left_arrow.shift(LEFT * 0.1)\n                arrows.add(left_arrow)\n\n                diagram.add(\n                    ellipse,\n                    sun_dot,\n                    earth_dot,\n                    earth_label,\n                    sun_label,\n                    arrows,\n                    sun_shine,\n                    earth_north,\n                )\n                self.add(diagram)\n\n            earth_orbit_alpha = (\n                EARTH_START_PROPORTION + v.get_value() * ORBIT_RATE\n            ) % 1\n\n            if any(\n                # abs(earth_orbit_alpha - x) < 0.0075 # low quality\n                abs(earth_orbit_alpha - x) < 0.0019\n                for x in [0.15 + 0.25 * x for x in [0, 1, 2, 3]]\n            ):\n                line1 = Line(\n                    start=sun.get_center(),\n                    end=sun.get_center()\n                    + 0.6 * rotate_vector(-sun_shift_direction, -PI / 8),\n                    stroke_width=DIAGRAM_STROKE_WIDTH,\n                )\n                line2 = Line(\n                    start=sun.get_center(),\n                    end=sun.get_center()\n                    + 0.6 * rotate_vector(-sun_shift_direction, PI / 8),\n                    stroke_width=DIAGRAM_STROKE_WIDTH,\n                )\n                arrow = VGroup(line1, line2)\n                self.add(arrow)\n\n            # Don't label March when the animation first starts.\n            if v.get_value() < 0.3:\n                return\n\n            # if abs(earth_orbit_alpha - 0.3) < 0.007: # low quality\n            if abs(earth_orbit_alpha - 0.3) < 0.0019:  # low quality\n                self.add(\n                    Tex(\n                        \"SETPEMBER 23\",\n                        tex_template=TexFontTemplates.american_typewriter,\n                    )\n                    .scale(LABEL_SCALE_FACTOR)\n                    .next_to(earth, RIGHT, buff=0.1)\n                    .shift(RIGHT * 0.5 + DOWN * 0.2)\n                )\n            # elif abs(earth_orbit_alpha - 0.8) < 0.008: # low quality\n            elif abs(earth_orbit_alpha - 0.8) < 0.002:  # low quality\n                self.add(\n                    Tex(\n                        \"MARCH 21\",\n                        tex_template=TexFontTemplates.american_typewriter,\n                    )\n                    .scale(LABEL_SCALE_FACTOR)\n                    .next_to(earth, LEFT, buff=0.1)\n                    .shift(LEFT * 0.6 + DOWN * 0.15)\n                )\n\n        earth_trail = VMobject(stroke_width=DIAGRAM_STROKE_WIDTH)\n        earth_trail.points = np.array([earth.get_center()])\n        earth_trail.add_updater(trail_earth)\n        self.add(earth_trail)\n\n        # Sun\n        sun_shift_direction = ORIGIN - earth.get_center()\n        sun = Dot(color=YELLOW)\n        always_shift(sun, normalize(sun_shift_direction), rate=SUN_MOVEMENT_RATE)\n        always_shift(orbit_path, normalize(sun_shift_direction), rate=SUN_MOVEMENT_RATE)\n        self.add(sun)\n\n        # Sun trail\n        original_earth_center = earth.get_center()\n        sun_trail = Line(\n            original_earth_center, sun.get_center(), stroke_width=DIAGRAM_STROKE_WIDTH\n        )\n\n        def trail_sun(trail):\n            trail.put_start_and_end_on(original_earth_center, sun.get_center())\n\n        sun_trail.add_updater(trail_sun)\n        self.add(sun_trail)\n\n        self.play(v.set_value, WAIT_TIME, run_time=WAIT_TIME, rate_func=linear)"
    },
    {
        "query": "I want an animation that explains the concept of simple harmonic motion and its general solution equation through a series of mathematical steps. The animation should start with presenting the second-order linear differential equation that describes simple harmonic motion. Then, it should introduce the characteristic equation that is used to solve the differential equation and animate the solving process to find the characteristic roots. After that, I'd like to see the general solution to the differential equation, which combines cosine and sine terms, and end with a statement that acknowledges the resulting expression represents simple harmonic motion. Each step should be accompanied by brief textual explanations that appear at the top of the screen, and the transition between steps should be smooth and clear for educational purposes.",
        "answer": "\\n from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        atom = self.create_atom()\n        electrons = self.create_electrons(atom)\n        self.play(FadeIn(atom))\n        self.play(*[FadeIn(e) for e in electrons])\n        self.play(*[self.electron_orbit_animation(e) for e in electrons])\n        self.wait(2)\n\n    def create_atom(self) -> Mobject:\n        proton = Circle(color=PURE_RED).set_fill(PURE_RED)\n        neutron = Circle(color=GRAY_B).set_fill(GRAY_B).shift(DOWN * 0.2 + RIGHT * 0.2)\n        nucleus = VGroup(proton, neutron).arrange_in_grid(1, 2, buff=0.1)\n        return nucleus\n\n    def create_electrons(self, nucleus: Mobject) -> List[Mobject]:\n        electrons = []\n        for _ in range(2):\n            electron = Circle(color=PURE_BLUE).scale(0.1).set_fill(PURE_BLUE)\n            electron.add_updater(\n                lambda m, dt: m.move_to(nucleus.get_center() + np.array([\n                    np.cos(self.time), \n                    np.sin(self.time), \n                    0\n                ]) * 1.5)\n            )\n            electrons.append(electron)\n        return electrons\n\n    def electron_orbit_animation(self, electron: Mobject) -> Animation:\n        return Rotate(electron, angle=2 * PI, about_point=electron.get_center(), run_time=2, rate_func=linear)"
    },
    {
        "query": "Could you create an animation explaining the process of integrating cosine squared using the power-reduction trigonometric identity, showing step-by-step calculations and providing brief verbal explanations for each step?",
        "answer": "\\n import manim as mn\nimport numpy as np\n\ndef regular_vertices(n, *, radius=1, start_angle=None):\n    if start_angle is None:\n        if n % 2 == 0:\n            start_angle = 0\n        else:\n            start_angle = mn.TAU / 4\n\n    start_vector = mn.rotate_vector(mn.RIGHT * radius, start_angle)\n    vertices     = mn.compass_directions(n, start_vector)\n\n    return vertices, start_angle\n\nclass Star(mn.Polygon):\n    def __init__(self, n=5, *, density=2, outer_radius=1, inner_radius=None, start_angle=None, **kwargs):\n        if density <= 0 or density >= n / 2:\n            raise ValueError(f\"Incompatible density {density}\")\n\n        inner_angle = mn.TAU / (2 * n)\n\n        if inner_radius is None:\n            # Calculate the inner radius for n and density.\n            # See https://math.stackexchange.com/a/2136292\n\n            outer_angle = mn.TAU * density / n\n\n            inverse_x = 1 - np.tan(inner_angle) * ((np.cos(outer_angle) - 1) / np.sin(outer_angle))\n\n            inner_radius = outer_radius / (np.cos(inner_angle) * inverse_x)\n\n        outer_vertices, self.start_angle = regular_vertices(n, radius=outer_radius, start_angle=start_angle)\n        inner_vertices, _                = regular_vertices(n, radius=inner_radius, start_angle=self.start_angle + inner_angle)\n\n        vertices = []\n        for pair in zip(outer_vertices, inner_vertices):\n            vertices.extend(pair)\n\n        super().__init__(*vertices, **kwargs)\n\nclass ModularMultiplier(mn.Group):\n    def __init__(self, mobject, *, modulus, factor, rate_func=mn.linear, line_config=None, **kwargs):\n        super().__init__(**kwargs)\n\n        self.mobject   = mobject.copy()\n        self.modulus   = modulus\n        self.factor    = mn.ValueTracker(factor)\n        self.rate_func = rate_func\n\n        self.add(self.mobject)\n\n        if line_config is None:\n            line_config = {}\n\n        self.line_config = line_config\n        self.init_lines()\n        mn.always(self.update_lines)\n\n    def number_to_point(self, n):\n        n %= self.modulus\n        n /= self.modulus\n\n        return self.mobject.point_from_proportion(self.rate_func(n))\n\n    def n2p(self, n):\n        return self.number_to_point(n)\n\n    def init_lines(self):\n        self.lines = mn.VGroup()\n        self.add_to_back(self.lines)\n\n        factor = self.factor.get_value()\n        for n in range(self.modulus):\n            n_point    = self.n2p(n)\n            mult_point = self.n2p(n * factor)\n\n            line = mn.Line(n_point, mult_point, **self.line_config)\n            self.lines.add(line)\n\n    def update_lines(self):\n        factor = self.factor.get_value()\n\n        for n, line in enumerate(self.lines):\n            n_point    = self.n2p(n)\n            mult_point = self.n2p(n * factor)\n\n            line.set_start_and_end_attrs(n_point, mult_point)\n            line.generate_points()\n\nclass ModularScene(mn.Scene):\n    def construct(self):\n        mod = ModularMultiplier(\n            Star(outer_radius=3, color=mn.BLUE),\n\n            modulus = 300,\n            factor  = 1,\n\n            line_config = {\n                \"stroke_width\": 1,\n            },\n        )\n\n        mod_var    = mn.Tex(\"Modulus\", \"$=$\", f\"${mod.modulus}$\")\n        factor_var = mn.Variable(mod.factor.get_value(), mn.Tex(\"Factor\"))\n\n        # Arrange mod_var so it lines up well with factor_var's elements\n        mod_var[2].align_to(factor_var, mn.UR)\n        mod_var[1].next_to(factor_var.label[0], mn.RIGHT)\n        mod_var[0].next_to(mod_var[1], mn.LEFT)\n        mod_var.shift((factor_var.height + 0.25) * mn.UP)\n\n        factor_var.add_updater(lambda v: v.tracker.set_value(mod.factor.get_value()))\n\n        info = mn.VGroup(mod_var, factor_var)\n        info.to_corner(mn.UR)\n\n        self.add(info, mod)\n\n        self.animate_factors(mod, [2, 1])\n\n    def animate_factors(self, mod, iterable, *, wait=0.3, run_time=2, **kwargs):\n        for f in iterable:\n            self.play(mod.factor.animate.set_value(f), run_time=run_time, **kwargs)\n            self.wait(wait)"
    },
    {
        "query": "I would like to create an educational animation that explains a third-order ordinary differential equation and its solution process. The animation should start by displaying the differential equation \"y''' - 3y'' + 3y' - y = 0\". Then, it should introduce the concept of the characteristic equation with a title and show the characteristic polynomial \"r^3 - 3r^2 + 3r - 1 = 0\", transitioning from the differential equation. I would like the next part of the animation to instruct on how to solve the characteristic polynomial with a new title and then display its roots, specifically if the root is \"r = 1\". Finally, the animation should reveal the general solution \"y = C_1 e^{x} + C_2 x e^{x} + C_3 x^2 e^{x}\" to the ODE with an explanation title, followed by clearing the scene and reiterating the general solution at the end. Each step should be shown clearly with pauses in between for emphasis.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ApplyWave\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Mathematical Animations\")\n            self.play(ApplyWave(some_text))\n            self.play(ApplyWave(some_text, direction=RIGHT))\n            self.remove(some_text)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates how to calculate the definite integral of x cubed from 0 to 2 using the power rule for integration, showing each step of the process including the integral setup, application of the power rule, evaluation of the integral at the bounds, and the final simplified solution, with explanatory texts for each step and pauses between them?",
        "answer": "\\n from manim import *\n\n\nclass DraftScene(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n\n        def line_to_normal(line, rotation_direction=\"CLOCKWISE\"):\n            if rotation_direction == \"CLOCKWISE\":\n                return normalize(\n                    rotate_vector(line.get_end() - line.get_start(), PI / 2)\n                )\n            elif rotation_direction == \"COUNTERCLOCKWISE\":\n                return normalize(\n                    rotate_vector(line.get_end() - line.get_start(), -PI / 2)\n                )\n            else:\n                raise Exception(rotation_direction)\n\n        def get_h(triangle):\n            h = Line(\n                ORIGIN,\n                ORIGIN\n                + normalize(\n                    rotate_vector(\n                        triangle[\"c\"].get_end() - triangle[\"c\"].get_start(), PI / 2\n                    )\n                ),\n            )\n            h.shift(triangle_points[\"C\"] - h.get_start())\n\n            triangle_points[\"D\"] = line_intersection(\n                triangle[\"c\"].get_start_and_end(), h.get_start_and_end()\n            )\n            h_length = get_norm(triangle_points[\"D\"] - triangle_points[\"C\"])\n\n            h.put_start_and_end_on(\n                h.get_start(),\n                h.get_start()\n                + normalize(\n                    rotate_vector(\n                        triangle[\"c\"].get_end() - triangle[\"c\"].get_start(), PI / 2\n                    )\n                )\n                * h_length,\n            )\n            h.shift(triangle_points[\"C\"] - h.get_start())\n            return h\n\n        triangle_points = {\n            \"A\": LEFT * 2.7 + UP * 1.7,\n            \"B\": RIGHT * 2.7 + DOWN * 1.3,\n            \"C\": LEFT * 2.7 + DOWN * 1.3,\n        }\n        lines = [\n            Line(triangle_points[\"A\"], triangle_points[\"B\"]),\n            Line(triangle_points[\"B\"], triangle_points[\"C\"]),\n            Line(triangle_points[\"C\"], triangle_points[\"A\"]),\n        ]\n        triangle = VDict(\n            {\n                \"c\": lines[0],\n                \"a\": lines[1],\n                \"b\": lines[2],\n                \"c_label\": MathTex(\"c\").move_to(\n                    lines[0].get_center() + line_to_normal(lines[0]) * 0.3\n                ),\n                \"a_label\": MathTex(\"a\").move_to(\n                    lines[1].get_center() + line_to_normal(lines[1]) * 0.3\n                ),\n                \"b_label\": MathTex(\"b\").move_to(\n                    lines[2].get_center() + line_to_normal(lines[2]) * 0.3\n                ),\n            }\n        )\n        # self.play(ShowCreation(triangle))\n        self.play(\n            ShowCreation(VGroup(triangle[\"a\"], triangle[\"b\"], triangle[\"c\"])),\n        )\n        self.play(\n            Write(\n                VGroup(triangle[\"a_label\"], triangle[\"b_label\"], triangle[\"c_label\"])\n            ),\n        )\n        self.wait(0.5)\n\n        triangle.add({\"h\": get_h(triangle)})\n        triangle.add(\n            {\n                \"h_label\": MathTex(\"h\").move_to(\n                    triangle[\"h\"].get_center()\n                    + line_to_normal(\n                        triangle[\"h\"], rotation_direction=\"COUNTERCLOCKWISE\"\n                    )\n                    * 0.3\n                )\n            }\n        )\n        self.play(ShowCreation(triangle[\"h\"]))\n        self.play(Write(triangle[\"h_label\"]))\n\n        def get_triangle_area(points, color, opacity=0.7):\n            return (\n                Polygon(*points)\n                .set_fill(color=color, opacity=opacity)\n                .set_stroke(color=color)\n            )\n\n        triangle_area_positions = {\n            \"ABC\": UP * 2.5 + LEFT * 2,\n            \"ADC\": UP * 2.5 + LEFT * 0.1,\n            \"BDC\": UP * 2.5 + RIGHT * 1.6,\n        }\n\n        # Animate full triangle area.\n        ABC_area = get_triangle_area(\n            [triangle_points[\"A\"], triangle_points[\"B\"], triangle_points[\"C\"]], BLUE\n        )\n        self.play(FadeIn(ABC_area))\n        ABC_area.generate_target().scale(0.3).move_to(triangle_area_positions[\"ABC\"])\n        self.play(MoveToTarget(ABC_area))\n        self.wait(0.5)\n\n        ADC_area = get_triangle_area(\n            [triangle_points[\"A\"], triangle_points[\"D\"], triangle_points[\"C\"]], ORANGE\n        )\n        ADC_area.generate_target().scale(0.3).move_to(triangle_area_positions[\"ADC\"])\n        triangle_area_equals = MathTex(\"=\").next_to(ABC_area.target, RIGHT, buff=0.1)\n\n        BDC_area = get_triangle_area(\n            [triangle_points[\"B\"], triangle_points[\"D\"], triangle_points[\"C\"]], GREEN\n        )\n        triangle_area_plus = MathTex(\"+\").next_to(triangle_area_equals, RIGHT, buff=1.2)\n        BDC_area.generate_target().scale(0.3).move_to(triangle_area_positions[\"BDC\"])\n\n        # Animate partial triangle areas.\n        self.play(FadeIn(ADC_area), FadeIn(BDC_area))\n        self.play(\n            MoveToTarget(ADC_area),\n            MoveToTarget(BDC_area),\n            FadeIn(triangle_area_equals),\n            FadeIn(triangle_area_plus),\n        )\n        self.wait(0.8)\n\n        half_a_b = MathTex(\"\\\\frac{1}{2}ab\").move_to(\n            ABC_area.get_center() + RIGHT * 0.3\n        )\n        self.play(ReplacementTransform(ABC_area, half_a_b))\n        self.wait(0.3)\n\n        short_leg_length = Line(\n            triangle_points[\"D\"], triangle_points[\"A\"], stroke_color=ORANGE\n        )\n        short_leg_variable = MathTex(\"x\", color=ORANGE).move_to(\n            triangle_points[\"A\"] + (UP + LEFT) * 0.2\n        )\n        self.play(ShowCreation(short_leg_length), FadeIn(short_leg_variable))\n        self.wait(0.3)\n\n        half_h_x = MathTex(\"\\\\frac{1}{2}hx\").move_to(ADC_area.get_center())\n        self.play(ReplacementTransform(ADC_area, half_h_x))\n        self.wait(0.3)\n\n        long_leg_length = Line(\n            triangle_points[\"D\"], triangle_points[\"B\"], stroke_color=GREEN\n        )\n        long_leg_variable = MathTex(\"y\", color=GREEN).move_to(\n            triangle_points[\"B\"] + (DOWN + RIGHT) * 0.2\n        )\n        self.play(ShowCreation(long_leg_length), FadeIn(long_leg_variable))\n        self.wait(0.3)\n\n        half_h_y = MathTex(\"\\\\frac{1}{2}hy\").move_to(BDC_area.get_center() + LEFT * 0.2)\n        self.play(ReplacementTransform(BDC_area, half_h_y))\n        self.wait(0.8)\n\n        self.play(\n            FadeOut(VGroup(half_a_b[0][0:3])),\n            FadeOut(VGroup(half_h_x[0][0:3])),\n            FadeOut(VGroup(half_h_y[0][0:3])),\n        )\n\n        ab_equals_h_x_plus_y = MathTex(\"ab=h(x+y)\").move_to(UP * 2.46)\n        self.play(\n            ReplacementTransform(\n                VGroup(half_a_b[0][3:]), VGroup(ab_equals_h_x_plus_y[0][0:2])\n            ),\n            ReplacementTransform(triangle_area_equals, ab_equals_h_x_plus_y[0][2]),\n            ReplacementTransform(triangle_area_plus, ab_equals_h_x_plus_y[0][6]),\n            ReplacementTransform(half_h_x[0][3], ab_equals_h_x_plus_y[0][3]),\n            FadeIn(ab_equals_h_x_plus_y[0][4]),\n            ReplacementTransform(half_h_x[0][4], ab_equals_h_x_plus_y[0][5]),\n            ReplacementTransform(half_h_y[0][4], ab_equals_h_x_plus_y[0][7]),\n            ReplacementTransform(half_h_y[0][3], ab_equals_h_x_plus_y[0][3]),\n            FadeIn(ab_equals_h_x_plus_y[0][8]),\n        )\n        self.wait(0.8)\n\n        ab_equals_hc = MathTex(\"ab=hc\")\n        ab_equals_hc.shift(\n            ab_equals_h_x_plus_y[0][0].get_center() - ab_equals_hc[0][0].get_center()\n        )\n        self.play(\n            ReplacementTransform(ab_equals_h_x_plus_y[0][0], ab_equals_hc[0][0]),\n            ReplacementTransform(ab_equals_h_x_plus_y[0][1], ab_equals_hc[0][1]),\n            ReplacementTransform(ab_equals_h_x_plus_y[0][2], ab_equals_hc[0][2]),\n            ReplacementTransform(ab_equals_h_x_plus_y[0][3], ab_equals_hc[0][3]),\n            ReplacementTransform(\n                VGroup(ab_equals_h_x_plus_y[0][4:]), ab_equals_hc[0][4]\n            ),\n            FadeOut(\n                VGroup(\n                    long_leg_length,\n                    long_leg_variable,\n                    short_leg_length,\n                    short_leg_variable,\n                )\n            ),\n        )\n        self.wait(0.5)\n\n        ab_over_h_equals_c = MathTex(\"\\\\frac{ab}{h}=c\").move_to(\n            ab_equals_hc.get_center()\n        )\n        self.play(\n            ReplacementTransform(\n                VGroup(ab_equals_hc[0][0:2]), VGroup(ab_over_h_equals_c[0][0:2])\n            ),\n            FadeIn(ab_over_h_equals_c[0][2]),\n            ReplacementTransform(ab_equals_hc[0][3], ab_over_h_equals_c[0][3]),\n            ReplacementTransform(ab_equals_hc[0][2], ab_over_h_equals_c[0][4]),\n            ReplacementTransform(ab_equals_hc[0][4], ab_over_h_equals_c[0][5]),\n        )\n        self.wait(0.8)\n\n        self.play(\n            ab_over_h_equals_c.animate.shift(LEFT * 2),\n            triangle.animate.shift(LEFT * 3),\n        )\n\n        pythagorean_theorem_text = MathTex(\n            \"\\\\underline{\\\\text{Pythagorean Theorem}}\"\n        ).shift(RIGHT * 3 + UP * 3)\n        pythagorean_theorem = MathTex(\"a^2 + b^2 = c^2\").next_to(\n            pythagorean_theorem_text, DOWN\n        )\n        self.play(Write(pythagorean_theorem_text))\n        self.wait(0.5)\n        self.play(Write(pythagorean_theorem), run_time=1.5)\n        self.wait(0.8)\n\n        pythagorean_substitution = MathTex(\n            \"a^2 + b^2 = \\\\left(\\\\frac{ab}{h}\\\\right)^2\"\n        ).next_to(pythagorean_theorem, DOWN, buff=0.1)\n        self.play(\n            ReplacementTransform(\n                VGroup(pythagorean_theorem[0][:6]).copy(),\n                VGroup(pythagorean_substitution[0][:6]),\n            ),\n            FadeIn(\n                VGroup(pythagorean_substitution[0][6], pythagorean_substitution[0][11])\n            ),\n            ReplacementTransform(\n                VGroup(ab_over_h_equals_c[0][0:4]).copy(),\n                VGroup(pythagorean_substitution[0][7:11]),\n            ),\n            ReplacementTransform(\n                pythagorean_theorem[0][7],\n                pythagorean_substitution[0][12],\n            ),\n            run_time=1.5,\n        )\n        self.wait(0.8)\n\n        pythagorean_substitution_2 = MathTex(\n            \"a^2\", \"+\", \"b^2\", \"=\", \"\\\\frac{a^2b^2}{h^2}\"\n        ).next_to(pythagorean_substitution, DOWN)\n        self.play(\n            # Transform squares\n            ReplacementTransform(\n                pythagorean_substitution[0][-1].copy(), pythagorean_substitution_2[4][1]\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][-1].copy(), pythagorean_substitution_2[4][3]\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][-1].copy(), pythagorean_substitution_2[4][6]\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][0].copy(),\n                pythagorean_substitution_2[0][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][1].copy(),\n                pythagorean_substitution_2[0][1],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][2].copy(),\n                pythagorean_substitution_2[1][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][3].copy(),\n                pythagorean_substitution_2[2][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][4].copy(),\n                pythagorean_substitution_2[2][1],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][5].copy(),\n                pythagorean_substitution_2[3][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][7].copy(),\n                pythagorean_substitution_2[4][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][8].copy(),\n                pythagorean_substitution_2[4][2],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][9].copy(),\n                pythagorean_substitution_2[4][4],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution[0][10].copy(),\n                pythagorean_substitution_2[4][5],\n            ),\n        )\n        self.wait(0.8)\n\n        pythagorean_substitution_3 = MathTex(\n            \"\\\\frac{a^2}{a^2b^2}\", \"+\", \"\\\\frac{b^2}{a^2b^2}\", \"=\", \"\\\\frac{1}{h^2}\"\n        ).next_to(pythagorean_substitution_2, DOWN)\n        self.play(\n            ReplacementTransform(\n                VGroup(pythagorean_substitution_2[4][:4]).copy(),\n                VGroup(pythagorean_substitution_3[0][3:]),\n            ),\n            ReplacementTransform(\n                VGroup(pythagorean_substitution_2[4][:4]).copy(),\n                VGroup(pythagorean_substitution_3[2][3:]),\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[0][0].copy(),\n                pythagorean_substitution_3[0][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[0][1].copy(),\n                pythagorean_substitution_3[0][1],\n            ),\n            FadeIn(pythagorean_substitution_3[0][2]),\n            ReplacementTransform(\n                pythagorean_substitution_2[1].copy(), pythagorean_substitution_3[1]\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[2][0].copy(),\n                pythagorean_substitution_3[2][0],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[2][1].copy(),\n                pythagorean_substitution_3[2][1],\n            ),\n            FadeIn(pythagorean_substitution_3[2][2]),\n            ReplacementTransform(\n                pythagorean_substitution_2[3].copy(), pythagorean_substitution_3[3]\n            ),\n            FadeIn(pythagorean_substitution_3[4][0]),\n            ReplacementTransform(\n                pythagorean_substitution_2[4][4].copy(),\n                pythagorean_substitution_3[4][1],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[4][5].copy(),\n                pythagorean_substitution_3[4][2],\n            ),\n            ReplacementTransform(\n                pythagorean_substitution_2[4][6].copy(),\n                pythagorean_substitution_3[4][3],\n            ),\n        )\n        self.wait(0.8)\n\n        crossed_tex = [\n            VGroup(pythagorean_substitution_3[0][:2]),\n            VGroup(pythagorean_substitution_3[0][3:5]),\n            VGroup(pythagorean_substitution_3[2][:2]),\n            VGroup(pythagorean_substitution_3[2][5:7]),\n        ]\n        crosses = []\n        for tex in crossed_tex:\n            crosses.append(Line(tex.get_critical_point(DL), tex.get_critical_point(UR)))\n        self.play(*[ShowCreation(cross) for cross in crosses])\n        self.wait(0.8)\n\n        inverse_pythagorean_theorem = MathTex(\n            \"\\\\frac{1}{a^2} + \\\\frac{1}{b^2} = \\\\frac{1}{h^2}\"\n        ).next_to(pythagorean_substitution_3, DOWN)\n        self.play(Write(inverse_pythagorean_theorem), run_time=3)\n        self.play(\n            AnimationOnSurroundingRectangle(\n                inverse_pythagorean_theorem,\n                ShowCreation,\n                surrounding_rectangle_config={\"color\": BLACK},\n            )\n        )\n\n        # Position labels for each side.\n        self.wait()"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the process of solving a double integral in polar coordinates, specifically the integral from 0 to 2\u03c0 of the integral from 0 to 1 of r^2 with respect to r and theta? Start by showing the integral problem on the screen, then explain and animate the solution of the inner integral with respect to r, followed by solving the outer integral with respect to theta, and conclude by showing the final area calculation result.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"AnimatedBoundary\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            animated_boundary = AnimatedBoundary(circle, cycle_rate=3, colors=[RED, GREEN, BLUE])\n            self.add(circle, animated_boundary)\n            self.wait(2)\n            self.remove(circle, animated_boundary)"
    },
    {
        "query": "Could you create an educational animation that visually demonstrates how to solve the integral of x squared times e to the x using integration by parts, including the step-by-step process and the final solution?",
        "answer": "\\n from manim import *\n\nclass CircleAreaExample(Scene):\n    def construct(self):\n        # Present the problem\n        problem = MathTex(r\"A = \\pi r^2\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Show the circle and radius\n        circle = Circle(color=BLUE)\n        radius = Line(start=ORIGIN, end=RIGHT).shift(LEFT).set_color(YELLOW)\n        radius_label = MathTex(r\"r\").next_to(radius, DOWN)\n        self.play(Create(circle), GrowFromCenter(radius), Write(radius_label))\n        self.wait(2)\n\n        # Present the formula for circle area\n        formula = MathTex(r\"A = \\pi \\cdot\", \"r\", \"^2\")\n        self.play(Transform(problem, formula))\n        self.wait(2)\n\n        # Calculate the area with a specific radius\n        specific_radius = MathTex(r\"r = 2\")\n        specific_area = MathTex(r\"A = \\pi \\cdot 2^2 = 4\\pi\")\n        self.play(Write(specific_radius))\n        self.wait(1)\n        self.play(ReplacementTransform(formula.copy(), specific_area))\n        self.wait(1)\n\n        # Show the new area in the circle\n        updated_area = problem.copy().shift(DOWN * 2)\n        self.play(Transform(problem, specific_area), MoveToTarget(updated_area))\n        self.wait(1)\n\n        # Clear the scene and finish\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"The area of the circle is 4 pi\", font_size=24)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that illustrates the dynamics of a harmonic oscillator, starting with the display of its differential equation on screen, then explaining the concept of angular frequency, followed by transforming the equation to include the angular frequency, and finally showing the general solution of the equation? Additionally, please visualize the harmonic motion by animating a dot moving along a circular path and conclude the animation with a recap text about harmonic oscillator dynamics.",
        "answer": "\\n class RateFuncDemo(Scene):\n    def construct(self):\n        props = [\n            (\"smooth\", X11.SIENNA1),\n            (\"smoothstep\", X11.SIENNA2),\n            (\"smootherstep\", X11.SIENNA3),\n            (\"smoothererstep\", X11.SIENNA4)\n        ]\n        squares = VGroup()\n        for label_text, color in props:\n            col_square = Square()\n            col_square.set_fill(color, opacity=1)\n            col_square.set_stroke(opacity=0)\n            label = Text(label_text, font_size=24, font=\"Monospace\")\n            label.next_to(col_square, UP)\n            col_square.add(label)\n            squares.add(col_square)\n            \n        squares.arrange(RIGHT, buff=1).shift(2*UP)\n        self.add(squares)\n        \n        progress = VDict({\n            \"line\": Line(4*LEFT, 4*RIGHT),\n            \"marker\": Dot(radius=0.15)\n        })\n        progress[\"marker\"].move_to(progress[\"line\"].point_from_proportion(0))\n        progress.next_to(squares, UP)\n        self.add(progress)\n        \n        anims = []\n        for ind, (rate_name, _) in enumerate(props):\n            rate_func = getattr(rate_functions, rate_name)\n            anims.append(squares[ind].animate(run_time=4, rate_func=rate_func).shift(4*DOWN))\n        \n        self.wait()\n        self.play(\n            *anims, \n            UpdateFromAlphaFunc(\n                progress, \n                lambda mobj, alpha: mobj[\"marker\"].move_to(mobj[\"line\"].point_from_proportion(alpha)),\n                run_time=4,\n                rate_func=linear,\n            )\n        )\n        self.wait()"
    },
    {
        "query": "Create an animated video that explains step by step how to solve the double integral of r^2*sin(\u03b8) with respect to r and \u03b8 over the limits from 0 to 1 for r and from 0 to \u03c0 for \u03b8, using polar coordinates. The animation should include writing out the integral problem, the process of integrating with respect to r first followed by \u03b8, and showing the intermediate steps. Each step should be accompanied by brief textual explanations of what the step involves, and the video should conclude with evaluating the antiderivative at the limits to find the final solution. The steps should appear sequentially, with each new step replacing the previous one, and there should be brief pauses for viewers to follow along.",
        "answer": "\\n from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the concept of finding the area under the curve of the function x squared between 0 and 2, by showing the integral symbol with the limits and the function, highlighting the area under the curve with color, and then explaining with text that this represents the area from 0 to 2? Also, can you show the antiderivative of the function being evaluated at the limits and finishing with the numeric value of the definite integral, followed by clearing everything except for the final solution?",
        "answer": "\\n from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef add_to_back(self, *mobjects):\n    all_mobjects = [*self.mobjects]\n\n    self.remove(*self.mobjects)\n    self.add(*mobjects, *all_mobjects)\n\nclass GraphTwo(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        table = Table(\n            [\n                [\"Pablo\", \"Banana\"],\n                [\"Gabriela\", \"Morango\"],\n                [\"Bianca\", \"Laranja\"],\n                [\"Murilo\", \"Morango\"],\n                [\"Heitor\", \"Banana\"],\n                [\"Isabela\", \"Banana\"],\n            ],\n            col_labels=[Text(\"Nome\"), Text(\"Fruta Favorita\")],\n            include_outer_lines=True\n        )\n        table.get_vertical_lines().set(color=BLACK)\n        table.get_horizontal_lines().set(color=BLACK)\n        table.get_entries().set(color=BLACK)\n        table.scale(0.5)\n        circle = Circle(2, color=BLACK)\n        legend = VGroup(\n            VGroup(\n                Square(0.3, fill_opacity=1, color=LIGHT_YELLOW_COLOR), \n                Tex(\"Banana\", color=BLACK).scale(0.5)\n            ).arrange(RIGHT),\n            VGroup(\n                Square(0.3, fill_opacity=1, color=LIGHT_ORANGE_COLOR), \n                Tex(\"Laranja\", color=BLACK).scale(0.5)\n            ).arrange(RIGHT),\n            VGroup(\n                Square(0.3, fill_opacity=1, color=LIGHT_RED_COLOR), \n                Tex(\"Morango\", color=BLACK).scale(0.5)\n            ).arrange(RIGHT)\n        ).arrange(DOWN, aligned_edge=LEFT)\n        table.shift(3.3 * UP)\n        graph = Group(circle, legend)\n        legend.shift(3 * RIGHT)\n        graph.shift(3.4 * DOWN)\n        basic_line = Line(circle.get_center(), circle.get_top(), color=BLACK)\n        auxiliary_lines = VGroup(\n            basic_line.copy(),\n            basic_line.copy().rotate(PI / 3, about_point=basic_line.get_bottom()),\n            basic_line.copy().rotate(2 * PI / 3, about_point=basic_line.get_bottom()),\n            basic_line.copy().rotate(PI, about_point=basic_line.get_bottom()),\n            basic_line.copy().rotate(4 * PI / 3, about_point=basic_line.get_bottom()),\n            basic_line.copy().rotate(5 * PI / 3, about_point=basic_line.get_bottom())\n        )\n        banana_angle = ValueTracker(0)\n        banana_max_angle = PI\n        banana_sector = always_redraw(lambda: \n            AnnularSector(0, 2, banana_angle.get_value(), PI/2, stroke_width=0, color=LIGHT_YELLOW_COLOR, fill_opacity=1)\n                .shift(3.4 * DOWN)\n        )\n        strawberry_angle = ValueTracker(0)\n        strawberry_max_angle = 2 * PI / 3\n        strawberry_sector = always_redraw(lambda: \n            AnnularSector(0, 2, strawberry_angle.get_value(), 6*PI/4, stroke_width=0, color=LIGHT_RED_COLOR, fill_opacity=1)\n                .shift(3.4 * DOWN)\n        )\n        orange_angle = ValueTracker(0)\n        orange_max_angle = PI / 3\n        orange_sector = always_redraw(lambda:\n            AnnularSector(0, 2, orange_angle.get_value(), 13*PI/6, stroke_width=0, color=LIGHT_ORANGE_COLOR, fill_opacity=1)\n                .shift(3.4 * DOWN)\n        )\n\n        self.add(table)\n        self.play(FadeIn(graph), run_time=0.5)\n        self.play(FadeIn(auxiliary_lines), run_time=0.5)\n        self.wait(1)\n        \n        banana_cells = Group(\n            table.get_highlighted_cell((2, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((2, 2), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((6, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((6, 2), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((7, 1), color=LIGHT_YELLOW_COLOR),\n            table.get_highlighted_cell((7, 2), color=LIGHT_YELLOW_COLOR)\n        )\n        add_to_back(self, banana_cells, banana_sector)\n\n        self.play(FadeIn(banana_cells), run_time=0.5)\n        self.play(banana_angle.animate.set_value(banana_max_angle), run_time=2)\n        self.play(FadeOut(banana_cells), run_time=0.5)\n\n        banana_sector.clear_updaters()\n        strawberry_cells = Group(\n            table.get_highlighted_cell((3, 1), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((3, 2), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((5, 1), color=LIGHT_RED_COLOR),\n            table.get_highlighted_cell((5, 2), color=LIGHT_RED_COLOR)\n        )\n        add_to_back(self, strawberry_cells, strawberry_sector)\n\n\n        self.play(FadeIn(strawberry_cells), run_time=0.5)\n        self.play(strawberry_angle.animate.set_value(strawberry_max_angle), run_time=1.5)\n        self.play(FadeOut(strawberry_cells), run_time=0.5) \n\n        strawberry_sector.clear_updaters()\n        orange_cells = Group(\n            table.get_highlighted_cell((4, 1), color=LIGHT_ORANGE_COLOR),\n            table.get_highlighted_cell((4, 2), color=LIGHT_ORANGE_COLOR)\n        )\n        add_to_back(self, orange_cells, orange_sector)\n\n        self.play(FadeIn(orange_cells), run_time=0.5)\n        self.play(orange_angle.animate.set_value(orange_max_angle), run_time=1)\n        self.play(\n            FadeOut(auxiliary_lines[1]),\n            FadeOut(auxiliary_lines[2]),\n            FadeOut(auxiliary_lines[4]),\n            FadeOut(orange_cells), \n            run_time=0.5\n        )\n\n        orange_sector.clear_updaters()      \n\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.7)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Can you create an animated video that explains the classical wave equation using visual aids? The video should begin by displaying the mathematical formula of the wave equation. After showing the formula, add a brief text description stating \"This is the classical wave equation.\" Then, proceed to clarify that in the equation, the 'c' symbol represents the speed of waves with another piece of text. Next, replace the wave equation with the general solution formula for a one-dimensional wave and accompany it with text that explains it's the general solution for the one-dimensional wave equation. Finally, clear all previous content and conclude the video by showing just the solution formula on the screen.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} (r^2 \\sin(\\theta))\\,r\\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{r^4}{4} \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4} \\sin(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Conclusion of solution\n        conclusion = MathTex(r\"= 0\")\n        self.play(Transform(final_solution, conclusion))\n        self.wait(2)\n\n        # Final message\n        final_message = Text(\"The polar double integral evaluates to 0\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_message))\n        self.wait(3)"
    },
    {
        "query": "Can you create an animated video that shows the steps to solve the definite integral of x cubed from 0 to 2, including the application of the Fundamental Theorem of Calculus and the evaluation of the integral at the given bounds, concluding with the final numerical result?",
        "answer": "\\n from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying Trigonometric Substitution Problem\n        problem = MathTex(r\"\\int \\frac{1}{\\sqrt{1-x^2}} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric substitution\n        explanation1 = Text(\"Use trigonometric substitution:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Choosing a substitution\n        substitution = MathTex(r\"x = \\sin(\\theta), dx = \\cos(\\theta) d\\theta\")\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Showing substituted integral\n        substituted_integral = MathTex(r\"= \\int \\frac{\\cos(\\theta)}{\\sqrt{1-\\sin^2(\\theta)}} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), substituted_integral))\n        self.wait(1)\n\n        # Simplify the integral using pythagorean identity\n        simplified_integral = MathTex(r\"= \\int \\cos(\\theta) d\\theta\")\n        self.play(Transform(substituted_integral, simplified_integral))\n        self.wait(2)\n\n        # Solve the integral\n        integral_solution = MathTex(r\"= \\sin(\\theta) + C\")\n        self.play(Transform(simplified_integral, integral_solution))\n        self.wait(1)\n\n        # Back substitution\n        back_substitution = Text(\"Back substitute to get the answer in terms of x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, back_substitution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\arcsin(x) + C\")\n        self.play(Transform(integral_solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated educational video that explains how to solve the first order ordinary differential equation y' - 3y = 0 using the separation of variables method, including steps to integrate and solve for y to find the general solution, and display this process step-by-step with equations, while providing brief textual explanations of each step at the top of the screen?",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass Introduction(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = VGroup(\n            Tex(\"Sequ\u00eancias\"), \n            Tex(\"Num\u00e9ricas\")\n        )\n        title.arrange(DOWN)\n\n        inner_box = Square(2.7, stroke_color=WHITE)\n        outer_box = Square(3.7, color=RED, fill_opacity=1, stroke_color=WHITE)\n\n        number_group_1 = ImageMobject(\"./assets/NumberGroup1.png\")\n        number_group_1.next_to(outer_box, LEFT)\n        number_group_1.shift(7 * UP + 1.7 * RIGHT)\n        number_group_1.scale(0.4)\n\n        number_group_2 = ImageMobject(\"./assets/NumberGroup2.png\")\n        number_group_2.next_to(outer_box, RIGHT)\n        number_group_2.shift(7 * UP + 2.1 * LEFT)\n        number_group_2.scale(0.4)\n\n        rectangle_group_1 = Rectangle(color=RED, height=0.05, width=2, fill_opacity=1)\n        rectangle_group_1.next_to(outer_box, LEFT)\n        rectangle_group_1.shift(0.6 * UP + 0.2 * RIGHT)\n\n        rectangle_group_2 = Rectangle(color=RED, height=0.05, width=2.5, fill_opacity=1)\n        rectangle_group_2.next_to(outer_box, RIGHT)\n        rectangle_group_2.shift(0.6 * DOWN + 0.2 * LEFT)\n        \n\n        self.play(\n            FadeIn(rectangle_group_1),\n            FadeIn(rectangle_group_2),\n            FadeIn(outer_box),\n            FadeIn(inner_box),\n            FadeIn(title)\n        )\n        self.play(\n            number_group_1.animate.shift(6 * DOWN), \n            rate_func=rate_functions.rush_from\n        )\n        self.wait(0.8)\n        self.play(\n            number_group_2.animate.shift(7.2 * DOWN), \n            rate_func=rate_functions.rush_from, \n            run_time=1.2\n        )\n        self.wait(1.5)\n        self.play(*[\n            mobject.animate(rate_func=running_start, run_time=1.3).shift(LEFT * 15) \n            for mobject in self.mobjects\n        ])\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Please create an educational animation that shows how to calculate the area under the curve of the function f(x) = x^2, specifically from x=1 to x=2, including a visual representation of the area, the integral notation, and the step-by-step calculation leading to the final solution.",
        "answer": "\\n from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for the series convergence test\n        explanation1 = Text(\"Use the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the p-test\n        p_test = MathTex(r\"p=2\", r\"> 1\").next_to(series, DOWN)\n        self.play(Write(p_test))\n        self.wait(1)\n\n        # Explanation for the convergence of the series\n        explanation2 = Text(\"Since p > 1, the series converges\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Conclusion about the series convergence\n        conclusion = MathTex(r\"\\text{The series converges}\")\n        self.play(ReplacementTransform(series, conclusion))\n        self.wait(1)\n\n        # Clear the scene and write conclusion text\n        self.clear()\n        self.wait(1)\n        conclusion_text = Text(\"The p-test confirms the series convergence\", font_size=24).to_edge(UP)\n        self.play(Write(conclusion_text))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that demonstrates how to compute the definite integral of the function 2x from 1 to 3. Start by displaying the integral problem on the screen. Then, show step-by-step integration on the screen along with a text explanation at the top that says \"Compute the definite integral\". After solving the integral, clear the screen and present the final result of the integral calculation. Make sure each step appears one at a time and pause between each step so the viewers can follow along.",
        "answer": "\\n from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Present the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Add explanation about the wave equation\n        wave_explanation = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(wave_explanation, shift=UP))\n        self.wait(3)\n\n        # Show general solution to the wave equation\n        general_wave_solution = MathTex(r\"u(x, t) = F(x - ct) + G(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, general_wave_solution))\n        self.play(FadeOut(wave_explanation, shift=UP))\n        self.wait(2)\n\n        # Discuss particular solution\n        particular_solution_text = Text(\"Particular solutions are found using initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(general_wave_solution, wave_eq))\n        self.play(FadeIn(particular_solution_text, shift=UP))\n        self.wait(3)\n\n        # Conclude and clear the scene\n        self.play(FadeOut(wave_eq), FadeOut(particular_solution_text))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that illustrates the process of solving an integration by parts problem, specifically integrating the function x times e to the power of x? I would like the animation to first display the problem, then show the steps for setting 'u' and 'dv', followed by an explanation of the integration by parts formula, and finally demonstrate the calculation steps with the final solution including the constant of integration. Each step should be shown clearly and give enough time for the viewer to follow along.",
        "answer": "\\n from manim import *\n\nclass TrigFunctionExample(Scene):\n    def construct(self):\n        # Displaying the trigonometric function\n        trig_func = MathTex(r\"\\int_0^{\\frac{\\pi}{2}} \\sin(x) \\,dx\")\n        self.play(Write(trig_func))\n        self.wait(1)\n\n        # Explanation for the definite integral\n        explanation1 = Text(\"Definite integral of a trigonometric function\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Calculating the integral\n        integral_calc = MathTex(r\"= [-\\cos(x)]_0^{\\frac{\\pi}{2}}\")\n        self.play(ReplacementTransform(trig_func.copy(), integral_calc))\n        self.wait(1)\n\n        # Explanation for solving the definite integral\n        explanation2 = Text(\"Solve the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_result = MathTex(r\"= 1\")\n        self.play(ReplacementTransform(integral_calc, final_result))\n        self.wait(1)\n\n        # Clear the scene and present final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation that visually explains the difference between the incorrect trigonometric expression \"sin(x) + cos(x) = 1\" and the correct Pythagorean trigonometric identity \"sin\u00b2(x) + cos\u00b2(x) = 1\". First, show the incorrect equation on the screen and indicate that it's not accurate. Then, replace it with the correct equation while explaining that this is the true Pythagorean identity. Could you also graph the sine and cosine functions for me and label them accordingly? Lastly, I'd like this to conclude by clearing everything away and presenting the correct equation and its explanation one more time for emphasis.",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#fdf1db\"\nTEXT_COLOR = \"#2b2b2b\"\nLIGHT_YELLOW_COLOR = \"#f7dc5c\"\nLIGHT_GREEN_COLOR = \"#7bd389\"\nLIGHT_BLUE_COLOR = \"#85a3e0\"\nLIGHT_ORANGE_COLOR = \"#ff9f40\"\nLIGHT_PURPLE_COLOR = \"#b78be0\"\n\ndef ease_in_out_quad(t):\n    return 2 * t * t if t < 0.5 else -1 + (4 - 2 * t) * t\n\ndef LucasNumberSquare(size, color):\n    rect = Rectangle(width=size, height=size, color=color, fill_opacity=0.5)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale_to_fit_width(min(0.8 * size, 3))\n    text.move_to(rect.get_center())\n\n    return Group(rect, text)\n\nclass LucasSpiral(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        colors = [\n            LIGHT_YELLOW_COLOR,\n            LIGHT_GREEN_COLOR,\n            LIGHT_BLUE_COLOR,\n            LIGHT_ORANGE_COLOR,\n            LIGHT_PURPLE_COLOR\n        ]\n        sequence = [2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n        squares = VGroup()\n        positions = [UP, RIGHT, DOWN, LEFT]\n        current_position = 3 * LEFT + 2 * UP\n\n        for i, number in enumerate(sequence):\n            color = colors[i % len(colors)]\n            square = LucasNumberSquare(number, color)\n            square.move_to(current_position)\n            squares.add(square)\n\n            if i != 0:\n                move_direction = positions[i % 4]\n                current_position += (sequence[i - 1] + number / 2) * move_direction\n\n        for i, square in enumerate(squares):\n            self.play(\n                FadeIn(square[0], run_time=0.5),\n                Write(square[1]),\n                rate_func=ease_in_out_quad\n            )\n            self.wait(0.1)\n\n        spiral_start = squares[0].get_center()\n        arm_length = 0.5\n        spiral = VMobject(color=TEXT_COLOR)\n        spiral.set_points_as_corners([spiral_start, spiral_start + RIGHT * arm_length])\n\n        for i in range(1, len(sequence)):\n            arm_length += sequence[i - 1]\n            direction = positions[(i - 1) % 4]\n            new_corner = spiral.points[-1] + direction * arm_length\n            spiral.add_points_as_corners([new_corner])\n\n            self.play(\n                ShowCreation(spiral),\n                run_time=1,\n                rate_func=linear,\n            )\n\n        self.wait(2)\n\n        self.play(\n            *[FadeOut(mobj) for mobj in self.mobjects],\n            run_time=1.5\n        )"
    },
    {
        "query": "Could you create an educational animation that explains the concept of a harmonic oscillator using simple visuals? Start by showing the basic differential equation that governs the motion, then display the characteristic equation derived from it. After that, solve the characteristic equation and display the solution. Finally, present the general solution of the differential equation for the harmonic oscillator. Between each step, give a brief pause to let viewers understand the equations, and at the end, clear everything and highlight only the general solution once more for emphasis.",
        "answer": "\\n from manim import *\n\nclass ExponentialGraphScene(Scene):\n    def construct(self):\n        # Display the function\n        func_title = MathTex(r\"f(x) = e^x\", font_size=36)\n        func_title.to_edge(UP)\n        self.play(Write(func_title))\n        self.wait(1)\n\n        # Display the graph\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: np.exp(x), color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='e^x')\n\n        self.play(Create(axes), Write(graph), Write(graph_label))\n        self.wait(1)\n\n        # Graph transformation\n        transformation_title = Text(\"Transformation: f(x) = e^{2x}\", \nfont_size=24).to_edge(UP)\n        new_graph = axes.plot(lambda x: np.exp(2*x), color=RED)\n        new_graph_label = axes.get_graph_label(new_graph, label='e^{2x}')\n\n        self.play(\n            Transform(func_title, transformation_title),\n            ReplacementTransform(graph, new_graph),\n            ReplacementTransform(graph_label, new_graph_label)\n        )\n        self.wait(1)\n\n        # Conclusion\n        conclusion_text = Text(\"Exponential functions growth rate\", \nfont_size=24).to_edge(UP)\n        self.play(Transform(func_title, conclusion_text))\n        self.wait(1)\n\n        # Clear and show only the new graph\n        self.clear()\n        self.play(Write(func_title), Create(axes), Write(new_graph), \nWrite(new_graph_label))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation explaining the concept of a simple harmonic oscillator. Can you show the equation of motion for the system, then describe it in simple terms, detail the physical constants involved, display and explain the solution to the equation, and finally conclude with a summary statement about the motion? It should be visually clear, with each step of the explanation appearing after the previous one is completed, and any equations or text should be appropriately displayed for a classroom setting.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve = FunctionGraph(lambda x: 0.1*(x-3)**2, x_min=-1, x_max=5)\n        area = Area(curve, x_min=1, x_max=4)\n        \n        eq = MathTex(r\"\\int_{1}^{4} 0.1 (x-3)^2 \\, dx\")\n        eq.to_edge(UP)\n\n        self.play(Write(eq), run_time=1)\n        self.wait(1)\n        \n        self.play(ShowCreation(curve), run_time=2)\n        self.play(FadeIn(area), run_time=2)\n        self.wait(2)\n        \n        result = MathTex(r'A = \\frac{1}{30} \\left[ (x - 3)^3 \\right]_{1}^{4} = \\frac{1}{30}')\n        result.next_to(area, DOWN)\n        \n        self.play(Write(result))\n        self.wait(3)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates how to calculate the area underneath the curve of the function f(x) = x^2 between the points x = -1 and x = 1. Can you show the function graphically with its label, highlight the area under the curve, and then step by step, display the integral formula, compute the definite integral, and reveal the final area value? Also, can you clear everything at the end and show a message that says \"Area calculated!\"?",
        "answer": "\\n from manim import *\n\nclass Gather(Animation):\n    def __init__(self, mobject, dot_radius=0.05, dot_number=100, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.dot_radius = dot_radius\n        self.dot_number = dot_number\n        self.starting_dots = VGroup(\n            *[Dot(radius=self.dot_radius) for _ in range(self.dot_number)]\n        )\n        self.create_starting_dots()\n\n    def begin(self):\n        self.mobject.set_opacity(0)\n        for dot in self.starting_dots:\n            dot.move_to(dot.initial_position)\n        self.mobject.add(self.starting_dots)\n        super().begin()\n\n    def create_starting_dots(self):\n        mobject_center = self.mobject.get_center()\n        for dot in self.starting_dots:\n            dot.shift_vector = np.random.uniform(-4, 4, 3)\n            dot.initial_position = mobject_center + dot.shift_vector\n            dot.set_opacity(0)\n\n    def interpolate_mobject(self, alpha):\n        alpha = self.rate_func(alpha)  # manually apply rate function\n        if alpha <= 0.5:\n            self.starting_dots.set_opacity(2 * alpha)\n            for dot in self.starting_dots:\n                dot.move_to(dot.initial_position + (0.5 - alpha) * dot.shift_vector)\n        else:\n            self.starting_dots.set_opacity(2 * (1 - alpha))\n            self.mobject.set_opacity(2 * (alpha - 0.5), family=False)\n\n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        scene.remove(self.starting_dots)\n\nclass CustomGatherAnimationExample(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1).scale(2)\n        self.add(square)\n        self.wait()\n        self.play(Gather(square, dot_number=200, run_time=4))\n        self.wait()"
    },
    {
        "query": "I would like an educational animation that visually explains the concept of finding the area under a curve for a quadratic function. Specifically, show the area under the curve y = x^2 from x=0 to x=2. Begin with displaying the coordinate axes and the curve, then highlight the area underneath the curve that we are interested in. Next, introduce the integral notation for this problem and animate it changing into the calculated value of the definite integral. Finish by showing the final numeric result of the area calculation in the center of the screen. Make the axes and the initial curve disappear at the end, leaving only the result displayed. Use different colors to clearly differentiate elements such as the axes, the curve, and the shaded area.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Write the equation of the curve\n        curve_eq = MathTex(r\"y = x^2\")\n        self.play(Write(curve_eq))\n        self.wait(1)\n\n        # Explain the goal of finding the area under the curve\n        goal_text = Text(\"Find the area under the curve from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Write(goal_text))\n        self.wait(2)\n\n        # Display the definite integral for the area under the curve\n        integral = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Transform(curve_eq, integral))\n        self.wait(2)\n\n        # Show the steps of integration\n        integration_steps = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^3\")\n        self.play(ReplacementTransform(integral, integration_steps))\n        self.wait(2)\n\n        # Evaluate the integral at bounds\n        evaluated_integral = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_steps, evaluated_integral))\n        self.wait(2)\n\n        # Show the final area result\n        area_result = Text(\"Area under curve from 1 to 3 is \\\\(\\\\frac{26}{3}\\\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(area_result))\n        self.wait(2)\n\n        # Remove all objects from the screen\n        self.play(FadeOut(curve_eq, goal_text, evaluated_integral, area_result))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that illustrates the process of integrating the exponential function e raised to the power of 2x with respect to x, including the steps involved in solving the integral, and a reminder to include the constant of integration, with each step accompanied by explanations?",
        "answer": "\\n from manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        heat_eq = MathTex(r\"\\frac{\\partial u}{\\partial t} - \\alpha \\nabla^2 u = 0\")\n        self.play(FadeIn(heat_eq))\n        self.wait(1)\n\n        # Introducing the equation\n        intro_text = Text(\"The heat equation is a second-order PDE.\", font_size=24).to_edge(UP)\n        self.play(Write(intro_text))\n        self.wait(2)\n\n        # Discussing the physical meaning\n        physical_meaning = Text(\"It describes the distribution of heat in a given region over time.\", font_size=24).to_edge(UP)\n        self.play(Transform(intro_text, physical_meaning))\n        self.wait(2)\n\n        # Displaying the steady-state solution\n        steady_state = MathTex(r\"\\nabla^2 u = 0\")\n        self.play(ReplacementTransform(heat_eq, steady_state))\n        self.wait(1)\n\n        # Steady-state explanation\n        steady_state_explanation = Text(\"A steady-state solution does not change with time.\", font_size=24).to_edge(UP)\n        self.play(Transform(intro_text, steady_state_explanation))\n        self.wait(2)\n\n        # Cleaning the scene\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(steady_state))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational math animation that visually demonstrates how to calculate the area under the curve of the quadratic function y = 0.1x^2 from x = 0 to x = 4. The animation should start by drawing the function on a graph, labeling it, and then showing the area under the curve between these two points. Afterward, I'd like the video to annotate this area with the corresponding integral expression, and step by step, show the calculation of this definite integral, ending with the exact answer and its decimal approximation. Finally, conclude the animation by clearing the screen and summarizing the process with the final decimal result displayed on the screen. Can you create this animation for me?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Drawing axes\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 10, 2],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Labels for axes\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Creating the curve \n        curve = axes.plot(lambda x: x**2, color=RED)\n        area = axes.get_area(curve, x_range=(0, 2), color=GREEN, opacity=0.5)\n\n        # Adding text\n        area_label = MathTex(r\"A=\\int_{0}^{2} x^2 \\,dx\", font_size=24).next_to(area, UP + LEFT)\n\n        # Displaying all elements\n        self.play(Create(axes), Create(labels))\n        self.play(Create(curve), FadeIn(area), Write(area_label))\n        self.wait(1)\n\n        # Calculating the area\n        area_calculation = MathTex(r\"A = \\left[ \\frac{1}{3}x^3 \\right]_0^2\")\n        self.play(Transform(area_label, area_calculation))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"A = \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(Transform(area_label, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(area_label))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation to help students understand how to calculate the basic definite integral of the function f(x) = x^3 from 0 to 2. Can you illustrate the process by first displaying the integral problem, then explaining and demonstrating the power rule for integration, followed by step-by-step calculation of the integral, including the evaluation of the function at the integration bounds, and finishing with the final numerical answer? Please also ensure there are pauses for explanation, and the text and equations are clearly labeled and easy to read.",
        "answer": "\\n from manim import *\n\nclass PythagoreanProof(Scene):\n    def construct(self):\n        # Introduction of the Pythagorean Theorem\n        theorem_text = MathTex(\"a^2 + b^2 = c^2\").scale(2)\n        self.play(Write(theorem_text))\n        self.wait(2)\n\n        # Display a right angle triangle\n        triangle = Polygon(np.array([-1, -1, 0]), np.array([-1, 1, 0]), np.array([1, -1, 0]))\n        self.play(Create(triangle))\n        self.wait(1)\n\n        # Label the sides of the triangle\n        side_a = MathTex(\"a\").next_to(triangle, LEFT)\n        side_b = MathTex(\"b\").next_to(triangle, DOWN)\n        side_c = MathTex(\"c\").next_to(triangle.get_center(), RIGHT)\n        self.play(Write(side_a), Write(side_b), Write(side_c))\n        self.wait(1)\n\n        # Show the squares of side a and side b\n        square_a = Square(side_length=2).move_to(triangle.get_vertices()[0] + np.array([-1, 0, 0]))\n        square_b = Square(side_length=2).move_to(triangle.get_vertices()[2] + np.array([0, -1, 0]))\n        self.play(Create(square_a), Create(square_b))\n        self.wait(1)\n\n        # Show the square of side c\n        square_c = Square(side_length=2 * np.sqrt(2)).rotate(np.arctan2(1, 1)).move_to(triangle.get_center())\n        self.play(Create(square_c))\n        self.wait(1)\n\n        # Show that the area of c^2 is the sum of a^2 and b^2\n        equation = MathTex(\"a^2\", \"+\", \"b^2\", \"=\", \"c^2\").scale(2)\n        self.play(\n            Transform(side_a.copy(), equation[0]),\n            Transform(side_b.copy(), equation[2]),\n            Transform(side_c.copy(), equation[4]),\n        )\n        self.wait(1)\n\n        # Show conclusion of the theorem\n        conclusion = Text(\"This illustrates the Pythagorean Theorem.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clear scene and display only the theorem\n        self.clear()\n        self.play(Write(theorem_text))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an educational animation that shows a blue parabola graph, displays the equation of the parabola as y = x^2, then demonstrates how to find the equation of the yellow tangent line to the parabola at the point where x = 1. Additionally, I want to display the tangent line's equation, y = 2x - 1, and explain that the slope of the tangent line is 2, showing the derivative dy/dx = 2. Finally, the animation should conclude with the words \"Tangents to parabolas\" at the top while re-displaying the parabola and the tangent line. Can you create this with smooth transitions and brief pauses in between each step for clarity?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShowPassingFlash\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(ShowPassingFlash(square))\n            self.remove(square)"
    },
    {
        "query": "Can you create an educational animation that visually explains how to solve the definite integral of x^3 from 0 to 3 using the power rule of integration, and includes the following steps: introducing the problem, explaining the power rule, demonstrating how to apply the rule to our specific problem, evaluating the integral at the upper and lower limits, and presenting the final numerical solution?",
        "answer": "\\n class Positioning(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        self.add(plane)\n\n        # next_to from episode 1\n        red_dot = Dot(color=RED)\n        green_dot = Dot(color=GREEN)\n        green_dot.next_to(red_dot, RIGHT + UP)  # RIGHT == [1, 0, 0]\n        self.add(red_dot, green_dot)\n\n        # shift\n        s = Square(color=ORANGE)\n        s.shift(2*UP + 4*RIGHT)\n        self.add(s)\n\n        # move_to\n        c = Circle(color=PURPLE)\n        c.move_to([-3, -2, 0])\n        self.add(c)\n\n        # align_to\n        c2 = Circle(radius=0.5, color=RED, fill_opacity=0.5)\n        c3 = c2.copy().set_color(YELLOW)\n        c4 = c2.copy().set_color(ORANGE)\n        c2.align_to(s, UP)\n        c3.align_to(s, RIGHT)\n        c4.align_to(s, UP + RIGHT)\n        self.add(c2, c3, c4)"
    },
    {
        "query": "Can you create an educational animation showing how to calculate the area under a parabola from x=0 to x=2 by demonstrating the integration of x squared using the power rule, and then evaluating the definite integral to find the final solution?",
        "answer": "\\n from manim import *\n\nclass GaussianIntegralExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_{-\\infty}^{\\infty} e^{-x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for switching to polar coordinates\n        explanation1 = Text(\"Use polar coordinates to solve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up polar coordinates\n        polar_setup = MathTex(r\"= \\left(\\int_{-\\infty}^{\\infty} e^{-x^2} \\,dx\\right)^2\")\n        self.play(ReplacementTransform(problem.copy(), polar_setup))\n        self.wait(1)\n\n        # Showing integral over a circle\n        circle_integral = MathTex(r\"= \\int \\int e^{-(x^2 + y^2)} \\,dx\\,dy\")\n        self.play(ReplacementTransform(polar_setup, circle_integral))\n        self.wait(1)\n\n        # Transform to polar coordinates\n        polar_transform = MathTex(r\"= \\int_0^{2\\pi} \\int_0^{\\infty} e^{-r^2} r \\,dr\\,d\\theta\")\n        self.play(ReplacementTransform(circle_integral, polar_transform))\n        self.wait(1)\n\n        # Integration in polar coordinates\n        integration_polar = MathTex(r\"= \\pi\")\n        self.play(ReplacementTransform(polar_transform, integration_polar))\n        self.wait(1)\n\n        # Explanation for taking the square root\n        explanation2 = Text(\"Taking the square root of the result\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\sqrt{\\pi}\")\n        self.play(ReplacementTransform(integration_polar, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation that visually demonstrates the concept of finding the area under the curve of the function f(x) = x^2 between the interval of 0 to 2. The animation should include the following steps:\n1. Start by displaying the function f(x) = x^2 on the screen clearly labeled.\n2. Introduce the integral problem with the integral sign, highlighting the specific area we're interested in, in yellow, which is from x=0 to x=2.\n3. Draw the graph of f(x) = x^2 within the limits from x=0 to x=2.\n4. Next, show the process of filling the area under the curve with rectangles to represent Riemann sums, communicating the idea of integral approximation.\n5. Include a sentence saying \"The area under the curve is the integral result,\" and position this sentence at the top of the screen.\n6. Proceed to show the integral calculation in stages: first, show the antiderivative form as if applying the fundamental theorem of calculus.\n7. Then, show the result by calculating the antiderivative at the upper limit minus the antiderivative at the lower limit.\n8. Simplify the expression to show the numerical value of the area under the curve.\n9. Finally, clear everything except the final result from the screen and leave the numerical value of the area centered for emphasis at the end of the animation.\n10. Make sure to include appropriate pauses after each step of the animation to allow the viewer to understand what is shown before moving on.",
        "answer": "\\n from manim import *\n\nconfig.frame_width = 14.22\nconfig.frame_height = 25.4\n\nclass AddingFractions(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{1}{4}\", color=BLACK).scale(2),\n            MathTex(r\"+\", color=BLACK).scale(2),\n            MathTex(r\"\\frac{1}{4}\", color=BLACK).scale(2),\n            MathTex(r\"=\", color=BLACK).scale(2),\n            MathTex(r\"\\frac{1}{2}\", color=BLACK).scale(2)\n        ).arrange(RIGHT, buff=0.5)\n\n        brace_top = Brace(fractions[:2], UP, color=BLACK)\n        brace_bottom = Brace(fractions[:2], DOWN, color=BLACK)\n        text_top = brace_top.get_tex(r\"\\text{Same Denominator}\", color=BLACK)\n        text_bottom = brace_bottom.get_tex(r\"\\text{Add Numerators}\", color=BLACK)\n\n        self.play(Write(fractions))\n        self.wait(1)\n        self.play(\n            GrowFromCenter(brace_top),\n            FadeIn(text_top, shift=DOWN)\n        )\n        self.wait(1)\n        self.play(\n            GrowFromCenter(brace_bottom),\n            FadeIn(text_bottom, shift=UP)\n        )\n        self.wait(1)\n        self.play(\n            ReplacementTransform(fractions[:3].copy(), fractions[3:])\n        )\n        self.wait(2)\n        self.play(FadeOut(VGroup(*self.mobjects)))"
    },
    {
        "query": "Can you create an animated video that visually explains the steps to solve a triple integral, specifically the integral of xyz from x ranging from -1 to 1, y ranging from -1 to 1, and z ranging from 0 to 1? I would like it to show the written problem, then step-by-step integration for each variable with short explanations for each step, and finally, clear the screen and present the final answer.",
        "answer": "\\n from manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\n# Define some constants for colors\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\n\n# Function to create a cookie circle\ndef CookieCircle():\n    return VGroup(\n        Circle(radius=1, color=TEXT_COLOR, fill_opacity=1),\n        Dot(point=UP, color=BACKGROUND_COLOR),\n        Dot(point=DOWN, color=BACKGROUND_COLOR),\n        Dot(point=RIGHT, color=BACKGROUND_COLOR),\n        Dot(point=LEFT, color=BACKGROUND_COLOR)\n    )\n\nclass CookiePartition(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Dividing cookie into 4 parts\", color=LIGHT_BLUE_COLOR)\n        title.scale(1.3).to_edge(UP)\n        \n        cookie = CookieCircle()\n        partition_lines = VGroup(\n            Line(UP, DOWN, color=BACKGROUND_COLOR),\n            Line(LEFT, RIGHT, color=BACKGROUND_COLOR),\n        )\n        \n        partitioned_cookie = VGroup(cookie, partition_lines)\n        \n        self.play(Write(title))\n        self.play(FadeIn(cookie))\n        self.wait(0.5)\n        \n        for line in partition_lines:\n            self.play(Write(line), run_time=0.5)\n        \n        self.play(partitioned_cookie.animate.scale(0.7).shift(3 * LEFT + 2 * UP))\n        \n        fraction_group = VGroup()\n        \n        # Add fractions to indicate parts of the cookie\n        for i in range(4):\n            frac = MathTex(rf\"\\frac{1}{{4}}\", color=LIGHT_BLUE_COLOR).scale(0.5)\n            pos = cookie.get_critical_point([UP, DOWN, LEFT, RIGHT][i]) + frac.get_width() * [DOWN, UP, RIGHT, LEFT][i]\n            frac.move_to(pos)\n            fraction_group.add(frac)\n        \n        self.play(AnimationGroup(*[FadeIn(f) for f in fraction_group], lag_ratio=0.3))\n        \n        self.wait(1)\n        self.play(Uncreate(title), FadeOut(partitioned_cookie), FadeOut(fraction_group))\n        self.wait(0.5)"
    },
    {
        "query": "Can you create an animated educational video that explains step-by-step how to solve a triple integral mathematically, specifically the integral of xyz over the ranges z from 0 to 3, x from 0 to 2, and y from 0 to 1? The explanation should include writing out the problem, integrating with respect to z first, then x, and finally y, showing the intermediate steps, and finishing with the numerical value of the triple integral. Each step should have clear text guidance on what is happening and highlight the integral calculation at each stage.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Define lower and upper bounds\n        a = 1\n        b = 2\n\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{\", str(a), r\"}^{\", str(b), r\"} x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration with bounds:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int_{a}^{b} x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_{a}^{b}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"\\left. \\frac{x^{3}}{3} \\right|_{\", str(a), \"}^{\", str(b), \"}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the expression at bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculation step\n        calc_step = MathTex(r\"= \\frac{\", str(b), r\"^3}{3} - \\frac{\", str(a), r\"^3}{3}\")\n        self.play(ReplacementTransform(integration_step, calc_step))\n        self.wait(2)\n\n        # Final solution with numerical values\n        final_solution_numeric = MathTex(r\"= \\frac{8}{3} - \\frac{1}{3}\")\n        self.play(Transform(calc_step, final_solution_numeric))\n        self.wait(1)\n\n        # Reduce to the simplest form\n        final_solution_simple = MathTex(r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(final_solution_numeric, final_solution_simple))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution_simple))\n        self.wait(1)"
    },
    {
        "query": "Create an educational animation that starts by displaying the mathematical series sum from n=1 to infinity of 1/n^2, then briefly explains that we can test for its convergence using a p-series test mentioning that because 'p' is 2, which is greater than 1, the series converges. After the explanation, transition the text to say 'Consider the partial sum S_m' and show the partial sum equation from n=1 to m of 1/n^2. Then, mention that we should evaluate the limit of the partial sums as m approaches infinity. Make the animation conclude by showing that this limit is equal to pi^2/6, referencing it as the solution to the Basel problem, and finally, clear everything else away to leave just the result on the screen. Can you make this animation using simple and smooth transitions?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve_text = Text(\"Area under the curve y = x^2 between x = 1 and x = 2\")\n        problem = MathTex(r\"\\int_1^2 x^2 \\,dx\")\n        self.play(Write(curve_text))\n        self.wait(1)\n        self.play(Transform(curve_text, problem))\n        self.wait(1)\n\n        # Explaining the concept of definite integral\n        explanation = Text(\"The definite integral represents the area under the curve\",\n                           font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Calculate the antiderivative\n        antiderivative = MathTex(r\"= \\frac{x^3}{3}\\Big|_1^2\")              \n        self.play(ReplacementTransform(problem, antiderivative))\n        self.wait(2)\n\n        # Plugging in the bounds\n        bounds_plug_in = MathTex(r\"= \\left(\\frac{2^3}{3}\\right) - \\left(\\frac{1^3}{3}\\right)\")\n        self.play(ReplacementTransform(antiderivative, bounds_plug_in))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(bounds_plug_in, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"Final area is 7/3 units squared\", font_size=36)))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation illustrating the concept of Taylor series approximations. Can you show the function f(x) = e^x and its approximation using the first four terms of the Taylor series? Start the animation with the function at the top, followed by text explaining that it's a Taylor series approximation up to the nth term. Then display the approximate expression using four terms. Transform that into a labeled polynomial P_4(x), and after that, graph both the original function and the Taylor polynomial on the same coordinate axes, with f(x) in green and P_4(x) in yellow, properly labeled. Finally, clear off the text leaving only the graph, and then highlight the area between the graphs for x values between -1 and 1 to show the approximation difference. Make sure to have transitions between each step and pauses to give viewers time to understand what is shown.",
        "answer": "\\n from manim import *\n\n\nclass Main(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        cylinder = Cylinder(radius=2, height=3)\n        name = Text(\"Kiron\").scale(2).shift(UP)\n        self.set_camera_orientation(phi=75 * DEGREES, theta=20 * DEGREES)\n        self.play(Create(cylinder, run_time=3))\n        self.play(FadeOut(cylinder))\n        self.play(DrawBorderThenFill(axes))\n        self.play(Write(name))"
    },
    {
        "query": "Can you create an educational animation that illustrates how to approximate the value of Euler's number, e, using the limit definition and a large but finite value of n for simplicity? I would like to see the definition of e as a limit, then an explanation that we will approximate it, followed by an actual approximation using n = 100, then show a rounded numerical result of this approximation, and finally end by stating the calculated value of e with the approximation. Please ensure that the explanation and all steps are clearly shown on the screen one after the other.",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Display the differential equation\n        deqn = MathTex(r\"m\\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(deqn))\n        self.wait(2)\n\n        # Introduce the characteristic equation\n        char_eq_label = Text(\"Characteristic equation:\", font_size=24).to_edge(UP)\n        self.play(Write(char_eq_label))\n        self.wait(1)\n\n        char_eq = MathTex(r\"mr^2 + k = 0\")\n        self.play(ReplacementTransform(deqn.copy(), char_eq))\n        self.wait(2)\n\n        # Solve the characteristic equation\n        solution_label = Text(\"Solution for r:\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_label, solution_label))\n        self.wait(1)\n\n        roots = MathTex(r\"r = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(2)\n\n        # General form of the solution\n        gen_sol_label = Text(\"General solution:\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_label, gen_sol_label))\n        self.wait(1)\n\n        gen_sol = MathTex(r\"x(t) = A\\cos\\left(\\sqrt{\\frac{k}{m}}t\\right) + B\\sin\\left(\\sqrt{\\frac{k}{m}}t\\right)\")\n        self.play(Write(gen_sol))\n        self.wait(3)\n\n        # Clear the scene and emphasize the general solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(gen_sol_label))\n        self.play(Write(gen_sol))\n        self.wait(2)"
    },
    {
        "query": "Please create an animation that walks through the process of solving a double integral in polar coordinates. Start by displaying the double integral symbolically on the screen. Then add a text explanation that we will first integrate with respect to the radius (r). Show the result of that inner integration and display the intermediate integral with respect to the angle (theta). Replace the explanation text with one that says we will now integrate with respect to theta. Complete the process by computing the final value and make sure each step transitions smoothly to the next, so it's easy to follow. Can you also include brief pauses between steps to allow viewers to understand each phase of the integration?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"MoveAlongPath\").shift(UP*2.5)), run_time=0.5)\n            l1 = Line(LEFT+DOWN, RIGHT+UP)\n            self.add(l1)\n            d1 = Dot().shift(LEFT+DOWN)\n            self.play(Create(d1), run_time=0.5)\n            self.play(MoveAlongPath(d1, l1), rate_func=linear)\n            self.remove(l1,d1)"
    },
    {
        "query": "Could you create an animation that explains how to integrate the function sin(x)cos(x) using a trigonometric identity, with the steps clearly shown and the final answer highlighted?",
        "answer": "\\n from manim import *\n\nclass AtomDiagram(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        grid = self.create_atom_grid(5, 5)\n        # Animate the grid\n        self.play(Create(grid))\n        # Wait for two seconds\n        self.wait(2)\n    \n    def create_atom_circle(self, label: str, atom_color: str, label_color: str = WHITE):\n        circle = Circle(radius=0.3, color=atom_color, fill_opacity=1)\n        text = Tex(label, color=label_color).scale(0.7)\n        return VGroup(circle, text)\n    \n    def create_atom_grid(self, rows: int, cols: int):\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom = self.create_atom_circle(\"H\", RED_B)\n                else:\n                    atom = self.create_atom_circle(\"He\", BLUE_B)\n                atom.move_to(np.array([i - rows // 2, j - cols // 2, 0]))\n                grid.add(atom)\n        return grid\n\nclass ElectronOrbit(Scene):\n    def construct(self):\n        # Create a proton\n        proton = self.create_atom_circle(\"+\", RED_A)\n        # Create an electron\n        electron = self.create_atom_circle(\"-\", BLUE_D)\n        # Create an orbit\n        orbit = self.create_orbit()\n        # Position electron at a specific point on the orbit\n        electron.move_to(orbit.points[0])\n\n        # Animate the proton, electron and its orbit\n        self.play(FadeIn(proton), Create(orbit))\n        self.play(FadeIn(electron))\n        # Electron orbits around the proton\n        self.play(MoveAlongPath(electron, orbit, rate_func=linear, run_time=5))\n        # Wait for two seconds\n        self.wait(2)\n\n    def create_atom_circle(self, label: str, atom_color: str):\n        circle = Circle(radius=0.2, color=atom_color, fill_opacity=1)\n        text = Tex(label, color=WHITE).scale(0.5)\n        return VGroup(circle, text)\n    \n    def create_orbit(self):\n        orbit = Ellipse(width=3, height=1.5, color=WHITE).shift(DOWN*0.5)\n        return orbit"
    },
    {
        "query": "Can you create an educational animation that visually walks through the steps of calculating a basic definite integral of x^2 from 0 to 1, including writing out the problem, using the power rule for integration, evaluating the limits, and presenting the simplified final solution, all accompanied by relevant explanations and pauses between each step for clarity?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series representation of a function\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left(a_n\\cos(nx) + b_n\\sin(nx)\\right)\")\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Display the coefficients explanation\n        coefficients_explanation = Text(\"Coefficients are calculated from the function.\", font_size=24).to_edge(UP)\n        self.play(Write(coefficients_explanation))\n        self.wait(2)\n\n        # Explaining even and odd functions\n        odd_even_explanation = Text(\"For even functions, b_n = 0. For odd functions, a_n = 0.\", font_size=24).to_edge(UP)\n        self.play(Transform(coefficients_explanation, odd_even_explanation))\n        self.wait(2)\n\n        # Displaying the formula for coefficients\n        coefficients_formula = MathTex(r\"a_n = \\frac{2}{T}\\int_{0}^{T} f(x)\\cos(nx)dx, \\\\ b_n = \\frac{2}{T}\\int_{0}^{T} f(x)\\sin(nx)dx\")\n        self.play(Transform(fourier_series, coefficients_formula))\n        self.wait(2)\n\n        # Comment on real-world applications\n        applications_explaining = Text(\"Fourier series play a crucial role in signal processing and heat transfer.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(coefficients_explanation, applications_explaining))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(fourier_series))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation that explains how to calculate the definite integral of x cubed from 0 to 2, step by step, using the Fundamental Theorem of Calculus. Include visual text expressions for the integral, its bounds, the integration process, and the evaluation of the result at the specified bounds. Finish with a clear, simplified solution displayed on screen.",
        "answer": "\\n class CircleExpansion(Scene):_x000D_\n    def construct(self):_x000D_\n        circles = VGroup()_x000D_\n        colors = [X11.AQUAMARINE1, X11.AQUAMARINE2, X11.AQUAMARINE3, X11.AQUAMARINE4]_x000D_\n        labels = [\"1x\", \"2x\", \"3x\", \"4x\"]_x000D_\n        for i, color in enumerate(colors):_x000D_\n            circle = Circle(radius=1)_x000D_\n            circle.set_fill(color, opacity=1)_x000D_\n            circle.set_stroke(opacity=0)_x000D_\n            label = Text(labels[i], font_size=24, font=\"Monospace\")_x000D_\n            label.move_to(circle)_x000D_\n            circle.add(label)_x000D_\n            circles.add(circle)_x000D_\n_x000D_\n        circles.arrange(RIGHT, buff=1).to_edge(UP)_x000D_\n        self.add(circles)_x000D_\n_x000D_\n        growth_animations = []_x000D_\n        for i, circle in enumerate(circles):_x000D_\n            scale_factor = i + 1_x000D_\n            growth_animations.append(circle.animate(run_time=2, rate_func=smooth).scale(scale_factor))_x000D_\n_x000D_\n        self.wait()_x000D_\n        self.play(*growth_animations)_x000D_\n        self.wait()_x000D_\n_x000D_\n        # Add a tracking line showing the expansion time_x000D_\n        tracker_line = Line(4*LEFT, 4*RIGHT).next_to(circles, DOWN, buff=1)_x000D_\n        tracker_dot = Dot().move_to(tracker_line.get_start())_x000D_\n        self.add(tracker_line, tracker_dot)_x000D_\n_x000D_\n        self.play(_x000D_\n            tracker_dot.animate(run_time=2, rate_func=linear).move_to(tracker_line.get_end()),_x000D_\n            *growth_animations,_x000D_\n        )_x000D_\n        self.wait()"
    },
    {
        "query": "Could you create an educational animation that visually explains how to calculate the area under the curve of a simple quadratic function, f(x) = x^2, specifically between the interval x=1 and x=3, using integration? The animation should show the function and its corresponding graph, the area under the graph being highlighted, and the step-by-step process of finding the definite integral, including evaluating the antiderivative at the upper and lower bounds of the interval to arrive at the final area value. It would be great if the animation slowly builds up from displaying the function, transforming it into an integral, plotting the function with the area shaded, calculating the integral, and finally presenting the numerical result.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Display the limits of integration\n        limits = Text(\"Integration bounds: from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(limits))\n        self.wait(2)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Apply the power rule, add 1 to the exponent and divide by the new exponent:\", font_size=24).next_to(limits, DOWN)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"=\\frac{x^{3+1}}{4}\\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for inserting the limits\n        explanation2 = Text(\"Evaluate at the upper and lower bounds:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculate the definite integral\n        evaluated_solution = MathTex(r\"=\\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, evaluated_solution))\n        self.wait(1)\n\n        # Simplify the final solution\n        explanation3 = Text(\"Simplify to find the area under the curve between the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluated_solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        result_text = Text(\"The area under the curve from 0 to 2 is 4\", font_size=24).to_edge(UP)\n        self.play(Write(result_text))\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that illustrates the concept of finding the area under a curve, specifically the gaussian function e^(-x^2), between the points x=-2 and x=2. The video should show the function being written as a mathematical expression, then transforming that expression into an integral representation. Afterward, the function should be plotted on a graph, with the area under the curve between those two points shaded. Additionally, I'd like the approximate numerical value of this area to be displayed on the screen. Finally, the animation should end with a clear explanatory message that reinforces what the shaded region represents. Can you create this animation for me without using any complex coding language or technical jargon, just simple step-by-step visuals to aid understanding?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the type of equation\n        explanation1 = Text(\"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # General solution explanation\n        explanation2 = Text(\"The general solution can be written as u(x, t) = f(x - ct) + g(x + ct)\", font_size=24).move_to(explanation1)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        general_solution.next_to(problem, DOWN)\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for the d'Alembert's formula\n        explanation3 = Text(\"This is known as d'Alembert's formula.\", font_size=24).move_to(explanation1)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Showing d'Alembert's formula\n        dalemberts_formula = MathTex(r\"u(x, t) = \\frac{1}{2}[f(x - ct) + f(x + ct)] + \\frac{1}{2c}\\int_{x-ct}^{x+ct} g(s) ds\")\n        dalemberts_formula.next_to(general_solution, DOWN)\n        self.play(Write(dalemberts_formula))\n        self.wait(1)\n\n        # Clear the scene and show final formula\n        self.clear()\n        self.wait(1)\n        self.play(Write(dalemberts_formula))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that demonstrates how to calculate the area under the curve of x squared from x = 1 to x = 3, showing each step including the integral setup, applying the power rule of integration, and the final solution?",
        "answer": "\\n from manim import *\n\nclass ParametricCurve3D(ThreeDScene):\n    def construct(self):\n        curve = ParametricFunction(\n            lambda t: np.array([\n                np.sin(t), \n                np.cos(t), \n                t / 2\n            ]),\n            t_range=[0, TAU], \n            color=BLUE\n        )\n        axes = ThreeDAxes()\n\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        self.play(Create(axes), Create(curve))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(5)"
    },
    {
        "query": "I would like to create an educational animation that demonstrates how to solve the integral of sin squared x minus cos squared x with respect to x. This should include a step showing the application of a trigonometric identity to transform the integral into a simpler form. Finally, display the solution to the integral including the integration constant C, and clear the screen before presenting the final answer prominently. Can you generate an animation sequence that includes these steps with written explanations and transformations?",
        "answer": "\\n \nfrom manim import *\n\nfrom manim_physics import *\nclass PendulumExample(SpaceScene):\n    def construct(self):\n        pends = VGroup(*[Pendulum(i) for i in np.linspace(1, 5, 7)])\n        self.add(pends)\n        for p in pends:\n            self.make_rigid_body(*p.bobs)\n            p.start_swinging()\n        self.wait(10)"
    },
    {
        "query": "I would like to see an educational animation that visually explains how to evaluate the definite integral of x cubed from 0 to 1. The video should start by displaying the integral problem, and then go step by step through the process of solving it using the power rule for integration. After that, it should show how to apply the bounds of the integral and simplify the final answer. Finally, it should conclude by showing the simplified solution on a clear screen. Can you create such an animation that is easy to understand, possibly for use in a math classroom?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 3, 1],\n            y_range=[0, 3, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(0, 2))\n\n        curve_label = axes.get_graph_label(graph, label='y = x^2')\n\n        self.play(Create(axes), Create(graph), FadeIn(curve_label))\n        self.wait(1)\n\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(2)\n\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        problem.next_to(area, UP)\n\n        self.play(Write(problem))\n        self.wait(1)\n\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3} x^3\\right]_0^2\")\n        integration_step.next_to(problem, DOWN)\n\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= \\frac{1}{3} (2^3) - \\frac{1}{3} (0^3)\", r\"= \\frac{8}{3}\")\n        final_solution.next_to(integration_step, DOWN)\n\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        self.play(FadeOut(area), FadeOut(curve_label), FadeOut(axes), FadeOut(graph))\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "Create an educational animation that walks me through the process of solving a triple integral step by step, visually showing each integration from the innermost integral to the outermost. I'd like to see the triple integral of xyz over the bounds x=0 to 2, y=-1 to 1, and z=0 to 1 with respect to x first, then z, and lastly y. Present it on-screen with clear text explanations before each integration step stating which variable we're integrating with respect to next, and at the end, show the fully evaluated solution. Can you also make sure to pause slightly after each step to give viewers a moment to understand before moving on to the next part?",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for u-substitution\n        explanation1 = Text(\"Use u-substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting the substitution\n        subst_step = MathTex(r\"u = 2x\", r\"\\quad\", r\"du = 2 \\,dx\", r\"\\quad\", r\"\\frac{1}{2}du = dx\")\n        self.play(ReplacementTransform(problem.copy(), subst_step))\n        self.wait(1)\n\n        # Explanation for the new integral form\n        explanation2 = Text(\"Rewrite the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Rewritten integral with u\n        rewritten_integral = MathTex(r\"\\int \\frac{1}{2}e^u \\,du\")\n        self.play(ReplacementTransform(subst_step, rewritten_integral))\n        self.wait(1)\n\n        # Explanation for integration result\n        explanation3 = Text(\"Integrate\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(rewritten_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that visually explains the classic wave equation used in physics. Start by presenting the wave equation itself, which involves a second-order partial differential in terms of time and space. After showing the equation, add a brief text explanation that it's the wave equation and then clarify that the constant 'c' within the equation represents the speed at which the wave propagates. Next, transition from the wave equation to show D'Alembert's solution, which expresses the wave function as a combination of two arbitrary functions depending on space and time. Accompany the appearance of D'Alembert's solution with a closing text note mentioning that it uses two arbitrary functions. After all elements are presented, clear the screen and conclude by restating D'Alembert's solution. Ensure there are pauses throughout the animation to allow for the material to be absorbed by the viewer.",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, Neuron, Connection\nfrom manim_ml.neural_network.layers import FeedForwardLayer, LSTMCellLayer\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 8.0\nconfig.frame_width = 8.0\n\nclass RNNSequenceScene(Scene):\n    def construct(self):\n        # Create a sequence of numbers as input\n        sequence = [1, 2, 3, 4, 5]\n        sequence_mob = VGroup(*[MathTex(str(num)) for num in sequence])\n        sequence_mob.arrange_in_grid(rows=1, buff=1)\n        self.play(Write(sequence_mob))\n        \n        # Move the sequence off to the side\n        self.play(sequence_mob.animate.to_edge(UP))\n\n        # Neural Network with LSTM Cells\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(5), # Input layer corresponding to the sequence length\n                LSTMCellLayer(),    # LSTM cell layer\n                FeedForwardLayer(5), # Output layer\n            ],\n            node_spacing=0.1,\n            layer_spacing=0.4\n        )\n        \n        nn.move_to(ORIGIN)\n        self.play(Write(nn))\n        \n        # Play a forward pass animation through the RNN\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)\n\n        # Isolate a Neuron and show its connections\n        focus_neuron = nn.all_layers[1].neurons[0]\n        connections = VGroup(*[\n            conn for conn in nn.connections\n            if conn.start_node is focus_neuron or conn.end_node is focus_neuron\n        ])\n        self.play(FocusOn(focus_neuron))\n        self.play(LaggedStart(*[ShowCreationThenFadeOut(conn) for conn in connections]))\n\n        # Display the updated sequence after RNN transformation\n        updated_sequence_mob = VGroup(*[MathTex(str(num+5)) for num in sequence])\n        updated_sequence_mob.next_to(nn, DOWN, buff=1)\n        self.play(Transform(sequence_mob, updated_sequence_mob))"
    },
    {
        "query": "I would like to have an animated video explaining the Pythagorean theorem visually. The video should start by displaying the theorem \"a^2 + b^2 = c^2\" on the screen. Then it should show a right-angled triangle and label its sides as \"a\", \"b\", and \"c\". Next to each side of the triangle, I want to see squares with the corresponding side lengths. Then the equation \"c^2 = a^2 + b^2\" should appear and the labels \"a\", \"b\", and \"c\" should move to their respective places in the equation. The areas of these squares should be highlighted with different colors to show the difference. At the end of the video, I want it to state \"Pythagorean theorem demonstrated\" as a conclusion and then clear the screen before showing the conclusion once more to reinforce the message. The animation should be engaging but simple enough for educational purposes. Can you make this for me?",
        "answer": "\\n from manim import *\n\nclass PythagoreanProof(Scene):\n    def construct(self):\n        # Displaying the Pythagorean theorem\n        theorem = MathTex('a^2 + b^2 = c^2')\n        self.play(Write(theorem))\n        self.wait(1)\n\n        # Draw right triangle\n        right_triangle = RightAngleTriangle()\n        self.play(Create(right_triangle))\n        self.wait(1)\n\n        # Explaining the square on the hypotenuse\n        explanation1 = Text(\"Consider squares on each side\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Creating squares on each side of the triangle\n        square_a = Square().scale(0.5).next_to(right_triangle, UP, buff=0)\n        square_b = Square().scale(0.5).next_to(right_triangle, RIGHT, buff=0)\n        square_c = Square().scale(0.7).next_to(right_triangle.hypotenuse, RIGHT, buff=0)\n        self.play(Create(square_a), Create(square_b), Create(square_c))\n        self.wait(2)\n\n        # Explaining Pythagorean theorem in this context\n        explanation2 = Text(\"Area of c^2 is equal to sum of a^2 and b^2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # The conclusion\n        conclusion = MathTex('a^2', '+', 'b^2', '=', 'c^2').move_to(DOWN * 3)\n        self.play(ReplacementTransform(theorem.copy(), conclusion))\n        self.wait(1)\n\n        # Clear the scene and show the conclusion again\n        self.clear()\n        self.wait(1)\n        conclusion_final = MathTex('a^2 + b^2 = c^2').move_to(DOWN * 3)\n        self.play(Write(conclusion_final))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that illustrates how to find the area under the curve of y = x^2 from x = 0 to x = 2, including both the visual representation of the graph and the integration steps to arrive at the numerical answer?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"CyclicReplace\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            star = Star()\n            circle = Circle()\n            triangle = Triangle()\n            vg = VGroup(square,star,circle,triangle)\n            vg.arrange(RIGHT)\n            self.play(CyclicReplace(*vg))\n            self.wait()\n            self.remove(square,star,circle,triangle)"
    },
    {
        "query": "Can you create an educational animation that shows step-by-step how to solve a triple integral problem, specifically the integral of xyz over the range from -1 to 1 for all variables? The animation should include writing out the problem, followed by a series of steps and explanations for integrating with respect to each variable z, y, and x, in that order, with a delay after each major step so it's clear to the viewer. Also, include the final solution at the end and make sure the text explaining the steps is easy to read and positioned at the top of the screen.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the method of rectangles\n        explanation1 = Text(\"Approximate area using rectangles\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Graph the function\n        axes = Axes(\n            x_range=[0, 2.5, 0.5],\n            y_range=[0, 4.5, 1],\n            x_length=5,\n            y_length=4,\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        self.play(Create(axes), Create(graph), FadeIn(graph_label))\n        self.wait(1)\n\n        # Display rectangles\n        rects = axes.get_riemann_rectangles(graph, x_range=[0, 2], dx=0.25)\n        self.play(Create(rects))\n        self.wait(2)\n\n        # Explanation for the actual integration\n        explanation2 = Text(\"Calculate the exact area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{2^3}{3} = \\frac{8}{3}\")\n        self.play(ReplacementTransform(rects, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(graph_label), FadeOut(explanation1))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that illustrates the concept of the Taylor series expansion by showing the mathematical function e^x along with its Taylor approximation up to the x cubed term? First, display the function 'f(x) = e^x' on the screen, then write out its approximate Taylor series expansion starting with '1 + x' through to 'x cubed over 3 factorial', followed by an ellipsis to imply the series continues indefinitely. Explain with text that this is an approximation around the point x=0 and highlight the polynomial terms specifically. Also mention that adding more terms of the series increases the approximation accuracy.\n\nAfter the text explanations, could you show a graph with the real function 'e^x' plotted, labeled accordingly, and demonstrate the polynomial approximation on the same graph with a different color to distinguish it? Then label the polynomial approximation as well. Finally, conclude the animation by clearing the screen and summarizing that this is the Taylor series approximation of e^x.",
        "answer": "\\n from manim import *\n\nclass CircumscribeExample(Scene):\n    def construct(self):\n        text = Text(\"Inscribe\")\n        self.add(text)\n        self.wait(0.5)\n        self.play(Transform(text, Text(\"Inscribe a Square\").shift(DOWN*2)))\n        self.wait(0.5)\n\n        square = Square()\n        square.surround(text)\n        self.play(ShowCreation(square))\n        self.wait(0.5)\n\n        self.play(FadeOut(square))\n        self.wait(0.5)\n\n        self.play(Transform(text, Text(\"Inscribe a Triangle\").shift(DOWN*2)))\n        self.wait(0.5)\n\n        triangle = Triangle()\n        triangle.surround(text)\n        self.play(ShowCreation(triangle))\n        self.wait(0.5)\n\n        self.remove(triangle, text)"
    },
    {
        "query": "I need to create an educational animation to help students understand how to integrate exponential functions. Specifically, I want to showcase the process of integrating the function e raised to the 2x power with respect to x. The animation should start by displaying the integral of e^(2x) with respect to x. Then, it should include a step-by-step explanation that demonstrates integrating by using the reverse power rule, complete with written commentary. After showing the result of this integration, which is one-half times e^(2x) plus a constant of integration, I would like the initial problem to transform smoothly into the final answer. Once that is done, I want to clear the frame and conclude by stating, \"The integral of an exponential\", followed by a display of the final integration result again. The entire process should be paced slowly enough for students to follow along, with each step displayed for a couple of seconds before moving on to the next. Can you create an animation that meets these requirements?",
        "answer": "\\n from manim import *\n\nclass ExponentIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x^2 e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using integration by parts\n        explanation1 = Text(\"Use integration by parts\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration by parts formula\n        parts_formula = MathTex(r\"\\int u \\,dv = uv - \\int v \\,du\")\n        self.play(ReplacementTransform(problem.copy(), parts_formula))\n        self.wait(1)\n\n        # Define u and dv\n        u_and_dv = MathTex(r\"u=x^2\", r\", \\quad dv=e^x\\,dx\")\n        self.play(Write(u_and_dv))\n        self.wait(2)\n\n        # Define du and v\n        du_and_v = MathTex(r\"du=2x \\,dx\", r\", \\quad v=e^x\")\n        self.play(Transform(u_and_dv, du_and_v))\n        self.wait(2)\n\n        # Apply the formula\n        substitute_parts = MathTex(r\"x^2 e^x - \\int 2x e^x \\,dx\")\n        self.play(ReplacementTransform(parts_formula, substitute_parts))\n        self.wait(2)\n\n        # Solve the remaining integral\n        final_integration = MathTex(r\"x^2 e^x - \\left( 2xe^x - 2\\int e^x \\,dx \\right)\")\n        self.play(Transform(substitute_parts, final_integration))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= x^2 e^x - 2xe^x + 2e^x + C\")\n        self.play(ReplacementTransform(final_integration, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that explains the wave equation from physics. Can you visualize the wave equation as a partial differential equation, and then display a text explanation emphasizing that it is a second-order linear PDE? Next, show that the general solution depends on initial and boundary conditions, and transform the displayed equation into its general solution format. Finally, present another text explanation highlighting that for the 1D wave equation, this general solution is known as d'Alembert's formula. The animation should start by writing out the wave equation, followed by the textual explanations and transformations, and conclude with a clear formulation of d'Alembert's formula.",
        "answer": "\\n from manim import *\n\nclass MoleculeMovementScene(Scene):\n    def construct(self):\n        # Create a grid of atoms representing a molecule\n        molecule_grid = self.create_molecule_grid(rows=3, cols=3)\n        molecule_grid.move_to(ORIGIN)\n        self.add(molecule_grid)\n\n        # Randomly move an electron around the molecule grid\n        moving_electron = electron().shift(LEFT * 2 + UP * 2)\n        self.add(moving_electron)\n\n        # Define complex path for the electron to move along\n        path_points = [\n            UR * 2, RIGHT * 2 + DOWN, UP + LEFT * 2, DOWN * 2 + RIGHT, ORIGIN\n        ]\n\n        # Move the electron along the path\n        self.play(\n            *move_along_complex_path(moving_electron, stop_indices=[1, 3], points=path_points, run_time=2)\n        )\n        self.wait(1)\n\n    def create_molecule_grid(self, rows: int, cols: int) -> Mobject:\n        # Create a grid of alternating positive and negative ions\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                ion = positive() if (i + j) % 2 == 0 else negative()\n                ion.move_to(i * RIGHT + j * UP)\n                grid.add(ion)\n        return grid.shift(DOWN + LEFT)"
    },
    {
        "query": "I would like an educational animation that visually demonstrates the process of solving a definite integral step by step. The integral to be solved should be the integral of x squared from 2 to 3. I want the animation to begin by displaying this integral. Then it should guide me through the solution using the power rule for integration, showing both the indefinite integral and the constant of integration. After that, the animation needs to clearly show how to evaluate the antiderivative at the upper and lower bounds of the integral, and then subtract the lower bound value from the upper bound value to reach the final answer. Finally, the solution should be clearly displayed on its own to emphasize the result. Can you create such an animation that walks through this math problem in a clear, step-by-step visual format?",
        "answer": "\\n from manim import *\n\nclass LinearTransformationSceneExample(Scene):\n    def construct(self):\n        # Define the matrices\n        matrix_A = [[2, 1], [1, 3]]\n        matrix_tex_A = MathTex(r\"\\begin{bmatrix} 2 & 1 \\\\ 1 & 3 \\end{bmatrix}\")\n\n        # Display the matrix A\n        self.play(Write(matrix_tex_A))\n        self.wait(1)\n        \n        # Explain what we will show\n        explanation = Text(\"Visualize a linear transformation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Create a grid and vector\n        grid = NumberPlane()\n        vector = Arrow(start=grid.c2p(0, 0), end=grid.c2p(1, 2), buff=0, color=YELLOW)\n        vector_label = MathTex(\"v\", color=YELLOW).next_to(vector.get_end(), RIGHT)\n        \n        # Display grid and vector\n        self.play(Create(grid), run_time=3)\n        self.play(GrowArrow(vector), Write(vector_label))\n        self.wait(2)\n\n        # Apply linear transformation\n        transformation = grid.apply_matrix(matrix_A)\n        transformed_vector = vector.copy().apply_matrix(matrix_A)\n        transformed_vector_label = MathTex(\"Av\", color=YELLOW).next_to(transformed_vector.get_end(), RIGHT)\n        \n        self.play(transformation, run_time=3)\n        self.play(Transform(vector, transformed_vector), Transform(vector_label, transformed_vector_label))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with showing the matrix again\n        self.play(Write(matrix_tex_A))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that explains the concept of Fourier series. It should begin by displaying the Fourier series equation on the screen followed by a brief wait. Then, I want the title \"Fourier Series\" to appear at the top of the screen. After that, there should be a simple explanation text stating that Fourier series represent periodic functions which transitions into another text mentioning how the coefficients of the series are calculated based on the function's periodicity. Furthermore, include an equation that shows an example of calculating the Fourier coefficients. Next, I would like to demonstrate a square wave approximation using a Fourier series with three terms and finally conclude with a statement on the significance of Fourier series in signal processing and analysis. Can you create an animation that visually presents all these elements in an instructive and engaging way for someone learning about Fourier series?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} [\\frac{1}{2}x y z^2]_{0}^{3} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{3}{2} x^2 y]_{0}^{2} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{3}{2} y^2]_{0}^{1}\", r\"= \\frac{3}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The triple integral evaluates to 3/2\", font_size=24)\n        self.clear()\n        self.wait(1)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the steps to evaluate a double integral in polar coordinates, starting with the setup of the integral, then showing how to integrate with respect to the radial coordinate r first and finally integrating with respect to the angular coordinate theta to find the final solution?",
        "answer": "\\n from manim import *\n\nclass BatteryAnimation(Scene):\n    def construct(self):\n        anode = self.create_electrode(\"Anode\", LEFT * 2)\n        cathode = self.create_electrode(\"Cathode\", RIGHT * 2)\n        battery = VGroup(anode, cathode)\n        self.add(battery)\n\n        electron_path = self.get_electron_path(LEFT * 2, RIGHT * 2, 3)\n        electron = electron().move_to(anode)\n        self.play(*move_along_complex_path(electron, [], electron_path, run_time=5, rate_func=there_and_back))\n\n    def create_electrode(self, label_text, position):\n        electrode = Rectangle(height=3, width=1, fill_opacity=1, fill_color=DARK_GREY)\n        label = Tex(label_text, color=WHITE)\n        electrode_group = VGroup(electrode, label).arrange(DOWN)\n        electrode_group.move_to(position)\n        return electrode_group\n\n    def get_electron_path(self, start_point, end_point, num_curves):\n        path = [start_point]\n        for i in range(num_curves):\n            path.append(path[-1] + UP if i % 2 == 0 else path[-1] + DOWN)\n            path.append(end_point if i % 2 == 0 else start_point)\n        return path"
    },
    {
        "query": "I'd like an animated educational video that explains what a Fourier series is and shows the equation of a Fourier series. First, display the equation with a brief pause. Then, in simple terms, describe what a Fourier series does, mentioning its ability to break down periodic functions into sums of sines and cosines, with each point appearing in succession. Afterward, give an example of its applications in fields like signal processing and physics. Furthermore, show how a partial sum of the series can be used to approximate functions, and conclude by indicating that we can approximate the functions using a finite number of terms. Finally, clear the screen and end with a statement summarizing the significance of the Fourier series in harmonic analysis. Ensure that each step is accompanied by appropriate pauses.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\frac{\\partial^2 u}{\\partial x^2} = 0\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Description of the wave equation\n        description = Text(\"This equation describes wave propagation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(description, shift=UP))\n        self.wait(2)\n\n        # Introduce a specific solution\n        solution_text = Text(\"A particular solution is the sine wave function\", font_size=24).to_edge(UP)\n        self.play(Transform(description, solution_text))\n        self.wait(2)\n\n        # Displaying a specific solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t + \\phi)\")\n        self.play(ReplacementTransform(wave_eq, specific_solution))\n        self.wait(1)\n\n        # Discuss the parameters of the sine wave solution\n        params_text = Text(\"Here, A is the amplitude, k is the wavenumber, \\omega is the frequency, and \\phi is the phase offset.\", font_size=20, line_spacing=1.5).to_edge(UP)\n        self.play(Transform(description, params_text))\n        self.wait(2)\n\n        # Clearing the screen\n        self.play(FadeOut(description), FadeOut(specific_solution))\n        self.wait(1)\n\n        # Conclude by writing a simplified version of the sine wave without a phase offset\n        simple_wave = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(Write(simple_wave))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that explains the process of solving a simple first-order differential equation. The content should begin by showing the differential equation y' - y = 0, and then proceed to explain how to form its characteristic equation. After forming the characteristic equation, r - 1 = 0, it should demonstrate how to find the roots of this equation. Once we have the root r = 1, the animation should then present the general solution to the differential equation which is y = C e^x, where C is an arbitrary constant. Throughout the animation, it would be helpful to have written explanations that appear at the top of the screen guiding viewers through each step of the process. Lastly, the entire solution process should conclude with the final general solution displayed clearly on the screen. Can this be visualized in an animation?",
        "answer": "\\n from manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.background_color = \"#faf4e1\"\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        colors = it.cycle([\n            \"#f55e61\",\n            \"#408ef5\",\n            \"#e3883d\",\n            \"#a346eb\",\n            \"#0dc786\"\n        ])\n\n        fib_numbers = [0, 1]\n        for _ in range(7):\n            fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n        \n        squares = VGroup()\n        for index, number in enumerate(fib_numbers[2:]):\n            color = next(colors)\n            square = Square(side_length=number).set_stroke(color, width=3).set_fill(color, opacity=0.5)\n            squares.add(square)\n        \n        squares.arrange_in_grid(buf=0)\n        center_of_spiral = squares.get_center()\n        \n        self.play(AnimationGroup(*[FadeIn(square, shift=0.5*UP) for square in squares], lag_ratio=0.2))\n        self.wait()\n        \n        arcs = VGroup()\n        for s1, s2 in zip(squares[:-1], squares[1:]):\n            angle = 90 * DEGREES if s2.get_y() < s1.get_y() else -90 * DEGREES\n            radius = abs(s1.get_width() - s2.get_width()) / 2\n            arc = Arc(radius=radius, angle=angle, arc_center=s1.get_center())\n            arc.move_arc_center_to(s1.get_center())\n            arcs.add(arc)\n        \n        arcs.set_color_by_gradient(RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE)\n        self.play(AnimationGroup(*[ShowCreation(arc) for arc in arcs], lag_ratio=0.4))\n        self.wait()\n\n        last_square = squares[-1]\n        circles = VGroup()\n        for n in fib_numbers[2:]:\n            circle = Circle(radius=n/2).set_stroke(BLACK, width=3)\n            circle.move_to(last_square)\n            last_square = circle\n            circles.add(circle)\n        \n        self.play(AnimationGroup(*[FadeIn(circle) for circle in circles], lag_ratio=0.7))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animated video that visually explains the steps to solve a triple integral, specifically integrating the function xyz over a volume V with respect to x, then y, and finally z, including written explanations for each integration step as the calculation progresses?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Drawing the axes\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE},\n        )\n        axes_labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Creating the curve f(x) = x^2 and the area under the curve\n        curve = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(curve, x_range=(0, 2), color=[BLUE, PURPLE], opacity=0.5)\n\n        # Displaying the curve formula and the axes\n        curve_label = MathTex(\"f(x) = x^2\").to_edge(UP)\n        self.play(Write(axes), Write(axes_labels))\n        self.play(Write(curve), Write(curve_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(1)\n\n        # Problem statement\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\").next_to(area, DOWN)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Calculation\n        calculation = MathTex(r\"= \\left[ \\frac{x^3}{3} \\right]_0^2\",\n                              r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\",\n                              r\"= \\frac{8}{3}\").to_edge(DOWN)\n\n        self.play(Write(calculation[0]))\n        self.wait(1)\n        self.play(ReplacementTransform(calculation[0], calculation[1]))\n        self.wait(1)\n        self.play(ReplacementTransform(calculation[1], calculation[2]))\n        self.wait(2)\n\n        # Clear and show final result\n        self.clear()\n        self.play(Write(curve_label), Write(calculation[2]))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually presents the wave equation, explains it briefly, shows the wave speed within the equation, introduces d'Alembert's solution formula, and finally gives a specific example of a sinusoidal traveling wave?",
        "answer": "\\n from manim import *\n\nclass GrowFromPointExample(Scene):\n    def construct(self):\n        text = Text(\"Original Text\").to_edge(UP)\n        self.add(text)\n        self.play(Transform(text, Text(\"Transformed Text\").to_edge(DOWN)), run_time=1)\n        square = Square()\n        self.play(GrowFromPoint(square, point=ORIGIN))\n        self.remove(square)"
    },
    {
        "query": "I'm looking to create an educational animation to explain the heat equation, a second-order partial differential equation used in thermodynamics and heat transfer. The animation should start by displaying the heat equation itself, then introduce the concept with text saying \"The heat equation is a second-order PDE.\" Next, I want to provide a more detailed explanation with another sentence stating \"It describes the distribution of heat in a given region over time.\" After that, demonstrate the concept of steady-state solution by transforming the heat equation into the steady-state form and include text to explain that \"A steady-state solution does not change with time.\" At the end, clear the screen and leave only the steady-state equation for emphasis. The text should appear on the upper part of the screen throughout the animation. Can you create a step-by-step animation like this for me?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation = Text(\"Evaluating the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Power rule for definite integrals\n        power_rule_definite = MathTex(r\"\\int_a^b x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_a^b\")\n        self.play(Write(power_rule_definite))\n        self.wait(2)\n\n        # Evaluating the limits\n        limits_eval = MathTex(r\"=\\left. \\frac{x^{3}}{3} \\right|_0^1\")\n        self.play(ReplacementTransform(problem.copy(), limits_eval))\n        self.wait(1)\n\n        # Solution after limits are substituted\n        solution = MathTex(r\"= \\frac{1^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(Transform(limits_eval, solution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}\")\n        self.play(ReplacementTransform(solution, final_solution))\n        self.wait(1)\n\n        # Show final answer\n        final_answer = Text(\"The area under the curve from 0 to 1 is 1/3.\", font_size=24).next_to(final_solution, DOWN)\n        self.play(Write(final_answer))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_solution), Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated educational video that explains the concept of finding the area under the curve of the function f(x) = x^2 from x=0 to x=2. The video should start by displaying the integral problem, then show a graphical representation of this function on a set of axes, and proceed to approximate the area under the curve using the method of rectangles. After the approximation, it should transition to explaining the actual integration process followed by showing the final solution of the integral. Each step should be displayed with clear visual and textual explanations, and there should be pauses between each step to ensure the viewer can follow along. Can you please create a scene that accomplishes this?",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass SumPattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Group(\n            Tex(\"Observe a sequ\u00eancia\", color=LIGHT_RED_COLOR),\n            Tex(\"abaixo:\", color=LIGHT_RED_COLOR)\n        )\n        title.arrange(DOWN)\n        title.scale(1.8)\n        title.shift(3.5 * UP)\n        pattern_text = Tex(\"1, 2, 3, 4, 5, 6, 7, 8, ...\", color=TEXT_COLOR)\n        pattern_text.scale(1.5)\n        previous_arc = None\n        previous_arc_text = None\n\n        self.play(\n            FadeIn(title), \n            FadeIn(pattern_text), \n            run_time=0.5\n        )\n        self.wait(0.3)\n        self.play(Circumscribe(pattern_text[0][0], color=LIGHT_RED_COLOR, run_time=2.5))\n\n        for i in range(7):\n            start = -2.7 + i * 0.85\n            end = start - 0.8\n\n            if i % 2 == 0:\n                y = 0.5\n                direction = UP\n            else:\n                y = -0.5\n                direction = DOWN\n\n            arc = ArcBetweenPoints([start, y, 0], [end, y, 0], color=LIGHT_RED_COLOR)\n            arc.flip(UP)\n\n            if i % 2 == 1: \n                arc.flip(RIGHT)\n\n            arc.add_tip(tip_shape=ArrowTriangleFilledTip)\n            arc_text = Tex(\"+1\", color=LIGHT_RED_COLOR)\n            arc_text.scale(0.8)\n            arc_text.next_to(arc, direction)\n\n            if previous_arc is None:\n                self.play(FadeIn(Group(arc_text, arc)), run_time=0.2)\n            else:\n                self.play(\n                    Transform(previous_arc_text.copy().set_opacity(0), arc_text), \n                    Transform(previous_arc.copy().set_opacity(0), arc),\n                    rate_func=rate_functions.rush_from,\n                    run_time=0.3\n                )\n\n            previous_arc_text = arc_text\n            previous_arc = arc\n            self.wait(0.5)\n\n        self.wait(0.5)\n        self.play(FadeOut(Group(*self.mobjects[1:]), run_time=0.5))\n        self.remove(*self.mobjects)"
    },
    {
        "query": "I would like to create an educational animation that visually explains the steps to solve a triple integral using spherical coordinates. Specifically, I want to solve the triple integral of \u03c1^2 sin \u03c6 with respect to \u03c1, then \u03b8, and finally \u03c6, over the ranges of 0 to 1 for \u03c1, 0 to 2\u03c0 for \u03b8, and 0 to \u03c0 for \u03c6. The animation should include the written integral problem, and step-by-step animations showcasing each stage of the integration process, complete with textual explanations guiding through the integration with respect to \u03c1, then \u03b8, then \u03c6, and finally evaluating the integral to find the numerical result. Can you create this animated visualization to help students understand the concept and steps of evaluating triple integrals in spherical coordinates?",
        "answer": "\\n from manim import *\n\nclass MolecularAnimation(Scene):\n    def construct(self):\n        # Create a sequence of objects\n        mol1 = electron()\n        mol2 = metal()\n        mol3 = positive()\n        mol4 = negative()\n        \n        # Position objects on the screen\n        mol_group = VGroup(mol1, mol2, mol3, mol4).arrange(RIGHT, buff=1)\n\n        # Animate the objects\n        self.play(Create(mol_group))\n        self.wait(1)\n\n        # Show them moving to different locations\n        self.play(\n            mol1.animate.shift(UP * 2),\n            mol2.animate.shift(DOWN * 2),\n            mol3.animate.shift(LEFT * 2),\n            mol4.animate.shift(RIGHT * 2),\n        )\n        self.wait(2)\n\n        # Disappear animation\n        self.play(FadeOut(mol_group))"
    },
    {
        "query": "I would like to see an animated video explaining the concept of finding the area under the curve y = x^2 from x = 0 to x = 2, including the steps for calculating the definite integral, writing out the antiderivative, substituting the upper and lower limits, and showing the final numerical value of the area. Can you create a visual presentation of this process, with each mathematical step appearing one after another?",
        "answer": "\\n from manim import *\n\nclass SquareWithText(Scene):\n    def construct(self):\n        s = self.square_with_text(2, \"Manim\", RED, 36, WHITE, 3, YELLOW)\n        self.play(Create(s))\n        self.wait(2)\n\n    def square_with_text(\n        self, side_length: float, txt: str, color=WHITE, font_size: int = 48,\n        font_color=BLACK, stroke_width: int = 2, fill_color=WHITE\n    ) -> Mobject:\n        sqr = Square(side_length, color).set_stroke(color).set_fill(fill_color, opacity=1.0)\n        t = Text(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(sqr, t).move_to(ORIGIN)"
    },
    {
        "query": "Can you create an educational animation that visually explains the process of solving a double integral in polar coordinates, specifically showing step-by-step how to integrate `\u222b from 0 to 2\u03c0 \u222b from 0 to 1 of r dr d\u03b8`? The animation should include the initial problem, text explanations before each step, and the mathematical work of performing the inner integral with respect to 'r' first, then computing the outer integral with respect to '\u03b8', and finally displaying the numeric answer. Each step should appear one after the other with a short pause between them for clarity.",
        "answer": "\\n from manim import *\n\nclass HydrogenGrid(Scene):\n    def construct(self):\n        rows, cols = 5, 6\n        hydrogen_grid = VGroup(*[self.hydrogen_atom().move_to([j - rows//2, i - cols//2, 0]) \n                                 for i in range(rows) for j in range(cols)])\n        self.add(hydrogen_grid)\n    \n    def hydrogen_atom(self) -> Mobject:\n        electron = Circle(radius=0.1, color=BLUE).set_fill(BLUE, opacity=1)\n        proton = Circle(radius=0.15, color=RED).set_fill(RED, opacity=1)\n        text_e = Text(\"e-\", color=WHITE, font_size=18).move_to(electron.get_center())\n        text_p = Text(\"p+\", color=WHITE, font_size=18).move_to(proton.get_center())\n        return VGroup(electron, text_e, proton, text_p).arrange(RIGHT, buff=0.25)"
    },
    {
        "query": "Create an animation that shows the wave equation for a vibrating string, followed by displaying the speed of light. Then, move the wave equation to the top of the screen and place the speed of light directly below it. Afterward, add a text explanation beneath them stating that the general solution to the wave equation involves sine and cosine functions, or exponentials with an imaginary argument. Next, transform the wave equation into an example solution involving a combination of cosine and sine functions, and replace the explanatory text with a new one that indicates the waves are traveling in the x direction. Finally, clear the screen by fading everything out.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty}(a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Explanation of Fourier series\n        explanation1 = Text(\"Fourier series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation2 = Text(\"The coefficients a_n and b_n are specific to the function's shape\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Display coefficients\n        coefficients = MathTex(r\"a_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\cos(nx) dx,\\ b_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\sin(nx) dx\")\n        self.play(ReplacementTransform(fourier_series, coefficients))\n        self.wait(2)\n\n        # Explanation of convergence\n        explanation3 = Text(\"The series converges to f(x) as n approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(coefficients))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that visually explains how to evaluate the definite integral of x cubed from 2 to 3. Start by showing the integral equation, then demonstrate the power rule for integration. After that, apply the limits from 2 to 3 to the integrated function. Next, calculate the exact numerical value using these limits according to the Fundamental Theorem of Calculus. Finally, simplify and present the result, clearing the board before showing the final answer clearly. Can you guide me through each step with both visual and textual explanations?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{2}r^2]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Integrate with respect to \\(\\\\theta\\) now\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} \\int_{0}^{2\\pi} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Computing the final integral\n        computed_solution = MathTex(r\"= \\frac{1}{2} [ \\theta ]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(final_solution, computed_solution))\n        self.wait(1)\n        \n        # Displaying the final answer\n        answer = MathTex(r\"= \\pi\")\n        self.play(ReplacementTransform(computed_solution, answer))\n        self.wait(2)"
    },
    {
        "query": "I would like an educational animation that visually explains the process of solving the definite integral of the function 2x from 1 to 3, including the power rule of integration, evaluating the antiderivative at the limits, and showing each step with both mathematical expressions and explanatory text. Can you also ensure the steps are shown clearly one after the other with appropriate pauses for understanding, and finish with displaying the final numeric answer?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display the Fourier Series formula\n        formula = MathTex(r\"f(x) \\approx a_0 + \\sum_{n=1}^{\\infty} \\left( a_n \\cos(nx) + b_n \\sin(nx) \\right)\")\n        self.play(Write(formula))\n        self.wait(2)\n\n        # Explanation of Fourier Series\n        explanation1 = Text(\"Fourier series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Visualization of the first three terms\n        first_three_terms = MathTex(r\"f(x) \\approx a_0 + a_1 \\cos(x) + b_1 \\sin(x) + a_2 \\cos(2x) + b_2 \\sin(2x) + a_3 \\cos(3x) + b_3 \\sin(3x)\")\n        self.play(Transform(formula, first_three_terms))\n        self.wait(2)\n\n        # Explanation of Convergence\n        explanation2 = Text(\"As more terms are added, the series converges to f(x)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clearing the explanation and showing the plot\n        self.remove(explanation1)\n        self.play(ShowCreation(formula))\n        self.wait(2)\n        \n        # Plot of a periodic function using Fourier series\n        axes = Axes(\n            x_range=[-PI, PI, PI/2],\n            y_range=[-1.5, 1.5],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: np.sin(x), color=WHITE)\n        self.play(Write(axes), ShowCreation(graph))\n        self.wait(2)\n\n        # Conclude with the graph\n        self.clear()\n        self.play(ShowCreation(graph))\n        self.wait(1)"
    },
    {
        "query": "\"I would like to create an educational math animation showing the concept of finding the area under a curve on a graph. Specifically, could you illustrate how to calculate the area under the curve y = x^2 from x = 1 to x = 3 using the method of Riemann rectangles? Start by displaying the graph of the function with labeled axes and the curve in green. Then, animate the shading of the appropriate region under the curve in blue with a semi-transparent effect. Afterward, present the calculated area using the integral notation on-screen, and finally, remove everything except the result, which should be centered. The animation should pause briefly at each step to allow viewers to follow along.\"",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area under the curve\n        function = MathTex(r\"f(x) = x^2\")\n        area = MathTex(r\"A = \\int_{a}^{b} f(x) \\,dx\")\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Write(area))\n        self.wait(2)\n\n        # Show the definite integral bounds\n        bounds = MathTex(r\"a=1, \\quad b=2\")\n        self.play(Write(bounds))\n        self.wait(2)\n\n        # Perform the definite integral\n        definite_integral = MathTex(r\"A = \\int_{1}^{2} x^2 \\,dx\")\n        self.play(ReplacementTransform(area, definite_integral))\n        self.wait(2)\n\n        # Solve the definite integral\n        solved_integral = MathTex(r\"A = \\left.\\frac{x^3}{3}\\right|_{1}^{2}\")\n        self.play(ReplacementTransform(definite_integral, solved_integral))\n        self.wait(2)\n\n        # Calculate the area value\n        area_value = MathTex(r\"A = \\frac{2^3}{3} - \\frac{1^3}{3}\")\n        self.play(ReplacementTransform(solved_integral, area_value))\n        self.wait(2)\n\n        # Simplify the result\n        simplified_result = MathTex(r\"A = \\frac{7}{3}\")\n        self.play(ReplacementTransform(area_value, simplified_result))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"The area under the curve is 7/3.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(simplified_result), Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that visually explains how to calculate the area under the curve of x squared from x=1 to x=3. The animation should start by displaying the integral formula for the area under the curve. Then it should show a brief introductory text that says \"Calculating the area under the curve\" followed by the animated steps of the integration process. After that, another text should replace the first one stating \"Substitute the upper and lower bounds\" to indicate the evaluation of the integral from the lower to the upper limit. Finally, show the details of the calculation and the final answer, and end with a clear screen that only displays the final numerical result. Can you create such an educational animation without assuming I have any background in programming?",
        "answer": "\\n from manim import *\n\nclass ExampleSinCosScene(Scene):\n    def construct(self):\n        # Problem statement\n        problem = MathTex(r\"\\int \\sin^2(x) - \\cos^2(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Show a trigonometric identity\n        identity = Text(\"Apply trig identity\", font_size=24).to_edge(UP)\n        self.play(Write(identity))\n        self.wait(2)\n\n        # Transformation using trig identity\n        identity_step = MathTex(r\"\\int \\cos(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, identity_step))\n        self.wait(1)\n\n        # Explanation for the integral solution\n        explanation = Text(\"Solve the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(identity, explanation))\n        self.wait(2)\n\n        # Solution to the integral\n        solution = MathTex(r\"= \\frac{1}{2}\\sin(2x) + C\")\n        self.play(ReplacementTransform(identity_step, solution))\n        self.wait(1)\n\n        # Clearing everything off the screen\n        self.play(FadeOut(identity), FadeOut(solution))\n        self.wait(1)\n\n        # Displaying the final answer\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation that shows the process of evaluating the double integral of \\(e^{y^2}\\) with respect to y from 0 to x and then with respect to x from 0 to 1, including intermediate steps and relevant explanations at each step?",
        "answer": "\\n from manim import *\nimport numpy as np\nfrom manim_ml.neural_network.layers import *\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\n\nROOT_DIR = Path(__file__).parent\n\nclass NeuralNetworkScene(MovingCameraScene):\n    def construct(self):\n        # Load image and convert to numpy array\n        image_path = ROOT_DIR / \"assets/mnist/sample_digit.png\"\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n        \n        # Define a simple neural network\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=2),\n            Convolutional2DLayer(\n                num_feature_maps=1,\n                feature_map_size=5,\n                filter_size=3,\n                padding=1,\n                stride=1,\n            ),\n            MaxPoolingLayer(\n                pool_size=2,\n                stride=2,\n            ),\n            FlattenLayer(),\n            FeedForwardLayer(10),\n        ])\n        \n        # Animation: Show neural network layers and perform forward pass\n        self.play(Create(nn))\n        self.wait(1)\n        forward_pass_animation = nn.make_forward_pass_animation()\n        self.play(forward_pass_animation)\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that demonstrates how to evaluate the definite integral of x squared from 0 to 2, including the step-by-step process from stating the problem to showing the calculation of the indefinite integral, applying the bounds, evaluating at the bounds, and then presenting the final solution? Also, can you include a brief pause after each step so that the viewer has time to understand what's happening?",
        "answer": "\\n from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identities\n        explanation1 = Text(\"Use the identity: sin(2x) = 2 sin(x) cos(x)\", font_size=24)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Rewriting the integral using the identity\n        rewritten_integral = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(Transform(problem, rewritten_integral))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(rewritten_integral, integration_step))\n        self.wait(2)\n\n        # Displaying the substitution\n        substitution = Text(\"Now substitute back for x\", font_size=24)\n        self.play(Transform(explanation1, substitution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that walks through the process of solving the integral of x times e to the power of x using the integration by parts method? The animation should begin by displaying the problem, then have a textual explanation that we will use integration by parts, followed by showing the integration by parts formula. Next, it should display the choices for u and dv, show the calculations for du and v, demonstrate the application of the integration by parts to the original problem, and then provide another text explanation to integrate e to the power x simply. Cap it off with the animation of the final solution to the problem and end with a clear screen that only shows the final solution.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [frac{1}{2}x y z^2]_{0}^{2} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n        \n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n        \n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [2 x y]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n        \n        # Explanation for outer integral\n        explanation3 = Text(\"Lastly, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n        \n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [2 x^2]_{0}^{1}\", r\"= 2\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an animated educational video that illustrates the concept of finding the area under a curve using integrals. The animation should include a blue-colored set of axes and a green parabolic function graph. I want to display the area under the curve between the points 0.3 and 4.5 on the x-axis, highlighted with a gradient of red to green with a semi-transparent effect. Also, animate the addition of x-axis labels at the points 0.3 and 4.5. Next, show the corresponding integral notation above this area and then transform it to display the exact algebraic calculation of the integral. Once that's done, demonstrate the final result of the definite integral just below the calculation steps. Finally, clear the other elements away to leave just the highlighted area and the result visible. Make sure each step is clearly shown with sufficient time for a viewer to follow, pausing for a couple of seconds between steps.",
        "answer": "\\n from manim import *\n\nclass OscillationScene(Scene):\n    def construct(self):\n        title = Text(\"Simple Harmonic Motion\", font_size=34)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Display the equation of motion\n        equation = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation of the terms\n        explanation1 = Tex(\n            \"Where $m$ is mass, \\\\\",\n            \"$\\\\frac{d^2x}{dt^2}$ is acceleration, \\\\\",\n            \"and $k$ is the spring constant.\",\n            font_size=24\n        ).next_to(equation, DOWN)\n\n        self.play(FadeIn(explanation1, shift=UP))\n        self.wait(2)\n\n        # Forming the characteristic equation\n        char_eq = MathTex(r\"r^2 + \\omega^2 = 0\", r\"\\quad \\text{where } \\omega = \\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(equation.copy(), char_eq[0]))\n        self.wait(1)\n        self.play(Write(char_eq[1]))\n        self.wait(2)\n\n        # General solution with sine and cosine\n        general_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(FadeOut(explanation1), ReplacementTransform(char_eq, general_solution))\n        self.wait(2)\n\n        # Explanation for general solution\n        explanation2 = Tex(\"General solution with arbitrary constants $A$ and $B$.\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation2))\n        self.wait(2)\n\n        # Clear scene for final representation\n        self.clear()\n        self.play(Write(general_solution))\n        explanation3 = Tex(\"This represents the position $x(t)$ over time.\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation3))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation using ManimCE that explains the Taylor Series approximation of the exponential function e^x? I'd like to see the function f(x) = e^x first, then transform it into the general form of the Taylor Series. After that, please visually demonstrate the zeroth, first, and second approximations of the function. Conclude with a text explanation that as n approaches infinity, the Taylor Series converges to f(x). Finally, return to the original function to end the animation.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve = FunctionGraph(\n            lambda x: 0.1 * x**2 - 1,\n            x_range=[-3, 3],\n            color=BLUE\n        )\n        area = area = Integral(curve, (x, -3, 3))\n\n        equation = MathTex(r\"\\int_{-3}^{3} 0.1x^2 - 1 \\, dx\")\n        equation.to_edge(UP)\n\n        self.play(Write(equation))\n        self.wait(1)\n\n        self.play(ShowCreation(curve))\n        self.wait(1)\n\n        self.play(Write(area))\n        self.wait(2)\n\n        solution = MathTex(r\"= \\left[\\frac{0.1}{3}x^3 - x\\right]_{-3}^{3}\")\n        solution.next_to(equation, DOWN)\n\n        self.play(ReplacementTransform(equation.copy(), solution))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\left(\\frac{0.1}{3} \\cdot 3^3 - 3 \\right)\")\n        final_answer.add_updater(lambda m: m.next_to(solution, DOWN))\n\n        self.play(Write(final_answer))\n        self.wait(2)\n\n        final_evaluation = MathTex(r\"= 0\")\n        final_evaluation.add_updater(lambda m: m.next_to(final_answer, DOWN))\n\n        self.play(ReplacementTransform(final_answer, final_evaluation))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that illustrates the fundamental concepts of the wave equation, visually explains its components, demonstrates a sinusoidal solution, and shows how the principle of superposition applies to wave solutions?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Writing the function and the area to find\n        function_tex = MathTex(r\"f(x) = x^2\")\n        area_tex = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        problem_group = VGroup(function_tex, area_tex).arrange(DOWN)\n        self.play(Write(problem_group))\n        self.wait(1)\n\n        # Explain which area we want to find\n        explanation_text = Text(\"Finding area under curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation_text))\n        self.wait(2)\n\n        # Draw graph\n        axes = Axes(x_range=[0, 3], y_range=[0, 5], axis_config={\"include_tip\": True})\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        area = axes.get_area(graph, x_range=(0,2), color=BLUE, opacity=0.3)\n        graph_group = VGroup(axes, graph, area)\n        self.play(Create(graph_group))\n        self.wait(1)\n\n        # Do the calculation\n        calculation = MathTex(r\"= \\frac{1}{3} x^3 \\Bigg|_0^2\")\n        self.play(ReplacementTransform(area_tex.copy(), calculation))\n        self.wait(1)\n\n        # Final answer after calculation\n        final_answer = MathTex(r\"= \\frac{1}{3} (2)^3 - \\frac{1}{3} (0)^3\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(calculation, final_answer))\n        self.wait(1)\n\n        # Highlight final answer\n        box = SurroundingRectangle(final_answer, color=RED)\n        self.play(Create(box))\n        self.wait(2)\n\n        # Clear and show final answer only\n        self.clear()\n        self.play(Write(final_answer))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually explains how to compute the definite integral of the function x^3 from 0 to 2. The animation should begin by displaying the integral problem, then highlight the integration bounds, and explain how to apply the power rule of integration. After that, I want to see the integration carried out step by step, how to insert the limits of integration, and finally, evaluate and simplify the solution to find the area under the curve. The conclusion should emphasize the result, which is the area under the curve between 0 and 2. Can you create and describe a video that covers all these steps in an accessible and engaging way for my students learning calculus?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi/2} \\int_{0}^{1} \\rho^2 \\sin(\\phi) d\\rho\\,d\\phi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} [\\frac{1}{3}\\rho^3 \\sin(\\phi)]_{0}^{1} d\\phi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplified inner integral step\n        simplified_inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} \\frac{1}{3} \\sin(\\phi) d\\phi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner_integral))\n        self.wait(1)\n        \n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3} (-\\cos(\\phi))]_{0}^{\\pi/2}\")\n        self.play(ReplacementTransform(simplified_inner_integral, final_solution))\n        self.wait(1)\n\n        # Calculation of the final result\n        final_result = MathTex(r\"= \\frac{1}{3} (1 - (-1)) = \\frac{2}{3}\")\n        self.play(Write(final_result))\n        self.wait(2)\n        \n        # Complete Scene\n        complete_scene = VGroup(explanation2, final_solution, final_result).arrange(DOWN)\n        self.play(Transform(VGroup(explanation1, simplified_inner_integral, final_result), complete_scene))\n        self.wait(3)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the area under a curve on a graph. The specific function should be a quadratic equation, let's use y = 0.1x^2 as an example. The graph should have axes with both x and y ranges going from 0 to 10, labeled in increments of 1, and the axes should be colored blue for clarity. The curve itself should be plotted in green color.\n\nCould you show the calculated area under the curve between x = 0 and x = 4? I'd like the area to be shaded in yellow with a 50% opacity to ensure that the viewers can still see the curve underneath.\n\nAdditionally, I want an equation displayed in the top left corner stating the integral that represents the area under the curve, A = \u222b from 0 to 4 of 0.1x^2 with respect to x, clearly written in white color, and as the animation proceeds, a solution to that integral just below the problem, which is A = (1/3)0.1 * 4^3, also in white.\n\nThe animation should start with writing the problem equation, then show the creation of the axes and the plotting of the curve. Then it should proceed with fading in the shaded area under the curve, followed by transforming the shaded area into the solution equation. To conclude, everything should fade out, leaving a clean slate. Each step should hold for a moment to allow viewers to understand the process. Can you design such an animation for me?",
        "answer": "\\n from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eqn = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eqn))\n        self.wait(1)\n\n        # Adding a subtext for the equation\n        subtext_eqn = Text(\"Classical wave equation\", font_size=24).next_to(wave_eqn, DOWN)\n        self.play(FadeIn(subtext_eqn))\n        self.wait(2)\n\n        # Introducing a specific solution form\n        solution_text = Text(\"Consider a solution of the form:\", font_size=24).to_edge(UP)\n        self.play(Write(solution_text))\n        self.wait(1)\n\n        # Display the specific solution form\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(Transform(wave_eqn, specific_solution))\n        self.wait(2)\n\n        # Explain the constants\n        constants_expl = MathTex(r\"A =\", \" amplitude,\", r\"\\ k =\", \" wavenumber,\", r\"\\ \\omega =\", \" angular frequency\")\n        self.play(FadeIn(constants_expl))\n        self.wait(3)\n\n        # Transition to the general solution\n        general_solution = Text(\"General solutions are formed by combinations of these specific solutions.\", font_size=24).to_edge(UP)\n        self.play(Transform(solution_text, general_solution))\n        self.wait(2)\n\n        # Clear everything for last message\n        self.clear()\n        self.wait(1)\n        \n        # Display final message\n        final_message = Text(\"Thanks for watching!\", font_size=36)\n        self.play(FadeIn(final_message))\n        self.wait(2)"
    },
    {
        "query": "Please create an educational animation that visually demonstrates how to solve the basic definite integral of x cubed from 2 to 3. The animation should include the following steps:\n\n1. Write the initial integral problem on the screen.\n2. Introduce the rule for integrating powers of x by showing the power rule formula.\n3. Apply the definite integration limits to the power rule.\n4. Show the intermediate step of substituting the bounds into the integrated function.\n5. Replace the initial problem with this intermediate step to show progression.\n6. Bring attention to the process of simplifying this intermediate result by updating the previous explanation.\n7. Simplify the intermediate step into a more reduced form showing each term evaluated at the bounds.\n8. Further simplify the expression to the final numerical result.\n9. Finally, clear the screen and conclude by writing the numeric result once more.\n\nEnsure that each step appears sequentially and give a moment of pause between steps to allow for the information to be absorbed.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier Series formula\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} a_n \\cos(nx) + b_n \\sin(nx)\")\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Explanation of Fourier Series\n        explanation1 = Text(\"Fourier Series represents periodic functions.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explaining coefficients\n        explanation2 = Text(\"The coefficients a_n and b_n are specific to the function's shape.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Displaying the formula for coefficients\n        coefficients = MathTex(r\"a_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\cos(nx) dx\", r\"\\\\\",\n                               r\"b_n = \\frac{2}{T} \\int_{0}^{T} f(x) \\sin(nx) dx\"\n        ).next_to(fourier_series, DOWN)\n        self.play(Write(coefficients))\n        self.wait(3)\n\n        # Explanation of convergence\n        explanation3 = Text(\"The series converges to f(x) as n approaches infinity.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"Fourier Series decompose periodic functions into harmonic components.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(3)"
    },
    {
        "query": "I would like to have an animated educational video that explains the concept of Fourier series decomposition for a function. The animation should start by displaying the function \"f(x) = x^2\" and then continue with a text saying \"Decompose using Fourier series:\". Then, I want the Fourier series formula to come up and replace the function text. It should read \"f(x) ~ a0 + the sum from n=1 to infinity of (an*cos(2*pi*n*x) + bn*sin(2*pi*n*x))\". Before moving onto the next step, I want another piece of text to come in and say \"Calculate coefficients an and bn\". After showing where the coefficients should be, the animation should demonstrate the first few terms of the Fourier series as an approximation. Lastly, I want to end the video with a clear graph of the function \"f(x) = x^2\", complete with labeled axes and a curve representing the function. Can this sequence be beautifully and clearly animated to help students understand the Fourier series decomposition visually?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral_x = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral_x))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral_y = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral_x, middle_integral_y))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} \\frac{1}{2}z \\,dz\", r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral_y, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(explanation1, shift=DOWN), FadeOut(final_solution, shift=DOWN))\n        self.wait(1)\n        conclusion = Text(\"The triple integral evaluates to 1/4\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visually demonstrates the concept of finding the area under the curve of the function f(x) = x^2 from x=0 to x=2 using definite integration? I want the animation to include the following elements:\n\n1. Display a pair of X and Y axes with appropriate ranges and a blue color for the axes.\n2. At the top, show the integral formula of the function from 0 to 2.\n3. Plot the graph of the function f(x) = x^2 with a white color and label it with its equation.\n4. Highlight the area under the graph between 0 and 2 in green with some transparency to denote the area we are finding.\n5. Directly below the integral, show the calculation of the definite integral using the formula for the area under the curve: (upper bound)^3/3 - (lower bound)^3/3.\n6. After displaying the calculation, simplify the expression to show the final numerical value of the integral.\n7. After the calculation is shown, clear the other elements while leaving the simplified result displayed for a moment longer before ending the animation.",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network.layers import ConvolutionalLayer, FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 10.0\n\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        image_path = \"path/to/your/image.png\"\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n\n        # Define layers for Convolutional Neural Network\n        cnn_layers = [\n            ImageLayer(numpy_image, height=2),\n            ConvolutionalLayer(num_kernels=5, kernel_size=(3, 3), stride=1),\n            FeedForwardLayer(128),\n            FeedForwardLayer(64),\n            FeedForwardLayer(3)  # Assuming an output of 3 classes\n        ]\n\n        # Initialize Neural Network\n        cnn = NeuralNetwork(cnn_layers, layer_spacing=0.5)\n\n        # Scale and Position the CNN\n        cnn.scale(0.8)\n        cnn.to_edge(UP)\n\n        # Add CNN to the scene\n        self.play(FadeIn(cnn))\n\n        # Animate the forward pass\n        self.play(cnn.make_forward_pass_animation(), run_time=5)\n\n        # Pause to observe the result\n        self.wait(2)\n\n# Run the scene\nscene = CNNVisualizationScene()\nscene.render()"
    },
    {
        "query": "Can you create an educational animation that shows how to find the derivative of the polynomial function x^2 + 3x + 2 using the power rule, with step-by-step visual and textual explanations, and then displays the final derivative formula, while finishing with a message that confirms \"That's the derivative!\"?",
        "answer": "\\n         self.play(Transform(text,Text(\"Write\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Here is more text\")\n        self.play(Write(some_text))\n        self.play(Transform(text,Text(\"Unwrite\").shift(UP*2.5)), run_time=0.5)\n        self.play(Unwrite(some_text))\n        self.remove(some_text)"
    },
    {
        "query": "I would like to create an educational video that explains how to find the area under a curve using integration. Can you show me a visual animation where it starts by displaying a mathematical function, specifically f(x) = 3x^2 + 2, and poses an initial problem: finding the area under this curve from x = 1 to x = 2? After establishing this problem, I want the animation to graph the function on an x-y plane with axes ranging from 0 to 3 on the x-axis and 0 to 20 on the y-axis. I would also like the area of interest under the curve to be highlighted. Once the problem is visually represented, can the animation then show the integral of the function from 1 to 2, and the steps to solve it, eventually displaying the antiderivative and calculating the numerical area value? Finally, clear everything away and show only the final result of the area value. The explanation should pause at key steps to give viewers time to understand the process, and each part of the problem should smoothly transition into the next.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Display the limits of integration\n        limits = MathTex(r\"[2^4/4, 3^4/4]\")\n        self.play(Write(limits))\n        self.wait(2)\n\n        # Evaluating the definite integral\n        solution1 = MathTex(r\"= \\frac{3^4}{4} - \\frac{2^4}{4}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Simplifying the result\n        explanation2 = Text(\"Simplifying the result:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{81}{4} - \\frac{16}{4}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Further simplification\n        final_answer = MathTex(r\"= \\frac{65}{4}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "Can you create a step-by-step educational animation that visually explains how to evaluate the double integral in polar coordinates, specifically the integral of r^2 sin(theta) with respect to r from 0 to 1 and with respect to theta from 0 to pi? Please include the written problem, a step-by-step breakdown of evaluating the inner integral first with respect to r, then evaluating the resulting integral with respect to theta, and finally simplifying the final solution to its numerical value. Add explanatory texts that guide through the process of integrating with respect to r first and then theta.",
        "answer": "\\n from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Displaying the sum of a geometric series\n        series_problem = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for the formula of the sum of a geometric series\n        explanation1 = Text(\"Geometric series converges if |r| < 1\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Writing the formula for convergence\n        convergence_formula = MathTex(r\"S = \\frac{a}{1 - r}, \\text{ if } |r| < 1\")\n        self.play(ReplacementTransform(series_problem.copy(), convergence_formula))\n        self.wait(2)\n\n        # Example with actual numbers\n        specific_example = MathTex(r\"S = \\sum_{n=0}^{\\infty} \\frac{1}{2^n}\")\n        self.play(Write(specific_example))\n        self.wait(1)\n\n        # Showing the convergence value for the example\n        convergence_value = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}} = 2\")\n        self.play(ReplacementTransform(specific_example, convergence_value))\n        self.wait(1)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        final_result = Text(\"The sum converges to 2\", font_size=24)\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that first displays the formula of a Fourier series, followed by a brief textual explanation of what a Fourier series is? Then, replace the initial text with an explanation that the coefficients in the series are derived from the function itself. Next, can you transition to showing the actual formulas used to calculate these coefficients, and finish with another short explanation mentioning that each term in the series represents a harmonic of the base frequency? After all of this, clear everything away to conclude the presentation.",
        "answer": "\\n         self.play(Transform(text,Text(\"FadeIn\").shift(UP*2.5)), run_time=0.5)\n        square = Square()\n        self.play(FadeIn(square))\n        self.play(Transform(text,Text(\"FadeOut\").shift(UP*2.5)), run_time=0.5)\n        self.play(FadeOut(square))\n        self.remove(square)"
    },
    {
        "query": "I would like to create an educational animation that visually explains the process of calculating a double integral step by step. Can you show the integration of x squared over a circular region, first integrating with respect to x from 0 to the square root of 1 minus y squared, and then integrating the resulting expression with respect to y from 0 to 1? Also, include text explanations for each step of the integration process and conclude the animation by presenting the final numeric value of the integral.",
        "answer": "\\n from manim import *\n\nclass CoupledPendulumScene(Scene):\n    def construct(self):\n        # Create two pendulums\n        pendulum1 = Pendulum(\n            initial_theta=PI / 6,\n            length=3,\n            bob_radius=0.2,\n            color=RED,\n        )\n        pendulum2 = Pendulum(\n            initial_theta=-PI / 6,\n            length=3,\n            bob_radius=0.2,\n            color=BLUE,\n        )\n\n        # Position second pendulum\n        pendulum2.shift(RIGHT * pendulum1.length)\n\n        # Create a spring connecting the two pendulums\n        spring = Spring(\n            body_a=pendulum1.bob,\n            body_b=pendulum2.bob,\n            color=YELLOW\n        )\n\n        # Add pendulums and spring to the scene\n        self.add(pendulum1, pendulum2, spring)\n\n        # Animate pendulums swinging and spring reacting\n        self.play(\n            MoveAlongPath(pendulum1.bob, pendulum1.create_arc_trajectory()),\n            MoveAlongPath(pendulum2.bob, pendulum2.create_arc_trajectory()),\n            rate_func=there_and_back,\n            run_time=3\n        )\n\n        # Keep the scene displayed\n        self.wait()"
    },
    {
        "query": "Could you create an educational animation that visualizes the concept of finding the area under a curve, specifically the graph of f(x) = x^2, between the points x=0 and x=2? The animation should begin by displaying the coordinate axes with labeled x and y-axes, followed by plotting the curve f(x) = x^2. After the graph is shown, illustrate the actual area under the curve from 0 to 2 by shading it. Then, bring in the integral notation for the area we're considering at the top of the screen. Finally, step through the calculation of this definite integral, showing how to find the numerical value of the area under the curve, and then fade all elements out at the end of the animation.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{4}\\Big|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the boundaries 0 and 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the definite integral\n        evaluation = MathTex(r\"= \\left(\\frac{2^{4}}{4}\\right) - \\left(\\frac{0^{4}}{4}\\right)\")\n        self.play(ReplacementTransform(solution1, evaluation))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(evaluation, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        conclusion = Text(\"The definite integral evaluates to 4\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains how to calculate the area under the curve of the function f(x) = x^2 from x = 0 to x = 2? I would like to see the following steps visualized: first, display the function and the integral expression for the area we are looking for. Next, add a note to clarify that we are finding the area under the curve between x = 0 and x = 2. Then, show the graph of the function with the area under the curve highlighted. After that, visually depict the actual calculation of the integral, and present the final numeric answer. It would be nice to have the final answer stand out, maybe by enclosing it within a colored box. Finally, clear everything else away and leave only the final answer displayed.",
        "answer": "\\n from manim import *\n\nclass ParametricFunctionExample(Scene):\n    def construct(self):\n        # Display the parametric function\n        param_func_text = MathTex(r'\\vec{r}(t) = \\langle \\cos(t), \\sin(t) \\rangle')\n        self.play(Write(param_func_text))\n        self.wait(1)\n\n        # Explain the parametric curve representation\n        explanation1 = Text(\"This parametric function represents a circle\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # The parametric curve\n        circle = ParametricFunction(\n            lambda t: np.array([np.cos(t), np.sin(t), 0]),\n            t_range=[0, TAU]\n        )\n        self.play(ShowCreation(circle))\n        self.wait(2)\n\n        # Label point moving along the curve\n        dot = Dot(radius=0.08)\n        dot.move_to(circle.get_start())\n        dot_label = MathTex(r'\\vec{r}(t)', color=BLUE).next_to(dot, RIGHT)\n        self.play(FadeIn(dot), FadeIn(dot_label))\n        self.wait(1)\n\n        # Animate the point moving along the curve\n        self.play(MoveAlongPath(dot, circle), rate_func=linear, run_time=5)\n        self.wait(1)\n\n        # Explanation for the parametric curve evolution\n        explanation2 = Text(\"As t varies from 0 to 2\u03c0, the point traces the circle\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        final_message = Text(\"Parametric curves can represent complex shapes\", font_size=24)\n        self.play(Write(final_message))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the concept of finding the area under the curve of the function f(x) = x^2 from x = 0 to x = 2? I would like the animation to first display the graph of the function and shade the area under the curve between these two points. After that, can you show the corresponding integral expression beneath the shaded area, and then present the steps of evaluating this definite integral at the top of the screen, resulting in the final numerical value? Lastly, could you clear the screen at the end of the animation?",
        "answer": "\\n \nfrom manim import *\n\nfrom manim_physics import *\n\nclass StandingWaveExampleScene(Scene):\n    def construct(self):\n        wave1 = StandingWave(1)\n        wave2 = StandingWave(2)\n        wave3 = StandingWave(3)\n        wave4 = StandingWave(4)\n        waves = VGroup(wave1, wave2, wave3, wave4)\n        waves.arrange(DOWN).move_to(ORIGIN)\n        self.add(waves)\n        for wave in waves:\n            wave.start_wave()\n        self.wait()"
    },
    {
        "query": "I would like to create an educational animation that visually explains Euler's formula and its special case, Euler's Identity. The animation should start by displaying Euler's formula, \"e^(i\u03b8) = cos(\u03b8) + i sin(\u03b8)\", and then show a short text explaining that Euler's formula connects complex exponentials with trigonometry. After that, I want the animation to transform the variable \u03b8 into the constant \u03c0, demonstrating how the formula simplifies when \u03b8 equals \u03c0, leading up to showing the resulting simplified expression \"e^(i\u03c0) = -1 + 0i\". Finally, the animation should reveal Euler's Identity, \"e^(i\u03c0) + 1 = 0\", and conclude with a statement about the beauty of this equation in mathematics. Can you create this sequence of animations while making sure that each step is clearly displayed and transitioned?",
        "answer": "\\n from manim import Scene, VGroup, Circle, Line\n\nclass LinearTransformationScene(Scene):\n    def construct(self):\n        # Create a group of objects\n        group = VGroup(*[Circle() for i in range(3)])\n        group.arrange_in_grid(buff=1.0)\n\n        # Start by drawing the group\n        self.play(Create(group))\n\n        # Apply a transformation to the group\n        transformation_matrix = [[1, 2], [0, 1]]\n        self.play(group.animate.apply_matrix(transformation_matrix))\n\n        # Draw lines to represent the transformation axis\n        x_axis = Line(start=-2 * RIGHT, end=2 * RIGHT)\n        y_axis = Line(start=-2 * UP, end=2 * UP)\n        self.play(Create(x_axis), Create(y_axis))\n\n        # Show the transformed group\n        self.wait(2)\n\n        # Fade out everything\n        self.play(FadeOut(group), FadeOut(x_axis), FadeOut(y_axis))"
    },
    {
        "query": "I would like to create an educational math animation where we visualize the process of solving a double integral problem step-by-step. I want to start with the problem \"\\(\\int_{0}^{1} \\int_{0}^{1-x} e^{-(x+y)} dy\\,dx\\)\" being written on the screen. Then, can you show a message saying to integrate with respect to y first and demonstrate this integration? After that, transition to showing the message to now integrate with respect to x, and carry out this integration as well. Lastly, display a message to evaluate the final integral at the boundaries and present the final solution. Can you animate each step with relevant explanations and pauses in between, so that it's easy to understand for students learning double integrals for the first time?",
        "answer": "\\n from manim import *\n\nclass DefiniteIntegral(Scene):\n    def construct(self):\n        # Introduce the definite integral problem\n        problem = MathTex(r\"\\int_{a}^{b} x dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explain the integral boundaries\n        boundaries_explanation = Text(\"Evaluating from 'a' to 'b':\", font_size=24).to_edge(UP)\n        self.play(Write(boundaries_explanation))\n        self.wait(2)\n\n        # Show fundamental theorem of calculus\n        theorem = MathTex(r\"F(b) - F(a)\", \"=\", r\"\\left. \\frac{x^{n+1}}{n+1} \\right|_{a}^{b}\")\n        self.play(Write(theorem))\n        self.wait(2)\n\n        # Perform the definite integral calculation\n        solution = MathTex(r\"=\", r\"\\frac{b^2}{2}\", \"-\", r\"\\frac{a^2}{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution))\n        self.wait(1)\n\n        # Highlight the result\n        highlight_box = SurroundingRectangle(solution[-2:], buff=.1)\n        self.play(Create(highlight_box))\n        self.wait(2)\n\n        # Clear everything\n        self.clear()\n        self.wait(1)\n\n        # Present the final result of the integral\n        final_result = MathTex(r\"\\int_{a}^{b} x dx\", \"=\", r\"\\frac{b^2}{2} - \\frac{a^2}{2}\")\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "Could you create a step-by-step animated video tutorial that explains how to evaluate the triple integral of the function xyz over the unit cube with bounds from 0 to 1 for the variables x, y, and z, showing the integration process in the order of z, y, then x, and display the final result of the triple integral?",
        "answer": "\\n from manim import *\n\nclass MontyHallProblem(Scene):\n    def construct(self):\n        doors = VGroup(*[Square() for _ in range(3)]).arrange(RIGHT, buff=1)\n        car_door = np.random.randint(0, 3)\n        goats = [Tex(\"Goat\") for _ in range(3)]\n        car = Tex(\"Car\")\n\n        for i, door in enumerate(doors):\n            door_content = car if i == car_door else goats[i]\n            door_content.next_to(door, UP)\n            self.play(FadeIn(door), Write(door_content))\n\n        description = Tex(\"One of these doors has a car behind it,\\\\and the others have goats.\").to_edge(UP)\n        self.play(Write(description))\n        self.wait(2)"
    },
    {
        "query": "I would like an educational animation that visually demonstrates the integration of the trigonometric function sin(x)cos(x) using a trigonometric identity to simplify the integral. The animation should start by writing out the integral problem on the screen, then step-by-step through the solution process. Begin with an explanation that utilizes the trigonometric identity sin(2x) = 2sin(x)cos(x) to rewrite the integral in a more manageable form. Show the rewritten integral on screen next. Then, perform the integration, ideally using a known integration formula such as a power reduction formula, and display the intermediate result of the integration process. Afterward, provide a brief explanation of the integration strategy that was used before presenting the final solution. End the animation by clearing the screen and rewriting the final solution for emphasis. The explanations should be clear and simple to understand, and the mathematical steps should have pauses in between to allow for the material to be absorbed by the viewer.",
        "answer": "\\n from manim import *\n\ntbox = r'''\n\\newtcolorbox{mybox}{colback=red!5!white, colframe=red!75!black, width=8cm}\n\\begin{mybox}\n    \\textcolor{black}{This is my own box.}\n\\end{mybox}\n'''\n\n\nclass Main(Scene):\n    def construct(self):\n        self.wait(0.5)\n\n        # self.camera.background_color = WHITE\n        # Basic self settings.\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble(r\"\\usepackage{tcolorbox, tikz}\")\n\n        self.always_update_mobjects = True\n        box = Tex(tbox, tex_template=myTemplate)\n\n        theBox = SVGMobject(\"box.svg\").scale(0.5)\n        self.play(DrawBorderThenFill(theBox), run_time=3)\n        self.play(Indicate(theBox, color=theBox.get_color()))\n\n        self.wait()\n\n\nclass AtomSVG(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        apple = SVGMobject(\"apple.svg\").scale(2)\n        self.play(Create(apple), run_time=3)\n        self.play(apple.animate.scale(0.5))\n\n        self.wait(2)\n\n\nclass LogoAnimate(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        self.wait(0.5)\n\n        react = SVGMobject(\"react logo.svg\", height=2.2, width=2.2).shift(LEFT * 5)\n        angular = SVGMobject(\"angular logo.svg\", height=2.2, width=2.2).next_to(react, RIGHT * 5)\n        vue = SVGMobject(\"vue logo.svg\", height=2.2, width=2.2).next_to(angular, RIGHT * 5)\n\n        g1 = Group(react, angular, vue).move_to(ORIGIN)\n\n        for fra in g1:\n            self.add_sound(\"grow sound.mp3\", gain=1.5)\n            self.play(GrowFromPoint(fra, fra.get_center()), run_time=0.5)\n            self.wait(1)\n\n        self.wait(3)\n\n        self.play(FadeOut(Group(angular, vue), run_time=0.6), react.animate.move_to(ORIGIN).scale(2))\n        self.play(Circumscribe(react))\n        self.wait(3)\n\n\nclass QuotedText(Scene):\n    def construct(self):\n        self.wait(0.5)\n\n        text = r'''\n        A REST API should spend almost all of its descriptive effort\n        \\linebreak\n        in defining the media type(s) used for representing resources\n        \\linebreak\n        and driving application state.\n        '''\n        quote = Tex(text)\n        quoter = Text(\"- Roy Fielding\").next_to(quote, DOWN).shift(RIGHT * 4)\n        self.play(Write(quote, run_time=4))\n        self.play(Create(quoter, run_time=2))\n        self.wait(2)\n        self.play(Unwrite(quote), FadeOut(quoter))"
    },
    {
        "query": "Could you create an educational animation that visually walks me through the process of solving a triple integral with specific bounds? I would like the animation to start by displaying the triple integral of the function f(x, y, z) = xyz over a volume V, then step by step, translate the triple integral into iterated integrals with the given bounds: x=0, y=0, z=0, and x+y=1. Finally, show the evaluation of these iterated integrals, simplifying at each stage until we reach the numerical answer. Please make sure the explanation text and mathematical steps are clearly presented one after the other and allow each step to be shown for a few seconds for better understanding.",
        "answer": "\\n from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        # Create Molecules\n        reactant1 = electron()\n        reactant2 = oxygen()\n        product = metal_oxid(2, 3)\n\n        # Position Molecules\n        reactant1.next_to(reactant2, LEFT, buff=1)\n        product.to_edge(RIGHT)\n\n        # Display Reactants\n        self.play(FadeIn(reactant1), FadeIn(reactant2))\n        self.wait(1)\n\n        # React and form Product\n        self.play(Transform(VGroup(reactant1, reactant2), product))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that first displays the general equation for a Fourier series, then explains it as a concept that decomposes periodic functions into constituent frequencies, and finally shows a simple example of a Fourier series with just two terms, all while smoothly transitioning between the stages of the explanation?",
        "answer": "\\n from manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nnn = NeuralNetwork([\n    FeedForwardLayer(num_nodes=3),\n    FeedForwardLayer(num_nodes=5),\n    FeedForwardLayer(num_nodes=3)\n])\nself.add(nn)"
    },
    {
        "query": "I would like an animated video demonstrating how to calculate the area under the curve 0.1x^2 from x=0 to x=4. Can you show the graph of the function on a set of axes, shade the area under the curve, and display the integral representation along with the step-by-step solution to the integral? Additionally, I want the final answer to be simplified and presented at the end of the animation.",
        "answer": "\\n class FadeInAndOut(Scene):_x000D_\n    def construct(self):_x000D_\n        red_square = Square(color=RED)_x000D_\n        square_label = Text(\"This is a square\").next_to(red_square, DOWN)_x000D_\n_x000D_\n        self.add(red_square, square_label)_x000D_\n        self.wait(1)_x000D_\n        self.play(FadeIn(red_square), FadeIn(square_label))_x000D_\n        self.wait(1)_x000D_\n        self.play(FadeOut(red_square), FadeOut(square_label))_x000D_\n        self.wait(1)"
    },
    {
        "query": "I would like an animated video that explains how to integrate the function sin(x)cos(x) with respect to x using a trigonometric identity. The animation should start by displaying the integral problem, then present a step-by-step solution, including the use of the identity sin(2x)=2sin(x)cos(x). After simplifying the integral using this identity, show the integration step and the final result, which is -1/4 cos(2x) + C. Conclude the video by fading out the working process and emphasizing the initial problem and final solution.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and its graph\n        func = lambda x: 0.1 * (x - 3) ** 2\n        graph = FunctionGraph(func, x_range=[0, 5])\n        self.play(ShowCreation(graph))\n        self.wait(1)\n\n        # Display the problem on the scene\n        problem = MathTex(r\"\\int_0^5 0.1(x-3)^2 \\,dx\")\n        problem.to_edge(UP)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation to show the area under the curve\n        area_explain = Text(\"Shaded area represents the integral\", font_size=24).next_to(problem, DOWN)\n        self.play(Write(area_explain))\n        self.wait(2)\n\n        # Shade the area under the graph\n        area = Integral(func, (x, 0, 5)).set_color(BLUE)\n        self.play(ShowCreation(area))\n        self.wait(2)\n\n        # Calculate the integral\n        integral_solution = MathTex(r\"= \\left[\\frac{0.1}{3}(x-3)^3 \\right]_0^5\")\n        integral_solution.next_to(area_explain, DOWN)\n        self.play(Write(integral_solution))\n        self.wait(1)\n\n        # Evaluating the definite integral\n        evaluation = MathTex(r\"= \\frac{0.1}{3}(5-3)^3 - \\frac{0.1}{3}(0-3)^3\")\n        self.play(ReplacementTransform(integral_solution, evaluation))\n        self.wait(2)\n\n        # Show final result\n        final_result = MathTex(r\"= 0.1(8) - 0.1(-27)\", r\"= 0.8 + 2.7\", r\"= 3.5\")\n        final_result.scale(0.8)\n        final_result.next_to(evaluation, DOWN)\n        self.play(Write(final_result))\n        self.wait(1)\n\n        # Clear the scene and display only the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation explaining geometric series, showing the sum notation, deriving the formula for the finite sum, discussing series convergence, and concluding with the formula for the sum of an infinite series where the common ratio is less than 1?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for applying the Fundamental Theorem of Calculus\n        explanation1 = Text(\"Using the Fundamental Theorem of Calculus:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the integration\n        integration = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(integration))\n        self.wait(2)\n\n        # Performing the integration step with limits\n        solution1 = MathTex(r\"= \\left. \\frac{x^{3+1}}{3+1} \\right|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluation of the definite integral\n        evaluated_integral = MathTex(r\"= \\left. \\frac{x^4}{4} \\right|_0^2\")\n        self.play(ReplacementTransform(solution1, evaluated_integral))\n        self.wait(1)\n\n        # Simplifying the expression\n        final_solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(Transform(evaluated_integral, final_solution))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(final_solution, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually explains how to integrate the function e raised to the power of 2x with respect to x. The animation should start by displaying the integration problem, followed by a brief written explanation that we use a reverse power rule to integrate the function. Then, the function should be replaced by the integrated function, which includes a constant C, demonstrating the result of the integration. The scene should clear before concluding by presenting the final integrated function once more. The presentation should be paced with pauses for the information to be absorbed by the viewers. Can you create such an animation for me, please?",
        "answer": "\\n from manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass SixDivisors(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(6, 1)\n        by_one.scale(1.3)\n        by_two = Division(6, 2)\n        by_two.scale(1.3)\n        by_three = Division(6, 3)\n        by_three.scale(1.3)\n        by_four = Division(6, 4)\n        by_four.scale(1.3)\n        by_five = Division(6, 5)\n        by_five.scale(1.3)\n        by_six = Division(6, 6)\n        by_six.scale(1.3)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two,\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_three,\n                by_four,\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_five,\n                by_six\n            ).arrange(RIGHT, buff=0.5),\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_two, color=LIGHT_RED_COLOR)\n        square3 = SurroundingRectangle(by_three, color=LIGHT_RED_COLOR)\n        square4 = SurroundingRectangle(by_six, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            FadeIn(by_six),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            Create(square3),\n            Create(square4),\n            lag_ratio=0.3,\n            run_time=2.5\n        ))\n        self.wait(2)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(square3), \n            FadeOut(square4), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)"
    },
    {
        "query": "Create an educational animation that explains the concept of damped oscillation in physics, starting with a title, followed by the second-order differential equation that models the system. Then show an explanation of damping factor, the characteristic polynomial related to this equation, a description of how the nature of the roots is determined by the discriminant, and the different types of damping conditions based on the value of the discriminant. Each of these parts should appear in sequence, remain on screen for a little while for viewers to understand, and then transition smoothly to the next part. Conclude by clearing all elements from the screen.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        function_label = MathTex(\"f(x)\", \"=\", \"x^2\").to_edge(UP)\n        function = FunctionGraph(lambda x: x**2, x_range=[-2, 2], color=BLUE)\n        \n        # Display the function\n        self.play(Write(function_label))\n        self.play(Create(function))\n        self.wait(1)\n\n        # Shade the area under the curve\n        area = area = self.get_area(graph=function, x_range=[-1, 1])\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(1)\n\n        # Display the area problem\n        problem = MathTex(r\"A = \\int_{-1}^{1} x^2 \\,dx\").next_to(function_label, DOWN)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Integration\n        solution = MathTex(r\"A = \\left[ \\frac{1}{3}x^3 \\right]_{-1}^{1}\").next_to(problem, DOWN)\n        self.play(Write(solution))\n        self.wait(2)\n\n        # Final area value\n        final_value = MathTex(r\"A = \\frac{2}{3}\").next_to(solution, DOWN)\n        self.play(Transform(problem, final_value))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        final_message = Text(\"Area calculated!\", font_size=36)\n        self.play(Write(final_message))\n        self.wait(1)"
    },
    {
        "query": "Can you create a step-by-step animated video demonstration that explains how to solve a triple integral problem where I have to integrate the function xyz over the cube with sides between 0 and 1, showing each stage of integration with respect to each variable x, y, and z, including written explanations of each step positioned at the top of the screen?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveScene(Scene):\n    def construct(self):\n        # Display the problem: Area under the curve y=x^2 from x=0 to x=2\n        problem_text = MathTex(r\"y = x^2, \\quad [0, 2]\")\n        problem_title = Text(\"Area Under the Curve\").next_to(problem_text, UP)\n        self.play(Write(problem_title), Write(problem_text))\n        self.wait(1)\n\n        # Draw the graph\n        axes = Axes(x_range=[0, 3], y_range=[0, 4],\n                    axis_config={\"include_ticks\": False})\n        graph = axes.plot(lambda x: x**2, color=BLUE, x_range=[0, 2])\n        area = axes.get_area(graph, x_range=[0, 2], color=BLUE, opacity=0.3)\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n        self.play(Create(axes), Create(graph), FadeIn(area))\n        self.play(Write(graph_label))\n        self.wait(1)\n\n        # Show the integration formula\n        integration_formula = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integration_formula))\n        self.wait(1)\n\n        # Show the calculation of the area\n        integration_result = MathTex(r\"= \\left[ \\frac{x^3}{3} \\right]_0^2\")\n        integration_final = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\")\n        integration_simplified = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integration_formula, integration_result))\n        self.wait(1)\n        self.play(ReplacementTransform(integration_result, integration_final))\n        self.wait(1)\n        self.play(ReplacementTransform(integration_final, integration_simplified))\n        self.wait(1)\n\n        # Show conclusion text\n        conclusion_text = Text(\"Area is 8/3 square units\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion_text))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_simplified))\n        self.wait(1)\n        self.play(Write(conclusion_text))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video in which you show the graph of the function f(x) = x^2 with its axes labeled, highlight the area under the curve between x=1 and x=3, and then show on screen the integral representation of the calculation of that area along with the step-by-step analytical solution to the integral, finally leaving only the solution displayed at the end?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Presenting the integral\n        integral = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait()\n\n        # Adding graph\n        axes = Axes(x_range=[0, 1], y_range=[0, 1], x_length=5, y_length=4)\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        area = axes.get_area(graph, x_range=[0, 1], color=BLUE, opacity=0.3)\n        self.play(Create(axes), Create(graph), FadeIn(area))\n        self.wait(2)\n\n        # Integral solution\n        solution = MathTex(r\"= \\frac{1}{3}\").next_to(integral, DOWN)\n        self.play(Write(solution))\n        self.wait(2)\n\n        # Comparing with the shaded area\n        comparison = Text(\"Area under the curve\", font_size=24).next_to(axes, UP)\n        self.play(Write(comparison))\n        self.wait()\n\n        # Clean up the scene\n        self.play(FadeOut(integral), FadeOut(solution), FadeOut(comparison), FadeOut(axes), FadeOut(graph), FadeOut(area))\n        self.wait()"
    },
    {
        "query": "Can you create an animated video using math visuals that explains the concept of finding the area under a curve, specifically demonstrating how to calculate the integral of x squared from 0 to 1? The video should include the following:\n- Start by displaying the integral of x squared from 0 to 1.\n- Then show a graph with the x-axis ranging from 0 to 1 and the y-axis also ranging from 0 to 1, and plot the curve of x squared on it.\n- Next, shade the area under the curve to represent the integral visually.\n- After that, reveal the solution to the integral as one-third and place it below the integral to show the answer.\n- Contrast the shaded area with a caption that reads \"Area under the curve\" above the graph.\n- Finally, conclude the video by removing all elements from the scene.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the type of PDE\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution explanation\n        explanation2 = Text(\"The solution is typically a function of both space and time.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the d'Alembert Solution\n        dalembert_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, dalembert_solution))\n        self.wait(2)\n\n        # Explanation for the nature of solutions\n        explanation3 = Text(\"Solutions consist of two arbitrary functions, representing waves travelling in opposite directions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Conclusion with the graphical representation mention\n        conclusion = Text(\"Graphical representations can show wave propagation.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.play(Write(dalembert_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually explains step-by-step how to solve a triple integral math problem. Specifically, the problem should be the triple integral of the function xyz over the cube with sides from 0 to 1. I'd like the animation to proceed by first showing the triple integral equation, then sequentially explain how to integrate with respect to z, y, and x, displaying each step of the integration process clearly and pausing between steps. Each explanation should be accompanied by a text description that specifies which variable is being integrated over. After the final integration, display the complete solution to the triple integral. Can you make sure that the final result is showcased clearly at the end once the previous steps have been cleared from view?",
        "answer": "\\n from manim import *\n\nclass ParabolaTangentExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"y = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Drawing the parabola graph\n        graph = FunctionGraph(lambda x : x**2, color=BLUE)\n        self.play(Create(graph))\n        self.wait(2)\n        \n        # Explanation for tangent line at x = 1\n        explanation1 = Text(\"Tangent at x = 1\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Tangent line at x = 1\n        tangent_eq = MathTex(r\"y = 2x - 1\").next_to(explanation1, DOWN)\n        self.play(Write(tangent_eq))\n        \n        tangent_line = FunctionGraph(lambda x : 2*x - 1, color=YELLOW)\n        self.play(Create(tangent_line))\n        self.wait(2)\n\n        # Explanation for slope of the tangent\n        explanation2 = Text(\"Slope of the tangent is 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        tangent_slope = MathTex(r\"\\frac{dy}{dx} = 2\").next_to(tangent_eq, DOWN)\n        self.play(Write(tangent_slope))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        conclusion_text = Text(\"Tangents to parabolas\", font_size=24).to_edge(UP)\n        self.play(Write(conclusion_text))\n        self.wait(1)\n        self.play(Create(graph), Write(tangent_line))\n        self.wait(1)"
    },
    {
        "query": "I would like an animated video that explains and visualizes the process of calculating the area under the curve y=x^2 from x=0 to x=2 using integral calculus. Could you create a step-by-step animation that first shows the curve and the specified area under it, then writes out the integral problem, explains what we're looking for, performs the integration steps, and finally displays the result? Additionally, the video should briefly hold on each step for clarity, and clear the screen before showing the final solution at the end.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr\\, d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Computing the definite integral\n        computed_solution = MathTex(r\"= [\\frac{1}{3} (-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, computed_solution))\n        self.wait(1)\n\n        # Result of the computation\n        result = MathTex(r\"= \\frac{1}{3} (1 - (-1)) = \\frac{2}{3}\")\n        self.play(Write(result))\n        self.wait(2)"
    },
    {
        "query": "Please create an animated video using simple graphics to explain the concept of a Fourier Series. Start with the mathematical definition and then clarify that any periodic function can be expressed as a series of sines and cosines. Include an example specifically showing the Fourier Series formula for a square wave, and mention how the coefficients in the Fourier Series are influenced by the function's periodicity and shape. Conclude the video with a placeholder for a graphic illustration of the square wave itself. The explanations should appear as text on screen and be easy to understand, keeping technical jargon to a minimum.",
        "answer": "\\n from manim import *\n\nclass WaterMoleculeScene(Scene):\n    def construct(self):\n        # Define the positions of hydrogen and oxygen atoms\n        oxygen_position = ORIGIN\n        hydrogen_position1 = UP + RIGHT\n        hydrogen_position2 = UP + LEFT\n        \n        # Create water molecule components\n        oxygen_atom = self.create_oxygen(oxygen_position)\n        hydrogen_atom1 = self.create_hydrogen(hydrogen_position1)\n        hydrogen_atom2 = self.create_hydrogen(hydrogen_position2)\n        \n        # Create bonding lines\n        bond1 = Line(oxygen_position, hydrogen_position1, color=WHITE)\n        bond2 = Line(oxygen_position, hydrogen_position2, color=WHITE)\n\n        # Combine all components into a water molecule group\n        water_molecule = VGroup(oxygen_atom, hydrogen_atom1, hydrogen_atom2, bond1, bond2)\n        \n        # Show the molecule\n        self.play(FadeIn(water_molecule))\n        self.wait(2)\n        self.play(ApplyMethod(water_molecule.scale, 2))\n        self.wait(2)\n        self.play(FadeOut(water_molecule))\n        \n    def create_oxygen(self, position):\n        # Create an oxygen atom with a red circle and \"O\" text in the center\n        oxygen_circle = Circle(radius=0.5, color=RED).set_fill(RED, opacity=1)\n        oxygen_text = Tex(\"O\", color=WHITE, font_size=30)\n        oxygen_atom = VGroup(oxygen_circle, oxygen_text).move_to(position)\n        return oxygen_atom\n        \n    def create_hydrogen(self, position):\n        # Create a hydrogen atom with a blue circle and \"H\" text in the center\n        hydrogen_circle = Circle(radius=0.3, color=BLUE).set_fill(BLUE, opacity=1)\n        hydrogen_text = Tex(\"H\", color=WHITE, font_size=20)\n        hydrogen_atom = VGroup(hydrogen_circle, hydrogen_text).move_to(position)\n        return hydrogen_atom"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates how to calculate the area under a specific mathematical curve. The curve is defined by the equation y = 0.1(x-2)^2. The animation should include a set of axes labelled 'x' and 'y', and the area under the curve between x=2 and x=8 should be shaded. The beginning of the animation should show the problem statement on top: \"Calculate the integral of 0.1(x-2)^2 with respect to x from 2 to 8.\" After displaying the problem, the axes and the graph of the curve should appear, followed by the shading of the area under the curve. Additionally, at the bottom of the screen, there should be a text saying \"Calculate the area under the curve\" to guide viewers on what the animation is about. At the end of the animation, clear the screen and show the final answer for the integral in a similar position as the initial problem statement. Can you help me create this animation?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\").shift(UP)\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution_step = MathTex(r\"= \\left. \\frac{x^{3+1}}{3+1} \\right|_0^3\")\n        self.play(ReplacementTransform(problem.copy(), solution_step))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Evaluate at the bounds:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the integral\n        evaluated_integral = MathTex(r\"= \\frac{3^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution_step, evaluated_integral))\n        self.wait(1)\n\n        # Simplifying the evaluated integral\n        simplified_solution = MathTex(r\"= \\frac{81}{4}\")\n        self.play(ReplacementTransform(evaluated_integral, simplified_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the simplified solution\n        self.play(Write(simplified_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create a step-by-step animated video that explains how to find the surface area of a unit sphere using spherical coordinates and triple integration? Include the mathematical formula for the integral, and show the integration process with respect to each variable one by one, providing a brief text explanation before each integration step. Conclude by showing the final surface area result.",
        "answer": "\\n from manim import Circle, VGroup, AnimationGroup, FadeIn, FadeOut\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nclass DropOutScene(Scene):\n    def construct(self):\n        # Create a neural network\n        nn = NeuralNetwork([\n            FeedForwardLayer(4, neuron_radius=0.2, layer_spacing=0.5),\n            FeedForwardLayer(6, neuron_radius=0.2, layer_spacing=0.5),\n            FeedForwardLayer(4, neuron_radius=0.2, layer_spacing=0.5),\n        ])\n\n        # Position the neural network\n        nn.move_to(ORIGIN)\n\n        # Add the neural network to the scene\n        self.add(nn)\n\n        # Create a group of circles simulating dropout\n        dropout_circles = VGroup(*[Circle(radius=0.2).move_to(neuron.get_center())\n                                   for layer in nn.layers[1:-1]\n                                   for neuron in layer.neurons])\n\n        # Create fade in and out animations for each circle\n        animations = [AnimationGroup(FadeIn(circle), FadeOut(circle)) for circle in dropout_circles]\n\n        # Play the animations for dropout effect\n        self.play(*animations, lag_ratio=0.1)\n\n        # Wait before ending the scene\n        self.wait(1)"
    },
    {
        "query": "Can you create a step-by-step educational animation that demonstrates how to evaluate a double integral in polar coordinates, starting from the original integral problem and going through each integration step with explanatory text?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function\n        curve = lambda x: 0.1 * x ** 2\n        \n        # Plot the function\n        graph = Axes(\n            x_range=[-3, 3],\n            y_range=[0, 2],\n            axis_config={\"color\": BLUE},\n        ).get_graph(curve, color=GREEN)\n        \n        # Display the function\n        graph_label = graph.get_label(label='f(x) = 0.1x^2').shift(UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Indicate the area under the curve\n        area = graph.get_riemann_rectangles(x_range=[0, 2], dx=0.1, input_sample_type=\"center\", stroke_width=0.5, stroke_color=BLACK)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Show the definite integral\n        definite_integral = MathTex(r\"\\int_0^2 0.1x^2 \\,dx\")\n        definite_integral.to_edge(UP)\n        self.play(Write(definite_integral))\n        self.wait(1)\n\n        # Calculating the area\n        area_calculation = MathTex(r\"= [\\frac{1}{30} x^3]_0^2\")\n        area_calculation.next_to(definite_integral, DOWN)\n        self.play(Write(area_calculation))\n        self.wait(1)\n\n        # Show final result\n        final_result = MathTex(r\"= \\frac{1}{30} \\cdot 2^3 - \\frac{1}{30} \\cdot 0^3\", r\"= \\frac{8}{30}\", r\"= \\frac{4}{15}\")\n        final_result.next_to(area_calculation, DOWN)\n        self.play(Write(final_result))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final calculated area\n        self.add(graph, graph_label)\n        self.play(FadeIn(area), Write(final_result))\n        self.wait(3)"
    },
    {
        "query": "Could you create an educational animation that visually explains how to calculate the area under a curve using a definite integral? Specifically, show the graph of the function f(x)=x^2, highlight the area under the curve between x=0 and x=2, and step by step, display the integration process to find the exact numerical value of this area.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        def func(x):\n            return 0.1 * x ** 2\n\n        graph = axes.plot(func, color=WHITE)\n        area = axes.get_area(graph, x_range=(0, 4), color=[BLUE, GREEN], opacity=0.3)\n\n        equation = MathTex(r\"\\int_0^4 0.1x^2 \\,dx\").to_edge(UP)\n        self.play(Write(equation))\n        self.wait(1)\n        self.play(FadeIn(axes), Write(graph))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        solution = MathTex(r\"= \\left[\\frac{1}{30} x^3 \\right]_0^4\").to_edge(UP)\n        self.play(ReplacementTransform(equation, solution))\n        self.wait(2)\n\n        final_answer = MathTex(r\"= \\frac{1}{30} (4)^3 - \\frac{1}{30} (0)^3\", r\"= \\frac{64}{30}\", r\"= \\frac{32}{15}\")\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), ReplacementTransform(solution, final_answer))\n        self.wait(2)\n\n        self.clear()\n        self.play(Write(final_answer))\n        self.wait(2)"
    },
    {
        "query": "I would like a step-by-step educational animation that helps visualize the process of calculating a definite integral, specifically for the integral of x cubed from 0 to 3. The animation should start by displaying the integral problem, followed by an explanation and demonstration of the power rule for integration. Then it should show the step where the power rule is applied to the initial problem, evaluate the integral at the upper and lower bounds, simplify the result, and then conclude by clearly presenting the final simplified solution. Can the demonstration be paced with pauses between steps, and include written explanations before each mathematical step?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\int_{-1}^{1}\\int_{0}^{\\pi}\\int_{0}^{1} r^2 \\sin\\theta \\, dr\\,d\\theta\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        explanation_r = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation_r))\n        self.wait(2)\n\n        r_integral = MathTex(r\"= \\int_{-1}^{1}\\int_{0}^{\\pi} [ \\frac{r^3}{3} \\sin\\theta ]_{0}^{1} \\,d\\theta\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), r_integral))\n        self.wait(1)\n\n        explanation_theta = Text(\"Now integrate with respect to \\\\( \\\\theta \\\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation_r, explanation_theta))\n        self.wait(2)\n\n        theta_integral = MathTex(r\"= \\int_{-1}^{1} [ -\\frac{\\cos\\theta}{3} ]_{0}^{\\pi} \\,dz\")\n        self.play(ReplacementTransform(r_integral, theta_integral))\n        self.wait(1)\n\n        explanation_z = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation_r, explanation_z))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= [ -\\frac{2z}{3} ]_{-1}^{1}\", r\"= -\\frac{2}{3} - \\left(-\\frac{2}{3} \\right)\", r\"= \\frac{4}{3}\")\n        self.play(ReplacementTransform(theta_integral, final_solution))\n        self.wait(1)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that introduces and explains the wave equation, including a transition from the general form to the one-dimensional version, and demonstrates possible solutions as waves moving in opposite directions?",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Display the integration problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explain the integration step\n        explanation1 = Text(\"Integrate by reversing the power rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show integration result\n        integration_step = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(2)\n\n        # Clear the screen and show conclusion\n        self.clear()\n        self.play(Write(Text(\"The integral of an exponential\", font_size=24)))\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(2)"
    },
    {
        "query": "I would like an educational animation that visually introduces and explains the one-dimensional wave equation. Start by displaying the wave equation, then add a text description that says it represents the one-dimensional wave equation. After a short pause, replace this text with another, explaining that solutions to this equation take a specific form, which should then be displayed in a mathematical format. Next, please transition to show that same solution replacing the original equation while updating the text description to talk about initial conditions' influence on the solution. Finally, clear the screen and conclude by displaying just the solution to the wave equation on its own. Can you create an engaging and informative animation that presents the equation and its solution with these explanations?",
        "answer": "\\n from manim import *\n\nclass EquivalentFractions(Scene):\n    def construct(self):\n        fractions = VGroup(\n            MathTex(r\"\\frac{1}{2}\", color=BLUE).scale(2),\n            MathTex(r\"\\frac{2}{4}\", color=BLUE).scale(2),\n        ).arrange(RIGHT, buff=2)\n\n        equals_sign = MathTex(r\"=\", color=WHITE).scale(2)\n        equals_sign.next_to(fractions[0], RIGHT)\n\n        fractions.add(equals_sign)\n\n        arrows = VGroup(\n            Arrow(fractions[0].get_bottom() + DOWN, fractions[1].get_bottom() + DOWN, color=GREEN),\n            Arrow(fractions[1].get_bottom() + DOWN, fractions[0].get_bottom() + DOWN, color=GREEN)\n        ).arrange(DOWN, buff=0.3)\n        arrows.next_to(fractions, DOWN, buff=0.5)\n\n        text = VGroup(\n            Tex(r\"Multiplicado por 2\", color=GREEN).scale(0.7),\n            Tex(r\"Dividido por 2\", color=GREEN).scale(0.7)\n        )\n        text[0].next_to(arrows[0], DOWN)\n        text[1].next_to(arrows[1], DOWN)\n\n        self.play(Write(fractions))\n        self.play(GrowFromCenter(arrows[0]), Write(text[0]))\n        self.play(GrowFromCenter(arrows[1]), Write(text[1]))\n        self.wait(2)\n\n        self.play(FadeOut(VGroup(fractions, arrows, text)))\n        self.wait(0.5)"
    },
    {
        "query": "Can you create an educational animation using Manim that explains the basics of Fourier Series to me? Start by showing the mathematical definition of Fourier Series. Then provide a simple text explanation about the concept and how it represents functions with sines and cosines. Next, introduce the coefficients of the series and explain that they're found through integration. After that, mention under what conditions the Fourier Series will converge to the function. Lastly, conclude by displaying a graph of a sample function like a sine wave, then clear everything away to complete the lesson.",
        "answer": "\\n from manim import *\n\nclass DerivativeConcept(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": BLUE}\n        )\n\n        func_graph = axes.plot(lambda x: x**2, color=GREEN)\n        derivative_graph = axes.plot(lambda x: 2 * x, color=ORANGE)\n\n        tangent_line = always_redraw(\n            lambda: axes.get_tangent_line(\n                x=1, \n                graph=func_graph, \n                length=4, \n                line_color=PURPLE\n            )\n        )\n        \n        self.play(Create(axes), Create(func_graph))\n        self.wait(1)\n\n        self.play(Write(derivative_graph), run_time=2)\n        self.wait(1)\n\n        self.play(Create(tangent_line), run_time=2)\n        self.wait(2)\n\n        explanation = Tex(r\"The tangent line at $x=1$ represents \\\\ the derivative of $x^2$, which is $2x$.\")\n        explanation.next_to(tangent_line, UP)\n        explanation.shift(RIGHT*3)\n\n        self.play(Write(explanation))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animated video that explains the wave equation and its properties in a simple and educational manner? I would like the video to start with the title \"Wave Equation\" appearing at the top, followed by the wave equation itself being written out on the screen. After showing the equation, can you have a brief description appear that explains the equation represents the propagation of waves through a medium at speed c? Then, transition to an example of a sinusoidal wave solution for the one-dimensional wave equation and accompany it with a text explanation. Lastly, introduce the concept of superposition in waves and show the superposition of two different sinusoidal waves mathematically. Please ensure all steps in the animation are clear and that there is a smooth flow from one topic to the next.",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#f8eedb\"\nTEXT_COLOR = \"#403c3c\"\nLIGHT_GREEN_COLOR = \"#4caf50\"\nLIGHT_BLUE_COLOR = \"#2196f3\"\nLIGHT_YELLOW_COLOR = \"#ffeb3b\"\nLIGHT_RED_COLOR = \"#f44336\"\nPURPLE_COLOR = \"#9c27b0\"\n\ndef ease_in_quad(t):\n    return rate_functions.ease_in_quad(t)\n\ndef PrimeRectangle(width, height, color):\n    rect = Rectangle(width=width, height=height, color=color)\n\n    label = Tex(f\"p={width * height}\", color=color)\n    label.scale(0.5)\n    label.move_to(rect)\n\n    return Group(rect, label)\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass PrimePattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"N\u00fameros primos e ret\u00e2ngulos\", color=LIGHT_GREEN_COLOR)\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        prime_rectangles = VGroup()\n\n        for i, prime in enumerate(primes):\n            color = interpolate_color(LIGHT_BLUE_COLOR, PURPLE_COLOR, i / (len(primes) - 1))\n            rectangle = PrimeRectangle(1, prime, color=color)\n            prime_rectangles.add(rectangle)\n\n        prime_rectangles.arrange_in_grid(rows=2, cols=5, buff=0.5)\n        prime_rectangles.move_to(ORIGIN)\n\n        self.add(title)\n        self.wait(0.5)\n\n        for rectangle in prime_rectangles:\n            self.play(\n                FadeIn(rectangle),\n                run_time=0.5,\n                rate_func=ease_in_quad\n            )\n            self.wait(0.25)\n\n        self.wait(1)\n        self.play(\n            FadeOut(prime_rectangles),\n            run_time=1\n        )\n        self.wait(0.5)"
    },
    {
        "query": "Create an animation that shows the process of solving the integral of e^(2x) using substitution. First, start by writing the integral problem on the screen. Then, after a brief pause, write at the top of the screen \"Let u = 2x, thus du = 2dx\" and pause again to let the audience process this information. Next, replace the initial integral with the new one where the substitution has been made, and put a factor of 1/2 in front of e^u to account for the du = 2dx. Include another pause and then update the text at the top to say \"Integrate using the antiderivative of e^u\". Following a short wait, show the final solution, which is the integrated function plus the constant of integration C. Finally, clear the screen, wait for a moment, and then rewrite the final solution to conclude the animation.",
        "answer": "\\n from manim import *\n\nclass TransformShapes(Scene):\n    def construct(self):\n        r = Rectangle color=BLUE, fill_opacity=0.7)\n        t = Triangle(color=YELLOW, fill_opacity=0.7)\n        self.add(r, t)\n        self.play(r.animate.shift(LEFT), t.animate.shift(RIGHT))\n        self.play(r.animate.rotate(PI/4), t.animate.rotate(-PI/4))\n        self.play(Transform(r, t))\n        self.wait()"
    },
    {
        "query": "Can you create an educational animation that introduces and visualizes a 3D parametric curve, specifically representing a helix using cosine and sine functions for the horizontal coordinates and a linear function for the vertical coordinate? Start with a title for the video, move it to the top, then show the parametric equation, followed by an explanation of what the curve represents. Next, plot the curve in 3D, and add a 3D axis to support it. Make sure to include a rotation effect to clearly show the curve is three-dimensional. Finally, clear the screen and refocus on just the 3D plot of the curve with its axes, then conclude by fading everything out.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation of the equation\n        explanation1 = Text(\"This is the classic wave equation for a scalar field u.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation of c constant\n        explanation2 = Text(\"The constant c represents the wave speed.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Example of a specific solution\n        specific_solution = MathTex(r\"u(x, t) = A \\cos(kx - \\omega t + \\phi)\")\n        self.play(ReplacementTransform(wave_eq, specific_solution))\n        self.wait(1)\n\n        # Explanation for this specific solution\n        explanation3 = Text(\"A harmonic wave solution of the wave equation.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Cleanup and conclusion\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create a step-by-step animated video that visually illustrates how to solve a triple integral problem? Specifically, show the process of evaluating the triple integral of xyz over the region from 0 to 1 for x, y, and z, including each stage of integration with respect to x, y, and then z, along with explanations at each step.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and its graph\n        f = lambda x: 0.1 * x**2\n        graph = FunctionGraph(f, x_range=[-3, 3], color=BLUE)\n\n        # Display the graph\n        graph_label = MathTex(\"y = 0.1 x^2\").next_to(graph, UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = area = Integral(f, (x, -2, 2), fill_opacity=0.3, fill_color=GREEN)\n        self.play(Create(area))\n        self.wait(1)\n\n        # Show the definite integral notation\n        integral_notation = MathTex(r\"\\int_{-2}^{2} 0.1 x^2 \\,dx\").to_edge(UP)\n        self.play(Write(integral_notation))\n        self.wait(1)\n\n        # Calculating the area under the curve\n        calculation_steps = MathTex(r\"= [ \\frac{0.1 x^3}{3} ]_{-2}^{2}\")\n        self.play(ReplacementTransform(integral_notation.copy(), calculation_steps))\n        self.wait(2)\n\n        # Showing the final area\n        solution = MathTex(r\"= \\frac{0.1 (2)^3}{3} - \\frac{0.1 (-2)^3}{3}\", r\"= \\frac{4}{30} + \\frac{4}{30}\", r\"= \\frac{8}{30} = \\frac{4}{15}\")\n        solution.scale(0.75).next_to(calculation_steps, DOWN)\n        self.play(Write(solution))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show just the solution at the end\n        self.play(Write(solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation using ManimCE that shows a point moving along a circular path, while highlighting that the path is a parametric curve defined by a specific mathematical function? Include text explanations to describe the circle's parametric function, explain how the function represents a circle, and show the point tracing the path as the parameter changes from 0 to 2\u03c0. Finally, end the animation with a message stating that parametric curves can describe complex shapes.",
        "answer": "\\n from manim import *\n\nclass ChemistryScene(Scene):\n    def construct(self):\n        # Create grid of lithium ions\n        li_grid = self.lithium_grid(3, 3)\n\n        # Create a single carbon layer\n        carbon_l = self.carbon_layer()\n\n        # Create a molecule of oxygen and a metal\n        oxy = self.oxygen().shift(LEFT * 2)\n        met = self.metal().shift(RIGHT * 2)\n\n        # Animate the objects\n        self.play(FadeIn(li_grid))\n        self.wait(1)\n        self.play(Transform(li_grid, carbon_l))\n        self.wait(1)\n        self.play(FadeIn(oxy), FadeIn(met))\n        self.wait(2)\n\n        # Move the oxygen in a triangle path\n        tri_points = [UP * 2 + LEFT, UP * 2, UP * 2 + RIGHT]\n        oxy_animations = self.move_along_complex_path(oxy, [1], tri_points, run_time=3)\n        self.play(*oxy_animations)\n\n        self.wait(3)\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        paths = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                paths.append(Line(points[i], points[i + 1]))\n\n        for i in range(len(paths)):\n            animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))\n\n        return animations\n\n    def lithium_grid(self, rows, cols) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                list.append(self.lithium_ion().set_x(j).set_y(i))\n        return VGroup(*list).set_x(0).set_y(0)\n\n    def carbon_layer(self) -> Mobject:\n        list = []\n        positions = [\n            [-1.2, 0, 0],\n            [-0.45, 0.4, 0],\n            [0.45, 0.4, 0],\n            [1.2, 0, 0],\n            [0.55, -0.3, 0],\n            [-0.55, -0.3, 0],\n        ]\n        small = [2, 1, 1, 2, 0, 0]\n        for i in range(len(positions)):\n            list.append(Line(positions[i], positions[(i + 1) % len(positions)], color=GREY_B).set_z_index(4))\n            list.append(self.carbon(small[i]).set_x(positions[i][0]).set_y(positions[i][1]))\n        list.append(Polygon(*positions, color=WHITE).set_fill(WHITE, 0.075).set_z_index(-1))\n        return VGroup(*list)\n\n    def lithium_ion(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Li$^+$\", RED_D, 25, WHITE, 1)\n\n    def oxygen(self) -> Mobject:\n        list = []\n        start = 0.3\n        end = 0.6\n        list.append(Line(start=LEFT * start, end=LEFT * end))\n        list.append(Line(start=RIGHT * start, end=RIGHT * end))\n        list.append(Line(start=UP * start, end=UP * end))\n        list.append(Line(start=DOWN * start, end=DOWN * end))\n        list = map(lambda x: x.set_opacity(0.7), list)\n        return VGroup(self.circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)\n\n    def metal(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n\n    def circle_with_text(\n        self, r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n    ) -> Mobject:\n        c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)\n\n    def carbon(self, small: int = False) -> Mobject:\n        return self.circle_with_text(\n            0.285 if small == 0 else (0.225 if small == 1 else 0.25),\n            \"C\",\n            GRAY_B,\n            30 if small == 0 else (24 if small == 1 else 27),\n            WHITE,\n            1,\n        ).set_z_index(5 if small == 1 else 10)"
    },
    {
        "query": "I would like an educational animation that demonstrates how to calculate the area of a circle. Start by presenting the formula for the area of a circle. Then, give an example with a specific radius, say r equals 2, and show how to substitute the value into the formula. Finally, simplify the expression to find the area and display the final result clearly stating that the area is 4\u03c0 units. Include pauses between steps for better understanding, and write explanations for key steps at the top of the screen. Clear the screen before showing the final message.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.rotate\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle(fill_opacity=1)\n            self.play(triangle.animate.rotate(PI))\n            self.remove(triangle)"
    },
    {
        "query": "Can you create an educational animation that visually explains the step-by-step process of solving the double integral in polar coordinates of the function \\( r \\) over the region defined by \\( \\theta \\) from 0 to \\( \\pi \\) and \\( r \\) from 0 to 1, including written explanations and the final solution?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 5, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create Graph\n        graph = axes.plot(lambda x: 0.5 * x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='y=0.5x^2')\n\n        # Create area under graph\n        graph_area = axes.get_area(graph, x_range=[0, 2], color=YELLOW, opacity=0.5)\n\n        # Display graph and area\n        self.play(Create(axes), Write(graph), FadeIn(graph_label))\n        self.play(FadeIn(graph_area))\n        self.wait(2)"
    },
    {
        "query": "I would like you to create an educational animation that explains how to solve a double integral in polar coordinates. The specific example I want demonstrated is the double integral of r-squared sine of theta with respect to r and theta, where r goes from 0 to 1, and theta goes from 0 to pi. I'd like the animation to show each step of the integration process starting with the initial integral expression, followed by the calculation of the integral with respect to r, and then the integral with respect to theta. After each step, please include a brief pause and then transition to explaining the next part. At the end, conclude with the solution to the integral and tie it to the concept of finding the area inside a unit semicircle. Can you also include some text explanations that appear at the top of each step, guiding viewers through the problem?",
        "answer": "\\n from manim import *\n\n# Define colors for each part of the fraction bar graph\nBACKGROUND_COLOR = \"#ffffff\"\nBAR_COLOR = \"#3e7aab\"\nLABEL_COLOR = \"#333333\"\n\nclass FractionBarGraph(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        # Create a list to hold the bars and labels.\n        bars = []\n        labels = []\n\n        # Define the maximum height of the bars and the total number of bars.\n        max_height = 5\n        num_bars = 6\n\n        # Create bars and corresponding labels.\n        for i in range(1, num_bars + 1):\n            height = max_height * (i / num_bars)\n            bar = Rectangle(width=0.8, height=height, color=BAR_COLOR, fill_opacity=1)\n            label = MathTex(f\"\\\\frac{{{i}}}{{{num_bars}}}\", color=LABEL_COLOR)\n            bars.append(bar)\n            labels.append(label)\n\n        # Position the bars and labels.\n        bar_group = VGroup(*bars)\n        label_group = VGroup(*labels)\n        bar_group.arrange(RIGHT, buff=1)\n        label_group.arrange(RIGHT, buff=1)\n\n        # Align the bars to the bottom and position the labels right below the bars.\n        for i in range(num_bars):\n            bars[i].align_to(bar_group, DOWN)\n            labels[i].next_to(bars[i], DOWN)\n\n        # Group the bars and the labels together.\n        graph_group = VGroup(bar_group, label_group)\n        graph_group.move_to(ORIGIN)\n\n        for bar, label in zip(bars, labels):\n            # Animate each bar and its corresponding label.\n            self.play(\n                GrowFromEdge(bar, DOWN),\n                Write(label),\n                run_time=0.5\n            )\n\n        # Show the entire graph for a brief moment\n        self.wait(1)\n\n        # Animate moving and scaling down of all the bars except the third one\n        self.play(\n            *[bar.animate.scale(0) for bar in bars if bar != bars[2]],\n            *[FadeOut(label) for label in labels if label != labels[2]],\n            run_time=0.8\n        )\n\n        # Highlight the selected bar and label\n        self.play(\n            bars[2].animate.set_color(YELLOW),\n            labels[2].animate.set_color(YELLOW),\n            run_time=0.5\n        )\n\n        # Animate shifting out all graph elements to the left\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects],\n            run_time=0.5\n        )\n\n        # Clear the scene\n        self.clear()"
    },
    {
        "query": "I'd like to create an educational animation which visually demonstrates how to find the area under the curve of the function f(x) = x^2 from x = 1 to x = 2. The animation should start by writing out the function, then stating the problem of finding the area under this curve between the given range. After that, I want to see the function graphed on a set of axes, and the specific area of interest shaded. Finally, could you illustrate the step-by-step process of calculating this area using the definite integral, showing the intermediate steps and arriving at the final numeric answer?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Calculate the area under the curve from x=1 to x=3\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Performing the integration\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3} x^3\\right]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the integral\n        explanation2 = Text(\"Plugging in the upper and lower bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that demonstrates the steps involved in integrating the expression \\( e^{2x} \\) with respect to \\( x \\), showing both the problem statement and the integration technique, with commentary text explaining each step, and finally displaying the answer clearly?",
        "answer": "\\n from manim import *\n\nclass MoleculeScene(Scene):\n    def construct(self):\n        # Adding hydrogen molecule\n        molecule = self.create_molecule()\n        self.play(FadeIn(molecule))\n        self.wait()\n\n        # Moving molecule in a zigzag path\n        points = [UP * 2, UP * 2 + RIGHT * 4, DOWN * 2, DOWN * 2 + LEFT * 4]\n        path_animations = move_along_complex_path(molecule, [1, 2], points, run_time=4)\n        self.play(*path_animations)\n        self.wait()\n\n    def create_molecule(self):\n        # Create atoms\n        hydrogen_1 = circle_with_text(0.3, 'H', WHITE, 24, BLACK, 1, RED_A).shift(LEFT)\n        hydrogen_2 = circle_with_text(0.3, 'H', WHITE, 24, BLACK, 1, BLUE_A).shift(RIGHT)\n\n        # Create bond\n        bond = Line(hydrogen_1.get_center(), hydrogen_2.get_center(), color=GREY_B)\n\n        # Create molecule out of atoms and bond\n        molecule = VGroup(hydrogen_1, hydrogen_2, bond)\n        return molecule\n\n# Example function from the provided code\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(radius=r, color=color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\n# Example function from the provided code\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n    animations = []\n    paths = []\n    for i in range(len(points) - 1):\n        if i not in stop_indices:\n            paths.append(Line(points[i], points[i + 1]))\n\n    for i in range(len(paths)):\n        animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))\n\n    return animations\n\n# To view the animation, uncomment the following line:\n# if __name__ == '__main__':\n#     scene = MoleculeScene()\n#     scene.render()"
    },
    {
        "query": "Can you create an educational animation that first displays a 2x2 matrix, then shows how to calculate its determinant with a formula and its computed value, followed by illustrating how to find the inverse of the matrix with a corresponding formula, and finally conclude with a message explaining that this is the method to compute a determinant and an inverse of a matrix?",
        "answer": "\\n BACKGROUND_COLOR = \"#d3e0ff\"\nTEXT_COLOR = \"#303030\"\nLIGHT_YELLOW_COLOR = \"#fff89a\"\nLIGHT_GREEN_COLOR = \"#7cd992\"\nLIGHT_BLUE_COLOR = \"#6ab0f3\"\nORANGE_COLOR = \"#ff9f68\"\nPURPLE_COLOR = \"#b28fd0\"\nTEAL_COLOR = \"#2dd4bf\"\nDARK_GREEN_COLOR = \"#1b5e20\"\nDARK_BLUE_COLOR = \"#1a237e\"\nSAND_COLOR = \"#f4e1c0\"\nBROWN_COLOR = \"#795548\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef ThoughtBubble(**kwargs):\n    gp = VGroup(\n        RoundedRectangle(width=6, height=3, corner_radius=0.75),\n        Polygram([\n            [6/3, -3 + 0.5, 0],\n            [6/3 - 0.3, -3 + 1.1, 0], \n            [6/3 + 0.8, -3 + 1.1, 0]\n        ])\n    )\n    gp.center()\n    \n    return Union(*gp, **kwargs)\n\nclass QuestionThree(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n        \n        robot = ImageMobject(\"./assets/robot_image.png\")\n        robot.scale(0.5)\n        robot.shift(8 * RIGHT)\n        thought = ThoughtBubble(color=TEXT_COLOR, fill_opacity=0.9, fill_color=LIGHT_YELLOW_COLOR)\n        thought.next_to(robot, UP+LEFT)\n        text_group = VGroup(\n            Text(\"What is\", font_size=28, color=TEXT_COLOR),\n            Text(\"the square root\", font_size=28, color=TEXT_COLOR),\n            Text(\"of 16?\", font_size=28, color=TEXT_COLOR)\n        )\n        text_group.arrange(DOWN, aligned_edge=LEFT)\n        text_group.next_to(robot, UP+LEFT)\n        \n        self.play(\n            robot.animate.shift(7 * LEFT),\n            FadeIn(thought, shift=DOWN),\n            FadeIn(text_group, shift=DOWN)\n        )\n        self.wait(3)\n        self.play(\n            robot.animate.shift(7 * RIGHT),\n            FadeOut(thought, target_position=thought.get_top()),\n            FadeOut(text_group, target_position=text_group.get_top())\n        )\n        self.remove(robot, thought, text_group)"
    },
    {
        "query": "I would like an animated video that explains the process of calculating a double integral in polar coordinates. The specific problem to be solved should be the integral of \"r\" over the unit circle. The video should start by displaying the integral of r from 0 to 1 with respect to \"r\" and from 0 to 2\u03c0 with respect to \"\u03b8\". Then, it should proceed by showing step-by-step how to integrate with respect to \"r\" first, including the intermediate step, followed by the integration with respect to \"\u03b8\". The video should conclude by showing the final solution of the double integral. Additionally, at each step, there should be a brief pause, and include some explanatory text above the integral to guide the viewer through the process.",
        "answer": "\\n from manim import *\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        colors = it.cycle([RED, BLUE, GREEN, YELLOW, PURPLE])\n\n        # Create a list to hold Fibonacci numbers and add the first two\n        fib_numbers = [0, 1]\n        for _ in range(5):\n            fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n\n        squares = VGroup()\n        for index, value in enumerate(fib_numbers[2:]):\n            # Create a square with side length corresponding to a Fibonacci number\n            square = Square(side_length=value)\n            square.set_stroke(width=2)\n            square.set_fill(next(colors), opacity=0.5)\n\n            # Position the square based on index\n            if index % 4 == 0:\n                square.next_to(squares, UP, buff=0)\n            elif index % 4 == 1:\n                square.next_to(squares, RIGHT, buff=0)\n            elif index % 4 == 2:\n                square.next_to(squares, DOWN, buff=0)\n            elif index % 4 == 3:\n                square.next_to(squares, LEFT, buff=0)\n\n            squares.add(square)\n\n        # Draw the Fibonacci spiral using quarter-circles inside the squares\n        spiral = VMobject()\n        for i, square in enumerate(squares):\n            angle_start = i * PI / 2  # Start angle of each quarter-circle\n            arc = Arc(radius=square.side_length / 2,\n                      start_angle=angle_start,\n                      angle=PI/2)\n            arc.move_arc_center_to(square.get_corner(UP + RIGHT) +\n                                   RotateVector(square.side_length/2 * DOWN, angle_start))\n            spiral.add(arc)\n\n        spiral.set_color_by_gradient(BLUE, GREEN)\n\n        # Group squares and spiral for easier handling\n        fib_spiral = VGroup(squares, spiral)\n\n        # Animate\n        self.play(LaggedStart(*[DrawBorderThenFill(sq) for sq in squares], lag_ratio=0.5))\n        self.play(ShowCreation(spiral), run_time=4)\n        self.wait(2)\n\n        # Center the whole group of squares and spiral on the screen\n        self.play(fib_spiral.animate.to_edge(UP, buff=1))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains how to calculate the definite integral of x squared from 0 to 1, using the power rule for integration, showing step by step, including: writing the problem, explaining the rule, performing the integration, evaluating the limits, simplifying the expression, and finally presenting the answer clearly?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[\\frac{1}{2}r^2\\right]_0^1 d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\left[\\frac{1}{2}\\theta\\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}\\pi\")\n        self.play(Transform(final_integral, final_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animated educational video using Python that explains the concept of Fourier series by displaying its formula, giving a brief introduction to what it represents, showing the notation for its partial sums, and providing explanations for these mathematical concepts?",
        "answer": "\\n from manim import *\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef metal() -> Mobject:\n    return circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\ndef electron() -> Mobject:\n    return circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)"
    },
    {
        "query": "I would like an educational animation that visually explains the concept of geometric series and how to calculate their sums. It should start by showing the general formula of a geometric series. Then, I want a clear visual presentation of the formula for the sum of a finite geometric series, followed by an explanation of the sum of an infinite geometric series specifically when the common ratio is less than 1. It would be helpful to see an example worked out, such as finding the sum of the infinite geometric series where the starting term is 1 and the common ratio is 1/2. Finally, the animation should conclude by reinforcing the solution to this example. Can you create this for me?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area to calculate\n        function = MathTex(r\"f(x) = e^{-x^2}\")\n        area_text = MathTex(r\"\\int_0^2 f(x) \\,dx\")\n        problem_group = VGroup(function, area_text).arrange(DOWN)\n        self.play(Write(problem_group))\n        self.wait(1)\n\n        # Plot the function\n        graph = FunctionGraph(lambda x: np.exp(-x**2), x_range=[0,2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = Integral(graph.curve, x_range=[0,2], color=YELLOW)\n        self.play(Write(area))\n        self.wait(2)\n\n        # Numerical approximation\n        approximation_text = Text(\"Numerical approximation:\", font_size=24).to_edge(UP)\n        self.play(Write(approximation_text))\n        self.wait(1)\n\n        # Riemann sum rectangles\n        riemann_rectangles = RiemannRectangles(graph, x_range=[0,2], dx=0.2)\n        self.play(ReplacementTransform(area.copy(), riemann_rectangles))\n        self.wait(1)\n\n        # Explanation for Riemann sum\n        explanation = Text(\"The area is approximated with rectangles\", font_size=24).to_edge(UP)\n        self.play(Transform(approximation_text, explanation))\n        self.wait(3)\n\n        # Value of the approximation\n        approximate_value = MathTex(r\"\\approx 0.8821\")\n        self.play(Write(approximate_value))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(approximate_value))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational video animation that explains the Taylor series expansion of the function e^x around the point x=0. The video should start by presenting the problem and the function e^x. Then, it should introduce the concept of Taylor series and showcase the actual expansion with an infinite number of terms. After that, I want the video to demonstrate a finite polynomial approximation of the function e^x by showing just the first four terms. It should also include an explanation that this represents a 3rd-degree polynomial approximation. Lastly, the video should clear away all elements and focus solely on displaying this finite approximation before fading out and concluding with a brief mention of the infinite radius of convergence for the Taylor series of the exponential function e^x. Can this be visualized in a simple and clear animation for educational purposes?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Convolutional2DLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork([\n            Convolutional2DLayer(1, 16, 5, filter_spacing=0.3),\n            Convolutional2DLayer(16, 32, 3, filter_spacing=0.3),\n            Convolutional2DLayer(32, 64, 3, filter_spacing=0.3),\n            FeedForwardLayer(128),\n            FeedForwardLayer(64),\n            FeedForwardLayer(10),\n        ],\n        layer_spacing=0.35,\n        )\n\n        nn.move_to(ORIGIN)\n        self.add(nn)\n\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)\n        self.wait()"
    },
    {
        "query": "I would like to have an educational animation that visually walks me through the problem and solution of the harmonic oscillator ordinary differential equation (ODE). The animation should start by writing the ODE y'' + \u03c9^2 y = 0 on the screen. Next, it should introduce the concept of a characteristic equation for this problem with text that says \"Form the characteristic equation\". Then, on the screen, transform the original equation into the characteristic equation, r^2 + \u03c9^2 = 0. Follow this with text stating \"Solve for r\" and show the solution to the characteristic equation as r = \u00b1i\u03c9. Lastly, I want the animation to present the general solution of the harmonic oscillator, which is y = C_1 cos(\u03c9x) + C_2 sin(\u03c9x), accompanied by a final explanatory text saying \"General solution of the harmonic oscillator\". To conclude, clear the screen and show the phrase \"End of the demonstration\". Please ensure there are appropriate pauses between steps so the viewer can follow along.",
        "answer": "\\n from manim import *\n\nclass ChemicalReaction(Scene):\n    def construct(self):\n        # Create reactants\n        oxygen_molecule = VGroup(oxygen(), oxygen()).arrange(RIGHT, buff=0.5)\n        hydrogen_molecule = VGroup(electron(), electron()).arrange(RIGHT, buff=0.5)\n\n        # Create products\n        water_molecule = VGroup(oxygen(), electron(), electron()).arrange(RIGHT, buff=0.25)\n\n        # Position molecules on screen\n        oxygen_molecule.next_to(ORIGIN, LEFT, buff=1)\n        hydrogen_molecule.next_to(ORIGIN, RIGHT, buff=1)\n        water_molecule.move_to(3 * DOWN)\n\n        # Display the reactants\n        self.play(FadeIn(oxygen_molecule), FadeIn(hydrogen_molecule))\n        self.wait(1)\n\n        # Move reactants off screen and products on screen\n        self.play(\n            oxygen_molecule.animate.shift(UP),\n            hydrogen_molecule.animate.shift(UP),\n            FadeIn(water_molecule)\n        )\n        self.wait(1)\n\n        # Display reactants turning into products\n        self.play(\n            FadeOut(oxygen_molecule),\n            FadeOut(hydrogen_molecule),\n            water_molecule.animate.move_to(ORIGIN)\n        )\n        self.wait(2)\n\n        # Clean up\n        self.play(FadeOut(water_molecule))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that illustrates the concept of the one-dimensional wave equation. First, display the partial differential equation on the screen. Then, follow it up with a textual explanation that it's the one-dimensional wave equation. Next, I'd like you to show the general solution for the equation and again provide a textual explanation. Afterward, present the d'Alembert's formula both in its mathematical form and with a text commentary making clear that this is d'Alembert's formula. Finally, clear all content from the screen and conclude by only showing d'Alembert's formula. Include pauses throughout the animation for emphasis and understanding.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesScene(Scene):\n    def construct(self):\n        self.camera.background_color = \"#dee3e6\"\n        path = Circle().scale(2)\n        fourier_series = self.get_fourier_series(path, color=PURE_RED, n_terms=10)\n        \n        self.play(ShowCreation(path), run_time=2)\n        self.wait()\n        \n        for n, partial_sum in enumerate(fourier_series):\n            self.play(TransformFromCopy(path, partial_sum), run_time=2)\n            self.wait(0.5)\n\n    def get_fourier_series(self, path, color=RED, n_terms=10):\n        fourier_series = []\n        for n in range(1, n_terms + 1):\n            sine_wave = self.get_sine_wave(n, path, color)\n            sine_wave.scale(0.5)\n            fourier_series.append(sine_wave)\n        return fourier_series\n\n    def get_sine_wave(self, frequency, path, color):\n        def func(t):\n            return np.array([np.sin(frequency * t), np.cos(frequency * t), 0])\n        sine_wave = ParametricFunction(func, t_range=[0, TAU], color=color)\n        sine_wave.move_to(path.get_center())\n        return sine_wave\n\nclass FourierSeriesOfSquareWave(FourierSeriesScene):\n    def get_sine_wave(self, frequency, path, color):\n        if frequency % 2 == 0:\n            return VMobject()  # Even harmonics are not present in square wave.\n        amplitude = 4 / (np.pi * frequency)  # Amplitude of the sine wave\n        def square_wave_func(t):\n            return np.array([amplitude * np.sin(frequency * t), 2 * (t - PI / 2) / TAU, 0])\n        sine_wave = ParametricFunction(square_wave_func, t_range=[0, TAU], color=color)\n        sine_wave.move_to(path.get_center())\n        return sine_wave\n\n    def construct(self):\n        self.camera.background_color = \"#dee3e6\"\n        path = Square().scale(2)\n        fourier_series = self.get_fourier_series(path, n_terms=10)\n\n        self.play(ShowCreation(path), run_time=2)\n        self.wait()\n\n        for n, partial_sum in enumerate(fourier_series):\n            self.play(TransformFromCopy(path, partial_sum), run_time=2)\n            self.wait(0.5)"
    },
    {
        "query": "Can you create an educational animation that teaches students how to solve a basic definite integral using the power rule? Start by showing the integral problem of the function x squared from 0 to 2. Then, introduce the concept of integration limits and place them below the problem. Next, add text indicating that we should use the power rule for integration and display the general power rule formula. Translate the problem into the solution using the power rule and show this step by step. After applying the power rule, show text cueing to evaluate at the limits, and then calculate the exact value by substituting the limits into the solution. Finally, clear the screen and conclude with the exact numerical value of the integral. Can you ensure that each step appears one after the other, with a brief pause in between to allow for understanding, and provide clear visual and text explanations for each part of the process?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define an axis system\n        axes = Axes(\n            x_range=[-1, 5],\n            y_range=[-1, 5],\n            axis_config={\"color\": BLUE}\n        )\n        \n        # Define the curve and the area under the curve\n        curve = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(curve, x_range=(0,2), color=GREY)\n\n        # Displaying the curve\n        self.play(Create(axes), Create(curve))\n        self.wait(1)\n\n        # Showing the area under the curve between 0 and 2\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\").shift(UP*3)\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Animating the area\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Evaluate the integral\n        integral_value = MathTex(r\"= [\\frac{1}{3}x^3]_0^2\")\n        self.play(ReplacementTransform(problem.copy(), integral_value))\n        self.wait(1)\n\n        # Calculate the specific values\n        final_value = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integral_value, final_value))\n        self.wait(2)\n\n        # Clear the scene and show the final area value\n        self.play(FadeOut(area), FadeOut(curve), FadeOut(axes))\n        self.play(Transform(final_value, MathTex(r\"\\frac{8}{3}\").move_to(ORIGIN)))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that walks through the steps of solving a first-order linear ordinary differential equation, specifically y' - 3y = 0, by separating variables, integrating both sides, and then expressing the solution in exponential form? I'd like text explanations for each step to guide viewers along with the mathematical transformations, starting with the problem statement and concluding with the general solution of the differential equation.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        curve = MathTex(r\"f(x) = 3 - \\frac{x^3}{3}\", font_size=24).to_edge(UP)\n        axes = Axes(\n            x_range=[0, 2],\n            y_range=[0, 3],\n            axis_config={\"color\": BLUE},\n        )\n        f = lambda x: 3 - (x**3)/3\n        graph = axes.get_graph(f, color=WHITE, x_range=[0, 2])\n\n        self.play(Write(curve))\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.5)\n        self.wait(1)\n\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        integral = MathTex(r\"\\int_0^2 (3 - \\frac{x^3}{3}) \\,dx\")\n        self.play(ReplacementTransform(curve, integral))\n        self.wait(1)\n\n        result = MathTex(r\"= [3x - \\frac{x^4}{12}]_0^2\", font_size=24)\n        result.to_edge(DOWN)\n        self.play(Transform(integral, result))\n        self.wait(1)\n\n        final_value = MathTex(r\"= (3(2) - \\frac{2^4}{12}) - (3(0) - \\frac{0^4}{12})\", r\"= 6 - \\frac{16}{12}\", r\"= 6 - \\frac{4}{3}\", r\"= \\frac{18}{3} - \\frac{4}{3}\", r\"= \\frac{14}{3}\", font_size=24)\n        final_value.next_to(result, DOWN)\n        self.play(Write(final_value))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(DOWN)\n        self.play(ReplacementTransform(final_value, conclusion))\n        self.wait(2)"
    },
    {
        "query": "I need an animation that explains how to solve a double integral in polar coordinates, specifically the integral of r^2 over a circle with radius 1. The animation should show the problem statement, explain that we need to integrate with respect to r first, and then carry out this inner integral. After that, it should explain that we then integrate with respect to theta, and show this step as well. Finally, the animation should present the final solution of the double integral. Can you create an animated step-by-step solution to this problem?",
        "answer": "\\n from manim import *\n\nclass SimplePendulum(Scene):\n    def construct(self):\n        pendulum_length = 3\n        circle_radius = 0.2\n        pendulum_color = BLUE\n        \n        pivot_point = UP * 2\n        pendulum_end = pivot_point + DOWN * pendulum_length\n        pendulum_rod = Line(pivot_point, pendulum_end, stroke_width=3)\n        pendulum_bob = Circle(radius=circle_radius, color=pendulum_color).shift(pendulum_end)\n        \n        pendulum = VGroup(pendulum_rod, pendulum_bob)\n        \n        initial_angle = PI / 6\n        pendulum.rotate(initial_angle, about_point=pivot_point)\n        \n        self.add(pendulum_rod, pendulum_bob)\n        self.wait(0.5)\n        \n        for _ in range(3):\n            self.play(SwingFromSide(pendulum, initial_angle, about_point=pivot_point, rate_func=there_and_back_with_pause))\n            self.wait(0.5)"
    },
    {
        "query": "I'd like an educational animation that visually demonstrates how to calculate the area under the curve of the function f(x) = x^2 from x=0 to x=1. The video should start by displaying the function, then proceed to find the area under the curve from x=0 to x=1. It should show the curve and the area underneath it progressively, and then transition to displaying the definite integral that represents the area. Afterward, I want the animation to show the step-by-step calculation of the definite integral and present the final solution. To conclude, the animation should clear everything else away and only present the final solution to reinforce it. Can you create this animation for a teaching session?",
        "answer": "\\n from manim import *\n\n\nclass PieChartExample(Scene):\n    def construct(self):\n        pie_chart = PieChart(\n            values=[30, 45, 10, 15],\n            radius=2,\n            colors=[RED, BLUE, GREEN, YELLOW],\n            labels=[\"Product A\", \"Product B\", \"Product C\", \"Product D\"],\n            label_colors=[WHITE, WHITE, WHITE, WHITE],\n            label_radius=1.5,\n            slice_colors=[TEAL_E,TEAL_D,TEAL_C,TEAL_B],\n            start_angle=90,\n        )\n\n        self.add(pie_chart)"
    },
    {
        "query": "Can you create an educational animation that explains how to calculate the area under the curve of the exponential function f(x) = e^(-x) from x = 0 to x = 1, by using the concept of a definite integral, showing the integral setup, the antiderivative, the evaluation at the bounds, and ultimately the final solution?",
        "answer": "\\n from manim import *\nimport numpy as np\n\nclass ConvolutionalNetworkScene(Scene):\n    def construct(self):\n        # Manim configuration\n        config.pixel_height = 1080\n        config.pixel_width = 1920\n        config.frame_height = 8.0\n        config.frame_width = 14.0\n\n        # Neural network layers\n        layers = VGroup(\n            Text(\"Input Image\").scale(0.5),\n            Text(\"Conv Layer\").scale(0.5),\n            Text(\"Max Pooling\").scale(0.5),\n            Text(\"ReLU Activation\").scale(0.5),\n            Text(\"Fully Connected\").scale(0.5),\n            Text(\"Output\").scale(0.5),\n        )\n\n        # Arrange layers vertically\n        layers.arrange(DOWN, buff=0.5)\n\n        # Create arrows to show data flow\n        arrows = VGroup(*[\n            Arrow(layers[i].get_bottom(), layers[i+1].get_top(), buff=0.1)\n            for i in range(len(layers) - 1)\n        ])\n\n        # Group layers and arrows\n        network_flow = VGroup(layers, arrows)\n\n        # Position network_flow in the center of the screen\n        network_flow.move_to(ORIGIN)\n\n        # Animate the construction of the neural network diagram\n        self.play(LaggedStartMap(GrowFromCenter, layers), run_time=3)\n        self.play(ShowCreation(arrows), run_time=2)\n        self.wait(2)"
    },
    {
        "query": "Could you create an animated video that explains how to solve the integral of the square root of (1 - x^2) using trigonometric substitution? The video should walk through the steps starting with stating the integral problem, then showing the trigonometric substitution of x for sin(theta), followed by simplifying the integral using trigonometric identities. After that, it should solve the simplified integral and give the final solution in terms of theta. Lastly, it should convert the final solution back to x and conclude the explanation.",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^{\\pi} \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for trigonometric integration\n        explanation1 = Text(\"Integrate using trigonometric identities\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^{\\pi}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "I'd like an animated video that explains the process of evaluating a definite integral of a simple power function from two different points, a and b. The video should start by introducing the integral of x with respect to x between the limits a and b. I want it to then display a clear explanation of what the boundaries a and b mean, followed by a demonstration of the fundamental theorem of calculus in relation to this problem. The video should also include the steps taken to calculate the definite integral of x in this specific case, preferably showing the algebraic manipulation leading to the final answer. I would like the answer to be highlighted in some way to draw attention to it. Lastly, after clearing all prior details, the final simplified result of the integral should be revisited and displayed on its own for emphasis.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.rotate\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(triangle.animate.rotate(PI))\n            self.remove(triangle)"
    },
    {
        "query": "I want an educational animation showing the area under the curve of the function y = 0.25x^2 from x=0 to x=2 on graph axes labeled with 'x' and 'y'. Also, let the graph and axes be created with an animation effect. After showing the area under the curve highlighted in yellow with 50% opacity, display text \"Area under curve\" beside the highlighted area. Then, transform the \"Area under curve\" label into the integral notation for the area calculation, which is an integral from 0 to 2 of 0.25x^2 dx and place it at the top of the screen. Finally, reveal the calculation process and result of the integral below the integral notation, show the final numerical value for the area, and then clear everything else off the screen, leaving only the final area value shown at the end. Make sure the color of the axes is blue, the function graph is green, and use an appropriate animation to transition between each of these visual elements.",
        "answer": "\\n from manim import *\n\nclass EpitrochoidScene(Scene):\n    def construct(self):\n        R = 3    # Radius of the larger circle\n        r = 1    # Radius of the smaller circle\n        d = 2    # Distance from the center of the smaller circle\n\n        def epitrochoid(t):\n            x = (R + r) * np.cos(t) - d * np.cos((R + r) / r * t)\n            y = (R + r) * np.sin(t) - d * np.sin((R + r) / r * t)\n            return np.array([x, y, 0])\n\n        path = ParametricFunction(epitrochoid, t_range=[0, TAU * r], color=BLUE)\n\n        dot = Dot(color=BLUE).move_to(path.get_start())\n        self.add(dot, path)\n        self.play(MoveAlongPath(dot, path), run_time=8, rate_func=linear)\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video that visually explains the process of solving a double integral in polar coordinates, specifically the integral of r from 0 to 1 and theta from 0 to pi/2? The video should start by showing the double integral formula, then step-by-step display the integration in terms of r first, replacing r with its limits and simplifying it. Next, it should show the integration in terms of theta and simplifying to get the final answer, emphasizing each step of the calculation. Can you also include explanatory texts that guide me through the stages of integrating with respect to r first and then with respect to theta, ensuring each step is clearly shown and waits long enough for me to follow?",
        "answer": "\\n from manim import *\n\nclass TorusSurface(ThreeDScene):\n    def construct(self):\n        resolution_fa = 22\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n\n        def param_surface(u, v):\n            R = 1\n            r = 0.25\n            return np.array([\n                (R + r * np.cos(v)) * np.cos(u),\n                (R + r * np.cos(v)) * np.sin(u),\n                r * np.sin(v)\n            ])\n\n        surface = ParametricSurface(\n            param_surface,\n            u_range=[0, TAU],\n            v_range=[0, TAU],\n            resolution=(resolution_fa, resolution_fa)\n        )\n        surface.set_style(fill_opacity=0.5, stroke_color=BLUE)\n        \n        self.play(Create(surface), run_time=3)\n        self.begin_ambient_camera_rotation(rate=0.3)\n        self.wait(10)"
    },
    {
        "query": "I would like an educational math animation that shows the process of finding the area under the curve of the function f(x) = 0.1(x - 3)^2 + 1 from x = 0 to x = 5. The animation should start by displaying the problem, which is the integral of the function from 0 to 5. Then, I want the animation to show the curve and a shaded area beneath it to represent the area we are trying to find. After that, please include text that explains the shaded region is the area under the curve. Next, can you animate step-by-step computations of the integral, showing each step of the antiderivative calculation and evaluation at the bounds, resulting in the final numeric answer? Lastly, clear the screen and display the final result in isolation at the end of the animation.",
        "answer": "\\n from manim import *\n\nclass ConcentricCirclesScene(Scene):\n    def construct(self):\n        circles = VGroup(*[\n            Circle(radius=i*0.2, stroke_width=15 - i*2, stroke_opacity=0.5).set_color(color=[RED, BLUE])\n            for i in range(1, 15)\n        ])\n        circles.arrange_in_grid(rows=1)\n        self.play(Create(circles), run_time=3)\n        self.wait(1)\n        self.play(circles.animate.shift(UP * 2), run_time=1)\n        self.play(circles.animate.scale(0.5), run_time=1)\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that introduces and solves the integral of e to the power of x, detailing each step of the process and highlighting the constant of integration?",
        "answer": "\\n from manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Displaying the heat equation\n        equation = MathTex(r\"\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for physical meaning\n        explanation1 = Text(\"The heat equation describes the distribution of heat in a given region over time.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1, shift=DOWN))\n        self.wait(2)\n\n        # Example of a solution\n        example_solution = MathTex(r\"u(x, t) = \\frac{1}{\\sqrt{4 \\pi \\alpha t}} e^{-\\frac{x^2}{4 \\alpha t}}\")\n        self.play(Transform(equation, example_solution))\n        self.wait(1)\n\n        # Explanation for solution\n        explanation2 = Text(\"This solution represents heat conduction in a rod as time progresses.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Discuss initial conditions\n        initial_conditions = Text(\"Initial and boundary conditions are crucial for specific solutions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation1, initial_conditions))\n        self.wait(2)\n\n        # Conclusion\n        self.clear()\n        self.play(FadeIn(equation, shift=UP))\n        self.wait(1)\n\n        # Display steady-state solution\n        steady_state = MathTex(r\"u(x) = ax + b\")\n        self.play(Transform(equation, steady_state))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated video using Manim which visually demonstrates the Pythagorean Theorem, starting by writing out the equation a^2 + b^2 = c^2, then showing a right-angled triangle and labeling its sides as 'a,' 'b,' and 'c'? Afterwards, I would like to see squares being constructed on each of these sides, followed by visual proof that the area of the square on the 'c' side is equal to the sum of the areas of the squares on sides 'a' and 'b.' To conclude the demonstration, could you showcase a sentence stating \"This illustrates the Pythagorean Theorem\" and end the animation with the theorem equation shown once more?",
        "answer": "\\n class ShapesScene(Scene):\n    def construct(self):\n        red_rect = Rectangle(color=RED, fill_opacity=0.6, width=4, height=2)\n        orange_triangle = Polygon(ORIGIN, RIGHT, RIGHT+UP, color=ORANGE, fill_opacity=0.3)\n        orange_triangle.next_to(red_rect, UP)\n        self.play(FadeIn(red_rect), GrowFromPoint(orange_triangle, ORIGIN))\n        self.wait(2)"
    },
    {
        "query": "I would like an animation that visually demonstrates how to solve a triple integral in a step-by-step manner. The integral should be of the function xyz over the ranges z from -2 to 2, y from -1 to 1, and x from 0 to 1. The animation should start by showing the original integral, and then proceed to solve the integral with respect to z first, showing the result. Following this, it should show the integration with respect to y and then finally with respect to x. At each step, I'd like a text explanation to appear that indicates which variable we are integrating with respect to next. After showing all the integrations, I want the animation to clear out everything and then present the final result of the integral calculation. Please include appropriate pauses for viewers to understand each step, and ensure the transition from one step to the next is smooth.",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass HowManyPrimes(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        text_1 = VGroup(\n            Text(\"Existem infinitos\", color=TEXT_COLOR),\n            Text(\"n\u00fameros primos!\", color=TEXT_COLOR)\n        )\n        text_1[0][7:].set(color=LIGHT_PURPLE_COLOR)\n        text_1.scale(1.4)\n        text_1.arrange(DOWN, buff=0.5)\n\n        self.play(Write(text_1), run_time=0.7)\n        self.wait(1)\n        self.play(text_1.animate.scale(0), run_time=0.7)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Create an educational animation that explains how to evaluate the definite integral of x cubed from 0 to 2. First, display the integral problem on the screen. Then, add text to clarify that we are evaluating from 0 to 2, followed by an explanation of the general rule for integrating powers of x. Show the application of the integration rule to our specific problem and then demonstrate the simplification of the power expression. Next, include a step to evaluate the simplified expression at the upper and lower limits of the integral. Finally, present the numerical solution after the evaluation and keep it displayed on the screen once everything else is cleared. The animation should be slow enough to follow but not too long between steps.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that explains how to integrate the function x squared, displays the power rule for integration, shows the step-by-step integration on a problem, illustrates the area under the parabola from x=0 to x=2 on a graph, and then clears the screen to present the final solution?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Indicate\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"This is important\")\n            self.play(Indicate(some_text))\n            self.remove(some_text)"
    },
    {
        "query": "Could you create an animated video for me that explains the concept of a harmonic oscillator using the example of a mass-spring system? I'd like the video to start by showing the differential equation of motion for the oscillator, and then introduce the idea of angular frequency with its formula. After that, please highlight that the solution is harmonic and show the general solution equation with both cosine function and parameters like amplitude and phase constant. Finally, wrap up by presenting the complete harmonic motion equation and make sure each step is clearly written out and explained with text on the screen.",
        "answer": "\\n from manim import *\n\nclass SurfaceAreaParametricSurface(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint_S \\, dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Displaying the parametric surface equation\n        surface_eq = MathTex(r\"S(u,v) = f(u,v)\\hat{i} + g(u,v)\\hat{j} + h(u,v)\\hat{k}\")\n        surface_eq.next_to(problem, DOWN)\n        self.play(Write(surface_eq))\n        self.wait(2)\n\n        # Explaining the formula for surface area element in parametric form\n        explanation1 = Text(\"For a surface parametrized by u and v\", font_size=24)\n        explanation1.to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Surface area element formula\n        dS_formula = MathTex(r\"dS = \\left| \\frac{\\partial S}{\\partial u} \\times \\frac{\\partial S}{\\partial v} \\right| dudv\")\n        self.play(ReplacementTransform(surface_eq.copy(), dS_formula))\n        self.wait(2)\n\n        # Displaying the integral with the surface area element\n        integral_with_dS = MathTex(r\"\\iint_S \\left| \\frac{\\partial S}{\\partial u} \\times \\frac{\\partial S}{\\partial v} \\right| dudv\")\n        self.play(ReplacementTransform(problem.copy(), integral_with_dS))\n        self.wait(1)\n\n        # Explaining how to solve the integral\n        explanation2 = Text(\"Solve the below double integral to find the surface area\", font_size=24)\n        explanation2.to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution placeholder (not solved)\n        final_solution = Text(\"Surface area = ...\", font_size=24)\n        final_solution.to_edge(UP)\n        self.play(ReplacementTransform(explanation1, final_solution))\n        self.wait(2)\n\n        # Finish the scene\n        self.play(FadeOut(final_solution), FadeOut(integral_with_dS))\n        self.wait(1)"
    },
    {
        "query": "I'd like to create an educational animation that visually explains the steps involved in calculating a surface integral of a vector field over a given surface. Can you show the mathematical representation of a surface integral, detail the components of the vector field, describe the surface over which the integral is calculated, and then go through the process of parameterization, computation of the surface differential, substitution into the integral, and evaluation over the parameterized domain? Also, include written explanations for each step to guide the viewer through the process.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        context = Text(\"This represents a one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(context))\n        self.wait(2)\n\n        solution_hint = Text(\"Seek solutions of the form u(x, t) = f(x - ct) or u(x, t) = g(x + ct)\", font_size=24).to_edge(UP)\n        self.play(Transform(context, solution_hint))\n        self.wait(2)\n\n        wave_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, wave_solution))\n        self.wait(1)\n\n        specific_harmonic = Text(\"For harmonic waves, f and g can be sine or cosine functions.\", font_size=24).to_edge(UP)\n        self.play(Transform(context, specific_harmonic))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(wave_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visually explains how to compute the definite integral of x cubed from 0 to 2 using the power rule for integration, including the step-by-step calculation and ending with the presentation of the final result as the area under the curve?",
        "answer": "\\n from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        electron_cloud = Ellipse(width=2.0, height=1.2, color=BLUE).set_fill(BLUE, opacity=0.3)\n        nucleus = Dot(color=RED).scale(0.5)\n        proton = Text(\"H\", color=WHITE, font_size=36).move_to(nucleus.get_center())\n        hydrogen = VGroup(electron_cloud, nucleus, proton)\n\n        self.play(FadeIn(hydrogen))\n        self.wait()\n        self.play(hydrogen.animate.scale(2))\n        self.wait()"
    },
    {
        "query": "I'd like to create an educational animation that visually explains the concept of a sine wave through a simple video. Can you show a sine function equation, follow it with a sentence describing it as the graph of a sine function, and then actually draw the sine wave graph? I'd also like to include a sentence stating that sine waves are periodic in nature, with a note on their amplitude and period afterward. Finally, clear the screen and restate the sine function equation to conclude the animation. The text should be easy to read and positioned appropriately.",
        "answer": "\\n from manim import *\n\nclass AtomDrawing(Scene):\n    def construct(self):\n        # Create a proton, neutron, and electron\n        proton = self.create_atom_part(radius=0.2, label_text=\"p^+\", color=RED)\n        neutron = self.create_atom_part(radius=0.2, label_text=\"n^0\", color=GREY)\n        electron = self.create_atom_part(radius=0.1, label_text=\"e^-\", color=BLUE)\n\n        # Positioning the protons and neutrons to form a nucleus\n        nucleus = VGroup(proton, neutron).arrange(buff=0.5)\n        \n        # Positioning the electron around the nucleus\n        electron.move_to(nucleus.get_edge_center(LEFT) + LEFT*0.5)\n\n        # Animating the electron to move around the nucleus\n        self.play(MoveAlongPath(electron, Circle(radius=1, color=WHITE).move_to(nucleus.get_center()), run_time=2, rate_func=linear))\n        self.wait(2)\n\n        # Group everything and add to the scene\n        atom = VGroup(nucleus, electron)\n        self.add(atom)\n        self.wait(2)\n\n    def create_atom_part(self, radius, label_text, color):\n        atom_part = Circle(radius=radius, color=color)\n        atom_part.set_fill(color, opacity=0.5)\n\n        # Create the label\n        label = Tex(label_text, color=color).scale(0.5)\n        atom_part.add(label)\n        \n        return atom_part"
    },
    {
        "query": "I would like to create an educational animation that walks through the process of evaluating a double integral in polar coordinates. Specifically, I\u2019m interested in an animation that shows the integral of r^2 sin(theta) with respect to r and theta, where r goes from 0 to 1 and theta goes from 0 to pi. I want the animation to visually display the problem, then demonstrate step-by-step integration with respect to r first, followed by integrating with respect to theta. After each integration step, I would like the results to be displayed in mathematical notation, along with a brief text explanation of what is being done. Finally, the solution should be simplified to show the final numeric answer. Can you create such an animation?",
        "answer": "\\n from manim import *\n\nclass TrigonometricFunctionIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of using a trigonometric identity\n        explanation1 = Text(\"Use the identity: sin(2x) = 2sin(x)cos(x)\",\n                            font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the identity\n        identity_applied = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, identity_applied))\n        self.wait(1)\n\n        # Integration of sin(2x)\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(identity_applied, integration_step))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated video using Manim that introduces the wave equation, describes its components including wave speed, then extends it to three dimensions and ends by showing an example solution involving terms like amplitude, wave number, and angular frequency, with each concept and equation appearing on screen sequentially and concluding by fading everything out?",
        "answer": "\\n import numpy as np\nfrom manim import *\n\n\nclass ComplexPlaneWithFunctionDots(ComplexPlane):\n    class InputDot(Dot):\n        def __init__(self, plane, **kwargs):\n            super().__init__(**kwargs)\n\n            self.plane = plane\n\n        def get_value(self):\n            return self.plane.p2n(self.get_center())\n\n        def set_value(self, value):\n            self.move_to(self.plane.n2p(value))\n\n            return self\n\n    class OutputDot(Dot):\n        def __init__(self, plane, input_dot, func, **kwargs):\n            super().__init__(**kwargs)\n\n            self.plane = plane\n            self.input_dot = input_dot\n            self.func = func\n\n            self.update_position()\n            always(self.update_position)\n\n        def get_value(self):\n            return self.plane.p2n(self.get_center())\n\n        def update_position(self):\n            self.move_to(self.plane.n2p(self.func(self.input_dot.get_value())))\n\n    def get_function_dots(self, func, *, input_config={}, output_config={}):\n        input_dot = self.InputDot(self, **input_config)\n        output_dot = self.OutputDot(self, input_dot, func, **output_config)\n\n        return input_dot, output_dot\n\n\nclass Euler(Scene):\n    def construct(self):\n        plane = ComplexPlaneWithFunctionDots()\n        plane.add_coordinates(*plane.get_default_coordinate_values())\n        self.add(plane)\n\n        theta_dot, z_dot = plane.get_function_dots(\n            lambda z: np.exp(1j * z),\n            input_config={\"color\": RED},\n            output_config={\"color\": YELLOW, \"z_index\": 1},\n        )\n\n        path = TracedPath(z_dot.get_center, min_distance_to_new_point=0)\n\n        formula = MathTex(\"z\", \"=e^{i\", r\"\\theta}\").move_to(5.5 * LEFT + 2.5 * UP)\n        formula[0].set_color(z_dot.get_color())\n        formula[2].set_color(theta_dot.get_color())\n\n        formula_box = Rectangle(\n            width=formula.get_width() + MED_SMALL_BUFF,\n            height=formula.get_height() + MED_SMALL_BUFF,\n        )\n        formula_box.move_to(formula).set_fill(BLACK, opacity=1).set_stroke(\n            BLUE, opacity=1, width=DEFAULT_STROKE_WIDTH / 2\n        )\n\n        formula_group = VGroup(formula_box, formula)\n\n        self.add(path, formula_group, theta_dot, z_dot)\n        self.play(theta_dot.set_value, TAU, run_time=3)\n\n        indicate_path = Circle(color=PINK)\n        self.play(ShowCreationThenDestruction(indicate_path), run_time=3)\n\n        self.play(theta_dot.set_value, 1j, run_time=3)\n        self.play(Rotating(theta_dot, about_point=ORIGIN), run_time=3)\n        self.play(theta_dot.move_to, plane.n2p(0))"
    },
    {
        "query": "Can you create an educational animation that illustrates the concept of Fourier series, specifically showing the general formula for the Fourier series, explaining how the coefficients of the series are calculated for a given function, distinguishing between the coefficients for even and odd functions, and finally, mentioning some real-world applications of Fourier series such as signal processing and heat transfer? Additionally, can you make sure that each of these points is presented clearly on the screen one after another, with a concluding summary at the end of the animation?",
        "answer": "\\n from manim import *\n\nclass ExampleNeuralNetworkScene(ThreeDScene):\n    def construct(self):\n        # Let's create a simple neural network with 3 layers\n        \n        # Define the number of neurons for each layer\n        layers = [4, 5, 3]  \n\n        # Colors for different layers\n        first_layer_color = BLUE\n        middle_layer_color = GREEN\n        output_layer_color = RED\n\n        # Initial positions\n        first_layer_position = LEFT * 3\n        middle_layer_position = ORIGIN\n        output_layer_position = RIGHT * 3\n\n        # Create the first layer\n        first_layer = VGroup(\n            *[Circle(radius=0.2, color=first_layer_color) for _ in range(layers[0])]\n        ).arrange(DOWN, buff=0.5).move_to(first_layer_position)\n\n        # Create the middle layer\n        middle_layer = VGroup(\n            *[Circle(radius=0.2, color=middle_layer_color) for _ in range(layers[1])]\n        ).arrange(DOWN, buff=0.5).move_to(middle_layer_position)\n\n        # Create the output layer\n        output_layer = VGroup(\n            *[Circle(radius=0.2, color=output_layer_color) for _ in range(layers[2])]\n        ).arrange(DOWN, buff=0.5).move_to(output_layer_position)\n\n        # Draw the neurons in the scene\n        self.add(first_layer, middle_layer, output_layer)\n\n        # Function for creating arrows from one layer to another\n        def connect_layers(layer1, layer2):\n            return VGroup(\n                *[Line(layer1[i].get_center(), layer2[j].get_center(), buff=0.1)\n                  for i in range(len(layer1)) for j in range(len(layer2))]\n            )\n        \n        # Connect the first layer to the middle layer\n        first_to_middle_arrows = connect_layers(first_layer, middle_layer)\n        # Connect the middle layer to the output layer\n        middle_to_output_arrows = connect_layers(middle_layer, output_layer)\n\n        # Add the arrows to the scene\n        self.add(first_to_middle_arrows, middle_to_output_arrows)\n\n        # Move the camera to get a better view\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n\n        # Show passing flash to simulate signal\n        self.play(ShowPassingFlash(first_to_middle_arrows.copy().set_color(YELLOW), run_time=2, lag_ratio=0.2))\n        self.play(ShowPassingFlash(middle_to_output_arrows.copy().set_color(YELLOW), run_time=2, lag_ratio=0.2))\n\n        # Hold on the last frame\n        self.wait()"
    },
    {
        "query": "Create an animated video explaining how to evaluate the double integral of the function x^2 over a circular region with radius 1, centered at the origin, by integrating first with respect to x and then with respect to y. The video should start by displaying the double integral in mathematical notation, followed by a step-by-step integration process. Each step should be clarified with a short text explanation that appears at the top, such as when to integrate with respect to x, then y, and finally how to evaluate the definite integral. The result should show the entire integral process in a way that's easy to follow for someone learning about double integrals in polar coordinates.",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Defining the differential equation\n        diff_eq = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Displaying the concept of angular frequency\n        angular_freq = Text(\"Angular Frequency: \" r\"\\(\\omega^2 = \\frac{k}{m}\\)\", font_size=24).to_edge(UP)\n        self.play(Write(angular_freq))\n        self.wait(2)\n\n        # Relating to the differential equation\n        ang_freq_eq = MathTex(r\"\\omega^2 = \\frac{k}{m}\")\n        self.play(ReplacementTransform(diff_eq.copy(), ang_freq_eq))\n        self.wait(1)\n\n        # Displaying solution approach\n        solution_approach = Text(\"Assume a solution of the form\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq, solution_approach))\n        self.wait(2)\n\n        # Assumed solution\n        assumed_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(ReplacementTransform(ang_freq_eq, assumed_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation_solution = Text(\"General solution of the harmonic oscillator\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq, explanation_solution))\n        self.wait(2)\n\n        # Clear the scene and display only the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(assumed_solution))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that visually demonstrates the process for calculating the definite integral of x^3 from 0 to 2, showing step-by-step how to integrate using limits, evaluating the function at the upper and lower limits, and displaying the final result, which is 4, with a concluding message that reinforces the integral result obtained.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title of the scene\n        title = Text(\"Fourier Series Approximation\").scale(0.9)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Define the function to be approximated\n        original_function = MathTex(r\"f(x) = x^2\").next_to(title, DOWN)\n        self.play(FadeIn(original_function))\n        self.wait(1)\n\n        # Show the nth partial sum of Fourier series\n        fourier_series = MathTex(r\"S_n(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} [a_n \\cos(nx) + b_n \\sin(nx)]\", font_size=24)\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Explain the coefficients\n        coefficients_info = Text(\n            \"Coefficients a_n and b_n are calculated based on f(x)\", \n            font_size=24).next_to(fourier_series, DOWN)\n        self.play(Write(coefficients_info))\n        self.wait(2)\n\n        # Define the Fourier series approximation for n=5\n        approximation = MathTex(r\"S_5(x) = \\frac{a_0}{2} + \\sum_{n=1}^{5} [a_n \\cos(nx) + b_n \\sin(nx)]\", font_size=24)\n        self.play(Transform(fourier_series, approximation))\n        self.wait(2)\n\n        # Remove everything and display only the approximation\n        self.play(FadeOut(title), FadeOut(original_function), FadeOut(coefficients_info))\n        self.wait(1)\n        self.play(Write(approximation))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation about surface integrals that visually explains the steps involved in finding the surface area of a three-dimensional object using a parametric surface. Can you illustrate the process of parameterizing the surface, calculating the partial derivatives, determining the normal vector and its magnitude, and finally setting up and solving the surface integral for the area? I want each step to be accompanied by clear mathematical formulas and some explanatory text.",
        "answer": "\\n from manim import *\nimport random\nfrom enum import Enum\n\n\nclass SwapMode(Enum):\n    OVER = 1\n    ACROSS = 2\n\n\nclass Array(VGroup):\n    def __init__(self, array, run_time=0.3):\n        super().__init__()\n        self.run_time = run_time\n        self.build_array(array)\n\n    def build_array(self, array):\n        for i, x in enumerate(array):\n            cell = VDict({\"cell\": Square(), \"number\": Integer(x)})\n            if i != 0:\n                cell.next_to(self, RIGHT, buff=0)\n            self.add(cell)\n        self.move_to(ORIGIN)\n\n    def value_at_index(self, index):\n        return self[index][\"number\"].get_value()\n\n    def swap(self, scn, i, j, swap_mode=SwapMode.ACROSS):\n        # Swap in submobjects list\n        temp = self.submobjects[i]\n        self.submobjects[i] = self.submobjects[j]\n        self.submobjects[j] = temp\n\n        # Swap on screen\n        if swap_mode == SwapMode.ACROSS:\n            scn.play(\n                self.submobjects[j].shift,\n                LEFT * self.submobjects[i].get_width(),\n                self.submobjects[i].shift,\n                RIGHT * self.submobjects[j].get_width(),\n                run_time=self.run_time,\n            )\n        elif swap_mode == SwapMode.OVER:\n            scn.play(\n                self.submobjects[j].shift,\n                self.submobjects[j].get_height() * UP,\n                run_time=self.run_time / 3,\n            )\n            scn.play(\n                self.submobjects[j].shift,\n                self.submobjects[j].get_width() * LEFT,\n                self.submobjects[i].shift,\n                self.submobjects[j].get_width() * RIGHT,\n                run_time=self.run_time / 3,\n            )\n            scn.play(\n                self.submobjects[j].shift,\n                self.submobjects[j].get_height() * DOWN,\n                run_time=self.run_time / 3,\n            )\n        else:\n            raise ValueError(f\"Unknown SwapMode {swap_mode}\")\n\n\nclass HeightArray(Array):\n    def __init__(self, array, unit_width=1.5, unit_height=1, run_time=0.3):\n        self.unit_height = unit_height\n        self.unit_width = unit_width\n        super().__init__(array, run_time=run_time)\n\n    def value_at_index(self, index):\n        return self[index].get_height() / self.unit_height\n\n    def build_array(self, array):\n        for i, x in enumerate(array):\n            cell = Rectangle(width=self.unit_width, height=x * self.unit_height)\n            if i != 0:\n                cell.next_to(self, RIGHT, buff=0)\n                cell.align_to(self, DOWN)\n            self.add(cell)\n        self.move_to(ORIGIN)\n\n\nclass DraftScene(Scene):\n    def construct(self):\n        self.sort_array()\n\n    def sort_array(self):\n        arr = list(range(1, 51))\n        random.shuffle(arr)\n        arr_mob = HeightArray(arr, run_time=0.03)\n        if type(arr_mob) == Array:\n            arr_mob.set_width(13)\n        elif isinstance(arr_mob, HeightArray):\n            arr_mob.set_height(7)\n            arr_mob.to_edge(DOWN)\n        self.play(ShowCreation(arr_mob))\n        self.wait()\n\n        i = 1\n        arr_mob[0].set_color(GREEN)\n        while i < len(arr_mob.submobjects):\n            arr_mob[i].set_color(YELLOW)\n            j = i\n            while j > 0 and arr_mob.value_at_index(j - 1) > arr_mob.value_at_index(j):\n                arr_mob.swap(self, j, j - 1)\n                j = j - 1\n            arr_mob[j].set_color(GREEN)\n            i = i + 1\n        self.wait()"
    },
    {
        "query": "I'd like an animation that visually depicts the step-by-step process of solving a triple integral math problem. Can you create a video that starts by showing the triple integral of xyz over the unit cube, then sequentially demonstrates how to integrate it with respect to z, then y, and finally x, with brief explanatory texts introducing each step of the integration? After completing each integration step, the result should replace the previous equation. Conclude the animation with the final numeric solution of the integral displayed on its own.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\iiint_V xyz \\,dx\\,dy\\,dz\", font_size=48)\n        self.play(Write(problem))\n        self.wait(1)\n\n        limits = Text(\"where V is the region bounded by the planes x=0, y=0, z=0, x+y=1\", font_size=24).to_edge(UP)\n        self.play(Write(limits))\n        self.wait(2)\n\n        first_integral = MathTex(r\"= \\int_0^1 \\int_0^{1-x} \\int_0^{1-x-y} xyz \\,dz\\,dy\\,dx\")\n        self.play(ReplacementTransform(problem, first_integral))\n        self.wait(3)\n\n        second_integral = MathTex(r\"= \\int_0^1 \\int_0^{1-x} [\\frac{1}{2} xy z^2 ]_{0}^{1-x-y} \\,dy\\,dx\")\n        self.play(ReplacementTransform(first_integral, second_integral))\n        self.wait(3)\n\n        third_integral = MathTex(r\"= \\int_0^1 [\\frac{1}{2} xy (\\frac{1}{2} - x - y) ]_{0}^{1-x} \\,dx\")\n        self.play(ReplacementTransform(second_integral, third_integral))\n        self.wait(3)\n\n        solution = MathTex(r\"= [\\frac{1}{24} - \\frac{1}{4} x^2 + \\frac{1}{3} x^3]_0^1\", r\"=\", r\"\\frac{1}{24}\")\n        self.play(ReplacementTransform(third_integral, solution))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation using ManimCE that explains how to integrate the sine function? Start by showing the integral of sin(x) with respect to x, then give a textual explanation that it's the integral of the sine function, followed by the mathematical rule showing the integral of sin(x) equals negative cosine of x plus the integration constant C. Next, substitute the integral of sin(x) with the solution including the integration constant. After that, remind viewers not to forget the integration constant by updating the text explanation. Finally, clear the screen and present the final solution neatly.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowFromEdge - DOWN\").shift(UP*2.5)), run_time=0.5)\n            squares = [Square() for _ in range(4)]\n            self.play(GrowFromEdge(squares[0], DOWN))\n            self.play(Transform(text,Text(\"GrowFromEdge - RIGHT\").shift(UP*2.5)), run_time=0.5)\n            self.play(GrowFromEdge(squares[1], RIGHT))\n            self.play(Transform(text,Text(\"GrowFromEdge - UP\").shift(UP*2.5)), run_time=0.5)\n            self.play(GrowFromEdge(squares[2], UP))\n            self.play(Transform(text,Text(\"GrowFromEdge - LEFT\").shift(UP*2.5)), run_time=0.5)\n            self.play(GrowFromEdge(squares[3], LEFT))\n            self.remove(*squares)"
    },
    {
        "query": "Can you create an educational animation that visually explains the process of solving a triple integral step by step, starting from the innermost integral of xyz with respect to z from -1 to 1, then with respect to y from -1 to 1, and finally with respect to x from 0 to 1? I'm looking for the animation to display the triple integral problem at the beginning and then show each integration step one by one along with a text explanation for each step. After each step, please replace the previous integral with the new one, and when the final solution is reached, clear everything and then present the final result alone to conclude the animation.",
        "answer": "\\n from manim import *\n\n\nclass WaterScene(Scene):\n    def construct(self):\n        water_molecule = self.create_water_molecule()\n        self.play(Create(water_molecule))\n        self.wait(2)\n\n    def create_water_molecule(self) -> VGroup:\n        oxygen = Circle(color=BLUE, fill_opacity=1).scale(0.5).set_fill(BLUE)\n        hydrogen_1 = Circle(color=WHITE, fill_opacity=1).scale(0.2).shift(UP * 0.3 + RIGHT * 0.5)\n        hydrogen_2 = Circle(color=WHITE, fill_opacity=1).scale(0.2).shift(DOWN * 0.3 + RIGHT * 0.5)\n\n        bond_1 = Line(oxygen.get_center(), hydrogen_1.get_center(), color=GREY)\n        bond_2 = Line(oxygen.get_center(), hydrogen_2.get_center(), color=GREY)\n\n        water_molecule = VGroup(oxygen, hydrogen_1, hydrogen_2, bond_1, bond_2)\n        water_molecule.move_to(ORIGIN)\n\n        return water_molecule"
    },
    {
        "query": "Can you create an educational animation using ManimCE that illustrates the concept of simple harmonic motion? I would like to start by showing the differential equation \\( m\\frac{d^2 x}{dt^2} = -kx \\) written out on the screen. Then, can you add a brief explanation of what each term represents (m for mass, k for spring constant, and x for position) just above the equation? After that, please replace the differential equation with the form of its solution \\( x(t) = A \\cos(\\omega t - \\phi) \\) and provide a similar explanation for the new terms (A for amplitude, omega for angular frequency, and phi for phase shift) above it. Lastly, could you animate a circle moving back and forth like an oscillator, with an arrow showing the force direction, and then go back to displaying the solution form \\( x(t) = A \\cos(\\omega t - \\phi) \\) at the end? Make sure to pause slightly in between each step so that the viewer has time to absorb the information.",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^\\infty e^{-x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the improper integral\n        explanation1 = Text(\"Setup as a limit for the improper integral\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the limit\n        limit_setup = MathTex(r\"= \\lim_{a \\to \\infty} \\int_2^a e^{-x} \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), limit_setup))\n        self.wait(1)\n\n        # Integration step\n        integration_step = MathTex(r\"= \\lim_{a \\to \\infty} [-e^{-x}]_2^a\")\n        self.play(ReplacementTransform(limit_setup, integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the limit\n        explanation2 = Text(\"Evaluate the limit as a approaches infinity\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= e^{-2}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the concept of finding the area under a curve using integral calculus. Specifically, the animation should show the following steps: \n\n1. Display the mathematical function f(x) = x^2 on the screen, preferably at the top.\n2. Plot the graph of this quadratic function from x = 0 to x = 2.\n3. Shade the area under the curve between x = 0 and x = 2 to illustrate the concept of integration visually.\n4. Introduce the integral calculus notation for the function's definite integral from 0 to 2.\n5. Show the step-by-step calculation of this integral, starting with the application of the integral formula.\n6. Evaluate the resulting expression at the upper and lower limits of the integral to find the numerical value of the area.\n7. Finally, clear the screen and display only the evaluated result of the integral, which is the exact area under the curve within the specified range.\n\nCan you create an animation that includes all of these educational elements using smooth transitions and suitable waiting times between each step for better understanding?",
        "answer": "\\n from manim import *\n\nclass FourierSeries(Scene):\n    def construct(self):\n        square_wave = lambda x: 1 if x % 2 < 1 else -1\n        approx = FourierSeries(square_wave, n_terms=10)\n        \n        self.play(Create(approx), run_time=5)\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using Manim that visually demonstrates how to calculate the area between the curves \\( y = x^2 \\) and \\( y = 0.8x^2 + 1 \\) from \\( x = 0 \\) to \\( x = 2 \\)? I'd like the animation to include the graphing of the two functions with labeled axes, shading of the area between the curves, and a step-by-step solution showing the set-up and calculation of the definite integral that gives the area. Also, can the final answer be prominently displayed at the end of the animation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShowPassingFlashWithThinningStrokeWidth\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(ShowPassingFlashWithThinningStrokeWidth(square))\n            self.remove(square)"
    },
    {
        "query": "Can you create an animation that explains the process of evaluating the double integral of e to the power of y squared over the region from y=0 to y=x and x=0 to x=1, with the steps to first integrate with respect to y, then show that the inner integral can't be solved with elementary functions, and finally suggest that we'll compute the integral numerically?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.stretch\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            self.play(circle.animate.stretch(2,1))\n            self.remove(circle)"
    },
    {
        "query": "Can you create an educational animation that illustrates how to solve a quadratic equation by factoring, shows the process step by step, graphically represents the roots on a number line, and emphasizes the final solution?",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef SpeechBubble(**kwargs):\n    gp = VGroup(\n        RoundedRectangle(width=4.5, height=2.5),\n        Polygram([\n            [-4.5/3, -2.5 + 0.55, 0], \n            [-4.5/2.8, -2.5 + 1.25, 0], \n            [-4.5/2.8 + 1, -2.5 + 1.25, 0]\n        ])\n    )\n\n    return Union(*gp, **kwargs)\n\nclass QuestionOne(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        animal_1 = ImageMobject(\"./assets/Asset 2 - Flipped.png\")\n        animal_1.scale(0.4)\n        animal_1.shift(9 * LEFT)\n        animal_2 = ImageMobject(\"./assets/Asset 3.png\")\n        animal_2.scale(0.4)\n        animal_2.shift(9 * RIGHT)\n        animal_3 = ImageMobject(\"./assets/Asset 4.png\")\n        animal_3.scale(0.4)\n        animal_3.shift(9 * RIGHT)\n        speech_1 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_PURPLE_COLOR)\n        speech_1.shift(3 * UP + 8 * LEFT)\n        speech_2 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_RED_COLOR)\n        speech_2.shift(3 * UP + 8 * RIGHT)\n        speech_2.flip(UP)\n        speech_3 = speech_2.copy()\n        speech_3.set(fill_color=GREEN_COLOR)\n        text_1 = VGroup(\n            Text(\"O que s\u00e3o\", color=WHITE),\n            Text(\"n\u00fameros primos?\", color=WHITE)\n        )\n        text_1.scale(0.6)\n        text_1.arrange(DOWN, buff=0.1)\n        text_1.shift(3 * UP + 8 * LEFT)\n        text_2 = VGroup(\n            Text(\"S\u00e3o n\u00fameros que\", color=WHITE),\n            Text(\"t\u00eam somente dois\", color=WHITE),\n            Text(\"divisores,\", color=WHITE)\n        )\n        text_2.scale(0.6)\n        text_2.arrange(DOWN, buff=0.1)\n        text_2.shift(3.03 * UP + 8 * RIGHT)\n        text_2[2].shift(0.1 * DOWN)\n        text_3 = VGroup(\n            Text(\"1 e ele\", color=WHITE),\n            Text(\"mesmo.\", color=WHITE)\n        )\n        text_3.scale(0.6)\n        text_3.arrange(DOWN, buff=0.3)\n        text_3.shift(3.03 * UP + LEFT)\n        text_4 = VGroup(\n            Text(\"O n\u00famero cinco\", color=WHITE),\n            Text(\"\u00e9 primo?\", color=WHITE)\n        )\n        text_4.scale(0.6)\n        text_4.arrange(DOWN, buff=0.2)\n        text_4.shift(3 * UP + 8 * RIGHT)\n\n        self.play(\n            animal_1.animate.shift(7 * RIGHT), \n            speech_1.animate.shift(9 * RIGHT),\n            text_1.animate.shift(9 * RIGHT),\n            run_time=0.7\n        )\n        self.wait(2.5)\n        self.play(\n            animal_1.animate.shift(9 * LEFT), \n            speech_1.animate.shift(9 * LEFT), \n            text_1.animate.shift(9 * LEFT), \n            animal_2.animate.shift(7 * LEFT), \n            speech_2.animate.shift(9 * LEFT), \n            text_2.animate.shift(9 * LEFT), \n            run_time=0.7\n        )\n        self.wait(2.5)\n        self.play(\n            FadeOut(text_2),\n            FadeIn(text_3), \n            run_time=0.5\n        )\n        self.wait(2.5)\n        self.play(\n            animal_2.animate.shift(9 * LEFT), \n            speech_2.animate.shift(9 * LEFT), \n            text_3.animate.shift(9 * LEFT), \n            animal_3.animate.shift(7 * LEFT), \n            speech_3.animate.shift(9 * LEFT), \n            text_4.animate.shift(9 * LEFT), \n            run_time=0.7\n        )\n        self.wait(2.5)\n        self.play(\n            animal_3.animate.shift(9 * LEFT), \n            speech_3.animate.shift(8 * LEFT), \n            text_4.animate.shift(8 * LEFT), \n            run_time=0.7\n        )\n        self.remove(*self.mobjects)"
    },
    {
        "query": "Could you create an educational animation using ManimCE that visually explains the wave equation and its general solution by doing the following steps: \n1. Start by displaying the wave equation \"partial squared u over partial t squared equals c squared times partial squared u over partial x squared\" on the screen.\n2. After showing the equation for a brief moment, accompany it with a written explanation that says \"This is the classic wave equation for u(x,t)\" at the top of the screen.\n3. Then, replace the initial explanation with a new text saying \"Its solutions include harmonic waves\" still positioned at the top.\n4. Next, transform the wave equation into its general solution \"u(x, t) equals A cos(kx - omega t) plus B sin(kx - omega t)\" on the screen.\n5. Following the transformation, present a final explanatory text that reads \"Here, A and B are determined by initial conditions\" at the top.\n6. Conclude by clearing everything else away and leaving only the general solution on screen for a little while before the animation ends.",
        "answer": "\\n from manim import *\n\n# Colors\nPRIMARY_COLOR = \"#ff0000\"\nSECONDARY_COLOR = \"#0000ff\"\nTERTIARY_COLOR = \"#00ff00\"\nACCENT_COLOR = \"#ff00ff\"\n\n# Configuration\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 8.0\nconfig.frame_width = 14.22\n\ndef Multiplication(factor1, factor2):\n    result = factor1 * factor2\n\n    gp = VGroup(\n        MathTex(str(factor1), color=PRIMARY_COLOR),\n        MathTex(\"\\\\times\", color=ACCENT_COLOR),\n        MathTex(str(factor2), color=SECONDARY_COLOR),\n        MathTex(\"=\", color=ACCENT_COLOR),\n        MathTex(str(result), color=TERTIARY_COLOR)\n    ).arrange(RIGHT)\n\n    return gp\n\nclass FiveMultiplication(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ffffff\"\n\n        times_one = Multiplication(5, 1)\n        times_two = Multiplication(5, 2)\n        times_three = Multiplication(5, 3)\n        times_four = Multiplication(5, 4)\n        times_five = Multiplication(5, 5)\n        multiplications = VGroup(\n            times_one,\n            times_two,\n            times_three,\n            times_four,\n            times_five\n        ).arrange(DOWN, buff=0.5)\n\n        rectangle_one = SurroundingRectangle(times_one, color=PRIMARY_COLOR)\n        rectangle_five = SurroundingRectangle(times_five, color=SECONDARY_COLOR)\n\n        self.play(LaggedStart(\n            *[FadeIn(multiplication) for multiplication in multiplications],\n            lag_ratio=0.2,\n            run_time=2\n        ))\n        self.wait(1)\n        self.play(Create(rectangle_one), Create(rectangle_five))\n        self.wait(2)\n        self.play(\n            FadeOut(rectangle_one),\n            FadeOut(rectangle_five),\n            *[FadeOut(multiplication) for multiplication in multiplications],\n            run_time=1\n        )\n        self.wait(0.5)"
    },
    {
        "query": "Could you create an educational animation that illustrates the step-by-step process of evaluating the surface area of a shape in polar coordinates, starting with the double integral of the function sqrt(1+r^2) over a polar region, and demonstrating the integration with respect to 'r' first, before then showing the integration with respect to 'theta'? Each step should include clear visual explanations and the final answer displayed on-screen.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = e^{-x^2}\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Displaying the area problem\n        area_problem = MathTex(r\"\\int_0^2 f(x) \\,dx\")\n        self.play(Transform(function, area_problem))\n        self.wait(1)\n\n        # Explanation for the area calculation\n        explanation1 = Text(\"Area under the curve between 0 and 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Numerical approximation setup\n        approximation_setup = MathTex(r\"\\approx \\sum_{i=1}^n f(x_i) \\Delta x\")\n        self.play(ReplacementTransform(area_problem, approximation_setup))\n        self.wait(1)\n\n        # Explanation for Riemann sum approximation\n        explanation2 = Text(\"Using Riemann sum to approximate the area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Riemann sum formula with n=4\n        riemann_sum_4 = MathTex(r\"\\approx \\sum_{i=1}^4 f(x_i) \\Delta x\")\n        self.play(ReplacementTransform(approximation_setup, riemann_sum_4))\n        self.wait(1)\n\n        # Explanation for increasing n for better approximation\n        explanation3 = Text(\"Increase n for a better approximation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Riemann sum formula with n=10\n        riemann_sum_10 = MathTex(r\"\\approx \\sum_{i=1}^{10} f(x_i) \\Delta x\")\n        self.play(ReplacementTransform(riemann_sum_4, riemann_sum_10))\n        self.wait(1)\n\n        # Clear the scene and explain the result\n        self.play(FadeOut(explanation1), FadeOut(riemann_sum_10))\n        result_explanation = Text(\"As n increases, the approximation becomes more accurate.\", font_size=24)\n        self.play(Write(result_explanation))\n        self.wait(2)"
    },
    {
        "query": "Create an animation that explains the concept of approximating the area under the curve of the function \\( f(x) = e^{-x^2} \\) from x=0 to x=2 using Riemann sums. Start by showing the mathematical function, then transition to showing the integral expression of the area under the curve between 0 and 2. After that, display a text explanation that we are looking at the area under the curve between these points. Replace the integral with an approximate sum expression, and then explain we can approximate this area using Riemann sums. Increase the number of intervals from n=4 to n=10, visually demonstrating that with more intervals the approximation gets better. Finally, clear the board and conclude with the written statement that as the number of intervals increases, the accuracy of the approximation improves.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated video that visually demonstrates how to evaluate the Gaussian integral, starting from the integral of e^(-x^2) from negative to positive infinity, transforming it by squaring, changing it to polar coordinates, and then showing that the result is pi, with step-by-step explanatory text throughout the animation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_y\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift((LEFT+UP)*2)\n            star = Star()\n            self.add(dot,star)\n            self.play(star.animate.match_y(dot))\n            self.remove(star,dot)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates how to calculate the area under the curve of the function y=0.2x^2 from x=0 to x=4, using a graph with labelled axes and the area shaded in green? Additionally, can it start by showing the axes and building the curve, labeling the curve with its equation, and then progressing to filling the area underneath it while displaying a text description of what's being shown? And after showing the graph, can the animation clear out and conclude with a text message on screen summarizing what was just presented?",
        "answer": "\\n from manim import Scene, Create\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nclass FeedForwardNetworkScene(Scene):\n    def construct(self):\n        # Create a feedforward neural network\n        nn = NeuralNetwork([\n            FeedForwardLayer(4, activation_function=\"ReLU\"),\n            FeedForwardLayer(8, activation_function=\"ReLU\"),\n            FeedForwardLayer(2, activation_function=\"Sigmoid\"),\n        ], layer_spacing=0.35)\n\n        # Add the neural network to the scene\n        self.add(nn)\n        \n        # Animate the forward pass through the neural network\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass)"
    },
    {
        "query": "Could you create an educational animation that walks through the process of solving a basic definite integral using the Fundamental Theorem of Calculus? Start by displaying the integral of x cubed from 1 to 2. Then, introduce the concept of the Fundamental Theorem of Calculus with a textual explanation at the top of the screen. Next, show the anti-derivative of the function being integrated. Afterward, evaluate the anti-derivative at the upper and lower bounds of the integral and display the subtraction of these values. Include another text explanation emphasizing the subtraction step for finding the definite integral. Finally, present the simplified numeric answer and clear the scene before showing the solution alone for emphasis.",
        "answer": "\\n from manim import *\n\nclass TaylorSeriesExample(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = e^x\")\n        self.play(FadeIn(function))\n        self.wait(1)\n        \n        # Display the Taylor Series approximation\n        taylor = MathTex(r\"P_n(x) = \\sum_{{i=0}}^n \\frac{f^{(i)}(0)}{i!} x^i\")\n        self.play(Transform(function, taylor))\n        self.wait(2)\n        \n        # Explaining the zeroth approximation\n        zeroth_approx = MathTex(r\"P_0(x) = 1\")\n        self.play(Write(zeroth_approx))\n        self.wait(1)\n        \n        # Show the first approximation\n        first_approx = MathTex(r\"P_1(x) = 1 + x\")\n        self.play(ReplacementTransform(zeroth_approx, first_approx))\n        self.wait(1)\n        \n        # Show the second approximation\n        second_approx = MathTex(r\"P_2(x) = 1 + x + \\frac{x^2}{2!}\")\n        self.play(ReplacementTransform(first_approx, second_approx))\n        self.wait(1)\n        \n        # Converging explanation\n        explanation = Text(\"As n approaches infinity, \\nP_n(x) converges to f(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n        \n        # Show the function again\n        final_function = MathTex(r\"f(x) = e^x\")\n        self.play(ReplacementTransform(second_approx, final_function), FadeOut(explanation))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that introduces the concept of Fourier series by visually demonstrating it using a square wave signal, and then showing how its Fourier series expansion is calculated as well as what the partial sum of the series looks like, with all steps accompanied by clear and concise text explanations?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and the area problem\n        axes = Axes(x_range=[0, 5], y_range=[0, 4], axis_config={\"color\": BLUE})\n        func_graph = axes.plot(lambda x: 0.1 * x ** 2, color=GREEN)\n        area = axes.get_area(func_graph, x_range=[0.3, 4.5], color=(RED, GREEN), opacity=0.5)\n        self.play(Create(axes), Create(func_graph), FadeIn(area))\n        self.wait(2)\n\n        # Annotating the boundaries of the integral\n        x_labels = [\n            axes.get_x_axis_label(MathTex(f\"{x_label}\")).rotate(90 * DEGREES)\n            for x_label in (0.3, 4.5)\n        ]\n        self.play(*[Write(label) for label in x_labels])\n        self.wait(1)\n\n        # Display the integral representation\n        integral_text = MathTex(r\"\\int_{0.3}^{4.5}\", r\"0.1x^2\", r\"dx\").next_to(area, UP)\n        self.play(Write(integral_text))\n        self.wait(2)\n\n        # Calculate and show the exact value of the integral\n        exact_value = MathTex(\"= \\\\left. \\\\frac{0.1}{3} x^3 \\\\right|_{0.3}^{4.5}\")\n        self.play(Transform(integral_text, exact_value))\n        self.wait(2)\n\n        # Show the result of the definite integral\n        result = MathTex(\"= \\\\frac{0.1}{3} (4.5^3 - 0.3^3)\").next_to(exact_value, DOWN)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear the scene and show the definite area\n        self.play(FadeOut(axes), FadeOut(func_graph), FadeOut(integral_text))\n        self.play(FadeIn(area), Write(result))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that introduces the concept of Fourier series, demonstrates the general formula for Fourier series, explains how it can represent periodic functions, gives a specific example of a Fourier series, and shows a graph of a simple function along with an explanation of applying Fourier series to a square wave function?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 4, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create Graph\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n\n        # Show area under curve\n        area = axes.get_area(graph, x_range=[0, 2])\n\n        curve_label = axes.get_graph_label(graph, label='y=x^2')\n\n        # Displaying the problem\n        problem = MathTex(r\"Area\\ under\\ y=x^2\\ from\\ x=0\\ to\\ x=2\")\n        problem.to_edge(UP)\n\n        self.play(Write(problem))\n        self.wait(1)\n        self.play(Create(axes), Create(graph))\n        self.play(FadeIn(area), Write(curve_label))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"Area is 8/3\", font_size=30).to_edge(DOWN)\n\n        self.play(ReplacementTransform(problem, conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like an educational animation that introduces viewers to the concept of exponential functions by graphing them using Manim. Start with a title that says \"Exponential Function Graph\" at the top. First, display a set of axes suitable for exponential growth with a range for x from -3 to 3 and y from -1 to 8. The axes should be in blue. Then plot the function e^x on these axes in green and label the curve accordingly. After showing the graph for a bit, introduce a second exponential function, 2^x. Replace the first graph with this new one, drawing the new function in red and moving the label up for better visibility. Finally, I would like the initial e^x graph to come back on screen alongside the 2^x graph for comparison. Both graphs should be labeled clearly, and after some time, the animation should end. Can you create an animation that follows these guidelines?",
        "answer": "\\n from manim import *\n\nclass SurfaceAreaExample(Scene):\n    def construct(self):\n        # Function to integrate\n        function_tex = MathTex(r\"f(x, y) = \\sqrt{1 - x^2 - y^2}\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explain the problem\n        problem_statement = Text(\"Find the surface area of the upper hemisphere of a unit sphere\", font_size=24).to_corner(UL)\n        self.add(problem_statement)\n        self.wait(2)\n\n        # Surface area integral in spherical coordinates\n        integral_tex = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{\\pi/2} \\sin(\\phi) d\\phi d\\theta\")\n        self.play(Transform(function_tex, integral_tex))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation_setup = Text(\"Setup the integral using spherical coordinates\", font_size=24).next_to(problem_statement, DOWN, buff=0.5)\n        self.play(Write(explanation_setup))\n        self.wait(2)\n\n        # Evaluate the phi integral\n        phi_integral = MathTex(r\"= \\int_{0}^{2\\pi} [-\\cos(\\phi)]_{0}^{\\pi/2} d\\theta\")\n        self.play(ReplacementTransform(integral_tex, phi_integral))\n        self.wait(1)\n\n        # Explanation for phi integral\n        explanation_phi = Text(\"Integrate with respect to phi\", font_size=24).next_to(explanation_setup, DOWN, buff=0.5)\n        self.play(Write(explanation_phi))\n        self.wait(2)\n\n        # Evaluated phi integral\n        evaluated_phi = MathTex(r\"= \\int_{0}^{2\\pi} 1 d\\theta\")\n        self.play(ReplacementTransform(phi_integral, evaluated_phi))\n        self.wait(1)\n\n        # Explanation for theta integral\n        explanation_theta = Text(\"Finally, integrate with respect to theta\", font_size=24).next_to(explanation_phi, DOWN, buff=0.5)\n        self.play(Write(explanation_theta))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [2\\pi \\theta]_{0}^{2\\pi} = 4\\pi\")\n        self.play(ReplacementTransform(evaluated_phi, final_solution))\n        self.wait(1)\n\n        # Display final result\n        final_result = Text(\"Surface area of the hemisphere is \\(4\\pi\\)\", font_size=24).next_to(explanation_theta, DOWN, buff=0.5)\n        self.play(Write(final_result))\n        self.wait(3)\n\n        # Conclusion of the scene\n        self.play(FadeOut(function_tex), FadeOut(problem_statement), FadeOut(explanation_setup), FadeOut(explanation_phi), FadeOut(explanation_theta), FadeOut(final_solution), FadeOut(final_result))"
    },
    {
        "query": "Can you create an educational animation using a math tool that shows a step-by-step process of factoring and finding the roots of the cubic polynomial equation x^3 - 3x^2 + 3x - 1, followed by a graphical representation of the function (x - 1)^3 on a set of straightforward axes, concluding with a message that indicates the end of the demonstration?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the definite integration\n        explanation1 = Text(\"Using the power rule and evaluating limits:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{2+1}}{2+1}\\Big|_0^1\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the limits\n        explanation2 = Text(\"Evaluate from 0 to 1\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution after evaluating limits\n        final_solution = MathTex(r\"= \\frac{1^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= \\frac{1}{3}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the simplified solution\n        self.play(Write(simplified_solution))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that starts by displaying the standard wave equation for a field u on the screen. After showing the equation, I'd like a brief text explanation to appear that says \"This is the standard wave equation for a field u.\" Once that's done, please add another piece of text near the equation that points out that the variable c represents the speed of wave propagation. Next, replace the initial explanation with a new one saying \"Solutions typically involve sinusoidal functions,\" and subsequently transition the scene to show a specific example of a solution to the wave equation using cosine. Accompany this particular solution with an explanation that details the meaning of the symbols A for amplitude, k for wavenumber, and \u03c9 for angular frequency. Finally, clear the screen and end the animation with the message \"End of demonstration!\" at the top.",
        "answer": "\\n from manim import *\n\nclass ExponentialFunctionScene(Scene):\n    def construct(self):\n        # Display the function's formula\n        formula = MathTex(r\"f(x) = e^{x}\")\n        self.play(Write(formula))\n        self.wait(1)\n\n        # Show the graph title\n        graph_title = Text(\"Plotting the exponential function\", font_size=24).to_edge(UP)\n        self.play(Write(graph_title))\n        self.wait(2)\n\n        # Draw the graph\n        graph = self.get_graph()\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Show the derivative's formula\n        derivative = MathTex(r\"f'(x) = e^{x}\")\n        self.play(Write(derivative))\n        self.wait(1)\n\n        # Explanation for the derivative\n        explanation = Text(\"Derivative of the exponential function\", font_size=24).to_edge(UP)\n        self.play(Transform(graph_title, explanation))\n        self.wait(2)\n\n        # Clear the scene and display the derivative\n        self.clear()\n        self.wait(1)\n        self.play(Write(derivative))\n        self.wait(1)\n\n    def get_graph(self):\n        graph = FunctionGraph(\n            lambda x: np.exp(x),\n            color=BLUE,\n            x_range=[-3, 3],\n        )\n        return graph"
    },
    {
        "query": "Can you create an animated video that explains how to calculate the area under the curve y = x^2 from x = 0 to x = 3, using the concept of integration, and visually shows the actual area under the curve, the integration process with steps, evaluation at the bounds, and conclude by highlighting that the definite integral represents the total area under the curve?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display the Fourier Series definition\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Explanation of Fourier Series\n        explanation1 = Text(\"Fourier Series expands functions in terms of sines and cosines.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Explanation for coefficients\n        explanation2 = Text(\"Coefficients are found using integrals of the function times the sines and cosines.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Display the formula for coefficients\n        coefficients = MathTex(r\"a_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x) \\cos(nx)dx\", r\",\\ \\ b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x) \\sin(nx)dx\")\n        self.play(ReplacementTransform(fourier_series, coefficients))\n        self.wait(1)\n\n        # Explaining convergence\n        explanation3 = Text(\"Fourier Series converge to the function under certain conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and show a graph\n        self.clear()\n        func_graph = self.get_graph(lambda x: np.sin(x))\n        self.play(ShowCreation(func_graph))\n        self.wait(1)\n\n        # Wrap up the scene\n        self.play(FadeOut(func_graph))\n        self.wait(1)\n\n    def get_graph(self, function):\n        return FunctionGraph(function, color=WHITE, x_range=[-PI, PI])"
    },
    {
        "query": "Create an animated video that explains the mathematics behind a harmonic oscillator. Start by presenting the basic differential equation that defines it. Then show clearly what this equation represents. After that, transition to the characteristic equation derived from the original equation, and display it. Next, demonstrate the process of solving the characteristic equation and display the roots. Finally, introduce the general solution to the harmonic motion that is based on the roots obtained, and conclude by showcasing just this final equation on a clean screen. Make sure that each step is introduced with a title or text that briefly describes it, and allow a brief pause after each part of the explanation for the information to be absorbed.",
        "answer": "\\n from manim import *\n\nclass ComplexPathAnimation(Scene):\n    def construct(self):\n        # Create a hexagon shape path using the Polygon class\n        hexagon_points = [UP, UR, DR, DOWN, DL, UL]\n        hexagon = Polygon(*hexagon_points, color=BLUE).scale(2)\n        self.play(ShowCreation(hexagon))\n\n        # Create an electron mobject\n        e = electron()\n\n        # Animate the electron follow the hexagon path\n        animations = move_along_complex_path(e, [5], hexagon_points, run_time=6)\n        self.play(AnimationGroup(*animations), run_time=6)\n\n        # Fade out all mobjects\n        self.play(*[FadeOut(mob) for mob in self.mobjects])"
    },
    {
        "query": "I would like to create an educational animation that visually explores a cubic function and its derivative. The animation should start by displaying the equation of the cubic function, and then proceed to the graph itself, showing it in a distinct color. After the graph is drawn, I would like to include a label near it to indicate that it is the graph of our function. \n\nNext, the animation should introduce the concept of critical points where the first derivative of the function equals zero, and I want a brief textual explanation about these critical points to appear on the screen as well. Following this explanation, I'm interested in seeing the actual derivative of the cubic function replace the original function on the screen.\n\nFurthermore, I would like to see the critical points of the function marked clearly on the graph. Once the points are marked, the animation should graph the derivative function, ideally in a different color to distinguish it from the original cubic function's graph. \n\nLastly, to finalize the presentation, the entire scene should be cleared, and a concluding text that encapsulates the essence of the animation\u2014\"Visualizing a Cubic Function and its Derivative\"\u2014should appear to conclude the animation. Can this be achieved such that it's clear, understandable, and visually engaging for students learning about calculus?",
        "answer": "\\n from manim import *\n\nclass IntegrationBySubstitution(Scene):\n    def construct(self):\n        integral = MathTex(\"\\\\int x\\\\cos(x^2)dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Step 1: Substitution\n        step1 = Tex(\"Let $u = x^2$, then $du = 2xdx$\")\n        self.play(Write(step1))\n        self.wait(2)\n\n        step2 = Tex(\"The integral becomes $\\\\frac{1}{2}\\\\int \\\\cos(u)du$\")\n        self.play(Write(step2))\n        self.wait(2)\n\n        # Step 2: Solving the new integral\n        step3 = Tex(\"Integrate to get $\\\\frac{1}{2}\\\\sin(u) + C$\")\n        self.play(Write(step3))\n        self.wait(2)\n\n        # Step 3: Back Substitution\n        final_step = MathTex(\"\\\\frac{1}{2}\\\\sin(x^2) + C\")\n        self.play(ReplacementTransform(step3, final_step))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that illustrates the concept of finding the area under a curve? In the animation, please show a graph of a quadratic function, let's say f(x) = 0.1(x - 3)^2 + 1, and highlight the region between x=1 and x=5 to represent the area under the curve between those points. Then, can you display the bounds of the integral for the area as text on the screen, followed by the integral expression? After that, replace it with the approximate numerical result of the integral. Once the calculation is shown, clear everything and display the final result again for emphasis.",
        "answer": "\\n from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iint_S (x^2+y^2) \\, dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"Parameterize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization step\n        parameterization = MathTex(r\"S(r, \\theta) = (r\\cos\\theta, r\\sin\\theta, h(r))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(1)\n\n        # Explanation for the calculation of dS\n        explanation2 = Text(\"Calculate differential area element dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Differential area step\n        differential_area = MathTex(r\"dS = |S_r \\times S_\\theta| \\, drd\\theta\")\n        self.play(ReplacementTransform(parameterization, differential_area))\n        self.wait(1)\n\n        # Explanation for setting limits of integration\n        explanation3 = Text(\"Set limits of integration for r and \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Limits of integration step\n        limits_of_integration = MathTex(r\"\\int_0^R \\int_0^{2\\pi} (r^2) |S_r \\times S_\\theta| \\,drd\\theta\")\n        self.play(ReplacementTransform(differential_area, limits_of_integration))\n        self.wait(1)\n\n        # Explanation for final evaluation\n        explanation4 = Text(\"Evaluate the integrals\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_0^R \\int_0^{2\\pi} r^3 \\,drd\\theta\")\n        self.play(ReplacementTransform(limits_of_integration, final_solution))\n        self.wait(1)"
    },
    {
        "query": "Please create an educational animation that starts by showing the one-dimensional wave equation on the screen, then brings in text from above that explains it describes wave propagation. After that, replace the text with another sentence indicating a specific solution to the equation being a sine wave function. Then transform the wave equation on screen into an expression of this sine wave solution, listing out and labeling its parameters such as amplitude, wavenumber, frequency, and phase offset. Finish the animation by replacing all elements on screen with a simplified version of the sine wave solution that does not include the phase offset. Make sure each step is clear and give me a moment to comprehend each part before moving on to the next.",
        "answer": "\\n from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create a grid of electrons\n        electrons = VGroup(*[electron().move_to(2*RIGHT*i+2*UP*j) for i in range(-2,3) for j in range(-2,3)])\n        \n        # Animate electrons entering the screen and create oxygen at the center\n        self.play(LaggedStart(*[FadeInFromPoint(elec, ORIGIN) for elec in electrons], lag_ratio=0.1))\n        central_oxygen = oxygen().move_to(ORIGIN)\n        self.wait(1)\n        \n        # Transform one electron into an oxygen and move others outwards\n        self.play(\n            ReplacementTransform(electrons[12], central_oxygen),\n            *[elec.animate.move_to(3 * elec.get_center()) for elec in electrons if elec is not electrons[12]],\n        )\n        self.wait(1)\n        \n        # Create a lithium ion grid and move it in\n        li_grid = lithium_grid(3, 3).next_to(central_oxygen, UP, buff=1)\n        self.play(FadeIn(li_grid), run_time=2)\n        self.wait(1)\n\n        # Animate lithium ions moving in a complex path\n        complex_path = [\n            ORIGIN, 2*LEFT, 2*LEFT + 3*DOWN, 4*RIGHT + 3*DOWN, 4*RIGHT, 2*UP + 4*RIGHT\n        ]\n        lithium_animations = move_along_complex_path(li_grid, [1,3], complex_path, 2)\n        self.play(AnimationGroup(*lithium_animations))\n        self.wait(2)"
    },
    {
        "query": "I would like a step-by-step animation that explains how to calculate the definite integral of x cubed from 1 to 3. Start by showing the integral problem, then explain and show the power rule for integration, followed by applying the power rule to our problem. Next, show how to evaluate the result using the boundaries of 1 and 3. Finally, present the final numerical answer of the integral, and then display it prominently on the screen by itself.",
        "answer": "\\n from manim import *\n\nconfig.frame_size = (1080, 1920)\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_BLUE_COLOR = \"#16b0b5\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nORANGE_COLOR = \"#fc5922\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nDARK_PURPLE_COLOR = \"#5157b9\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef DivisionOperation(path, expression_text):\n    image = ImageMobject(path)\n    expression = Tex(expression_text, color=BLACK)\n    expression.scale(1.5)\n    group = Group(image, expression)\n    group.arrange(RIGHT, buff=0.25)\n\n    return group\n\nclass GeometryFive(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        operation_1 = DivisionOperation(\"./assets/Asset 5.png\", \"\\\\div 3 = 15\")\n        operation_2 = Tex(r\"\\textbf{b} \\div 3 = 15\", color=BLACK)\n        operation_2[0][0].set(color=LIGHT_GREEN_COLOR)\n        operation_2.scale(1.5)\n        operation_3 = Tex(r\"\\textbf{45} \\div 3 = 15\", color=BLACK)\n        operation_3[0][0].set(color=LIGHT_GREEN_COLOR)\n        operation_3.scale(1.5)\n        conclusion_1 = DivisionOperation(\"./assets/Asset 5.png\", \"= 45\")\n        conclusion_2 = Tex(r\"\\textbf{b} = 45\", color=BLACK)\n        conclusion_2[0][0].set(color=LIGHT_GREEN_COLOR)\n        conclusion_1.scale(0.8)\n        conclusion_2.scale(1.5)\n        Group(\n            operation_1,\n            operation_2,\n            operation_3,\n            Group(conclusion_1, conclusion_2).arrange(RIGHT, buff=0.5)\n        ).arrange(DOWN, buff=0.7)\n\n        self.play(operation_1.shift(9 * RIGHT).animate.shift(9 * LEFT), run_time=0.5)\n        self.wait(1)\n        self.play(Transform(operation_1[1].copy(), operation_2))\n        self.wait(1)\n        self.play(Transform(operation_2.copy(), operation_3))\n        self.wait(1)\n        self.play(\n            FadeIn(conclusion_1, target_position=ORIGIN),\n            FadeIn(conclusion_2, target_position=ORIGIN)\n        )\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "I want to create an educational animation that explains the process of evaluating a surface integral of a function over a specific surface. Start with displaying the integral of the function x^2 + y^2 over the surface S. Then, guide through the steps of using the parametrization of surface S in terms of r and theta, which are polar coordinates. After that, show how to convert the surface integral into polar coordinates and proceed to evaluate the integral step by step until reaching the final solution. Each step should be accompanied by a brief pause for clarity and with written textual explanations to help viewers follow along. The surface S should be defined with r ranging from 0 to 1 and theta ranging from 0 to 2pi. Conclude the animation with the final value of the surface integral.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Write down the function and the area to compute\n        function = MathTex(r\"f(x) = e^{-x^2}\")\n        area_text = MathTex(r\"\\int_{-2}^{2} e^{-x^2} dx\")\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Transform(function, area_text))\n        self.wait(2)\n\n        # Plot the function\n        graph = FunctionGraph(lambda x: np.exp(-x**2), x_range=[-2, 2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Shade the area under the curve\n        area = graph.get_area(x_range=[-2, 2], color=BLUE, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Show the area value (assuming it was calculated before)\n        area_value = MathTex(r\"Area \\approx 1.764\")\n        area_value.to_edge(DOWN)\n        self.play(Write(area_value))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(graph), FadeOut(area), FadeOut(area_text), FadeOut(area_value))\n        self.wait(1)\n        \n        # Final message\n        message = Text(\"The shaded region represents the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(message))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that starts by displaying a 2x2 matrix A with entries [[2, 1], [1, 3]] on the screen. Then, after showing the matrix, I want to add text above it that says \"Visualize a linear transformation\" to explain the purpose of the animation. Next, please create a grid representing the 2D plane and place a yellow arrow labeled with \"v\" on it, representing a vector from the origin to the point (1, 2). After setting up the grid and vector, I want to animate the effect of applying the matrix A to the plane and the vector \"v\", showing how both the grid and the vector are transformed according to the matrix. The transformed vector should be labeled with \"Av\". To finish the animation, clear everything off the screen, and then redraw the same matrix A to reinforce what was presented. The animation should have pauses and play at a speed that allows the viewers to follow along easily.",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_0^{\\pi} \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Setting up the integral computation\n        integral_step = MathTex(r\"= [-\\cos(x)]_0^{\\pi}\")\n        self.play(ReplacementTransform(problem, integral_step))\n        self.wait(2)\n\n        # Explanation for evaluating the antiderivative\n        explanation = Text(\"Evaluate the antiderivative at the bounds\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [-\\cos(\\pi) - (-\\cos(0))]\")\n        self.play(Transform(integral_step, final_solution))\n        self.wait(1)\n\n        solution_simplified = MathTex(r\"= [1 - (-1)]\")\n        self.play(Transform(final_solution, solution_simplified))\n        self.wait(1)\n\n        solution_result = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(solution_simplified, solution_result))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_result))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates the concept of integrating the function y = x^2 from 0 to 2, including the representation of the area under the curve, the integrand written as a mathematical problem, the steps to solve the integration, and the final solution, while also adding a clean transition at the end that fades out the graph and only leaves the final answer on the screen?",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        explanation1 = Text(\"Let u = 2x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        u_substitution = MathTex(r\"\\frac{1}{2}\\int e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), u_substitution))\n        self.wait(1)\n\n        explanation2 = Text(\"Integrate with respect to u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(u_substitution, final_solution))\n        self.wait(1)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like an animated video that explains the process of integrating \\(\\sin(x)\\) from \\(0\\) to \\(\\pi\\), including the use of trigonometric identities and the evaluation of the definite integral, with the final answer displayed at the end. Can you create an animation that writes out the problem, provides a brief written explanation of the steps involved in solving it, shows the integration step where the trigonometric identity is used, and then evaluates the definite integral with the final solution appearing at the end? Please also make sure there is enough time for viewers to follow along with each step before moving on to the next.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and the area problem\n        function = MathTex(r\"f(x) = x^2\")\n        area_question = MathTex(r\"\\int_0^2 x^2 \\,dx\", color=YELLOW)\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Write(area_question))\n        self.wait(1)\n\n        # Drawing the graph\n        graph = FunctionGraph(lambda x: x**2, x_range=[0, 2], color=WHITE)\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Filling the area under the graph\n        area = graph.get_riemann_rectangles(x_range=[0, 2], dx=0.1)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Explanation of Area Computation\n        explanation1 = Text(\"The area under curve is the integral result\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Computing the area\n        area_computation = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\")\n        self.play(Write(area_computation))\n        self.wait(2)\n\n        # Showing the final result\n        final_result = MathTex(r\"= \\left[\\frac{2^3}{3}\\right] - \\left[\\frac{0^3}{3}\\right]\")\n        self.play(Transform(area_computation, final_result))\n        self.wait(1)\n\n        # Simplifying the result\n        simplified_result = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(area_computation, simplified_result))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(graph), FadeOut(area), FadeOut(function), FadeOut(area_question), FadeOut(explanation1))\n        self.wait(1)\n        self.play(Write(simplified_result))\n        self.wait(1)"
    },
    {
        "query": "I want to create an educational animation that visually explains the process of solving a triple integral step by step. The integral I want to showcase is the integration of the function xyz over the unit cube, with the bounds of integration from 0 to 1 for all variables x, y, and z. It should start with displaying the integral problem on the screen, and then in three separate steps, show how to integrate with respect to x, y, and then z. Accompany each step with a brief text explanation of which variable we're integrating with respect to at that moment. After each integration step, show the updated integral result. At the end, the animation should display the final numerical result of this triple integral, and then the screen should clear before showing the final answer again for emphasis. Can an animation be made for this purpose?",
        "answer": "\\n from manim import *\n\nclass BouncingBall(Scene):\n    def construct(self):\n        # Create a circle to represent the ball\n        ball = Circle(radius=0.5, fill_color=BLUE, fill_opacity=0.5)\n        ball.set_stroke(BLUE)\n\n        # Define the ground line\n        ground = Line(LEFT*5, RIGHT*5)\n\n        # Initial position of the ball\n        ball.move_to(UP*2)\n\n        # Animation of the ball bouncing\n        self.play(FadeIn(ball))\n        self.play(FadeIn(ground))\n        self.wait(1)\n\n        # Bouncing motion\n        bounce_path = PathArc(arc_angle=-PI/2)\n        for _ in range(5):\n            self.play(MoveAlongPath(ball, bounce_path), rate_func=there_and_back, run_time=0.5)\n            bounce_path = bounce_path.copy().scale(0.5)\n\n        # Finish the scene\n        self.play(FadeOut(ball), FadeOut(ground))\n        self.wait(1)"
    },
    {
        "query": "I want to create an educational math animation where we visually demonstrate calculating the area under a curve. The animation should start by drawing a set of axes from 0 to 4 on the x-axis and 0 to 8 on the y-axis, and the axes should be in blue color. Then, I need to plot a white curve representing the function x squared on these axes. Can you also label the curve with its equation 'x^2'? Afterward, I'd like to highlight the area under the curve between x = 0 and x = 2. The highlighted area should gently transition from blue to green and be semi-transparent. Please ensure our animation includes pauses to give viewers time to understand each step: first show the axes with the label, then the curve, and finally the area under the curve with a smooth fade-in effect. Can you create such an animation for me?",
        "answer": "\\n from manim import *\n\n# Define colors used in the animation\nBACKGROUND_COLOR = \"#1e1e1e\"\nTEXT_COLOR = \"#ffffff\"\nHIGHLIGHT_COLOR = \"#ff6666\"\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass PrimeNumberScene(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        # Create a title text\n        title = Text(\"Prime Numbers\", color=TEXT_COLOR).scale(1.5)\n\n        # Create a list of prime numbers\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        primes_text = VGroup(\n            *[Text(str(prime), color=HIGHLIGHT_COLOR).scale(0.7) for prime in primes]\n        ).arrange_in_grid(cols=5, buff=0.8).next_to(title, DOWN)\n\n        # Display the title and then the prime numbers\n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(AnimationGroup(*[FadeIn(number) for number in primes_text], lag_ratio=0.1))\n        self.wait(2)\n        \n        # Emphasize each prime number sequentially\n        for number in primes_text:\n            self.play(number.animate.set_color(HIGHLIGHT_COLOR))\n            self.wait(0.4)\n        \n        # Fade out the entire scene\n        self.play(FadeOut(VGroup(title, primes_text)))\n        self.wait(0.5)"
    },
    {
        "query": "I want to create an educational video that illustrates the steps of calculating a triple integral, specifically the integral of 'xyz' over a specific range for each variable. Can you animate the problem statement and demonstrate the integration process step by step, beginning with z, then y, and finally x? Each step of the integration should be explained with text at the top of the screen and show the updated integral below. Once we find the final numeric answer, can you clear the screen and then just show the final answer for a moment?",
        "answer": "\\n from manim import *\n\nclass AnimatedScene(Scene):\n    def construct(self):\n        # Generate grid of metals and oxygen\n        metal_oxides_grid = metal_oxid(5, 5)\n        self.add(metal_oxides_grid)\n\n        # Create carbon grids at the top of the screen\n        carbon_grids = carbon_grid(3)\n        carbon_grids.to_edge(UP, buff=0.5)\n        self.add(carbon_grids)\n\n        # Create a lithium ion and electron\n        li_ion = lithium_ion().shift(DOWN * 2 + LEFT * 3)\n        e_particle = electron().next_to(li_ion, RIGHT, buff=0.5)\n\n        # Move lithium ion and electron across the screen\n        path_points = [li_ion.get_center(), *[RIGHT * x for x in range(7)], li_ion.get_center() + DOWN * 3]\n        move_animations = move_along_complex_path(li_ion, [2, 4], path_points, run_time=3)\n\n        # Move electron along a mirrored path\n        e_path_points = [e_particle.get_center(), *[RIGHT * x + DOWN * 0.1 for x in range(7)], e_particle.get_center() + DOWN * 3 - RIGHT * 6]\n        move_e_animations = move_along_complex_path(e_particle, [2, 4], e_path_points, run_time=3, rate_func=there_and_back_with_pause)\n\n        # Animate lithium ion and electron moving\n        self.play(AnimationGroup(*move_animations), AnimationGroup(*move_e_animations), lag_ratio=0.5)\n        self.wait(2)"
    },
    {
        "query": "I would like an animated video explaining the process of solving a basic definite integral using the power rule. The video should start by introducing the integral of x cubed from 0 to 2, then demonstrate step-by-step how to apply the power rule to find the indefinite integral. Please include on-screen text that states \"Apply the power rule of integration\" followed by the general formula for the power rule. Next, show how to substitute the specific function and limits into the formula, simplify the resulting expression, and evaluate the integral at the upper and lower bounds. Conclude with the numerical value of the definite integral and then clear the screen to end with showing just the final result. The presentation should be clear and paced with brief pauses to allow the viewer to follow along.",
        "answer": "\\n from manim import *\nfrom manim_physics import *\n\nclass BalancingBall(SpaceScene):\n    def construct(self):\n        # Create a rectangle to act as a seesaw\n        seesaw = Rectangle(height=0.2, width=4)\n        seesaw.set_color(BLUE)\n\n        # Create a circle to act as a ball\n        ball = Circle(radius=0.2)\n        ball.set_fill(RED, opacity=1)\n        ball.move_to(3 * RIGHT)\n\n        # Create a small rectangle to act as the fulcrum of the seesaw\n        fulcrum = Rectangle(height=0.1, width=0.2)\n        fulcrum.set_color(GREEN)\n        fulcrum.next_to(seesaw, DOWN, buff=0)\n\n        # Add all the objects to the scene\n        self.add(seesaw, ball, fulcrum)\n\n        # Make the seesaw a static body so it can rotate around the fulcrum\n        self.make_static_body(seesaw, bounce=0.5, friction=1.0, angle_of_restitution=0.5)\n        # Pin the seesaw to the fulcrum\n        self.pin(seesaw, fulcrum.get_center())\n\n        # Make the ball a rigid body so it is affected by gravity and can bounce\n        self.make_rigid_body(ball, bounce=0.8, friction=1.0)\n\n        # Play the animation\n        self.wait(5)\n        # during wait time, the ball would move and the seesaw would balance itself according to physics simulation"
    },
    {
        "query": "Can you create an educational animation that shows me how to calculate the definite integral of a quadratic function, specifically the integral of x squared from 1 to 2, with a step-by-step explanation including the power rule of integration and how to evaluate the integral at the given bounds?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Write\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Here is more text\")\n            self.play(Write(some_text))\n            self.play(Transform(text,Text(\"Unwrite\").shift(UP*2.5)), run_time=0.5)\n            self.play(Unwrite(some_text))\n            self.remove(some_text)"
    },
    {
        "query": "I would like to have an educational animation that visually explains the process of integrating the exponential function e raised to the power of 2x with respect to x. The animation should start by displaying the integral problem, and then it should have a text that encourages using the exponential rule. After this, the integral should be solved using the exponential rule, and the intermediate step should morph into the final solution. Finally, the solution should be shown on its own to emphasize the result. Can the animation also have appropriate pauses between each step to allow viewers to follow along?",
        "answer": "\\n         self.play(Transform(text,Text(\"AnimatedBoundary\").shift(UP*2.5)), run_time=0.5)\n        circle = Circle()\n        animated_boundary = AnimatedBoundary(circle, cycle_rate=3, colors=[RED, GREEN, BLUE])\n        self.add(circle, animated_boundary)\n        self.wait(2)\n        self.remove(circle, animated_boundary)"
    },
    {
        "query": "I would like to create an educational animation that explains the concept of an infinite geometric series. Can you produce a video that starts by displaying the general formula for an infinite geometric series, then presents text explaining using the sum formula for an infinite geometric series, followed by showing the actual sum formula with the condition for convergence? After that, can the animation provide an example calculation of such a series with the first term being 1 and the common ratio being 1/2, and conclude by showing the result of this specific example calculation on the screen?",
        "answer": "\\n from manim import *\n\nclass TrigonometricSubstitutionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sqrt{1-x^2} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for trigonometric substitution\n        explanation1 = Text(\"Use trigonometric substitution:\", font_size=24).to_edge(UP)\n        substitution_explanation = MathTex(r\"x = \\sin(\\theta), \\, dx = \\cos(\\theta)d\\theta\")\n        self.play(Write(explanation1))\n        self.play(Write(substitution_explanation))\n        self.wait(2)\n\n        # Substituting the values\n        substitution_step = MathTex(r\"= \\int \\sqrt{1-\\sin^2(\\theta)} \\cos(\\theta)d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), substitution_step))\n        self.wait(2)\n\n        # Simplifying the integral\n        simplified_integral = MathTex(r\"= \\int \\cos^2(\\theta)d\\theta\")\n        self.play(ReplacementTransform(substitution_step, simplified_integral))\n        self.wait(2)\n\n        # Explanation for further steps\n        explanation2 = Text(\"Now integrate using a trigonometric identity\", font_size=24)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Writing the trigonometric identity\n        trig_identity = MathTex(r\"\\cos^2(\\theta) = \\frac{1+\\cos(2\\theta)}{2}\")\n        self.play(Write(trig_identity))\n        self.wait(2)\n\n        # Applying the identity\n        with_identity = MathTex(r\"= \\frac{1}{2} \\int (1+\\cos(2\\theta))d\\theta\")\n        self.play(ReplacementTransform(simplified_integral, with_identity))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} (\\theta + \\frac{1}{2}\\sin(2\\theta)) + C\")\n        self.play(ReplacementTransform(with_identity, final_solution))\n        self.wait(1)\n\n        # Convert back to x\n        back_to_x = MathTex(r\"= \\frac{1}{2} (\\arcsin(x) + \\frac{x\\sqrt{1-x^2}}{2}) + C\")\n        self.play(ReplacementTransform(final_solution, back_to_x))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(back_to_x))\n        self.wait(1)"
    },
    {
        "query": "I need an animation that helps visualize the double integration process. Can you create a step-by-step animation that shows the calculation of the double integral of 'xy' over the region bounded by the x-axis, the line x=1, and the circle x^2+y^2=1? The animation should start by displaying the double integral, proceed by integrating with respect to y first, substituting the limits, and then integrate with respect to x. Also, include explanatory text that guides through the process of first integrating with respect to y and then with respect to x. Finally, display the evaluation of the outer integral to show the final numerical result.",
        "answer": "\\n from manim import *\n\nclass AnimatedScene(Scene):\n    def construct(self):\n        # Create a grid of lithium ions\n        lithium_ions = self.lithium_grid(5, 5)\n        \n        # Create an electron object\n        electron_obj = electron()\n        \n        # Define path points for electron movement\n        path_points = [UP * 2, UP + RIGHT * 2, DOWN * 2, DOWN + LEFT * 2, UP * 2]\n        \n        # Create animations for electron moving along complex path\n        electron_animations = move_along_complex_path(\n            electron_obj, stop_indices=[1, 3], points=path_points, run_time=3\n        )\n\n        # Add lithium ions to the scene\n        self.add(lithium_ions)\n        # Add electron to the scene\n        self.add(electron_obj)\n        # Play electron animations\n        self.play(*electron_animations)\n        # Hold the final frame\n        self.wait()\n\n    def lithium_grid(self, rows, cols) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                list.append(self.lithium_ion().set_x(j).set_y(i))\n        return VGroup(*list).set_x(0).set_y(0)\n\n    def lithium_ion(self) -> Mobject:\n        return circle_with_text(0.285, \"Li$^+$\", RED_D, 25, WHITE, 1)\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                path = Line(points[i], points[i + 1])\n                animations.append(MoveAlongPath(obj, path, run_time=run_time / len(points), rate_func=rate_func))\n        return animations\n\n    def circle_with_text(\n        self, r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n    ) -> Mobject:\n        c = Circle(r, color=color, fill_opacity=1).set_fill(color=fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the concept of finding the area under the curve for the function f(x) = x^2, from x=0 to x=2. This should include a coordinate system with labeled axes, the graph of the function, and a shaded region under the curve that represents the area we're interested in. Additionally, I want to introduce the integral symbol and show the mathematical process of calculating the exact area using integration, and then replace the integral with the final numeric solution. Can you provide a step-by-step animation that can help students visually understand this mathematical concept?",
        "answer": "\\n from manim import *_x000D_\n_x000D_\nclass BallRollingDownInclinedPlane(Scene):_x000D_\n    def construct(self):_x000D_\n        # Create an inclined plane_x000D_\n        plane = Polygon(_x000D_\n            ORIGIN, 5*RIGHT + 2*UP, 6*RIGHT + 2*UP, 1*RIGHT, fill_opacity=0.5_x000D_\n        )_x000D_\n        plane.set_fill(BLUE_B)_x000D_\n        plane.set_stroke(width=0)_x000D_\n        _x000D_\n        # Create a ball at the top of the inclined plane_x000D_\n        ball = Circle(radius=0.2, color=RED_A).shift(5*RIGHT + 2.2*UP)_x000D_\n        _x000D_\n        # Create gravity_x000D_\n        gravity = 9.81 * DOWN_x000D_\n        _x000D_\n        # Add objects to the scene_x000D_\n        self.add(plane, ball)_x000D_\n        _x000D_\n        # Apply gravity to the ball_x000D_\n        ball_acceleration = always_redraw(_x000D_\n            lambda: ball.shift(gravity * self.time**2 / 2)_x000D_\n        )_x000D_\n        _x000D_\n        # Roll the ball down the plane_x000D_\n        self.play(_x000D_\n            ball_acceleration,_x000D_\n            rate_func=linear,_x000D_\n            run_time=2_x000D_\n        )_x000D_\n        _x000D_\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually explains how to use the p-test to determine the convergence of the series \u2211 1/n^2. Can you showcase the series, explain the p-test, apply the p-test to the series, conclude that the series converges based on the p-test, and finish with a clear statement confirming the series convergence?",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillator(Scene):\n    def construct(self):\n        # Displaying the equation of motion\n        motion_eq = MathTex(r\"m \\frac{d^2 x}{dt^2} + k x = 0\")\n        self.play(Write(motion_eq))\n        self.wait(1)\n\n        # Explanation for solving the ODE\n        explanation1 = Text(\"Harmonic Oscillator Equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Reformulated equation\n        reformulated_eq = MathTex(r\"\\frac{d^2 x}{dt^2} + \\frac{k}{m} x = 0\")\n        self.play(Transform(motion_eq, reformulated_eq))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation2 = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Characteristic equation\n        char_eq = MathTex(r\"r^2 + \\frac{k}{m} = 0\")\n        self.play(ReplacementTransform(reformulated_eq, char_eq))\n        self.wait(1)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = \\pm i\\sqrt{\\frac{k}{m}}\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution of motion\n        general_solution = MathTex(r\"x(t) = A \\cos\\left(\\sqrt{\\frac{k}{m}} t\\right) + B \\sin\\left(\\sqrt{\\frac{k}{m}} t\\right)\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation3 = Text(\"General solution for x(t)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"The harmonic oscillator's motion is sinusoidal.\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Create an animated video using a Python library that visually explains the steps to solve a double integral in polar coordinates, where the integral is from 0 to \u03c0 for \u03c6 (phi) and from 0 to 2 for \u03c1 (rho) of the function \u03c1^3 sin\u03c6. Display the mathematical problem on the screen, then show the process of integrating \u03c1 first while explaining that step through text on the screen, and simplify the resulting expression. Next, switch the explanation to integrate with respect to \u03c6, perform the integration, and show each simplification step. Finally, evaluate the definite integral, simplify the answer, and present the final numerical solution. Each step should be written out and transitions should be smooth to help viewers follow along with the calculation. Include pauses between each step to give viewers time to understand the information before moving on to the next part.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2\\nabla^2 u\")\n        self.play(FadeIn(wave_eq))\n        self.wait(1)\n\n        # Define c as the speed of light\n        speed_of_light = MathTex(r\"c\", r\" = 3 \\times 10^8 \\, \\text{m/s}\")\n        self.play(Write(speed_of_light))\n        self.wait(1)\n\n        # Move wave equation up and speed of light below it\n        self.play(wave_eq.animate.to_edge(UP))\n        speed_of_light.next_to(wave_eq, DOWN)\n        self.play(Write(speed_of_light))\n        self.wait(1)\n\n        # Display the general form of the solution\n        general_solution = Text(\"The general solution involves sine and cosine functions or exponentials with imaginary argument.\", font_size=24)\n        general_solution.to_edge(DOWN)\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Presenting an example solution\n        example_solution = MathTex(r\"u(x, t) = A\\cos(kx - \\omega t) + B\\sin(kx - \\omega t)\")\n        self.play(Transform(wave_eq, example_solution))\n        self.wait(1)\n\n        # Explanation propagation direction\n        propagation_direction = Text(\"The solution represents traveling waves in the x direction.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(general_solution, propagation_direction))\n        self.wait(1)\n\n        # Clear the scene and fade out\n        self.play(FadeOut(wave_eq), FadeOut(speed_of_light), FadeOut(general_solution))\n        self.wait(1)"
    },
    {
        "query": "Create an educational animation that shows how to calculate the area under a curve between two points using integration. Start by displaying the mathematical function being used, which is f(x) = 3 - (1/2)x^2. After introducing the function, draw its curve on a graph. Once the curve is drawn, indicate the specific section under the curve between x=1 and x=2 by shading it. Then, present the integral that calculates the area of the shaded section. Finally, display the worked-out solution to the integral and provide the exact numerical area of the shaded region. Make sure that between each step, there's a brief pause so that viewers can follow along easily.",
        "answer": "\\n from manim import *\n\nclass ChemicalBondingScene(Scene):\n    def construct(self):\n        # Create Oxygen and Hydrogen molecules\n        o2_molecule = self.create_o2_molecule()\n        h2_molecule_1 = self.create_h2_molecule().shift(LEFT * 3)\n        h2_molecule_2 = self.create_h2_molecule().shift(RIGHT * 3)\n\n        # Display O2 and two H2 molecules\n        self.play(FadeIn(o2_molecule), FadeIn(h2_molecule_1), FadeIn(h2_molecule_2))\n        self.wait(2)\n\n        # Move H2 molecules towards O2 and form H2O molecules\n        h2o_molecule_1, h2o_molecule_2 = self.create_h2o_molecules()\n        self.play(Transform(h2_molecule_1, h2o_molecule_1))\n        self.play(Transform(h2_molecule_2, h2o_molecule_2.shift(RIGHT * 3)))\n        self.wait(2)\n\n    def create_o2_molecule(self):\n        o_atom_1 = self.create_atom(\"O\", color=RED_E)\n        o_atom_2 = self.create_atom(\"O\", color=RED_E)\n        bond = Line(o_atom_1.get_right(), o_atom_2.get_left()).set_stroke(width=2)\n        o2_molecule = VGroup(o_atom_1, bond, o_atom_2).arrange(buff=0.2)\n        return o2_molecule\n\n    def create_h2_molecule(self):\n        h_atom_1 = self.create_atom(\"H\", color=BLUE)\n        h_atom_2 = self.create_atom(\"H\", color=BLUE)\n        bond = Line(h_atom_1.get_right(), h_atom_2.get_left()).set_stroke(width=2)\n        h2_molecule = VGroup(h_atom_1, bond, h_atom_2).arrange(buff=0.1)\n        return h2_molecule\n\n    def create_h2o_molecules(self):\n        h_atom_1 = self.create_atom(\"H\", color=BLUE)\n        o_atom = self.create_atom(\"O\", color=RED_E)\n        h_atom_2 = self.create_atom(\"H\", color=BLUE)\n        bond_1 = Line(h_atom_1.get_right(), o_atom.get_left()).set_stroke(width=2)\n        bond_2 = Line(h_atom_2.get_right(), o_atom.get_bottom()).set_stroke(width=2)\n        h2o_molecule_1 = VGroup(h_atom_1, bond_1, o_atom).arrange(buff=0.1)\n        h2o_molecule_2 = VGroup(o_atom, bond_2, h_atom_2).arrange(buff=0.1, aligned_edge=DOWN)\n        return h2o_molecule_1, h2o_molecule_2\n\n    def create_atom(self, text, color):\n        atom = Circle(radius=0.5, color=color, fill_opacity=1)\n        symbol = Tex(text, color=WHITE).scale(0.8)\n        return VGroup(atom, symbol)"
    },
    {
        "query": "Can you create an educational animation using Manim to explain the wave equation, showing the equation itself, describing it as a classic partial differential equation, discussing the general form of its solution as a function of both space and time, presenting the d'Alembert solution, explaining that the solutions consist of components moving in opposite directions, and finally mentioning that graphical representations can illustrate wave propagation, with all explanations appearing as text on the screen?",
        "answer": "\\n from manim import *\n\nclass SurfaceAreaParametricSurfaceExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(\n            r\"\\iint_D \\sqrt{1 + \\left(\\frac{\\partial z}{\\partial x}\\right)^2 + \\left(\\frac{\\partial z}{\\partial y}\\right)^2}\\,dA\"\n        )\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parametric representation\n        explanation1 = Text(\"Parametrize the surface with u and v\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parametric surface\n        parametric_surface = MathTex(\n            r\"x = f(u, v), \\quad y = g(u, v), \\quad z = h(u, v)\"\n        )\n        self.play(ReplacementTransform(problem, parametric_surface))\n        self.wait(1)\n\n        # Explanation for cross product\n        explanation2 = Text(\"Cross the partial derivatives of the position vector\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Cross product notation\n        cross_product = MathTex(\n            r\"\\|\\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v}\\|\"\n        )\n        self.play(ReplacementTransform(parametric_surface, cross_product))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation3 = Text(\"Set up the surface integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Setup integral\n        setup_integral = MathTex(\n            r\"\\iint_S \\|\\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v}\\|\\,dA\"\n        )\n        self.play(ReplacementTransform(cross_product, setup_integral))\n        self.wait(1)\n\n        # Explanation for the final step\n        explanation4 = Text(\"Compute the integral over the domain D\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(\n            r\"\\iint_D \\|\\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v}\\|\\,dA\"\n        )\n        self.play(ReplacementTransform(setup_integral, final_solution))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animated video using a math visualization tool that shows the process of calculating the area under the curve of the function 0.1x^2 - 1 from x = -3 to x = 3, including the graph of the function, the integral expression, and the step-by-step solution of the integral, ending with the numerical answer to the integral?",
        "answer": "\\n from manim import *\n\nclass ChemistryAnimation(Scene):\n    def construct(self):\n        # Create an electron Mobject\n        electron_particle = electron()\n        electron_particle.move_to(LEFT * 4)\n\n        # Create an oxygen Mobject\n        oxygen_molecule = oxygen()\n        oxygen_molecule.move_to(4 * RIGHT)\n\n        # Animate the electron moving towards the oxygen\n        self.play(MoveToTarget(electron_particle, target_position=oxygen_molecule.get_center(), run_time=3))\n\n        # Create a group of metal oxide molecules in a grid layout\n        metal_oxide_grid = metal_oxid(rows=3, cols=3)\n        metal_oxide_grid.move_to(DOWN * 2)\n\n        # Display oxygen molecule and metal oxide grid\n        self.play(FadeIn(oxygen_molecule), FadeIn(metal_oxide_grid))\n\n        # Move the metal oxide grid upwards while electron moves toward it\n        self.play(metal_oxide_grid.animate.move_to(UP * 2),\n                  MoveToTarget(electron_particle, target_position=metal_oxide_grid.get_center()))\n\n        # Finish the scene\n        self.wait(2)\n        self.play(FadeOut(oxygen_molecule), FadeOut(metal_oxide_grid), FadeOut(electron_particle))"
    },
    {
        "query": "I would like to create an educational animation that visually explains the concept of finding the area under a curve using integration. Specifically, could you illustrate how to calculate the area under the parabola described by the function y = x^2, between x = 0 and x = 2? I would like the animation to include the following elements:\n\n1. A set of Cartesian axes with a blue color scheme.\n2. The graph of the function y = x^2 plotted in green with the label 'x^2' near the curve.\n3. A shaded area under the curve between x = 0 and x = 2 to represent the definite integral, with a gray color and partial transparency.\n4. A title for the animation that reads \"Area under the curve y = x^2 from 0 to 2\".\n5. An animated sequence where:\n   - The axes and graph are drawn first.\n   - After a short pause, the title appears.\n   - Then the area under the curve gets shaded.\n   - Following another short pause, the mathematical representation of the integral from 0 to 2 of x^2 dx is displayed in the upper left corner.\n   - The evaluated integral value is shown step by step below the integral representation.\n6. Finally, after the calculation is complete, I want to clear the scene and have the final evaluated integral value appear at the top center of the screen.\n\nPlease ensure that each step is visually appealing and paced with pauses to allow viewers time to comprehend each part of the process. Can you create such an animation for me?",
        "answer": "\\n class Gather(Animation):\n    def __init__(self, mobject, dot_radius=0.05, dot_number=100, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.dot_radius = dot_radius\n        self.dot_number = dot_number\n        self.dots = VGroup(\n            *[Dot(radius=self.dot_radius).move_to(\n                self.mobject.get_center() + np.random.uniform(-1, 1, size=3))\n              for _ in range(self.dot_number)]\n        ).set_opacity(0)\n    \n    def begin(self):\n        self.mobject.set_opacity(0)\n        self.starting_mobject = self.mobject.copy()\n        self.starting_mobject.add(self.dots)\n        super().begin()\n\n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        scene.remove(self.dots)\n            \n    def interpolate_mobject(self, alpha):\n        alpha = self.rate_func(alpha)  # manually apply rate function\n        if alpha <= 0.5:\n            self.dots.set_opacity(alpha * 2)\n            for dot in self.dots:\n                dot.move_to(dot.get_center() + alpha*(self.mobject.get_center() - dot.get_center()))\n        else:\n            self.mobject.set_opacity((alpha - 0.5) * 2)\n            self.dots.set_opacity((1 - alpha) * 2)\n            for dot in self.dots:\n                dot.move_to(self.mobject.get_center())\n\nclass CustomAnimationGatherExample(Scene):\n    def construct(self):\n        circle = Circle(color=RED, fill_opacity=1).scale(3)\n        self.play(Gather(circle, dot_number=200, run_time=4))\n        self.wait()"
    },
    {
        "query": "I want an animated presentation of Euler's Formula and its transformation. Start the video by writing the phrase \"Euler's Formula:\" followed by the mathematical representation \"e^(ix) = cos(x) + isin(x)\" appearing just below it. Then, below the formula, can there be an arrow pointing downward to the expanded form of Euler's Formula, \"cos(x) = (e^(ix) + e^(-ix))/2\"? Afterward, I'd like all the elements on the screen to fade out and be replaced by the title \"Euler's Formula Transformation\" at the top of the screen in yellow. Finish up the animation by replacing the title with \"Euler's Identity\" and write out Euler\u2019s famous identity \"e^(i\u03c0) + 1 = 0\" below the title. Make sure each part of the animation is clear and give a brief pause between transitions so viewers can follow along.",
        "answer": "\\n from manim import *\n\nclass ParticleScene(Scene):\n    def construct(self):\n        proton = self.create_particle(\"p^+\", color=RED, size=0.2, label_size=24, label_color=WHITE)\n        neutron = self.create_particle(\"n^0\", color=BLUE, size=0.2, label_size=24, label_color=WHITE)\n        electron = self.create_particle(\"e^-\", color=YELLOW, size=0.1, label_size=18, label_color=BLACK)\n\n        self.play(FadeIn(proton))\n        self.wait(0.5)\n\n        self.play(proton.animate.shift(LEFT))\n        self.play(FadeIn(neutron.next_to(proton, RIGHT)), FadeIn(electron.next_to(proton, UP)))\n        self.wait(0.5)\n\n        self.play(electron.animate.orbit(proton, ellipse=True, run_time=2))\n        self.wait(1)\n\n        self.play(FadeOut(VGroup(proton, neutron, electron)))\n        \n    def create_particle(self, label, color, size, label_size, label_color):\n        particle_circle = Circle(radius=size, color=color, fill_opacity=1)\n        particle_label = Tex(label).scale(label_size).set_color(label_color)\n        \n        particle = VGroup(particle_circle, particle_label)\n        return particle\n    \n    def orbit(self, obj, about=None, ellipse=False, run_time=1):\n        if about is None:\n            about = self.plane.c2p(0, 0)\n        path = Ellipse() if ellipse else Circle()\n        \n        self.play(MoveAlongPath(obj, path, run_time=run_time))"
    },
    {
        "query": "Can you create an educational animation that illustrates the concept of calculating the area under a quadratic curve between two points on the x-axis, showing the graph of the function, highlighting the specific area under consideration, presenting the integral formula, and then breaking down the calculation step by step until the final numerical answer is revealed?",
        "answer": "\\n from manim import *\n\nclass QuadraticFormula(Scene):\n    def construct(self):\n        equation = MathTex(r\"ax^2 + bx + c = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        explanation = Text(\"Solve using the quadratic formula\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        formula = MathTex(r\"x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\")\n        self.play(Write(formula))\n        self.wait(2)\n\n        self.play(FadeOut(equation), ReplacementTransform(explanation, formula))\n        self.wait(1)\n\n        solutions = MathTex(r\"x_1 = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}, \\quad x_2 = \\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\")\n        self.play(ReplacementTransform(formula, solutions))\n        self.wait(3)\n\n        self.play(FadeOut(solutions))\n        conclude = Text(\"The solutions can be found using these values.\", font_size=24)\n        self.play(Write(conclude))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(solutions))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated math tutorial video that explains how to differentiate the function f(x) = x^2 + 2x + 1 step by step using the power rule and show that the derivative is a linear function?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{1}^{3} 2x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x \\,dx = \\frac{x^{2}}{2} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= 2 \\cdot \\frac{x^{2}}{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the limits\n        evaluated_at_limits = MathTex(r\"= x^{2} \\Big|_1^3\")\n        self.play(ReplacementTransform(solution1, evaluated_at_limits))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 3^{2} - 1^{2}\")\n        self.play(ReplacementTransform(evaluated_at_limits, final_solution))\n        self.wait(1)\n\n        final_value = MathTex(r\"= 9 - 1\")\n        self.play(Write(final_value))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(final_value, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated explanation of how to calculate the definite integral of x^3 from 0 to 2, with each step of the process displayed, including the use of the power rule for integration, the evaluation of the integral at the boundaries, and the final simplified answer. Can you also make sure to pause briefly after each new piece of information is shown so I can understand it fully before moving on?",
        "answer": "\\n from manim import *\n\nclass PendulumMotion(Scene):\n    def construct(self):\n        pivot = Dot(UP * 2)\n        bob = Dot(DOWN * 1)\n        rod = Line(pivot.get_center(), bob.get_center()).set_stroke(width=2)\n        pendulum = VGroup(pivot, rod, bob)\n        \n        self.play(FadeIn(pivot), GrowFromCenter(bob), ShowCreation(rod))\n        self.play(Rotating(rod, radians=PI/4, about_point=pivot.get_center(), rate_func=there_and_back, run_time=2))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the process of calculating the area under the curve of the function f(x) = 3 - x^2 from x = -1 to x = 2. Can you show the function as a mathematical expression, then highlight the specific area under the curve to be integrated in blue, along with a graph that plots the function with axes? Additionally, could you include step-by-step calculations of the definite integral of this function, showing the evaluation of the antiderivative at the bounds and concluding with the numerical value of the area? I'd like the explanation to be clear and paced, with the text explaining that the shaded area represents the solution to the integral, and the final result displayed prominently at the end.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShowSubmobjectsOneByOne\").shift(UP*2.5)), run_time=0.5)\n            circles2 = VGroup(\n                Circle().shift(UP*0.5),\n                Circle().shift((DOWN+LEFT)*0.5),\n                Circle().shift((DOWN+RIGHT)*0.5)\n            )\n            self.play(ShowSubmobjectsOneByOne(circles2))\n            self.play(Uncreate(circles2))"
    },
    {
        "query": "Could you create an educational animation that demonstrates how to find the determinant and the eigenvalues of a 2x2 matrix using ManimCE? The matrix should be presented first, followed by an explanation of how to calculate its determinant, and then proceed to explain and calculate the eigenvalues. Additionally, can the animation include text explanations and the mathematical formulas for the calculations, concluding with the final eigenvalues highlighted on screen?",
        "answer": "\\n from manim import *\n\nclass AnimatedBoundaryExample(Scene):\n    def construct(self):\n        # Create a square with a label\n        square = Square()\n        label = Text(\"Math is Fun!\").scale(0.7)\n        group = VGroup(square, label).arrange(UP)\n\n        # Create an animated boundary around the square with specified colors\n        animated_boundary = AnimatedBoundary(group, colors=[TEAL, PURPLE, YELLOW])\n\n        # Add the square and the animated boundary to the scene\n        self.add(group, animated_boundary)\n\n        # Play the animation where the square scales up and down\n        self.play(group.animate.scale(1.5), run_time=2)\n        self.play(group.animate.scale(0.66), run_time=2)\n\n        # Wait for a moment\n        self.wait(2)\n\n        # Remove the square and the animated boundary from the scene\n        self.remove(group, animated_boundary)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates how to calculate the area under the curve y=x^2 from x=1 to x=3. Can we start by presenting the integral problem on the screen, followed by a step-by-step explanation that includes setting up the integral, performing the integration, and explaining the process of evaluating the integral at the upper and lower bounds? Finally, can we show the final solution, clear the scene, and then conclude by highlighting the final solution again?",
        "answer": "\\n from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Introduce the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2}\", \"=\",\n                          \"c^2\", r\"\\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Discuss the equation\n        eq_description = Text(\n            \"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(eq_description, shift=UP))\n        self.wait(2)\n\n        # Show the general solution to the equation\n        gen_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(wave_eq, gen_solution))\n        self.wait(2)\n\n        # Describe the general solution\n        solution_description = Text(\n            \"The solution represents traveling waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(eq_description, solution_description))\n        self.wait(2)\n\n        # Discuss characteristic lines\n        char_lines = MathTex(r\"x - ct = k_1, x + ct = k_2\",\n                             tex_environment=\"align*\")\n        self.play(FadeOut(eq_description), FadeOut(wave_eq), FadeIn(char_lines))\n        self.wait(2)\n\n        # Explain characteristic lines\n        char_lines_description = Text(\n            \"Characteristic lines of the wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(char_lines_description))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.play(FadeIn(char_lines_description), FadeIn(char_lines))\n        self.wait(1)\n        self.play(FadeOut(char_lines_description), FadeOut(char_lines))\n        self.wait(1)\n\n        # Show initial and boundary conditions\n        init_boundary_conditions = Text(\n            \"Solutions also require initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Write(init_boundary_conditions))\n        self.wait(3)\n\n        # Conclude the scene\n        self.play(FadeOut(init_boundary_conditions))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation video that visually demonstrates the concept of finding the area under a curve, specifically the curve f(x) = x squared, between x = 0 and x = 2? The video should start by drawing a set of axes and labeling them. Then, it should plot the curve f(x) = x squared in green and shade the area under the curve between x = 0 and x = 2 with a gradient from blue to purple at 50% opacity. Afterward, can you show the mathematical formula for the curve at the top and the integral problem specifying the area calculation at the bottom? Finally, step through the integral calculation to find the exact area and present the final numerical answer clearly onscreen. Throughout the video, have smooth transitions between steps, allowing a moment for each to be observed.",
        "answer": "\\n from manim import *\n\nclass ParticleScene(Scene):\n    def construct(self):\n        electron_particle = self.create_electron()\n        self.play(FadeIn(electron_particle))\n        self.wait()\n        self.play(ApplyMethod(electron_particle.shift, UP * 2))\n        self.wait()\n        \n    def create_electron(self) -> Mobject:\n        return Circle(radius=0.15, color=YELLOW_D).add(Tex(\"e$^-$\", color=BLACK).scale(0.5)).move_to(ORIGIN)"
    },
    {
        "query": "I'd like to create an educational math animation where two functions are graphed on a coordinate system. First, can you show the equation \"y = x^2\" and then transform it into \"y = 2x + 1\" after a brief moment? Once the second equation is shown, I want both equations to be graphically represented as plots on the same axes. The first graph should be green and labeled \"x^2\", and the second one should be red and labeled \"2x+1\". Could you also make sure that the axes go from -3 to 3 on the x-axis, and from -1 to 8 on the y-axis, and have the axis lines colored blue? After showing each graph for a little while, I'd like to smoothly transition from the first graph to the second one. To finish, can you make all the elements fade away?",
        "answer": "\\n from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define neural network architecture\n        architecture = [\n            {\"layer_type\": \"Input\", \"units\": 784},  # 28x28 pixels input image\n            {\"layer_type\": \"Dense\", \"units\": 128, \"activation\": \"relu\"},\n            {\"layer_type\": \"Dense\", \"units\": 64, \"activation\": \"relu\"},\n            {\"layer_type\": \"Output\", \"units\": 10, \"activation\": \"softmax\"}\n        ]\n\n        # Create a VGroup to hold neural network layers\n        nn_layers = VGroup()\n        layer_spacing = 0.5\n\n        # Create neural network layers based on architecture and add to VGroup\n        for index, layer_info in enumerate(architecture):\n            layer_text = f\"{layer_info['layer_type']}\\\\n{layer_info['units']}\"\n            if \"activation\" in layer_info:\n                layer_text += f\"\\\\n{layer_info['activation']}\"\n            layer = Rectangle(height=1, width=2)\n            layer_text = Text(layer_text, font_size=24)\n            layer_group = VGroup(layer, layer_text)\n            layer_group.arrange(DOWN)\n            \n            # Position each layer\n            if index > 0:\n                layer_group.next_to(nn_layers, RIGHT, buff=layer_spacing)\n            \n            nn_layers.add(layer_group)\n        \n        # Center the entire neural network on screen\n        nn_layers.move_to(ORIGIN)\n\n        # Animate the creation of the neural network\n        self.play(LaggedStart(*[Create(layer) for layer in nn_layers], lag_ratio=0.2))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that visibly explains the steps to calculate the definite integral of the function 3x^2 from 0 to 2, complete with the integration process, simplifying the result, and presenting the final answer?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network.layers.image import ImageLayer\nimport numpy as np\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image),\n            Convolutional2DLayer(1, 6, 1, padding=1),\n            Convolutional2DLayer(3, 6, 3),\n            FeedForwardLayer(3),\n            FeedForwardLayer(1),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(\n                    num_feature_maps=1,\n                    feature_map_size=6,\n                    padding=1,\n                    padding_dashed=True,\n                ),\n                Convolutional2DLayer(\n                    num_feature_maps=3,\n                    feature_map_size=6,\n                    filter_size=3,\n                    padding=0,\n                    padding_dashed=False,\n                ),\n                FeedForwardLayer(3),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        self.add(nn)\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=20)"
    },
    {
        "query": "I'm teaching students about triple integrals and I'd like to create an educational animation that visually explains the step-by-step process of evaluating a triple integral. Can you make an animation that starts by showing the integral of xyz from 0 to 1 for z, y, and x in that order? Once the problem is presented, I want to sequentially integrate with respect to z, y, and then x, each time showing the intermediate steps and results. Include text explanations above each step that say \"First, integrate with respect to z,\" then \"Next, integrate the result with respect to y,\" and finally \"Finally, integrate with respect to x.\" After concluding each integration step, I want the previous step to be replaced by the new expression that shows the progress. At the end of the animation, I would like the scene to be cleared and the final solution to be displayed prominently. Can you create this instructional animation showing the process of solving a triple integral step by step?",
        "answer": "\\n from manim import *\n\nclass SurfaceAreaSphericalExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{1} \\rho^2 \\sin \\phi \\, d\\rho \\, d\\theta \\, d\\phi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\left[\\frac{\\rho^3}{3}\\right]_{0}^{1} \\sin \\phi \\, d\\theta \\, d\\phi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[\\frac{\\theta \\rho^3}{3}\\right]_{0}^{2\\pi} \\sin \\phi \\, d\\phi\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation3 = Text(\"Finally, integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\left[\\frac{2\\pi \\rho^3}{3}\\left(-\\cos \\phi\\right)\\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(middle_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{2\\pi}{3} (1 - (-1))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Conclusion of the integral calculation\n        conclusion = Text(\"Surface area of a unit sphere is 4*pi\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that explains the concept of a simple harmonic oscillator by visually showing the formula, transforming it into standard form by defining angular frequency, then presenting the general solution and finally noting how the constants are determined by initial conditions? The animation should include text explanations and equations that fade in and out in a sequence to help the viewer understand step by step.",
        "answer": "\\n from manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        wave_explanation = Text(\"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(wave_explanation))\n        self.wait(2)\n        \n        # Displaying the general solution to the wave equation\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(1)\n        \n        # Explanation for characteristics\n        characteristics = Text(\"The functions f and g represent waves traveling in opposite directions.\",\n                               font_size=24).to_edge(UP)\n        self.play(Transform(wave_explanation, characteristics))\n        self.wait(2)\n\n        # Displaying a specific solution example\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(general_solution, specific_solution))\n        self.wait(1)\n\n        # Explanation for a specific solution\n        specific_explanation = Text(\"A specific solution can represent a sinusoidal wave.\", font_size=24).to_edge(UP)\n        self.play(Transform(wave_explanation, specific_explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the specific solution again to conclude\n        self.play(Write(specific_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation that demonstrates the principles of Fourier series, including the visualization of a simple piecewise function, its mathematical definition, the coefficients involved, and a statement on the purpose of Fourier series in approximating periodic functions, ensuring there's a clear visual and written representation throughout?",
        "answer": "\\n from manim import *\n\nclass CubicPolynomialExample(Scene):\n    def construct(self):\n        # Displaying the cubic polynomial\n        polynomial = MathTex(r\"x^3 - 3x^2 + 3x - 1 = 0\")\n        self.play(Write(polynomial))\n        self.wait(1)\n\n        # Explanation for factoring the polynomial\n        explanation1 = Text(\"Factor the polynomial\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Factoring step\n        factored = MathTex(r\"(x - 1)^3 = 0\")\n        self.play(ReplacementTransform(polynomial.copy(), factored))\n        self.wait(1)\n\n        # Explanation for finding roots\n        explanation2 = Text(\"Find the roots\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing the roots\n        roots = MathTex(r\"x = 1\")\n        self.play(ReplacementTransform(factored, roots))\n        self.wait(1)\n\n        # Graphical representation\n        explanation3 = Text(\"Graphical representation\", font_size=24).to_edge(UP)\n        axes = Axes(\n            x_range=[-1, 3],\n            y_range=[-1, 3],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: (x - 1)**3, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='f(x)=(x-1)^3')\n\n        self.play(Transform(explanation1, explanation3))\n        self.play(Create(axes), Write(graph), Write(graph_label))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of the demonstration\", font_size=24)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually explains how to solve a double integral in polar coordinates, specifically the integral of r from r=0 to r=1 and theta from theta=0 to theta=2\u03c0? I\u2019d like to see the problem statement first, followed by a step-by-step walkthrough, showing the integration with respect to r first, then with respect to \u03b8, and finally the calculation of the area inside a unit circle expressed by the integral. The explanation for each step should appear at the top of the screen and it should pause briefly on each part to give viewers time to understand before moving on to the next step.",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyPattern(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Group(\n            Tex(\"Observe a sequ\u00eancia\", color=LIGHT_RED_COLOR),\n            Tex(\"abaixo:\", color=LIGHT_RED_COLOR)\n        )\n        title.arrange(DOWN)\n        title.scale(1.8)\n        title.shift(3.5 * UP)\n        pattern_text = Tex(\"1, 3, 9, 27, 81, 243, ...\", color=TEXT_COLOR).scale(1.5)\n        previous_arc = None\n        previous_arc_text = None\n        \n        self.add(title)\n        self.play(FadeIn(pattern_text), run_time=0.8)\n        self.wait(1)\n\n        for i in range(5):\n            start = -2.6 + i * 0.85\n            end = start - 0.8\n\n            if i > 2:\n                start += 0.4\n                end += 0.3\n            \n            if i > 3:\n                start += 0.6\n                end += 0.3\n\n            if i % 2 == 0:\n                y = 0.5\n                direction = UP\n            else:\n                y = -0.6\n                direction = DOWN\n\n            arc = ArcBetweenPoints([start, y, 0], [end, y, 0], color=LIGHT_BLUE_COLOR)\n            arc.flip(UP)\n            \n            if i % 2 == 1:\n                arc.flip(RIGHT)\n\n            arc.add_tip(tip_shape=ArrowTriangleFilledTip)\n            arc_text = Tex(\"x3\", color=LIGHT_BLUE_COLOR)\n            arc_text.scale(0.8)\n            arc_text.next_to(arc, direction)\n\n            if previous_arc is None:\n                self.play(FadeIn(Group(arc_text, arc)), run_time=0.25)\n            else:\n                self.play(\n                    Transform(previous_arc_text.copy().set_opacity(0), arc_text), \n                    Transform(previous_arc.copy().set_opacity(0), arc),\n                    rate_func=rate_functions.rush_from,\n                    run_time=0.4\n                )\n\n            previous_arc_text = arc_text\n            previous_arc = arc\n            self.wait(0.5)\n\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects[1:])))\n        self.remove(*self.mobjects)"
    },
    {
        "query": "I would like an educational animation that explains the sum of a geometric series. It should start by displaying the formula for the sum of an infinite geometric series. Then it should explain that the series converges only if the absolute value of the common ratio is less than 1, and follow up by showing the simplified formula for the sum when this condition is met. Furthermore, I want an example with numbers, showing the sum of a series where each term is one-half to the power of n, and then show that the sum converges to 2. To wrap up, clear the screen and present the final statement that the sum of the series converges to 2. Could you create such an animation in a clear and visually appealing way?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1}\\int_{0}^{1}\\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1}\\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution[-1]))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation using Manim that introduces the concept of a derivative, visually demonstrates how to calculate the derivative of a quadratic function, and then shows the slope of the tangent line to the function at a specific point?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi/2} \\int_{0}^{1} r^2 \\sin(\\theta) dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi/2} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi/2} \\frac{1}{3} \\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for final solution\n        explanation3 = Text(\"Solve the remaining integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [-\\frac{1}{3} \\cos(\\theta)]_{0}^{\\pi/2}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplified final solution\n        simplified_solution = MathTex(r\"= -\\frac{1}{3} \\cos(\\frac{\\pi}{2}) + \\frac{1}{3} \\cos(0)\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(2)\n\n        # Simplified even further to numeric solution\n        numeric_solution = MathTex(r\"= \\frac{1}{3}\")\n        self.play(Transform(final_solution, numeric_solution))\n        self.wait(3)"
    },
    {
        "query": "Can you create an educational animation using Manim that first displays the one-dimensional wave equation, followed by a textual explanation that it represents the wave equation for a string with fixed ends, which can have sinusoidal solutions? Then, can you show a transformation of this equation into a particular sinusoidal solution form, with an accompanying explanation that mentions the concept of harmonics, indicating that multiples of the fundamental frequency produce harmonics? After that, please clear the scene and sequentially display the first and second harmonic equations with a fade transition, and finally conclude with a text at the bottom of the screen explaining that the string\u2019s shape at any given time represents a standing wave.",
        "answer": "\\n from manim import *\n\nclass CreateGraph(Scene):\n    def construct(self):\n        # Create vertices\n        v1 = Dot(LEFT)\n        v2 = Dot(RIGHT)\n        v3 = Dot(UP)\n\n        vertices = VGroup(v1, v2, v3)\n\n        # Create edges connecting the vertices\n        e1 = Line(v1.get_center(), v2.get_center())\n        e2 = Line(v2.get_center(), v3.get_center())\n        e3 = Line(v3.get_center(), v1.get_center())\n\n        edges = VGroup(e1, e2, e3)\n\n        # Create a graph from vertices and edges\n        graph = VGroup(vertices, edges)\n\n        # Perform animation\n        self.play(FadeIn(graph))\n        self.wait(1)\n\n        # Label vertices\n        l1 = Tex(\"V1\").next_to(v1, DOWN)\n        l2 = Tex(\"V2\").next_to(v2, DOWN)\n        l3 = Tex(\"V3\").next_to(v3, UP)\n\n        labels = VGroup(l1, l2, l3)\n\n        self.play(FadeIn(labels))\n        self.wait(1)\n\n        # Create a path to move an object along\n        path = VMobject()\n        path.set_points_as_corners([v1.get_center(), v2.get_center(), v3.get_center(), v1.get_center()])\n\n        # Create a moving object\n        moving_dot = Dot(color=RED).move_to(v1)\n\n        # Animation: move along the path created\n        self.play(MoveAlongPath(moving_dot, path), run_time=3, rate_func=linear)\n\n        # Finish animation\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that explains the physics of a spring-mass-damper system. Can you show the equation of motion for such a system and then gradually transform it into its standard form? After that, please introduce and explain the characteristic equation and finally present the underdamped solution of the system, including an explanation for when the damping ratio is less than one. Each part of the equation and its explanation should appear on the screen sequentially to aid understanding. To conclude, display a statement summarizing the concept of free vibration in a spring-mass-damper system.",
        "answer": "\\n from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        text = Text(\"Inscribe\").shift(DOWN*2.5)\n        self.add(text)\n        self.play(Transform(text, Text(\"Inscribe\").shift(UP*2.5)), run_time=0.5)\n        another_text = Text(\"Watch Here\")\n        self.add(another_text)\n        self.play(Indicate(another_text))\n        self.play(Indicate(another_text, color=RED))\n        self.remove(another_text)"
    },
    {
        "query": "Can you create an educational animation that starts by displaying the Fourier series formula, followed by a textual explanation about how it decomposes periodic functions? Then, could you show the first three terms of the series visually transforming the original formula on the screen and provide an additional text explanation on how the series converges to the original function as more terms are added? Finally, remove all text and illustrate this with a plot of a periodic function, like a sine wave, showing both the axes and the plotting animation to conclude?",
        "answer": "\\n from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create an electron\n        e = electron()\n        self.play(FadeIn(e))\n        self.wait(1)\n\n        # Move the electron around in a circle\n        circle_path = Circle(radius=1.0)\n        self.play(MoveAlongPath(e, circle_path), run_time=2, rate_func=smooth)\n        self.wait(1)\n\n        # Create a grid of metal and oxygen\n        grid = metal_oxid(rows=3, cols=3, scale=2)\n        self.play(FadeIn(grid))\n        self.wait(1)\n\n        # Transition from metal_oxid to carbon_grid\n        carbon_grid_mobject = carbon_grid(rows=2)\n        self.play(ReplacementTransform(grid, carbon_grid_mobject))\n        self.wait(1)\n\n        # Create and move a lithium ion along a complex path\n        li_ion = lithium_ion()\n        self.play(FadeIn(li_ion))\n\n        # Example of complex path\n        complex_path_points = [UP + LEFT, UP + RIGHT, DOWN + RIGHT, DOWN + LEFT]\n        complex_path_animations = move_along_complex_path(li_ion, [2], complex_path_points, run_time=1)\n\n        for anim in complex_path_animations:\n            self.play(anim)\n        \n        self.wait(1)"
    },
    {
        "query": "Create an educational math animation where a narrator demonstrates how to calculate the area under the curve of the function f(x) equals x squared from x equals 1 to x equals 3. The animation should start by writing out the function on the top of the screen, followed by showing the integral expression of the function within the given limits. Then animate the steps of the integration process to calculate the definite integral. Each transformation in the calculation should be shown one step at a time with a brief pause in between. After reaching the final value, clear the screen and display the final calculated result again for emphasis. Include pauses after each new element is introduced so the viewers have time to understand each step.",
        "answer": "\\n class TriangleToSquare(Scene):\n    def construct(self):\n        red_triangle = Triangle(color=RED, fill_opacity=0.5)\n        self.play(DrawBorderThenFill(red_triangle))\n        yellow_square = Square(color=YELLOW, fill_opacity=0.5)\n        self.play(ReplacementTransform(red_triangle, yellow_square))\n        self.play(Indicate(yellow_square))\n        self.play(FadeOut(yellow_square))"
    },
    {
        "query": "I would like to create an educational animation that visually explains how to calculate a basic definite integral in calculus step by step. Could you show me how to evaluate the integral of 3x^2 with respect to x from 0 to 2, using the power rule for integration and then evaluating the resulting expression at the upper and lower bounds to find the area under the curve? Finally, please conclude the animation by displaying the final numerical result.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        curve = FunctionGraph(lambda x: x**2, x_range=[-2, 2], color=BLUE)\n        area = area = Integral(curve, (x, -2, 2), fill_opacity=0.3, fill_color=BLUE)\n        equation = MathTex(r\"A = \\int_{-2}^{2} x^2 dx\")\n\n        # Draw the curve and the equation\n        self.play(DrawBorderThenFill(curve), Write(equation))\n        self.wait(1)\n\n        # Shift equation to the top\n        self.play(ApplyMethod(equation.to_edge, UP))\n        self.wait(1)\n\n        # Show the area under the curve\n        self.play(Write(area))\n        self.wait(2)\n\n        # Compute the integral with intermediate step\n        intermediate_step = MathTex(r\"A = \\left[ \\frac{1}{3}x^3 \\right]_{-2}^{2}\")\n        self.play(ReplacementTransform(equation, intermediate_step))\n        self.wait(2)\n\n        # Show the final solution\n        final_solution = MathTex(r\"A = \\frac{1}{3}(2)^3 - \\frac{1}{3}(-2)^3\", r\"= \\frac{8}{3} - \\left(-\\frac{8}{3}\\right)\", r\"= \\frac{16}{3}\")\n        self.play(ReplacementTransform(intermediate_step, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an educational animation that visually and step-by-step demonstrates how to calculate the area under the curve of the function f(x) = x^2 from x=1 to x=2, including writing the function, explaining the process of setting up the definite integral, showing the integration steps with the antiderivative, evaluating the integral with limits, simplifying the result, and finally presenting the calculated area value. Can you also ensure that each step appears on the screen with enough time for the viewer to follow, and clear the screen before presenting the final answer?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralSphericalExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{\\pi/2} \\int_{0}^{1} \\rho^2 \\sin(\\phi) d\\rho\\,d\\phi\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{\\pi/2} \\left[ \\frac{1}{3}\\rho^3 \\sin(\\phi) \\right]_{0}^{1} d\\phi\\,d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{\\pi/2} \\frac{1}{3} \\sin(\\phi) d\\phi\\,d\\theta\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\left[ -\\frac{1}{3} \\cos(\\phi) \\right]_{0}^{\\pi/2} d\\theta\")\n        self.play(ReplacementTransform(middle_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation3 = Text(\"Finally, integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ -\\frac{1}{3} \\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n\n        # Display the solution\n        solution_text = Text(\"The solution is -pi/3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, solution_text))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually represents the steps involved in solving a triple integral, starting with the integration with respect to z, followed by y, and finally x, for the function xyz over the range from 0 to 1 for each variable? I would like the animation to display the mathematical problem, then show step-by-step integration with explanatory text for each variable, and conclude with the final solution.",
        "answer": "\\n from manim import *\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Creating atoms\n        hydrogen_atom = self.create_atom(\"H\", WHITE, 0.1)\n        carbon_atom = self.create_atom(\"C\", BLUE_E, 0.2)\n        nitrogen_atom = self.create_atom(\"N\", GREEN_E, 0.2)\n        oxygen_atom = self.create_atom(\"O\", RED_E, 0.2)\n\n        # Positioning atoms\n        molecule = VGroup(hydrogen_atom, carbon_atom, nitrogen_atom, oxygen_atom)\n        molecule.arrange_in_grid(rows=2, cols=2, buff=1)\n\n        # Animating creation of atoms\n        self.play(AnimationGroup(\n            FadeIn(hydrogen_atom, shift=UP*0.5),\n            FadeIn(carbon_atom, shift=DOWN*0.5),\n            FadeIn(nitrogen_atom, shift=LEFT*0.5),\n            FadeIn(oxygen_atom, shift=RIGHT*0.5),\n            lag_ratio=0.5\n        ))\n        \n        # Rotate the molecule\n        self.play(Rotate(molecule, angle=PI/2))\n        \n        # Wait for 2 seconds\n        self.wait(2)\n\n    def create_atom(self, symbol, color, radius):\n        # Create an atom with a symbol inside a circle\n        atom_circle = Circle(radius=radius, color=color)\n        atom_symbol = Tex(symbol, color=color)\n        atom = VGroup(atom_circle, atom_symbol)\n        return atom"
    },
    {
        "query": "Can you create an educational animation that explains the wave equation and its solutions, provides an example of a specific solution, explains the meaning of the parameters in the wave solution, and demonstrates typical boundary conditions for a wave on a string, wrapping up with a general conclusion about the importance of wave equations?",
        "answer": "\\n from manim import *\n\n\ndef normalize(v):\n    norm = np.linalg.norm(v)\n    if norm == 0:\n        return v\n    return v / norm\n\n\n# Render with -c \"#ece6e2\"\nclass DraftScene(Scene):\n    def construct(self):\n        logo_green = \"#81b29a\"\n        logo_blue = \"#454866\"\n        logo_red = \"#e07a5f\"\n        logo_black = \"#343434\"\n\n        ds_m = MathTex(r\"\\mathbb{M}\", z_index=20).scale(7).set_color(logo_black)\n        ds_m.shift(2.25 * LEFT + 1.5 * UP)\n\n        circle = Circle(color=logo_green, fill_opacity=1, z_index=7).shift(LEFT)\n        square = Square(color=logo_blue, fill_opacity=1, z_index=5).shift(UP)\n        triangle = Triangle(color=logo_red, fill_opacity=1, z_index=3).shift(RIGHT)\n\n        vgroup = VGroup(triangle, square, circle, ds_m).scale(0.7)\n        vgroup.move_to(ORIGIN)\n\n        self.add(circle, square, triangle)\n\n        shape_center = VGroup(circle, square, triangle).get_center()\n\n        spiral_run_time = 2.1\n        expansion_factor = 8\n        m_height_over_anim_height = 0.75748\n        m_shape_offset = 4.37\n        m_anim_buff = 0.06\n\n        tracker = ValueTracker(0)\n\n        for mob in [circle, square, triangle]:\n            mob.final_position = mob.get_center()\n            mob.initial_position = (\n                mob.final_position\n                + (mob.final_position - shape_center) * expansion_factor\n            )\n            mob.initial_to_final_distance = np.linalg.norm(\n                mob.final_position - mob.initial_position\n            )\n            mob.move_to(mob.initial_position)\n            mob.current_time = 0\n            mob.starting_mobject = mob.copy()\n\n            def updater(mob, dt):\n                mob.become(mob.starting_mobject)\n                mob.shift(\n                    normalize((shape_center - mob.get_center()))\n                    * mob.initial_to_final_distance\n                    * tracker.get_value()\n                )\n                mob.rotate(TAU * tracker.get_value(), about_point=shape_center)\n                mob.rotate(-TAU * tracker.get_value())\n\n            mob.add_updater(updater)\n\n        self.play(tracker.set_value, 1, run_time=spiral_run_time)\n\n        circle.clear_updaters()\n        square.clear_updaters()\n        triangle.clear_updaters()\n\n        self.wait(0.3)\n\n        self.play(FadeIn(ds_m), rate_func=rate_functions.ease_in_sine)\n        self.wait(0.7)\n\n        ds_m_target = ds_m.generate_target()\n        circle_target = circle.generate_target().shift(RIGHT * m_shape_offset)\n        square_target = square.generate_target().shift(RIGHT * m_shape_offset)\n        triangle_target = triangle.generate_target().shift(RIGHT * m_shape_offset)\n\n        anim = VGroup()\n        for i, ch in enumerate(\"anim\"):\n            tex = Tex(\n                \"\\\\textbf{\" + ch + \"}\",\n                z_index=10,\n                tex_template=TexFontTemplates.gnu_freeserif_freesans,\n            )\n            if i != 0:\n                tex.next_to(anim, buff=0.01)\n            tex.align_to(ds_m, DOWN)\n            anim.add(tex)\n\n        anim.set_color(logo_black).set_height(\n            m_height_over_anim_height * ds_m.get_height()\n        ).next_to(ds_m_target, buff=m_anim_buff).align_to(ds_m, DOWN)\n\n        banner = VGroup(\n            ds_m_target, anim, circle_target, square_target, triangle_target\n        )\n        banner.move_to(ORIGIN)\n\n        ds_m_offset_vec = ds_m_target.get_center() - ds_m.get_center()\n\n        self.play(\n            circle.shift,\n            ds_m_offset_vec,\n            square.shift,\n            ds_m_offset_vec,\n            triangle.shift,\n            ds_m_offset_vec,\n            ds_m.shift,\n            ds_m_offset_vec,\n        )\n\n        tracker.set_value(0)\n        shape_center = VGroup(circle, square, triangle).get_center()\n        for mob in [circle, square, triangle]:\n            mob.starting_mobject = mob.copy()\n            mob.shape_center_offset = mob.get_center() - shape_center\n\n            def updater(mob, dt):\n                center = shape_center + RIGHT * tracker.get_value() * m_shape_offset\n                mob.become(mob.starting_mobject)\n                mob.move_to(center + mob.shape_center_offset)\n\n            mob.add_updater(updater)\n\n        self.play(\n            tracker.set_value,\n            1,\n            FadeIn(anim, lag_ratio=1),\n        )\n        anim.z_index = 20\n        self.wait(1)"
    },
    {
        "query": "I need to create an educational animation that demonstrates the process of integrating the exponential function e to the power of 2x with respect to x. The video should start by displaying the integral of e to the power of 2x, and then proceed step-by-step, first by mentioning the use of the power rule for the exponential function. After that, it should show the intermediate step of the integration with the constant factor, followed by a reminder to add the constant of integration. Finally, the animation should reveal the complete integrated function including the constant of integration, before clearing the screen and concluding the lesson.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ScaleInPlace\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(ScaleInPlace(square, scale_factor=2))\n            self.remove(square)"
    },
    {
        "query": "I'd like to have an animated video that teaches the process of integrating the function e^(2x) step by step using the substitution method. Please start by displaying the integral of e^(2x) with respect to x. Then have the video show a step where it explains that we are going to use substitution and introduces the substitution u = 2x. It should then express the derivative of u with respect to x and solve for dx. Following that, the video should rewrite the original integral in terms of u and simplify it by substituting dx. Next, have the video show the step where the integral with respect to u is taken, leading to the final solution in terms of x with the integration constant added. After presenting the final solution, I'd like the animation to clear the screen of all the work and end with a concluding statement that the integral has been successfully solved. Can you create such an educational mathematics animation for me?",
        "answer": "\\n from manim import *\n\nclass ThirdOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the original ODE\n        ode_text = MathTex(r\"y''' - 3y'' + 3y' - y = 0\")\n        self.play(Write(ode_text))\n        self.wait(1)\n\n        # Explanation for characteristic equation derivation\n        char_eq_explanation = Text(\"Derive the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(FadeIn(char_eq_explanation))\n        self.wait(2)\n\n        # Characteristic equation\n        char_eq = MathTex(r\"r^3 - 3r^2 + 3r - 1 = 0\")\n        self.play(ReplacementTransform(ode_text.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for finding the roots of the characteristic equation\n        roots_explanation = Text(\"Find the roots of the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_explanation, roots_explanation))\n        self.wait(2)\n\n        # Displaying the roots\n        roots = MathTex(r\"r = 1\", r\"\\\\ r = 1\", r\"\\\\ r = 1\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # Explanation for the general solution\n        general_sol_explanation = Text(\"Write down the general solution\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_explanation, general_sol_explanation))\n        self.wait(2)\n\n        # Writing the general solution of the ODE\n        general_solution = MathTex(r\"y = C_1 e^{x} + C_2 x e^{x} + C_3 x^2 e^{x}\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Final step: Concluding the process\n        conclusion = Text(\"This is the general solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(char_eq_explanation, conclusion))\n        self.wait(2)\n\n        # Clearing everything and showing the final result only\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(general_solution))\n        self.wait(1)"
    },
    {
        "query": "I want to create an animated video that visually demonstrates how to evaluate a triple integral step by step. Can you show the process of solving the integral of the function xyz with respect to z, y, and x over the range 0 to 1 for all variables? It should display the problem, provide written explanations for each step of integration, and show the integration being performed in sequence from the innermost integral to the outermost. Include pauses and transitions to ensure that the explanation is digestible. Conclude by presenting the final evaluated result clearly.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        curve = MathTex(r\"f(x) = 3 - x^2\")\n        self.play(Write(curve))\n        self.wait(1)\n\n        # Displaying the area question\n        area_question = MathTex(r\"\\text{Find the area under }\",\n                                r\"f(x)\", r\"\\text{ from }\", r\"x = -1\", r\"\\text{ to }\", r\"x = 2\")\n        area_question.next_to(curve, DOWN)\n        self.play(Write(area_question))\n        self.wait(2)\n\n        # Setting up the integral\n        integral = MathTex(r\"A = \\int_{-1}^{2} (3 - x^2) \\,dx\")\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Calculating the integral\n        integral_calculation = MathTex(r\"A = \\left[3x - \\frac{1}{3}x^3\\right]_{-1}^{2}\")\n        self.play(Transform(integral, integral_calculation))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"A = \\left(6 - \\frac{8}{3}\\right) - \\left(3 + \\frac{1}{3}\\right) = \\frac{7}{3}\")\n        self.play(ReplacementTransform(integral, final_solution))\n        self.wait(1)\n\n        # Show final answer on screen\n        final_answer = Text(\"Area under the curve is 7/3\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_answer))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video explaining how to solve a double integral in polar coordinates. Can you show the integral of r from 0 to 1 and theta from 0 to \u03c0, and then step through the process of integrating with respect to r first to find the inner integral, followed by integrating with respect to theta to get the final solution? Additionally, I would like each step to be displayed with some explanatory text, and the final answer simplified on screen.",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_YELLOW_COLOR = \"#f7e03c\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef ThoughtBubble(**kwargs):\n    bubble = SVGMobject(\"./assets/thought.svg\", **kwargs)\n    bubble.set(height=2)\n    return bubble\n\nclass KnowledgeQuestion(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n        \n        teacher = ImageMobject(\"./assets/teacher.png\")\n        teacher.scale(0.5)\n        teacher.to_edge(LEFT)\n        \n        thought_bubble = ThoughtBubble(fill_opacity=0.8, fill_color=LIGHT_BLUE_COLOR)\n        thought_bubble.next_to(teacher, UP+RIGHT, buff=0.5)\n        thought_bubble.shift(2.5 * UP)\n\n        knowledge_text_1 = Text(\"What is the\", color=WHITE)\n        knowledge_text_2 = Text(\"Pythagorean\", color=WHITE)\n        knowledge_text_3 = Text(\"Theorem?\", color=WHITE)\n        knowledge_text_group = VGroup(knowledge_text_1, knowledge_text_2, knowledge_text_3)\n        knowledge_text_group.scale(0.6)\n        knowledge_text_group.arrange(DOWN, center=False, aligned_edge=LEFT)\n        knowledge_text_group.move_to(thought_bubble.get_center_of_mass())\n\n        self.play(\n            FadeIn(teacher), \n            FadeIn(thought_bubble), \n            run_time=0.5\n        )\n        self.play(\n            Write(knowledge_text_1),\n            Write(knowledge_text_2),\n            Write(knowledge_text_3),\n            run_time=2\n        )\n        self.wait(1)\n\n        answer_text_1 = Text(\"In a right triange,\", color=WHITE)\n        answer_text_2 = Text(\"the square of the hypotenuse\", color=WHITE)\n        answer_text_3 = Text(\"is equal to the sum of\", color=WHITE)\n        answer_text_4 = Text(\"the squares of the other two sides.\", color=WHITE)\n        answer_text_group = VGroup(answer_text_1, answer_text_2, answer_text_3, answer_text_4)\n        answer_text_group.scale(0.5)\n        answer_text_group.arrange(DOWN, center=False, aligned_edge=LEFT)\n        answer_text_group.next_to(thought_bubble.get_bottom(), DOWN)\n\n        self.play(\n            FadeOut(knowledge_text_group),\n            FadeIn(answer_text_group),\n            run_time=1.5\n        )\n        self.wait(2)\n        \n        self.play(\n            FadeOut(answer_text_group),\n            FadeOut(thought_bubble),\n            FadeOut(teacher),\n            run_time=0.5\n        )\n        self.wait(0.5)"
    },
    {
        "query": "Can you create an educational animation using ManimCE that shows how to find the area under the curve y=x^2 from x=0 to x=2, demonstrating the concept graphically with Riemann rectangles and analytically by calculating the definitive integral step by step, and displaying the final area in square units?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_fill\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1)\n            self.play(square.animate.set_fill(RED))\n            self.remove(square)"
    },
    {
        "query": "I would like to see an animated video which starts with displaying the mathematical function f(x) = x^2, then transforms that into an integral problem showing the area under that curve between x=1 and x=3. After that, it should visually display the area under the curve on a set of axes, and color the area between 1 and 3. Following the visuals, I'd like the animation to demonstrate the integration process by showing how to evaluate the integral of x^2 from 1 to 3 step by step, ending with the exact value of the area. Finally, it should conclude with a statement that this shaded area is equal to the calculated value in square units.",
        "answer": "\\n from manim import *\n\nclass LinearTransformationExample(Scene):\n    def construct(self):\n        matrix = [[1, 2], [2, 1]]\n        matrix_tex = MathTex(r\"\\begin{pmatrix} 1 & 2 \\\\ 2 & 1 \\end{pmatrix}\")\n        matrix_tex.to_edge(UP)\n\n        self.play(Write(matrix_tex))\n        self.wait(1)\n\n        # Linear transformation\n        transform_title = Text(\"Linear transformation effect\", font_size=24).to_edge(UP)\n        self.play(Transform(matrix_tex, transform_title))\n        self.wait(1)\n\n        # Create a grid and vector\n        grid = NumberPlane()\n        vector = Arrow([0, 0, 0], [1, 1, 0], buff=0, color=YELLOW)\n        self.play(Create(grid), GrowArrow(vector))\n        self.wait(1)\n\n        # Apply matrix transformation\n        transformed_vector = vector.copy()\n        transformed_vector.apply_matrix(matrix)\n        transformed_vector.set_color(RED)\n\n        self.play(Transform(vector, transformed_vector))\n        self.wait(1)\n\n        final_text = Text(\"Transformed Vector\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_text))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)"
    },
    {
        "query": "How can I create an educational animation that visually explains the process of evaluating a double integral in polar coordinates, specifically integrating the function r^2 sin(\u03b8) first with respect to r from 0 to 1 and then with respect to \u03b8 from 0 to \u03c0, with each step accompanied by a textual explanation of the integration process?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display the Fourier series definition\n        series_def = MathTex(r\"f(x) \\sim a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(series_def))\n        self.wait(2)\n\n        # Explanation about periodic function\n        explanation1 = Text(\"Fourier series represents periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Example of a specific Fourier series\n        specific_series = MathTex(r\"f(x) \\sim \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} (\\frac{4}{n\\pi} \\sin(n\\pi x))\")\n        self.play(ReplacementTransform(series_def, specific_series))\n        self.wait(2)\n\n        # Display the function graphics\n        axes = Axes(x_range=[0, 2, 0.5], y_range=[-1.5, 1.5, 0.5])\n        graph = axes.plot(lambda x: np.sin(math.pi * x), color=BLUE)\n        graph_label = axes.get_graph_label(graph, label='f(x)')\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(2)\n\n        # Explanation of applying Fourier series to square wave\n        explanation2 = Text(\"Applying series to square wave\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clear the graph and explanation\n        self.play(FadeOut(graph), FadeOut(graph_label), FadeOut(axes), FadeOut(explanation1))\n        self.wait(1)\n\n        # Conclude with the specific series\n        self.play(Write(specific_series))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that visually explains the area of a circle formula using the Python library ManimCE? I would like to see the equation \"A = \u03c0r^2\" written out, followed by a brief text explanation about the area being that of a circle with a radius 'r'. Then, could you highlight the 'r^2' part in the equation to emphasize the squared radius? Next, visually show a blue circle alongside a green line representing the radius labeled 'r'. After that, I'd like to see a demonstration of the area calculation for a unit circle where r=1, so the equation simplifies to \"A = \u03c0\". Finally, morph the circle to match the size of the area when r=1 (which should be a circle with an area of \u03c0), remove the radius from the scene, and then clear the scene to only show the final area value for a unit circle. Can you have pauses in the animation to allow time for the information to be absorbed?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Create\").shift(UP*2.5)), run_time=0.5)\n            start = Star()\n            self.play(Create(start))\n            self.play(Transform(text,Text(\"Uncreate\").shift(UP*2.5)), run_time=0.5)\n            self.play(Uncreate(start))"
    },
    {
        "query": "I would like an animated video that visually demonstrates the concept of finding the area under the curve of the function f(x) = x^2 from x = 0 to x = 3 using integration. The video should start by displaying the integral of x squared from 0 to 3. Next, I want to see a graph with the function plotted on some axes, followed by shading the area under the curve within the given interval. It should then show the steps to calculate this integral, replacing the integral symbol with the equivalent expression obtained after integration and evaluating from the lower to upper limits. After this, the video should show the final numerical value of the area, and include a text that states \"Area under the curve is equal to the integral value\". Finally, clear everything off the screen except the final numerical value, which should remain for a short time before ending the video.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Display the Fourier Series Definition\n        fourier_series = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Initial Explanation\n        explanation1 = Text(\"This represents a Fourier series.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation2 = Text(\"Here, a_n and b_n are the Fourier coefficients.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing an example with fixed limits\n        example_eq = MathTex(r\"a_n = \\frac{1}{\\pi} \\int_{-\\pi}^\\pi f(x) \\cos(nx) dx\", r\"\\quad\",\n                             r\"b_n = \\frac{1}{\\pi} \\int_{-\\pi}^\\pi f(x) \\sin(nx) dx\")\n        self.play(ReplacementTransform(fourier_series, example_eq))\n        self.wait(2)\n\n        # Explanation for the orthogonality of sine and cosine\n        explanation3 = Text(\"Sines and cosines are orthogonal functions over this interval.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and show an application of Fourier series\n        self.clear()\n        self.wait(1)\n        application = Text(\"Fourier series are used in signal processing and many areas of physics.\", font_size=24)\n        self.play(FadeIn(application))\n        self.wait(2)\n\n        # Conclude the demonstration\n        self.wait(1)\n        self.play(FadeOut(application))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation that visually demonstrates the process of calculating the definite integral of the function x squared from 0 to 2, including the steps involved in evaluating the integral and showing the final value of the area under the curve?",
        "answer": "\\n from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series_problem = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for the convergence test\n        explanation_convergence = Text(\"Test for convergence using the p-test\", font_size=24)\n        self.play(Write(explanation_convergence))\n        self.wait(2)\n\n        # Showing the p-test result\n        p_test_result = MathTex(r\"\\text{Since } p = 2 > 1, \\text{the series converges.}\")\n        self.play(Transform(series_problem, p_test_result))\n        self.wait(2)\n\n        # Explanation for comparison with integral\n        explanation_integral = Text(\"Compare with a known convergent integral\", font_size=24).shift(UP*3)\n        self.play(Transform(explanation_convergence, explanation_integral))\n        self.wait(2)\n\n        # Comparison with integral\n        integral_comparison = MathTex(r\"\\int_{1}^{\\infty} \\frac{1}{x^2} \\,dx \\text{ converges, so does our series}\")\n        self.play(ReplacementTransform(series_problem, integral_comparison))\n        self.wait(2)\n\n        # Final statement\n        final_statement = MathTex(r\"\\therefore \\sum_{n=1}^{\\infty} \\frac{1}{n^2} \\text{ converges}\")\n        self.play(ReplacementTransform(integral_comparison, final_statement))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(explanation_convergence), FadeOut(final_statement))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the process of calculating a definite integral in calculus. The integral to be solved should be the integral from 1 to 3 of the function 3x^2 with respect to x. The animation should include the following steps: first, display the integral problem; then, show the application of the integral power rule to obtain the general antiderivative; next, evaluate this antiderivative at the upper and lower bounds; and finally, show the subtraction of these values to reach the definite integral\u2019s numerical result. The animation should pause briefly on each step to allow viewers to follow along, and then at the end, it should clear the screen and display only the final answer. Can you create this animation in a clear and concise manner to help students understand how to solve a definite integral?",
        "answer": "\\n from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        layers = VGroup(\n            Rectangle(width=2, height=1, color=BLUE),\n            Rectangle(width=2, height=1, color=GREEN),\n            Rectangle(width=2, height=1, color=RED),\n        )\n        layers.arrange(RIGHT, buff=1)\n\n        arrows = VGroup(\n            Arrow(start=layers[0].get_right(), end=layers[1].get_left(), buff=0.1),\n            Arrow(start=layers[1].get_right(), end=layers[2].get_left(), buff=0.1),\n        )\n\n        neural_network = VGroup(layers, arrows)\n\n        self.play(ShowCreation(neural_network))\n        self.wait()\n\n        activation_text = Text(\"Activation Function: ReLU\", font_size=24)\n        activation_text.next_to(layers[2], DOWN)\n\n        self.play(Write(activation_text))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the process of calculating the area under the curve of the function sqrt(x) between x=1 and x=3. The animation should start by showing the integral symbol with limits of integration, followed by a graph of the function with a coordinate system. Then, I want the area under the curve within the specified range to be shaded to represent the integral visually. Afterward, the animation should transition into showing the setup for the solution of the integral and then display the algebraic steps to reach the final numeric answer. Additionally, I'd like the function graph and the shaded area to be displayed first before showing the integral calculation steps, and the entire scene should be cleared before revealing the final answer at the end of the animation. Can all these details be sequentially animated for educational purposes?",
        "answer": "\\n from manim import *\n\nconfig.frame_size = (1080, 1920)\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass PieChartExample(Scene):\n    def construct(self):\n        colors = [BLUE_D, GREEN_D, YELLOW_D, RED_D, PURPLE_D, ORANGE_D, PINK_D]\n        data = {'Blueberry': 60, 'Green Apple': 10, 'Lemon': 30, 'Watermelon': 20, 'Grape': 15, 'Orange': 50, 'Strawberry': 25}\n        pie_chart = PieChart(values=data.values(), radius=1.5, colors=colors, labels=data.keys(), label_font_size=24, stroke_width=1)\n        \n        legends = pie_chart.get_legend()\n        legends.scale(0.5).to_corner(UR, buff=0.5).shift(LEFT * 0.5)\n        \n        self.play(Create(pie_chart), run_time=1)\n        self.play(FadeIn(legends), run_time=1)\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the process of calculating a triple integral. The triple integral should be set up to integrate over x from 0 to 1, y from -1 to 1, and z from 0 to 2 of the function xyz. The animation should show the step-by-step integration in the following order: first with respect to z, then y, and finally x. After each integration step, I want a text explanation stating which variable we are integrating with respect to next. At the end of the animation, present the final numerical solution of the triple integral. Can you do this?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2} \\rho^3 \\sin\\varphi d\\rho d\\varphi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{\\rho^4}{4}]_{0}^{2} \\sin\\varphi d\\varphi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplify the inner integral\n        simplified_inner = MathTex(r\"= \\int_{0}^{\\pi} 4\\sin\\varphi d\\varphi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for the outer integral\n        explanation2 = Text(\"Now integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [-4\\cos\\varphi]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for the final result\n        explanation3 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= -4(\\cos(\\pi) - \\cos(0))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= -4(-1 - 1)\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Display final answer\n        final_answer = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(simplified_solution, final_answer))\n        self.wait(2)"
    },
    {
        "query": "Please create an educational animation that visually walks through the steps of solving a double integral in polar coordinates. Start by displaying the double integral of r^2 * sin(theta) with respect to r from 0 to 1 and theta from 0 to pi. Follow that by a step-by-step integration process. First, calculate the inner integral with respect to r and display the intermediate result. Then, explain that the next step is to integrate with respect to theta and show this calculation, leading to the final result. Finally, evaluate the integral and simplify the expression to get the numerical answer. Make sure that each step is clearly written out and that there are brief pauses between steps for viewers to follow along.",
        "answer": "\\n from manim import *\n\nclass CalculateSeries(Scene):\n    def construct(self):\n        # Display the series to be calculated\n        series_problem = MathTex(r\"S = \\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for partial sums\n        explanation1 = Text(\"Use partial sums to approach the series' value\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Partial sum notation\n        partial_sum = MathTex(r\"S_N = \\sum_{n=1}^{N} \\frac{1}{n^2}\")\n        self.play(ReplacementTransform(series_problem, partial_sum))\n        self.wait(1)\n\n        # Representing the series with partial sums\n        partial_sum_example = MathTex(r\"S_5 = 1 + \\frac{1}{4} + \\frac{1}{9} + \\frac{1}{16} + \\frac{1}{25}\")\n        self.play(ReplacementTransform(partial_sum, partial_sum_example))\n        self.wait(2)\n\n        # Explanation for the known limit\n        explanation2 = Text(\"The series converges to a known value\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Series limit is pi squared over 6\n        series_solution = MathTex(r\"S = \\frac{\\pi^2}{6}\")\n        self.play(ReplacementTransform(partial_sum_example, series_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(series_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated video that visually demonstrates the Pythagorean theorem? It should include the equation \"a^2 + b^2 = c^2\" written out, followed by a right triangle appearing on the screen. Next, can you show squares being formed on each side of the triangle to represent \"a^2\", \"b^2\", and \"c^2\" respectively? I'd also like two separate pieces of text that explain the concept: one that says \"Consider squares on each side\" and another that changes to say \"Area of c^2 is equal to sum of a^2 and b^2\". To conclude, can you transform the original equation into a final statement at the bottom of the screen, clear everything else, and then rewrite the equation one more time to emphasize the conclusion? Include pauses in the animation to allow the viewer to understand each step.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ShrinkToCenter\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(ShrinkToCenter(square))\n            self.remove(square)"
    },
    {
        "query": "Create an educational animation that visually explains the process of solving a triple integral problem step by step. Start with the triple integral of the function xyz over the cube defined by 0 to 1 on all axes. First, display the integral formula on the screen. Then, guide me through each integration step one at a time, integrating first with respect to x, then y, and finally z, using text explanations placed at the top of the screen before each step. At each step, replace the previous mathematical step with the new integral expression that results from performing the integration. After completing all integration steps, show the final numerical answer. Clear the screen before showing me the concluding answer again to reinforce it. Make sure to pause briefly after introducing new information so I can follow along with the computation.",
        "answer": "\\n         self.play(Transform(text,Text(\"ShowSubmobjectsOneByOne\").shift(UP*2.5)), run_time=0.5)\n        circles2 = VGroup(\n            Circle().shift(UP*0.5),\n            Circle().shift((DOWN+LEFT)*0.5),\n            Circle().shift((DOWN+RIGHT)*0.5)\n        )\n        self.play(ShowSubmobjectsOneByOne(circles2))\n        self.play(Uncreate(circles2))"
    },
    {
        "query": "Can you create an animation that visually demonstrates the process of solving a first-order linear ordinary differential equation (ODE), specifically showing the ODE y' - 3y = 0, and then methodically solving it by using an integrating factor, resulting in the general solution y(x) = Ce^(3x)? The steps should include writing down the equation, displaying text cues for each step like 'Solve the differential equation', 'Use the integrating factor', and 'General solution of the first-order ODE', following with the appropriate mathematical expressions and animations that transform one step to the next. Lastly, can you conclude the animation by clearing the screen and highlighting the general solution?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Showing the function\n        function_label = MathTex(\"f(x) = x^2\", font_size=24).to_edge(UP)\n        self.play(Write(function_label))\n        self.wait(1)\n\n        # Plotting the graph\n        graph = FunctionGraph(lambda x: x**2, x_range=[0,2])\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Area under the graph\n        area = area = Integral(graph, (0, 2))\n        area.set_fill(opacity=0.3)\n        self.play(Write(area))\n        self.wait(1)\n\n        # Integral calculus\n        integral_form = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral_form))\n        self.wait(1)\n\n        # Calculating the integral\n        integral_solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\")\n        self.play(ReplacementTransform(integral_form.copy(), integral_solution))\n        self.wait(1)\n\n        # Evaluating at bounds\n        evaluated_solution = MathTex(r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integral_solution, evaluated_solution))\n        self.wait(1)\n\n        # Conclusion with result\n        self.clear()\n        self.wait(1)\n        self.play(Write(evaluated_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation using Manim that introduces Fourier Series, visually presents an example of a square wave, explains the concept of representing functions as sums of sines and cosines, shows the mathematical equation for a Fourier Series, and explains how partial sums of Fourier Series converge to the function as the number of terms increases?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates the concept of finding the area under a curve using calculus. Specifically, I want to show a parabolic curve on a graph labelled with its equation, highlight the area between the curve and the x-axis from x=1 to x=4, and then display the integral that represents this area. After that, I would like to walk through the steps of calculating the definite integral, showing the antiderivative formula, evaluating it at the limits of integration, and finally presenting the numerical solution. Can you create an animation that accomplishes this?",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nHIGHLIGHT_COLOR = \"#f08a5d\"\n\nconfig.background_color = BACKGROUND_COLOR\n\nclass PrimeFactors(Scene):\n    def construct(self):\n        title = Text(\"Fatores Primos\", color=TEXT_COLOR).to_edge(UP)\n\n        number = Text(\"60 = 2 x 2 x 3 x 5\", color=TEXT_COLOR).next_to(title, DOWN)\n        factors = VGroup(\n            Text(\"2,\", color=HIGHLIGHT_COLOR),\n            Text(\"2,\", color=HIGHLIGHT_COLOR),\n            Text(\"3,\", color=HIGHLIGHT_COLOR),\n            Text(\"5\", color=HIGHLIGHT_COLOR),\n        )\n        factors.arrange(RIGHT, buff=0.2).next_to(number, DOWN)\n\n        braces = Brace(factors, DOWN, color=TEXT_COLOR)\n        braces_text = braces.get_text(\"Fatores Primos\", color=TEXT_COLOR)\n\n        self.add(title)\n        self.play(Write(number))\n        self.play(ReplacementTransform(number.copy(), factors))\n        self.play(GrowFromCenter(braces), Write(braces_text))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that illustrates the concept of the one-dimensional heat equation, shows its steady-state condition, explains the importance of boundary conditions, and finally, revisits the heat equation? The animation should introduce the heat equation, provide a brief explanation of what it represents, transition into showing what happens in a steady state where the solution does not change over time, highlight the necessity of boundary conditions for a specific solution, and conclude by fading out the visual elements related to steady-state and boundary conditions before restating the heat equation once more.",
        "answer": "\\n from manim import *\n\nclass IntroScene(Scene):\n    def construct(self):\n        # Create a text title\n        title = Text(\"Welcome to Manim\").scale(1.5).to_edge(UP)\n\n        # Different geometry shapes\n        square = Square(color=YELLOW).to_edge(LEFT)\n        circle = Circle(color=GREEN).next_to(square, RIGHT)\n        triangle = Triangle(color=BLUE).next_to(circle, RIGHT)\n\n        # Add title and shapes to the scene\n        self.play(Write(title))\n        self.play(ShowCreation(square), ShowCreation(circle), ShowCreation(triangle))\n        self.wait(1)\n\n        # Animate transformation of shapes into a single dot\n        dot = Dot().move_to(square.get_center())\n        self.play(Transform(square, dot), Transform(circle, dot.copy()), Transform(triangle, dot.copy()))\n        self.wait(1)\n\n        # Transform the dot into a text message\n        end_text = Text(\"Let's learn Manim!\").next_to(dot, DOWN)\n\n        self.play(Transform(dot, end_text))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that visually explains the convergence of the series sum from n equals 1 to infinity of 1 over n squared using the p-test? The animation should introduce the series, explain how to use the p-test for convergence by displaying a condition, apply the p-test to show that the series converges because p equals 2 is greater than 1, and conclude by stating that the series is convergent. Can you also ensure that each part of the explanation is displayed clearly before moving on to the next, and at the end, clear everything and display the final conclusion again for emphasis?",
        "answer": "\\n from manim import *\n\nclass WaveAnimationExample(Scene):\n    def construct(self):\n        title = Text(\"Manim Wave Effects\").to_edge(UP)\n        self.play(Write(title))\n\n        subtitle = Text(\"Various wave animations\").next_to(title, DOWN)\n        self.play(Write(subtitle))\n\n        square_wave = Square().set_fill(BLUE, opacity=0.5)\n        self.play(FadeIn(square_wave))\n        self.play(ApplyWave(square_wave))\n        self.play(ApplyWave(square_wave, rate_func=linear))\n        self.play(ApplyWave(square_wave, amplitude=0.2))\n        \n        self.play(FadeOut(square_wave))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated video that explains step by step how to evaluate the definite integral of the sine function from 0 to \u03c0, showing the integral problem, the integration process with the antiderivative, evaluating the bounds, and then revealing the final answer, with written explanations accompanying each step?",
        "answer": "\\n from manim import *\n\nclass EulersFormulaScene(Scene):\n    def construct(self):\n        # Display Euler's formula\n        eulers_formula = MathTex(\"e^{i\\\\theta} = \\\\cos(\\\\theta) + i\\\\sin(\\\\theta)\")\n        self.play(Write(eulers_formula))\n        self.wait(2)\n\n        # Explanation for Euler's formula\n        explanation = Text(\"Euler's formula relates complex exponentials and trigonometry\", font_size=24)\n        self.play(FadeIn(explanation, shift=UP))\n        self.wait(2)\n\n        # Transform theta into pi\n        pi_transform = MathTex(\"e^{i\\\\pi} = \\\\cos(\\\\pi) + i\\\\sin(\\\\pi)\")\n        self.play(TransformMatchingTex(eulers_formula, pi_transform))\n        self.wait(2)\n\n        # Simplify the expression\n        simplified_expression = MathTex(\"e^{i\\\\pi} = -1 + 0 \\\\cdot i\")\n        self.play(ReplacementTransform(pi_transform, simplified_expression))\n        self.wait(2)\n\n        # Show the famous identity\n        identity = MathTex(\"e^{i\\\\pi} + 1 = 0\")\n        self.play(ReplacementTransform(simplified_expression, identity))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"This is one of the most beautiful equations in mathematics\")\n        self.play(Transform(explanation, conclusion))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(eulers_formula), FadeOut(explanation))\n        self.wait(1)"
    },
    {
        "query": "I would like an animated video that visually explains the process of solving a basic definite integral using the power rule of integration. It should start by presenting the problem of integrating x cubed from 0 to 1. Then, it should display a text saying \"Using the power rule of integration\" followed by the formula for the power rule. After this, the video should show the step-by-step substitution of the values into the power rule formula and transform the original problem to reflect this integration step. Next, the animation should update the text to \"Evaluating the definite integral\" and demonstrate how to evaluate the result at the bounds of 0 and 1. Finally, it should display the final solution and conclude by clearing the screen and showing the result by itself. Can you create this educational animation using simple and engaging visuals?",
        "answer": "\\n from manim import *\n\nclass MultiplyMatrix(VMobject):\n    def __init__(self, matrix_1, matrix_2, element_time=1, run_time=3, **kwargs):\n        super().__init__(**kwargs)\n        self.matrix_1 = matrix_1\n        self.matrix_2 = matrix_2\n        self.element_time = element_time\n        self.run_time = run_time\n        self.result_matrix = self.get_result_matrix()\n\n    def get_result_matrix(self):\n        return np.dot(self.matrix_1, self.matrix_2)\n\n    def animate_multiplication(self):\n        animations = []\n        m1_rows, m1_cols = self.matrix_1.shape\n        m2_cols = self.matrix_2.shape[1]\n        for i in range(m1_rows):\n            for j in range(m2_cols):\n                dot_product_anim = []\n                for k in range(m1_cols):\n                    elem_1 = DecimalNumber(self.matrix_1[i, k]).move_to(i * UP + k * LEFT)\n                    elem_2 = DecimalNumber(self.matrix_2[k, j]).move_to(k * UP + j * RIGHT)\n                    product = DecimalNumber(self.matrix_1[i, k] * self.matrix_2[k, j]).move_to(i * UP + j * RIGHT)\n                    dot_product_anim += [\n                        TransformFromCopy(elem_1, product),\n                        TransformFromCopy(elem_2, product),\n                        FadeOut(product)\n                    ]\n                animations.append(AnimationGroup(*dot_product_anim, run_time=self.element_time))\n        return Succession(*animations, lag_ratio=1)\n\nclass MatrixScene(Scene):\n    def construct(self):\n        matrix_1 = np.array([[1, 2], [3, 4]])\n        matrix_2 = np.array([[2, 0], [1, 2]])\n\n        matrix_mobject_1 = Matrix(matrix_1).to_edge(UP)\n        matrix_mobject_2 = Matrix(matrix_2).to_edge(DOWN)\n\n        self.play(Write(matrix_mobject_1), Write(matrix_mobject_2))\n\n        multiply_matrix = MultiplyMatrix(matrix_1, matrix_2)\n        self.play(multiply_matrix.animate_multiplication())\n\n        result_matrix_mobject = Matrix(multiply_matrix.result_matrix).move_to(ORIGIN)\n        self.play(TransformFromCopy(matrix_mobject_1, result_matrix_mobject))\n        self.play(TransformFromCopy(matrix_mobject_2, result_matrix_mobject))\n\n        self.wait()"
    },
    {
        "query": "I would like an animation that visually demonstrates how to solve a triple integral in spherical coordinates. The animation should start by presenting the problem of integrating the volume of a sphere using the function rho squared times the sine of phi over the regions from 0 to pi for theta, from 0 to pi/2 for phi, and from 0 to 1 for rho. Then, step by step, it should show the solution process by first integrating with respect to rho and simplifying that part, followed by integrating the resulting expression with respect to phi, and finally with respect to theta. After each integration step, include some text that tells the viewer which variable we are integrating with respect to next. End the animation with the final solution to the integral and a text conclusion stating that the solution is negative pi over 3.",
        "answer": "\\n from manim import *\n\nclass ExampleIntegrationByParts(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int x e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Step for setting u and dv\n        set_uv = MathTex(r\"u = x, \\ dv = e^x \\,dx\")\n        self.play(Write(set_uv))\n        self.wait(2)\n\n        # Explanation for integration by parts\n        parts_formula = MathTex(r\"\\int u \\,dv = uv - \\int v \\,du\")\n        self.play(FadeIn(parts_formula))\n        self.wait(2)\n\n        # Steps for computing the integration by parts\n        integration_steps = MathTex(r\"= x e^x - \\int e^x \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), integration_steps))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= x e^x - e^x + C\")\n        self.play(ReplacementTransform(integration_steps, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(parts_formula), FadeOut(set_uv))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you please create an animated video that explains step by step how to solve the double integral problem in polar coordinates, specifically the integral from 0 to pi of the integral from 0 to 1 of r squared times sine theta with respect to r and theta? I would like each step of the problem solving process to be written out and displayed, along with verbal descriptions of what to integrate first. Additionally, show the antiderivative as it is being calculated for each integral, with a final display of the computed numerical value of the entire integral.",
        "answer": "\\n from manim import *\n\nclass MultipleWavesScene(Scene):\n    def construct(self):\n        wave_list = [Wave(frequency=i, amplitude=0.5) for i in range(1, 5)]\n        waves_group = VGroup(*wave_list).arrange(DOWN, buff=0.5).move_to(ORIGIN)\n        self.add(waves_group)\n        self.play(*[wave.create_wave() for wave in wave_list])\n        self.wait(4)"
    },
    {
        "query": "Create an animation that visually explains how to calculate the definite integral of the function x squared from x equals 2 to x equals 3, step by step, including the power rule for integration, evaluating at the upper and lower bounds, subtracting the results, simplifying the expression, and presenting the final answer.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Display the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u\")\n        self.play(FadeIn(wave_eq))\n        self.wait(1)\n\n        # Explanation of the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Specific form in one dimension\n        explanation2 = Text(\"In one dimension, it simplifies to:\", font_size=24).next_to(explanation1, DOWN)\n        self.play(GrowFromCenter(explanation2))\n        one_d_wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Transform(wave_eq, one_d_wave_eq))\n        self.wait(2)\n\n        # Displaying a possible solution\n        solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        explanation3 = Text(\"Solutions can be represented as a sum of two functions.\", font_size=24).next_to(explanation1, DOWN)\n        self.play(Transform(explanation2, explanation3))\n        self.play(Transform(wave_eq, solution))\n        self.wait(2)\n\n        # Concluding the solutions are waves\n        explanation4 = Text(\"These represent waves moving in opposite directions.\", font_size=24).next_to(explanation1, DOWN)\n        self.play(Transform(explanation2, explanation4))\n        self.wait(2)\n\n        # Clear scene\n        self.play(FadeOut(wave_eq), FadeOut(explanation1), FadeOut(explanation2))\n        self.wait(1)"
    },
    {
        "query": "I would like an educational animation that starts by displaying the mathematical function f(x) = x^2 on the screen. Then, I want the animation to present a task to calculate the area under this curve from x = 0 to x = 2 with a text description. Next, the animation should show the formula for the definite integral of x squared from 0 to 2, as a means to find that area under the curve, with an added text explanation about using the definite integral. After that, it should transform the integral into the antiderivative, which is (1/3)x^3 evaluated from 0 to 2, and finally show the numerical result of the area calculation, which is 8/3. At the end, clean up the animation so only the final numerical result is displayed.",
        "answer": "\\n from manim import *\n\nclass HydrogenScene(Scene):\n    def construct(self):\n        hydrogen = self.hydrogen_atom()\n        self.play(ShowCreation(hydrogen))\n        self.wait(2)\n\n    def hydrogen_atom(self) -> Mobject:\n        electron_orbit = self.get_electron_orbit()\n        proton = self.proton()\n        electron = self.electron()\n        return VGroup(proton, electron_orbit, electron)\n\n    def get_electron_orbit(self) -> Mobject:\n        orbit = Circle(radius=1, color=BLUE)\n        orbit.set_stroke(width=2)\n        return orbit\n\n    def proton(self) -> Mobject:\n        return circle_with_text(0.3, \"P$^+$\", RED, 24, BLACK, 2, RED)\n\n    def electron(self) -> Mobject:\n        electron = Dot(point=RIGHT, radius=0.08, color=BLUE)\n        electron.shift(UP * self.get_electron_orbit().radius)\n        orbit_animation = Rotate(electron, angle=2 * PI, about_point=ORIGIN, rate_func=linear)\n        self.play(orbit_animation, run_time=5, rate_func=linear)\n        return electron\n\ndef circle_with_text(\n    radius: float, txt: str, color=WHITE, font_size: int = 10, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE\n) -> Mobject:\n    circle = Circle(radius, color=color, fill_opacity=1).set_fill(color=fill_color)\n    text = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(circle, text).move_to(ORIGIN)"
    },
    {
        "query": "I would like to create an educational animation that explains the concept of Fourier series. Can you show, step by step, the Fourier series equation and then provide a visual breakdown of each component in the equation? Also, can you include an explanation of how Fourier series decomposes periodic functions, demonstrate the idea of harmonics in the series, and illustrate how a finite number of terms can approximate a function? I'd like each part of the explanation to be accompanied by corresponding equations and text summaries to reinforce the learning.",
        "answer": "\\n from manim import *\n\nclass IntegrationByPartsExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using integration by parts\n        explanation1 = Text(\"Use integration by parts\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration by parts formula step\n        formula_step = MathTex(r\"\\int u \\,dv = uv - \\int v \\,du\")\n        self.play(Write(formula_step))\n        self.wait(2)\n\n        # Choosing u and dv\n        u_and_dv = MathTex(r\"u = x, \\quad dv = e^x \\,dx\")\n        self.play(Write(u_and_dv))\n        self.wait(2)\n\n        # Calculating du and v\n        du_and_v = MathTex(r\"du = dx, \\quad v = e^x\")\n        self.play(Write(du_and_v))\n        self.wait(2)\n\n        # Applying the integration by parts\n        integration_step = MathTex(r\"x e^x - \\int e^x \\,dx\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        # Explanation for the simple integral\n        explanation2 = Text(\"Integrate e^x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= x e^x - e^x + C\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(2)\n\n        # Conclude the problem\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation using Manim that visualizes the concept of finding the area under a curve, specifically showing the area under the function f(x) = x^2 from x=0 to x=2? I'd like the video to include the following elements:\n\n1. Blue-colored axes with an x-range from 0 to 5 and y-range from 0 to 10, with appropriate numerical labels.\n2. The function f(x) = x^2 should be plotted in red on the graph.\n3. A shaded green area under the curve between x=0 and x=2 to represent the area we're interested in.\n4. A moving label that shows the integral equation for the area A = \u222b_0^2 x^2 dx in a clear manner and places itself above the shaded area.\n5. An animation transforming the integral label to show the intermediate step of the area calculation as A = [1/3 x^3]_0^2.\n6. Finally, show the exact calculation of the area using the fundamental theorem of calculus and the arithmetic to find the numerical value of the area.\n7. End the animation by clearing the graph and only showing the final calculated value of the area.\n8. Also, Can you make sure each of the elements appears sequentially and make sure there are pauses where appropriate to give the viewers time to understand each step?",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_GREEN_COLOR = \"#2ecc71\"\nLIGHT_YELLOW_COLOR = \"#f1c40f\"\nLIGHT_BLUE_COLOR = \"#3498db\"\nLIGHT_PURPLE_COLOR = \"#9b59b6\"\n\ndef ease_in_quad(t):\n    return rate_functions.smooth(t, inflection=10.0)\n\ndef GeometricSquare(size, color):\n    rect = Square(side_length=size, color=color, fill_opacity=0.5)\n    text = Tex(str(size), color=color)\n    text.scale(0.5 + 0.5 * min(1, size))\n    text.move_to(rect.get_center())\n\n    return Group(rect, text)\n\nclass PowersOfTwoScene(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Powers of Two\", color=LIGHT_GREEN_COLOR)\n        title.scale(2)\n        title.to_edge(UP)\n\n        subtitle = Tex(\"2, 4, 8, 16, 32, ...\", color=TEXT_COLOR).scale(1.5)\n        subtitle.next_to(title, DOWN)\n\n        self.add(title)\n        self.play(FadeInFrom(subtitle, direction=DOWN), run_time=1)\n        self.wait(1)\n\n        squares = VGroup()\n        previous_square = None\n        for i, x in enumerate([2 ** (i + 1) for i in range(5)]):\n            square = GeometricSquare(size=x, color=LIGHT_BLUE_COLOR if i % 2 == 0 else LIGHT_PURPLE_COLOR)\n            square.move_to(3 * RIGHT + 2 * DOWN if previous_square is None else previous_square.get_center() + 1.5 * RIGHT)\n\n            if previous_square:\n                self.play(Transform(previous_square, square), run_time=0.75)\n            else:\n                self.play(FadeIn(square))\n\n            previous_square = square\n            squares.add(square)\n            self.wait(0.5)\n\n        self.play(squares.animate.arrange(RIGHT, buff=0.2).scale(0.6).move_to(ORIGIN))\n        self.wait(1)\n\n        for square in squares:\n            self.play(square.animate.set_color(LIGHT_YELLOW_COLOR), run_time=0.5)\n            self.wait(0.25)\n\n        self.play(FadeOut(VGroup(*self.mobjects)))\n        self.wait(0.5)"
    },
    {
        "query": "I would like to create an educational animation that visually explains how to evaluate a double integral step by step. The double integral I want to focus on is the integration of (x^2 + y^2) over the region bounded by y=-1 to y=1 and x=0 to x=1. The animation should first display the integral, then show the integration with respect to y, replace the solved part with the new expression, and then do the same for the integration with respect to x. After each step, the animation should pause to give viewers time to understand before proceeding. At the final stage, the animation should display the evaluated result of the integral. Can you create such an animation sequence for me?",
        "answer": "\\n from manim import *\nimport numpy as np\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.pooling import PoolingLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 8.0\nconfig.frame_width = 14.0\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define the neural network structure\n        nn = NeuralNetwork([\n            Convolutional2DLayer(\n                num_feature_maps=16,\n                feature_map_size=5,\n                kernel_size=3,\n                stride=1,\n                padding='same',\n                activation='relu'\n            ),\n            PoolingLayer(\n                pool_size=2,\n                stride=2,\n                pooling_type='max',\n            ),\n            Convolutional2DLayer(\n                num_feature_maps=32,\n                feature_map_size=5,\n                kernel_size=3,\n                stride=1,\n                padding='valid',\n                activation='relu',\n            ),\n            PoolingLayer(\n                pool_size=2,\n                stride=2,\n                pooling_type='max',\n            ),\n            FeedForwardLayer(120),\n            FeedForwardLayer(10)\n        ])\n        \n        # Place the neural network on the scene\n        nn.move_to(ORIGIN)\n        \n        # Create animations\n        neural_network_intro = Create(nn)\n        \n        # Play animations\n        self.play(neural_network_intro)\n        self.wait()\n        \n        # Show the forward pass through the neural network\n        forward_pass_anim = nn.make_forward_pass_animation()\n        self.play(forward_pass_anim)\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that explains Simple Harmonic Motion (SHM) in physics. It should begin by displaying the differential equation for SHM on screen and then introduce the concept of angular frequency with an explanation. It should also show the transformation of the original SHM equation with the introduction of angular frequency. Next, can you illustrate the general solution of the SHM equation, and mention how initial conditions can determine the constants in the solution? Finally, I\u2019d love to see a visual example of SHM, such as a dot moving back and forth in simple harmonic motion, and end with a closing statement that signifies the end of the demonstration. The entire explanation throughout the animation should be both visual and text-based for clarity. Can you do something like that?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Introduce the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(FadeIn(wave_eq))\n        self.wait(1)\n\n        # Mention it's a second-order PDE\n        explanation1 = Text(\"This is a second-order linear PDE.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the general solution\n        general_solution = MathTex(r\"u(x, t) = F(x - ct) + G(x + ct)\")\n        self.play(Transform(wave_eq, general_solution))\n        self.wait(2)\n\n        # Comment on the solution\n        explanation2 = Text(\"It represents waves moving in both directions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Special solution case\n        special_solution = MathTex(r\"u(x, t) = A\\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(general_solution, special_solution))\n        self.wait(2)\n\n        explanation3 = Text(\"This is a specific sinusoidal wave solution.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(3)\n\n        # Clear the screen\n        self.play(FadeOut(special_solution), FadeOut(explanation1))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using ManimCE that illustrates the concept of the second-order wave equation, showcases the general form of its solution including a brief description, and concludes by highlighting how specific solutions would depend on initial and boundary conditions?",
        "answer": "\\n class Grouping(Scene):\n    def construct(self):\n        red_dot = Dot(color=RED)\n        green_dot = Dot(color=GREEN).next_to(red_dot, RIGHT)\n        blue_dot = Dot(color=BLUE).next_to(red_dot, UP)\n        dot_group = VGroup(red_dot, green_dot, blue_dot)\n        dot_group.to_edge(RIGHT)\n        self.add(dot_group)\n\n        circles = VGroup(*[Circle(radius=0.2) for _ in range(10)])\n        circles.arrange(UP, buff=0.5)\n        self.add(circles)\n\n        stars = VGroup(*[Star(color=YELLOW, fill_opacity=1).scale(0.5) for _ in range(20)])\n        stars.arrange_in_grid(4, 5, buff=0.2)\n        self.add(stars)"
    },
    {
        "query": "Could you create an animation using a Python library that shows a 4x4 grid of alternating atoms, where even-indexed positions have a hydrogen atom and odd-indexed positions have a chlorine atom, with hydrogen represented by a small white circle with an \"H\" in the center and chlorine by a slightly larger green circle with \"Cl\" in the center, and have the created grid displayed on the screen for 2 seconds?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin\\theta dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin\\theta]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Middle integral evaluation\n        middle_evaluation = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3}\\sin\\theta d\\theta\")\n        self.play(ReplacementTransform(inner_integral, middle_evaluation))\n        self.wait(1)\n\n        # Explanation for the final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [-\\frac{1}{3}\\cos\\theta]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(middle_evaluation, final_solution))\n        self.wait(1)\n\n        # Simplify the final solution\n        simplified_solution = MathTex(r\"= -\\frac{1}{3}(\\cos\\pi - \\cos0)\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Result of the final integral\n        result = MathTex(r\"= \\frac{2}{3}\")\n        self.play(Transform(final_solution, result))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that shows the concept of a lithium-ion moving through the grid of metal oxides in a battery, along with an electron. The animation should start with both a grid of metal oxides and a separate set of carbon grids at the top of the screen. There should also be a lithium ion and an electron positioned together with the lithium ion below the carbon grids. I want the lithium ion to move smoothly across the screen from left to right and then down, tracing a specific path, while an electron follows it along a similar but slightly different path that mimics the main movements of the lithium ion but is offset a bit downward. The electron's path should have it move there and back with a noticeable pause in the middle of its journey to signify it\u2019s interacting with the metal oxides. Can we have the entire movement of both the lithium ion and the electron synchronized and animated in such a way that it's visually pleasing, with a slight delay between their movements?",
        "answer": "\\n from manim import *\n\nclass AreaBetweenCurves(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 4, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Labels for the axes\n        x_label = axes.get_x_axis_label(MathTex(\"x\"))\n        y_label = axes.get_y_axis_label(MathTex(\"y\")).shift(LEFT)\n\n        # Functions\n        func_graph1 = axes.plot(lambda x: x**2, color=RED)\n        func_graph2 = axes.plot(lambda x: 0.8*x**2 + 1, color=GREEN)\n\n        # Area between curves\n        area = axes.get_area(func_graph2, [0, 2], bounded_graph=func_graph1, color=ORANGE, opacity=0.5)\n\n        # Display the axes, labels, and functions\n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.play(Create(func_graph1), Create(func_graph2))\n        self.wait(1)\n\n        # Highlight the area\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Problem setup\n        problem_text = MathTex(r\"\\text{Find area between }\", \"y = x^2\", r\"\\text{ and }\", \"y = 0.8x^2 + 1\")\n        problem_text.to_edge(UP)\n        self.play(Write(problem_text))\n        self.wait(1)\n\n        # Solving step 1: highlighting the functions\n        self.play(Indicate(func_graph1), Indicate(func_graph2))\n        self.wait(1)\n\n        # Solving step 2: showing the integral\n        integral_text = MathTex(\n            r\"\\int_{0}^{2} \", \"(0.8x^2 + 1)\", \" - \", \"(x^2)\", r\"\\, dx\"\n        ).to_edge(DOWN)\n        self.play(Write(integral_text))\n        self.wait(1)\n\n        # Solving step 3: show the calculated area's value\n        calculated_area = MathTex(r\"= \", \"4/3\").next_to(integral_text, DOWN)\n        self.play(Write(calculated_area))\n        self.wait(1)\n\n        # Conclusion: clear and show the final answer\n        self.clear()\n        final_answer = MathTex(\n            r\"\\text{Area} = \\frac{4}{3}\"\n        ).scale(1.5).to_edge(DOWN)\n        self.play(Write(final_answer))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an educational animation that shows a simple water molecule which consists of two hydrogen atoms and one oxygen atom, with each atom represented as a colored circle. The oxygen atom should be larger and colored blue to stand out as the central element, while the hydrogen atoms should be smaller and white. There should be lines connecting the hydrogen atoms to the oxygen atom to represent the chemical bonds. Additionally, I want each atom to be labeled with its respective chemical symbol, 'O' for oxygen and 'H' for hydrogen, directly on the atoms. Once constructed, I want the molecule to increase in size to become more noticeable and then rotate around in the scene to be viewed from different angles. Can you create an animation like this, and end with the molecule on screen long enough to make an impression?",
        "answer": "\\n from manim import *\n\nclass BouncingBallScene(Scene):\n    def construct(self):\n        floor = Line(LEFT * 5, RIGHT * 5).shift(DOWN * 3)\n        ball = Circle(radius=0.5, fill_color=BLUE, fill_opacity=0.7).shift(UP * 2)\n\n        self.play(Write(floor))\n        self.play(DrawBorderThenFill(ball))\n        self.wait(1)\n\n        bounce_path = [ball.get_center(), DOWN * 2 + RIGHT * 0.5, UP * 1 + RIGHT * 1, DOWN * 2 + RIGHT * 1.5, UP * 0.5 + RIGHT * 2]\n        for k in range(len(bounce_path) - 1):\n            anim = AnimationGroup(\n                ApplyMethod(ball.move_to, bounce_path[k + 1], path_arc=-np.pi / 4),\n                rate_func=linear,\n                lag_ratio=0.5\n            )\n            self.play(anim)\n            self.wait(0.5)\n\n        self.play(FadeOut(ball), FadeOut(floor))"
    },
    {
        "query": "\"I would like to create an animation that shows three different types of particles: an electron, an oxygen particle, and a metal particle. Initially, I want these particles to appear onto the screen from different positions; the electron should come from the left-top side, the oxygen from directly above, and the metal particle from the right-top side. After they appear, each particle should move in a distinct direction over a period of 2 seconds: the electron should travel towards the right across the screen, the oxygen should sink down to the bottom of the screen, and the metal particle should head towards the left across the screen. Once the particles have moved to their new positions, there should be a brief pause before the animation concludes. Can you create this animation for me?\"",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation2, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated video of a simple model of an atom where the nucleus is composed of an equal number of protons and neutrons, and electrons are orbiting around the nucleus. The protons should be represented by red circles with a positive sign, neutrons by grey circles with a zero, and electrons by smaller blue circles with a negative sign. The electrons should start by appearing in their orbits and then move around the nucleus in a continuous loop. Can you create such an animation to help visualize the structure and dynamics of an atom?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2} \\int_{0}^{\\pi} r \\sin(\\theta) d\\theta\\,dr\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to \\(\\theta\\) first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2} [-\\cos(\\theta)]_{0}^{\\pi} dr\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Solution after inner integral\n        solved_inner = MathTex(r\"= \\int_{0}^{2} [-(-1) - (-1)] dr\")\n        self.play(ReplacementTransform(inner_integral, solved_inner))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\(r\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_solution = MathTex(r\"= \\left[ 2r \\right]_{0}^{2}\")\n        self.play(ReplacementTransform(solved_inner, final_solution))\n        self.wait(1)\n\n        # Calculation of the final solution\n        calculated_solution = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(final_solution, calculated_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation for me where the first part shows a simple 5 by 5 grid made with squares, centered on the screen, and the second part displays a red dot traveling along a complex, hexagonal path defined by straight blue lines connecting UP, UP+RIGHT, DOWN+RIGHT, DOWN, DOWN+LEFT, UP+LEFT, and returning to UP again? I'd like the movement of the red dot along the path to be smooth and occur over the course of 4 seconds.",
        "answer": "\\n from manim import *\n\nclass ParametricCurveExample(Scene):\n    def construct(self):\n        # Parametric curve definition\n        parametric_func = ParametricFunction(\n            lambda t: np.array([\n                1.5 * np.sin(t),\n                1.5 * np.cos(t),\n                0\n            ]), t_range = np.array([0, 2*PI]), color = RED\n        )\n\n        # Display the curve\n        self.play(Create(parametric_func))\n        self.wait(2)\n\n        # Add derivative vector\n        derivative = Arrow(\n            start = ORIGIN, \n            end = np.array([1.5, 0, 0]), \n            buff = 0,\n            color = YELLOW\n        )\n        derivative_label = MathTex(r\"\\vec{s}'(t)\", color=YELLOW).next_to(derivative, UP)\n\n        self.play(GrowArrow(derivative), Write(derivative_label))\n        self.wait(2)\n\n        # Display tangent line at a point on the curve\n        tangent_line = Line(\n            start = np.array([1.5, 0, 0]),\n            end = np.array([-1.5, 0, 0]),\n            color = GREEN\n        )\n\n        self.play(Create(tangent_line))\n        self.wait(1)\n\n        # Show the point of tangency\n        dot = Dot(\n            point = np.array([1.5, 0, 0]),\n            color = BLUE\n        )\n\n        self.play(FadeIn(dot))\n        self.wait(1)\n\n        # Label the point of tangency\n        point_label = MathTex(r\"(1.5, 0)\", color=BLUE).next_to(dot, DOWN)\n\n        self.play(Write(point_label))\n        self.wait(2)\n\n        # Clean the scene\n        self.clear()\n        self.play(FadeIn(parametric_func), FadeIn(dot), FadeIn(point_label))\n        self.wait(2)"
    },
    {
        "query": "I would like an animated video that visualizes a simple atom model. The video should begin by fading in a blue nucleus representing eight protons and eight neutrons, labeled accordingly. Around this nucleus, electrons should orbit in two separate paths: the first orbit with two electrons and the second orbit with four electrons. The electrons themselves should be tiny red dots moving around grey elliptical paths that represent their orbits. The animation should show the electrons starting to move along these paths one after the other, with a slight delay between each electron's movement. Once all electrons are in motion, the animation should play for a short while before ending.",
        "answer": "\\n from manim import *\n\nclass SimpleHarmonicMotion(Scene):\n    def construct(self):\n        # Display the differential equation for Simple Harmonic Motion\n        differential_eq = MathTex(r\"\\frac{d^2x}{dt^2} + \\frac{k}{m}x = 0\")\n        self.play(Write(differential_eq))\n        self.wait(2)\n\n        # Explain the transformation to the angular frequency\n        explanation1 = Text(\"Introduce angular frequency \", r\"\\(\\omega=\\sqrt{\\frac{k}{m}}\\)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(3)\n\n        # Show the transformed equation\n        transformed_eq = MathTex(r\"\\frac{d^2x}{dt^2} + \\omega^2 x = 0\")\n        self.play(ReplacementTransform(differential_eq.copy(), transformed_eq))\n        self.wait(2)\n\n        # Explain the solution process\n        explanation2 = Text(\"General solution of SHM\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Write down the general solution\n        general_solution = MathTex(r\"x(t) = A \\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(transformed_eq, general_solution))\n        self.wait(2)\n\n        # State the initial conditions\n        initial_conditions = Text(\"Given initial conditions determine \\(A\\) and \\(\\phi\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(initial_conditions))\n        self.wait(3)\n\n        # Show the system in motion (example)\n        oscillator = Dot().shift(LEFT * 2)\n        path = TracedPath(oscillator.get_center, stroke_width=6, stroke_color=YELLOW)\n        self.add(path)\n        self.play(MoveAlongPath(oscillator, Circle(radius=2).shift(LEFT * 2)), run_time=4, rate_func=lambda t: there_and_back(t))\n        self.wait(2)\n\n        # Concluding the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of the SHM demonstration.\", font_size=30)))\n        self.wait(3)"
    },
    {
        "query": "I want to create an educational animation that illustrates a simplified chemical reaction where a lithium ion and an electron move towards a grid representing a metal oxide. The lithium ion should start from the top left corner and the electron from the bottom right corner, converging on the metal oxide in the center. Once they reach the metal oxide, a reaction should be indicated visually by flashes at their respective meeting points. Subsequently, both the lithium ion and the electron should disappear, and the metal oxide grid should become semi-transparent to represent a change caused by the reaction. The final scene should hold for a short duration to let viewers reflect on the process before it ends. Can you help me draft the script for this animation without using any technical jargon or coding language?",
        "answer": "\\n from manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x^2 dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using the power rule\n        explanation1 = Text(\"Use the power rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integral_step = MathTex(r\"\\int x^2 dx = \\frac{1}{3} x^3 + C\")\n        self.play(ReplacementTransform(problem, integral_step))\n        self.wait(2)\n\n        # Show area under parabola\n        graph = FunctionGraph(lambda x: x**2, x_range=[-3,3], color=BLUE)\n        area = graph.get_area(x_range=[0,2], color=GREEN, opacity=0.5)\n        self.play(ShowCreation(graph), FadeIn(area, rate_func=smooth, run_time=3))\n        self.play(FadeIn(explanation1, shift=UP))\n        self.wait(1)\n\n        # Clear the scene and show final solution\n        self.play(FadeOut(graph), FadeOut(area), FadeOut(explanation1))\n        self.wait(1)\n        final_solution = MathTex(r\"\\frac{1}{3} x^3 + C\")\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation that shows a chemical reaction where an electron and an oxygen molecule come together to form a metal oxide with the formula \\( \\text{Me}_2\\text{O}_3 \\). The electron and the oxygen molecule should appear on screen, move together, and then transform into the metal oxide on the right side of the screen. Can you design an animation that represents this chemical reaction process visually?",
        "answer": "\\n class EasingFunctionComparison(Scene):\n    def construct(self):\n        rate_function_names = [\n            \"linear\", \"ease_in_quad\", \"ease_out_quad\",\n            \"ease_in_out_quad\", \"ease_in_cubic\", \"ease_out_cubic\",\n        ]\n        colors = color_gradient([BLUE, GREEN, YELLOW, ORANGE, RED], len(rate_function_names))\n\n        easing_squares = VGroup()\n        for name, color in zip(rate_function_names, colors):\n            square = Square(size=0.5)\n            square.set_fill(color, opacity=0.9)\n            label = Text(name.replace(\"_\", \" \").title(), font_size=18)\n            label.next_to(square, DOWN)\n            combined = VGroup(square, label)\n            easing_squares.add(combined)\n\n        easing_squares.arrange_in_grid(rows=2, cols=3, buff=1)\n        self.add(easing_squares)\n\n        # Add a thick line to represent progression\n        progression_line = Line(start=4*LEFT, end=4*RIGHT, stroke_width=10)\n        progression_line.next_to(easing_squares, DOWN, buff=1)\n        self.add(progression_line)\n\n        # Marker for the line\n        progression_marker = Dot(color=RED).move_to(progression_line.get_start())\n        self.add(progression_marker)\n\n        self.wait()\n        # Animate squares with different easing functions and marker on the line\n        animations = []\n        for ind, name in enumerate(rate_function_names):\n            rate_func = getattr(rate_functions, name)\n            animation = easing_squares[ind].animate(rate_func=rate_func).shift(4*DOWN)\n            animations.append(animation)\n\n        # Animate all squares simultaneously with the line marker\n        self.play(\n            AnimationGroup(*animations, lag_ratio=0.1),\n            UpdateFromAlphaFunc(\n                progression_marker,\n                lambda m: m.move_to(progression_line.point_from_proportion(self.time / 4)),\n                run_time=4,\n                rate_func=linear\n            )\n        )\n        self.wait()"
    },
    {
        "query": "Could you create an educational animation that shows a simple chemical bonding scenario with an oxygen molecule, a sodium atom, and a chlorine atom, where the oxygen is represented by two bonded spheres, sodium is a single metal sphere, and chlorine is a single negatively charged sphere? First, assemble them in a line with the oxygen molecule in the center, sodium on the left, and chlorine on the right. Then, after showing them briefly, make the sodium and chlorine atoms move closer to the oxygen molecule as if they are bonding, and then move the sodium atom above and the oxygen and chlorine atoms below to indicate a reaction or transformation. Finish the animation by fading out all the atoms and molecules.",
        "answer": "\\n from manim import *\n\nclass AreaUnderGraph(Scene):\n    def construct(self):\n        # Plotting the graph of the function\n        axes = Axes(x_range=[0, 5], y_range=[0, 10], axis_config={\"color\": BLUE})\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='y=x^2')\n\n        # Area under graph (Illustration of the integral)\n        area = axes.get_area(graph, x_range=(0, 2), color=BLUE, opacity=0.3)\n\n        # Displaying Area under Graph problem\n        area_problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n\n        # Set up the scene\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(1)\n        self.play(Write(area_problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation = Text(\"Find the area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Performing the integration\n        integration_step = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(ReplacementTransform(area_problem, integration_step))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3\", r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), FadeOut(graph_label), FadeOut(explanation))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create a simple animated diagram of a water molecule using the Manim library where you show a blue oxygen atom in the center with its symbol \"O\" inside, two grey hydrogen atoms each labeled with the symbol \"H\", and connect them with lines to represent chemical bonds? The atoms should fade in to form the molecule, stay on screen briefly, and then fade out.",
        "answer": "\\n from manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Equation of heat conduction\n        heat_eq = MathTex(r\"\\frac{\\partial u}{\\partial t} = \\alpha^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(heat_eq))\n        self.wait(1)\n\n        # Explanation of heat equation\n        explanation1 = Text(\"This is the one-dimensional heat equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Steady-state solution\n        explanation2 = Text(\"In steady state, the solution does not change over time.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Heat steady-state equation\n        steady_state_eq = MathTex(r\"\\frac{d^2 u}{dx^2} = 0\")\n        self.play(ReplacementTransform(heat_eq, steady_state_eq))\n        self.wait(1)\n\n        # Explanation of boundary conditions\n        explanation3 = Text(\"Boundary conditions are needed for a specific solution.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Concluding the example\n        self.play(FadeOut(explanation1), FadeOut(steady_state_eq))\n        self.wait(1)\n\n        # Restating the heat equation\n        self.play(Write(heat_eq))\n        self.wait(1)"
    },
    {
        "query": "I would like an animation that starts by creating a 5 by 5 grid of red circles, each labeled with the text \"Li+\" representing lithium ions. Then I want an animation of a small white electron moving in a complex path around and through the lithium ion grid. The electron's path should include upwards, downwards, and diagonal movements, but it should pause momentarily at certain points before continuing on the path. It's important that the electron's animation is smooth and takes a total of 3 seconds to complete the journey around the grid. Can you create and show me this animated scene?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{\\sqrt{1-y^2}} x^2 dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to x first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{3}x^3]_{0}^{\\sqrt{1-y^2}} dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{3}(1-y^2)^{\\frac{3}{2}} dy\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for evaluation\n        explanation3 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution (elaborate as necessary for the math at hand)\n        final_solution = MathTex(r\"= \\frac{1}{3} \\int_{0}^{1} (1-y^2)^{\\frac{3}{2}} dy\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation video using ManimCE that demonstrates an electron moving towards an oxygen molecule, followed by a transition to a grid of metal oxide molecules moving upwards while the electron moves to the center of the grid? Ensure that the electron starts on the left side of the screen, the oxygen molecule on the right, and the grid appears at the bottom of the screen. The animation should end with all the molecules and the electron fading out.",
        "answer": "\\n from manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Displaying the PDE\n        pde = MathTex(r\"\\frac{\\partial u}{\\partial t} - \\alpha^2 \\nabla^2 u = 0\")\n        self.play(Write(pde))\n        self.wait(1)\n\n        # Explanation for the heat equation\n        explanation1 = Text(\"This PDE represents the Heat Equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution form\n        explanation2 = Text(\"The solution describes how heat evolves over time.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying separation of variables\n        separation_of_vars = MathTex(r\"u(x, t) = X(x)T(t)\")\n        self.play(Transform(pde, separation_of_vars))\n        self.wait(1)\n\n        # Displaying the separated equations\n        separated_pde = MathTex(r\"\\frac{T'}{\\alpha^2 T} = \\frac{X''}{X} = -\\lambda\")\n        self.play(Write(separated_pde))\n        self.wait(2)\n\n        # Explanation for boundary conditions\n        explanation3 = Text(\"Boundary conditions will give specific solutions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(separation_of_vars))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video that depicts a checkerboard pattern of metal and oxygen atoms to visually represent a metal oxide crystal structure. The metals should alternate colors with the oxygen atoms, clearly distinguishing the two types. Each metal should have the label \"Co\" as if it's a cobalt atom, and each oxygen should have the label \"O\" with the charge 2- written as a superscript. The structure should consist of a grid with specific dimensions, let's say 4 rows and 3 columns, and it would be nice if the atoms appeared one by one to create a dynamic effect. Can you create a simple and educational animation to explain this concept?",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^\\frac{\\pi}{2} \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integral of sine\n        explanation1 = Text(\"Integrate the sine function\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^\\frac{\\pi}{2}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Evaluation step\n        evaluation_step = MathTex(r\"= [-\\cos(\\frac{\\pi}{2})] - [-\\cos(0)]\")\n        self.play(Transform(integration_step, evaluation_step))\n        self.wait(1)\n\n        # Explanation for evaluating the result\n        explanation2 = Text(\"Evaluate the cosine values at the bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 1 - (-1)\")\n        self.play(ReplacementTransform(evaluation_step, final_solution))\n        self.wait(1)\n\n        # Simplify final solution\n        final_simplified = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(final_solution, final_simplified))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_simplified))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation of an electron moving back and forth in a straight line with a brief pause at the end of its motion? The motion should start from the left side of the screen, have an arc upwards in the middle, and end at the right side of the screen before reversing back along the same path.",
        "answer": "\\n from manim import *\n\nclass ParticleScene(Scene):\n    def construct(self):\n        electron_particle = electron()\n        oxygen_particle = oxygen()\n        metal_particle = metal()\n\n        # Place the particles on screen\n        electron_particle.shift(LEFT * 2 + UP * 2)\n        oxygen_particle.shift(UP * 2)\n        metal_particle.shift(RIGHT * 2 + UP * 2)\n\n        self.play(FadeIn(electron_particle), FadeIn(oxygen_particle), FadeIn(metal_particle))\n        \n        # Movement animations\n        self.play(\n            electron_particle.animate.shift(RIGHT * 4),\n            oxygen_particle.animate.shift(DOWN * 2),\n            metal_particle.animate.shift(LEFT * 4),\n            run_time=2\n        )\n\n        self.wait(1)"
    },
    {
        "query": "I\u2019d like to create an educational animation showing the movement of electrons through a grid of metal and oxygen ions. Can you depict an electron moving in a zigzag path through a grid to represent conductivity? Furthermore, I want to represent positive and negative ions moving in opposite directions. After that, can you show two separate smaller grids, one made of lithium ions and another of carbon atoms, entering from the sides of the screen? Each element\u2019s grid should be distinct, and they should settle to either side of the main grid. It\u2019s important that all movements are smooth and that you can clearly differentiate between the different types of ions and atoms. The final animation should hold on the screen for a moment before ending.",
        "answer": "\\n from manim import *\n\nclass ElectricFieldLines(Scene):\n    def construct(self):\n        charge = Dot(ORIGIN, color=RED)\n        charge_label = Tex(\"+\").next_to(charge, UP)\n\n        self.play(FadeIn(charge), Write(charge_label))\n        self.wait(1)\n\n        field_lines = StreamLines(\n            lambda p: np.array([p[0], p[1], 0]) / np"
    },
    {
        "query": "Can you create an educational animation that shows how a water molecule is formed with its oxygen and hydrogen atoms, demonstrates a full rotation of the molecule, and then briefly splits the atoms apart to simulate dissociation before recombining them back into the water molecule?",
        "answer": "\\n # Implement Animation for this mobject.\nfrom abc import ABC\n\nfrom manim import *\n\n\nclass IndexPositionError(Exception):\n    def __str__(self):\n        return \"'index_pos' should be either 'UP' or 'DOWN'\"\n\n\n# Extend from VMobject cause no other has defined animations.\n# Don't extend from Mobject directly because of Mobject is abstract.\nclass Array(VMobject):\n    def __init__(\n            self,\n            entries: Mobject | str = [],\n            show_index: bool = True,\n            start_index: int = 0,\n            index_step: int = 1,\n            index_pos: np.ndarray = UP,\n            index_color: color = WHITE,\n            box_height: float = 1.0,\n            box_width: float = 1.0,\n            box_color: color = YELLOW,\n            entry_color: color = PURE_BLUE,\n            stroke_width: float = 1.5\n    ):\n        self.length = len(entries)\n        self.entries = entries\n        super().__init__()\n\n        if index_pos is not UP and index_pos is not DOWN:\n            raise IndexPositionError()\n\n        # boxes\n        self.base_box = Rectangle(height=box_height, width=box_width, stroke_width=stroke_width, stroke_color=box_color)\n        self.boxes = Group(*[self.base_box.copy() for i in range(0, self.length)]).arrange(buff=0)\n\n        # indices\n        if show_index:\n            self.indices = []\n            count = 0\n            while count < self.length:\n                self.indices.append(Tex(f\"${start_index}$\", color=index_color))\n                start_index += index_step\n                count += 1\n            for i in range(0, self.length, 1):\n                self.indices[i].scale(box_height * 0.7)\n                self.indices[i].next_to(self.boxes[i], index_pos, buff=MED_SMALL_BUFF)\n\n        # entries, must be a list of Mobjects or str.\n        for i in range(0, self.length, 1):\n            if type(self.entries[i]) is str:\n                self.entries[i] = Text(f\"{self.entries[i]}\")\n            self.entries[i]. \\\n                set_color(entry_color). \\\n                scale_to_fit_height(box_height * 0.70). \\\n                scale_to_fit_width(box_width * 0.82). \\\n                move_to(self.boxes[i])\n\n        # adding all submobjects\n        if show_index:\n            self.add(*self.indices)\n        self.add(*self.boxes)\n        self.add(*self.entries)\n        self.move_to(ORIGIN)\n\n\nclass Pointer(VMobject):\n    def __init__(self):\n        super().__init__()\n        pass\n\n\nclass Main(Scene):\n    def construct(self):\n        a = Array([\"Kiron\", \"Nirob\", \"Israt\"], start_index=2, index_pos=RIGHT)\n        self.play(Create(a, run_time=8))"
    },
    {
        "query": "I would like to create an educational animation illustrating atomic interactions. I'm envisioning starting with a blank screen and then seeing electrons fade into view, arranged in a grid pattern. After that, one electron should transform into an oxygen atom at the center of the grid while the other electrons expand outward from the center. Following this, a grid of lithium ions should appear above the central oxygen and then fade in. Finally, I want the lithium ions to move in a complex, predetermined path around the oxygen. Can we make an animation like that, which also includes some pauses throughout to allow for explanations during a presentation?",
        "answer": "\\n from manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Define series problem\n        series_problem = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(2)\n\n        # Explanation for series convergence test\n        convergence_test = Text(\"Apply the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(convergence_test))\n        self.wait(2)\n\n        # Showing that p > 1\n        p_value = MathTex(r\"p = 2 > 1\")\n        self.play(Write(p_value))\n        self.wait(2)\n\n        # Explanation for result\n        result_explanation = Text(\"The series converges\", font_size=24).to_edge(UP)\n        self.play(Transform(convergence_test, result_explanation))\n        self.wait(2)\n\n        # Write the final conclusion\n        final_conclusion = MathTex(r\"\\text{The series is convergent}\")\n        self.play(ReplacementTransform(series_problem, final_conclusion))\n        self.wait(3)\n\n        # Clean up the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_conclusion))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation in Manim that illustrates the flow of electrons from the anode to the cathode and back in a battery setup? The animation should include clearly labeled anode and cathode terminals, and I'd like to visibly track an electron's path as it moves in a zigzag pattern between these two terminals, with the entire journey taking approximately 5 seconds and the motion being such that the electron travels to the cathode and then back to the anode. The electrodes must be vertically aligned and colored distinctly, and the electron should become visible when it starts at the anode.",
        "answer": "\\n from manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the initial surface integral problem\n        problem = MathTex(r\"\\iint_{S} (x^2 + y^2 + z^2) dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization of S\n        explanation1 = Text(\"Parameterize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Surface parameterization\n        parameterization = MathTex(r\"S(\\theta, \\phi) = (\\sin(\\phi)\\cos(\\theta), \\sin(\\phi)\\sin(\\theta), \\cos(\\phi))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(2)\n\n        # Explanation for using the parameterization\n        explanation2 = Text(\"Substitute parameterization into integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integral with parameterization substituted\n        integral_param = MathTex(r\"\\int_0^{2\\pi}\\int_0^{\\pi} \\sin^3(\\phi) d\\phi d\\theta\")\n        self.play(ReplacementTransform(parameterization, integral_param))\n        self.wait(1)\n\n        # Explanation for integrating over theta\n        explanation3 = Text(\"Integrate with respect to \\(\\\\theta\\) first\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Integrate over theta\n        integral_theta = MathTex(r\"\\int_0^{\\pi} [\\theta \\sin^3(\\phi)]_0^{2\\pi} d\\phi\")\n        self.play(ReplacementTransform(integral_param, integral_theta))\n        self.wait(2)\n\n        # Explanation for final integration over phi\n        explanation4 = Text(\"Now integrate with respect to \\(\\\\phi\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final integration over phi\n        final_solution = MathTex(r\"(2\\pi) \\int_0^{\\pi} \\sin^3(\\phi) d\\phi\")\n        self.play(ReplacementTransform(integral_theta, final_solution))\n        self.wait(2)\n\n        # Final evaluation of integral\n        solution = MathTex(r\"= (2\\pi) \\left[ -\\frac{\\cos(\\phi)\\sin^2(\\phi)}{3} - \\frac{2\\cos^3(\\phi)}{9} \\right]_0^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, solution))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that illustrates the simple structure of an atom. Can you make a visual representation of an atom that features a red proton, a grey neutron, and a blue electron? I'd like the proton and neutron to form a nucleus in the center of the atom and the electron to orbit around this nucleus as in the classic Bohr model. It's important that the labels \"p^+\" for the proton, \"n^0\" for the neutron, and \"e^-\" for the electron are clearly shown on the respective particles. Can the electron circling the nucleus be animated so that it visibly moves around it? Please ensure that the animation is simple enough for basic educational purposes and the entire structure is properly centered on the screen.",
        "answer": "\\n from manim import *\n\nclass RadialWaveExampleScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(60 * DEGREES, -45 * DEGREES)\n        wave = RadialWave(\n            LEFT * 2 + DOWN * 5,  # Two source of waves\n            RIGHT * 2 + DOWN * 5,\n            checkerboard_colors=[BLUE_D],\n            stroke_width=0,\n        )\n        self.add(wave)\n        wave.start_wave()\n        self.wait()\n        wave.stop_wave()"
    },
    {
        "query": "Can you create an educational animation using Manim that shows a simplified model of a hydrogen atom? The animation should start with the atom appearing on screen, followed by the atom spinning around its center for a complete turn, and finally fading out from the screen. The hydrogen atom should be represented visually by a blue circle with the letter \"H\" in the center, indicating the nucleus, and an electron in orbit represented by a red dot moving along a red elliptical path. The animation should be clear and simple, suitable for a basic chemistry lesson on atomic structure.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} [\\frac{1}{2}x y z^2]_{0}^{3} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{3}{2} x y^2 z^2]_{0}^{2} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{3}{2} x^2 y^2 z^2]_{0}^{1}\", r\"= \\frac{3}{2}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that shows a water molecule made up of one oxygen atom and two hydrogen atoms. I want the oxygen atom to be in the center with a red background and the hydrogen atoms to be blue and positioned at an angle on either side of the oxygen atom, resembling the molecular structure of water. Can you also add bonds between the oxygen and hydrogen atoms to illustrate how they're connected? After assembling the molecule, I'd like it to fade into view and then rotate around its center for a bit so students can get a good look at the arrangement from different angles. Could you help me make this happen without needing to understand complex animation software?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_width\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().scale(2)\n            square = Square()\n            self.add(circle,square)\n            self.play(square.animate.match_width(circle))\n            self.remove(square,circle)"
    },
    {
        "query": "Could you create a simple animation for me where three points form a triangle, each point is labeled, and then a red dot travels along the edges of the triangle? The points should fade in with the connecting lines between them, and after a short pause, the labels should appear. After another pause, the dot should start moving at a constant pace, following the triangle's outline from one labeled point to the next, returning to its starting point, before the animation comes to an end.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation of wave equation\n        explanation1 = Text(\"This is the classic wave equation for u(x,t).\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # General solution explanation\n        explanation2 = Text(\"Its solutions include harmonic waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the general solution\n        general_solution = MathTex(r\"u(x, t) = A\\cos(kx - \\omega t) + B\\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(1)\n\n        # Explanation for harmonic solutions\n        explanation3 = Text(\"Here, A and B are determined by initial conditions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude by showing only the general solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated educational video that illustrates the concept of a quadratic function and its derivative. The video should start with a graph of the function f(x) = x^2 on a set of blue axes that range from -3 to 3 on the x-axis and -5 to 5 on the y-axis. The function should be represented by a green curve. \n\nOnce the graph of the function is drawn, a yellow dashed vertical line should appear at x=1, going from the x-axis up to the graph. Close to the graph, there should be a green label with the function's equation, 'x^2'.\n\nAfterwards, I'd like the video to show the purple curve of the derivative of this function. The presentation should allow some time to observe each element as it is created: first the axes with the function, then the label and the vertical line, and finally the derivative. Each step should have a couple of seconds of pause for the viewer to take in the information before moving on to the next element.",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using the power of e\n        explanation1 = Text(\"Use the power rule for e\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integrate step\n        integrate_step = MathTex(r\"\\frac{1}{2} e^{2x}\")\n        self.play(ReplacementTransform(problem.copy(), integrate_step))\n        self.wait(1)\n\n        # Explanation for adding constant of integration\n        explanation2 = Text(\"Add the constant of integration\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(integrate_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.play(FadeOut(integrate_step), FadeOut(explanation1))\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated visualization of a simplified atom model. The animation should start with a red proton and a grey neutron that form the nucleus, appearing together at the center of the screen. Then, two blue electrons should fade in, orbiting around the nucleus. The electrons must be animated to constantly orbit the nucleus in a smooth, circular motion, as if they are revolving around the nucleus in a two-dimensional plane. I'd like the animation to last for a few seconds, displaying this basic atomic structure with its moving parts. Can you create such an animation?",
        "answer": "\\n from manim import *\n\nclass ExampleTransformation(Scene):\n    def construct(self):\n        # Create text objects\n        text1 = Text(\"Euler's Formula:\")\n        text2 = MathTex(\"e^{ix} = \\\\cos(x) + i\\\\sin(x)\")\n\n        # Position second text\n        text2.next_to(text1, DOWN)\n\n        # Display texts\n        self.play(Write(text1))\n        self.play(FadeInFrom(text2, UP))\n        self.wait(2)\n\n        # Add an arrow\n        arrow = Arrow(LEFT, RIGHT)\n        arrow.next_to(text2, DOWN)\n\n        # Add the expanded form of Euler's formula\n        expanded = MathTex(\"\\\\cos(x) = \\\\frac{e^{ix} + e^{-ix}}{2}\")\n        expanded.next_to(arrow, DOWN)\n        \n        # Show the expansion\n        self.play(GrowArrow(arrow))\n        self.play(Write(expanded))\n        self.wait(2)\n\n        # Show the full transformation\n        complete_expansion = VGroup(text1, text2, arrow, expanded)\n        transformation_title = Text(\"Euler's Formula Transformation\", color=YELLOW)\n        transformation_title.to_edge(UP)\n\n        self.play(\n            FadeOut(complete_expansion),\n            Write(transformation_title),\n            run_time=2\n        )\n        self.wait(2)\n\n        # Conclude with Euler's identity\n        identity_title = Text(\"Euler's Identity\", font_size=36)\n        identity = MathTex(\"e^{i\\\\pi} + 1 = 0\")\n\n        self.play(\n            ReplacementTransform(transformation_title, identity_title),\n        )\n        self.wait(1)\n\n        self.play(Write(identity))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that visualizes the formation of an ionic compound for my chemistry class? Start by showing separate representations of an oxygen molecule, a metal atom, and an electron. These should appear in a row, with some space between them. Then, have a positively charged ion fade in above this group, and a negatively charged ion fade in below the group. After that, I'd like the oxygen, metal, and electron to transform into the ionic compound, consisting of the positive and negative ions placed side by side. Next, let the ionic compound move in a zigzag motion across the screen, as if it's showing the random movement of ions in a solution. Finish the animation by fading out the ionic compound at the end. Can the whole sequence last about 12 seconds?",
        "answer": "\\n         self.play(Transform(text,Text(\"DrawBorderThenFill\").shift(UP*2.5)), run_time=0.5)\n        square = Square(color=BLUE, fill_opacity=1).set_fill(YELLOW)\n        self.play(DrawBorderThenFill(square))\n        self.remove(square)"
    },
    {
        "query": "I would like to create an educational animation that illustrates basic chemistry concepts for my students. Can you show the transformation of an electron into an oxygen atom, then show a grid formation of metal oxides, followed by the appearance of a single carbon atom? After that, I want the carbon atom to move along a complex path with specific stopping points. To wrap up, all the elements and compounds should fade out together.",
        "answer": "\\n from manim import *\n\nclass DerivativeConcept(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1, 5, 1], axis_config={\"color\": GREEN})\n        func_graph = axes.plot(lambda x: x**2, color=BLUE)\n        derivative_graph = axes.plot_derivative_graph(func_graph, color=ORANGE)\n        self.play(Create(axes), Create(func_graph))\n        self.wait(1)\n\n        explanation = MathTex(r\"\\text{The derivative of }\", \"x^2\", r\"\\text{ is }\", \"2x\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n\n        self.play(Create(derivative_graph))\n        self.wait(1)\n\n        point = axes.input_to_graph_point(1, func_graph)\n        slope = axes.get_tangent_line(1, func_graph, length=3, color=PURPLE)\n        dot = Dot(point, color=RED)\n\n        self.play(Create(slope), FadeIn(dot))\n        self.wait(2)"
    },
    {
        "query": "Could you create a simple animation using ManimCE that depicts a hydrogen atom, consisting of a proton and an electron, where the proton is represented by a red circle with a plus sign and the electron by a blue circle with a minus sign, both labeled accordingly, and then group them together with a little space in between? Once the atom is shown, I would like the whole atom to shift upwards on the screen.",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\nabla^2 u = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for the equation\n        explanation1 = Text(\"This is the classical wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Introduce the speed of waves\n        explanation2 = Text(\"Here, c represents the speed of waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the solution format\n        solution_format = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(equation, solution_format))\n        self.wait(2)\n\n        # Explanation for d'Alembert's formula\n        explanation3 = Text(\"Solutions can be described by d'Alembert's formula.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Displaying specific example\n        specific_example = MathTex(r\"u(x, t) = A \\sin(k(x - ct))\")\n        self.play(Transform(equation, specific_example))\n        self.wait(2)\n\n        # Explanation for the specific solution\n        explanation4 = Text(\"This represents a sinusoidal traveling wave.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_example))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that visually represents a chemical reaction where two oxygen atoms join with two hydrogen atoms to create a water molecule, including the process of the reactants appearing, reacting, and then the product moving to the center of the screen while the reactants disappear?",
        "answer": "\\n from manim import *_x000D_\nfrom manim_ml.neural_network import NeuralNetwork_x000D_\nfrom manim_ml.neural_network.layers import FeedForwardLayer, Convolutional2DLayer_x000D_\nfrom manim_ml.utils import generate_random_image_x000D_\n_x000D_\n# Set the configuration for the scene_x000D_\nconfig.pixel_height = 1080_x000D_\nconfig.pixel_width = 1920_x000D_\nconfig.frame_height = 8.0_x000D_\nconfig.frame_width = 14.0_x000D_\n_x000D_\nclass CNNRepresentationScene(Scene):_x000D_\n    def construct(self):_x000D_\n        # Generate a random RGB image_x000D_\n        input_image = generate_random_image(height=28, width=28, channels=3)_x000D_\n_x000D_\n        # Neural Network Architecture_x000D_\n        neural_network = NeuralNetwork([_x000D_\n            # Convert the image to grayscale and show it as the first layer_x000D_\n            Convolutional2DLayer(num_feature_maps=1, feature_map_size=28, filter_size=1),_x000D_\n            # First Convolutional layer_x000D_\n            Convolutional2DLayer(num_feature_maps=16, feature_map_size=28, filter_size=3),_x000D_\n            # Second Convolutional layer_x000D_\n            Convolutional2DLayer(num_feature_maps=32, feature_map_size=14, filter_size=3),_x000D_\n            # Fully Connected layer_x000D_\n            FeedForwardLayer(128),_x000D_\n            # Output layer_x000D_\n            FeedForwardLayer(10)_x000D_\n        ],_x000D_\n        input_image_shape=input_image.shape,_x000D_\n        layer_spacing=0.2,_x000D_\n        layer_buff=1)_x000D_\n_x000D_\n        # Add neural network to the scene_x000D_\n        self.add(neural_network)_x000D_\n_x000D_\n        # Animate the forward pass of the neural network_x000D_\n        self.play(neural_network.create_forward_pass_animation(), run_time=10)_x000D_\n        self.wait()"
    },
    {
        "query": "Can you create an animation of a helium element symbol with two electrons orbiting around it, and ultimately have the entire image fade away? The helium symbol should be prominent and centered, with the electrons depicted as red dots. They should orbit in a yellow elliptical path that is wider than it is tall. I'd also like both electrons to complete the orbit in synchronized motion with a constant speed, lasting for about 4 seconds, and then have everything smoothly fade out at the end.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dx\\,dz\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [ \\frac{1}{2}x^2yz ]_{0}^{2} \\,dz\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [2yz]_{-1}^{1} \\,dy\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= \\int_{0}^{1} 4y \\,dy\", r\"= [2y^2]_{0}^{1}\", r\"= 2\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using a library like Manim that illustrates a simple hydrogen atom model with a proton at the center and an electron orbiting around it? The proton should be labeled with \"P+\" and both the orbit and the electron should be easily distinguishable, possibly with different colors. Additionally, I\u2019d like the electron to actually move around the proton in a circular path, demonstrating how electrons might orbit a nucleus in a very basic way. The animation should be simple and clear enough to be used as a teaching aid for basic chemistry or physics lessons.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.pose_at_angle\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.pose_at_angle())\n            self.remove(square)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates an atom with a nucleus and three electrons orbiting around it. The nucleus should appear as a red dot in the center, with the electrons being small blue dots moving in a circular path, representing their orbit. The orbit path itself should be a visible circle. First, I'd like to see the atom being assembled piece by piece \u2014 the nucleus appears, then the orbit path, followed by the electrons. After the atom is assembled, the electrons should start to move around the nucleus continuously. Once that is established, I want the entire atom to move to the left side of the screen. Then, I'd like a replica of the original atom to appear and move to the right side of the screen. To conclude the animation, I would like both atoms to fade away, leaving the screen empty. Can we make this animation clear, visually appealing, and scientifically accurate for educational purposes?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.to_edge\").shift(UP*2.5)), run_time=0.5)\n            square = Square().shift(LEFT*2)\n            self.play(square.animate.to_edge())\n            self.remove(square)"
    },
    {
        "query": "I would like to create an educational animation that visualizes the movement of different molecular particles. Could you show an electron, a metal atom, a positively charged ion, and a negatively charged ion lining up next to each other and then moving in different directions? The electron should move upwards, the metal atom should move downwards, the positively charged ion should go to the left, and the negatively charged ion should go to the right. After moving to their new positions, I'd like all the particles to fade away. Can you create this animation in such a way that a viewer with no background in chemistry or physics can understand it?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale_to_fit_width\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale_to_fit_width(5))\n            self.remove(square)"
    },
    {
        "query": "Please create an educational animation where first, a hydrogen ion (a red circle labeled H+) fades in, moves upwards, and then fades out. After that, show a blue electron (a small blue circle labeled e-) moving along a squared path, going through each corner and then reversing back to the start with a pause in the middle of the movement.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_y\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.set_y(-1))\n            self.remove(square)"
    },
    {
        "query": "I'd like to create an educational animation that visualizes the movement of an electron through a complex path on a grid. The grid should have 4 rows and 4 columns, and each cell should be fairly small. I imagine an electron starting at a specific point and then moving through a predefined zigzag path that represents a complex trajectory before disappearing from the grid. Can you illustrate this concept in a simple and clear animation, including the grid appearing at first and then fading out with the electron after the path is complete?",
        "answer": "\\n from manim import *\n\nclass LimitConcept(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1, 5, 1])\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n\n        explanation = Tex(\"As $x$ approaches 2, the value of $x^2$ approaches 4.\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n\n        dot = Dot(color=RED).move_to(axes.c2p(2, 4))\n        approaching_line = DashedLine(start=axes.c2p(2, 0), end=axes.c2p(2, 4), color=YELLOW)\n\n        self.play(Create(approaching_line), FadeIn(dot))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that demonstrates the movement of an electron within a basic molecular structure. The molecular structure should be represented by a 3x3 grid with alternating positive and negative ions, somewhat like a simplistic visual representation of a molecular lattice. The animation should include a single electron that appears to be moving randomly across the grid following a defined, albeit intricate, path that makes the electron visit several locations before finally settling at the centre of the grid. I'd like to show this electron's path clearly with pauses in between to signify certain points of interest. The visualization should have a minimalist and educational style suitable for a basic chemistry lesson. Can you create an animation like that for me?",
        "answer": "\\n from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        # Create a hydrogen atom with one proton and one electron\n        electron_group = self.create_electron()\n        proton = self.create_proton()\n\n        # Create a hydrogen molecule (H2) by adding a second hydrogen atom\n        hydrogen_molecule = VGroup(proton, electron_group).arrange(RIGHT, buff=1)\n        second_hydrogen = hydrogen_molecule.copy().next_to(hydrogen_molecule, RIGHT, buff=0.2)\n        \n        # Combine the individual hydrogen atoms to form a molecule group\n        h2_molecule_group = VGroup(hydrogen_molecule, second_hydrogen)\n\n        # Show the construction of hydrogen molecule\n        self.play(Write(proton))\n        self.play(FadeIn(electron_group))\n        self.play(h2_molecule_group.animate.shift(LEFT*0.6))\n        self.play(FadeIn(second_hydrogen))\n        self.play(h2_molecule_group.animate.scale(0.8).move_to(ORIGIN))\n\n        self.wait(2)\n\n    # Helper function to create an electron\n    def create_electron(self):\n        electron_circle = Circle(radius=0.1, color=BLUE).set_fill(BLUE, opacity=0.5)\n        electron = Tex('e$^-$', color=WHITE, font_size=20).move_to(electron_circle.get_center())\n        return VGroup(electron_circle, electron)\n\n    # Helper function to create a proton\n    def create_proton(self):\n        proton_circle = Circle(radius=0.2, color=RED).set_fill(RED, opacity=0.5)\n        proton = Tex('p$^+$', color=WHITE, font_size=20).move_to(proton_circle.get_center())\n        return VGroup(proton_circle, proton)"
    },
    {
        "query": "I would like to create two separate animated diagrams using educational animations. First, can you make a 5x5 grid of alternating red and blue atoms to represent hydrogen (H) and helium (He), respectively, where each atom should be a circle with the element's symbol in the center? The second animation I'd like is to illustrate a basic atom model with a proton at the center and an electron orbiting around it. The proton should be a red circle with a plus sign and the electron a blue circle with a minus sign, and can you show the electron moving around the proton in a simple elliptical orbit? Let's make sure to have a brief pause at the end of both animations, so viewers have a moment to take in the scene.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.to_corner\").shift(UP*2.5)), run_time=0.5)\n            square = Square().shift(LEFT*2)\n            self.play(square.animate.to_corner())\n            self.remove(square)"
    },
    {
        "query": "Could you create an animation of a blue circle following an oscillating path that looks like a wave, with the path shown in yellow, and can you make sure that everything comes to life sequentially and then disappears together at the end?",
        "answer": "\\n from manim import *\n\nclass QuadraticEquationExample(Scene):\n    def construct(self):\n        # Display the quadratic equation\n        equation = MathTex(\"x^2 - 5x + 6 = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for factoring the equation\n        explanation1 = Text(\"Factor the quadratic equation\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Factoring step\n        factored_form = MathTex(\"(x - 2)(x - 3) = 0\")\n        self.play(ReplacementTransform(equation, factored_form))\n        self.wait(1)\n\n        # Explanation for finding the roots\n        explanation2 = Text(\"Solve for the roots\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Root solution\n        roots = MathTex(\"x = 2 , x = 3\")\n        self.play(ReplacementTransform(factored_form, roots))\n        self.wait(1)\n\n        # Show the roots on the number line\n        number_line = NumberLine(x_range=[0, 5, 1], length=10)\n        dot1 = Dot().move_to(number_line.n2p(2))\n        dot2 = Dot().move_to(number_line.n2p(3))\n\n        self.play(GrowFromCenter(number_line), FadeIn(dot1), FadeIn(dot2))\n        self.wait(1)\n\n        # Clear the scene and focus on the roots\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(roots))\n        self.wait(2)\n\n        # Conclude the example\n        conclusion = Text(\"Roots are x = 2 and x = 3\", font_size=24).to_edge(DOWN)\n        self.play(FadeIn(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like an animation that visually represents a water molecule, with one blue circle at the center representing an oxygen atom, and two white circles representing hydrogen atoms, each positioned at an angle to create a V-shape with the oxygen atom in the middle. The oxygen should be labeled with a white \"O\", and the hydrogens should each be labeled with a black \"H\". I want the whole molecule to fade in, then enlarge to double its original size, then shrink back to half that enlarged size, and finally fade out. Can you create this animation in a simple and visually appealing way for a science education video?",
        "answer": "\\n from manim import *\n\n\ndef circle_with_text(\n    r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n) -> Mobject:\n    c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n    t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(c, t)\n\ndef carbon(small: int = False) -> Mobject:\n    return circle_with_text(\n        0.285 if small == 0 else (0.225 if small == 1 else 0.25),\n        \"C\",\n        GRAY_B,\n        30 if small == 0 else (24 if small == 1 else 27),\n        WHITE,\n        1,\n    ).set_z_index(5 if small == 1 else 10)"
    },
    {
        "query": "I would like to create a series of educational science animations using the ManimCE library. Firstly, can you make a grid showing a collection of hydrogen atom symbols, with alternating isotopes of hydrogen denoting Deuterium for every other row, where the isotopes differ by having 'D' with the subscript '2' and regular hydrogen having 'H' with the subscript '1'? The grid should have 5 rows and 7 columns, with each atom represented by a different colored circle and with the symbol inside, and the animation should introduce the grid of atoms on the screen.\n\nSecondly, can you create an animation of an electron depicted as a yellow circle, transitioning between energy levels? We'd like the electron to move along a semi-circular path above and below its initial position, kind of like it's jumping up to a higher energy state and then falling back down.\n\nLastly, I am interested in an animation showing a single proton. It has to be a red circle with the label 'p+' to indicate a proton. It should fade into view, then move upwards and afterwards move back down, as if it's oscillating up and down along the vertical axis.",
        "answer": "\\n from manim import *\n\nclass ProjectileMotionWithAirResistance(Scene):\n    def construct(self):\n        # Initial setup\n        description1 = Tex(\"Projectile motion with air resistance\")\n        self.play(Write(description1))\n        self.wait(1)\n\n        description2 = Tex(\"The motion is influenced by gravity and drag force.\")\n        description2.next_to(description1, DOWN)\n        self.play(Write(description2))\n        self.wait(2)\n\n        # Physics equations\n        equations = VGroup(\n            MathTex(\"F_{drag} = -k v^2\"),\n            MathTex(\"\\\\vec{a} = g - \\\\frac{F_{drag}}{m}\")\n        ).arrange(DOWN, aligned_edge=LEFT)\n\n        self.play(Write(equations))\n        self.wait(2)\n\n        # Animation of the projectile\n        projectile = Dot()\n        path = Parabola(start=LEFT * 4, end=RIGHT * 4, height=2)\n        self.play(FadeIn(projectile), ShowCreation(path))\n        self.play(MoveAlongPath(projectile, path), run_time=4)\n        self.wait(1)"
    },
    {
        "query": "I'd like to see an animated video representation of a hydrogen and a chlorine atom coming together to form a molecule. The hydrogen atom should be white and smaller, while the chlorine atom should be green and slightly larger. Show each atom individually first, then have a line appear between them to represent the chemical bond, and finally move the combined molecule to the center of the screen. Can you make such an animation in a simple and visually appealing way?",
        "answer": "\\n class AnimationMechanisms(Scene):\n    def construct(self):\n        c = Circle()\n        \n        c.generate_target()\n        c.target.set_fill(color=GREEN, opacity=0.5)\n        c.target.shift(2*RIGHT + UP).scale(0.5)\n        \n        self.add(c)\n        self.wait()\n        self.play(MoveToTarget(c))\n        \n        s = Square()\n        s.save_state()\n        self.play(FadeIn(s))\n        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n        self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n        self.wait()\n        self.play(Restore(s), run_time=2)\n\n        self.wait()"
    },
    {
        "query": "Could you create an educational animation using Manim that visually represents the structure of a simple atom? In the animation, I would like to see a red circle representing a proton with the label \"p+\" on it, a blue circle for a neutron with the label \"n0\", and a smaller white circle for an electron with the label \"e-\". Can you arrange the proton and neutron together to form a nucleus at the center of the atom, and then show the electron orbiting around this nucleus? Also, please make sure the electron orbits in a circular path that takes it to the upper right quadrant of the screen. Additionally, I'd like the labels for each particle to be clearly visible and for the nucleus to be scaled down and moved to the top of the screen to make space for the electron's orbit.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Presenting the integral problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2 \\sin(\\theta) dr d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # First integral explanation\n        explanation1 = Text(\"Integrating with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral calculation\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3 \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Second integral explanation\n        explanation2 = Text(\"Now integrate with respect to \\(\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral calculation\n        final_integral = MathTex(r\"= [\\frac{1}{3}r^3 (-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{1}{3}(1 - (-1)) = \\frac{2}{3}\")\n        self.play(ReplacementTransform(final_integral, final_answer))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"The area inside a unit semicircle\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually explains electron movement in a two-dimensional grid. The idea is to show a grid that represents ions in a solid with alternating colors to differentiate between positive and negative ions. Then, I want to introduce an electron with a distinct color and an \"e^-\" label to represent its charge. The electron should follow a complex, predefined path across the grid, with specific points where it briefly stops before moving on. The movement of the electron should be continuous and take a certain amount of time to complete. How would I go about animating this process to clearly illustrate the concept?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function to be integrated\n        function_text = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_text))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Area under the curve from x=0 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integral setup\n        integral_setup = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(ReplacementTransform(function_text, integral_setup))\n        self.wait(1)\n\n        # Explanation for the antiderivative\n        explanation2 = Text(\"Compute antiderivative\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Antiderivative result\n        antiderivative_result = MathTex(r\"\\left[\\dfrac{1}{3}x^3\\right]_0^2 = \\dfrac{8}{3}\")\n        self.play(ReplacementTransform(integral_setup, antiderivative_result))\n        self.wait(1)\n\n        # Clear the scene and show final area value\n        self.play(FadeOut(explanation1))\n        self.clear()\n        self.wait(1)\n        final_area_value = MathTex(r\"\\text{Area} = \\dfrac{8}{3}\")\n        self.play(Write(final_area_value))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that shows a simple chemical bonding process between an oxygen atom and a hydrogen atom leading to the formation of a water molecule, visually illustrating the transfer of an electron, and then transforming the individual oxygen and hydrogen atoms into a water molecule?",
        "answer": "\\n from manim import *\n\n\nclass AtomScene(Scene):\n    def construct(self):\n        atom = self.create_atom()\n        electrons = self.create_electrons(atom)\n        self.play(FadeIn(atom))\n        self.play(*[FadeIn(e) for e in electrons])\n        self.play(*[Rotate(e, angle=2*PI, about_point=atom.get_center()) for e in electrons])\n        self.wait(2)\n    \n    def create_atom(self) -> Mobject:\n        proton = Circle(radius=0.2, stroke_color=RED, fill_color=RED, fill_opacity=1)\n        neutron = Circle(radius=0.2, stroke_color=BLUE, fill_color=BLUE, fill_opacity=1)\n        nucleus = VGroup(proton, neutron).arrange(RIGHT, buff=0.1)\n        return nucleus\n\n    def create_electrons(self, nucleus: Mobject) -> List[Mobject]:\n        electrons = []\n        positions = [UP, DOWN, LEFT, RIGHT]\n        for pos in positions:\n            electron = Circle(radius=0.05, stroke_color=YELLOW, fill_color=YELLOW, fill_opacity=1)\n            electron.move_to(nucleus.get_center() + pos * 0.5)\n            electrons.append(electron)\n        return electrons"
    },
    {
        "query": "Could you create an educational animation that illustrates a simple chemical reaction where oxygen reacts with a metal to produce an electron and a positive ion? I'd like to see the reactants on the left and right side of the screen, respectively, and then see them transform into the products, which should include an electron and a positive ion, also on the left and right side but lower down the screen. Additionally, please have a plus sign between the reactants and an arrow pointing from the reactants to the products to signify the reaction process. Can the animation start with the reactants fading in, then have a short pause before they transform into the products, followed by another pause to allow viewers to see the end result?",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#edf2f7\"\nTEXT_COLOR = \"#2b2d42\"\nLIGHT_GREEN_COLOR = \"#8d99ae\"\nLIGHT_YELLOW_COLOR = \"#f2cc8f\"\nLIGHT_RED_COLOR = \"#ef233c\"\nLIGHT_BLUE_COLOR = \"#4a7c59\"\nNAVY_COLOR = \"#3d405b\"\n\nclass PrimeNumberSpiral(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Prime Number Spiral\", color=LIGHT_BLUE_COLOR)\n        title.scale(1.5)\n        title.shift(3 * UP)\n\n        dots = VGroup()\n        primes = set()\n        n = 400  # Total number of dots to be checked and displayed\n\n        for i in range(1, n + 1):\n            angle = i * 0.2  # Angle for the polar position\n            radius = 0.1 * i  # Radius for the polar position\n            dot = Dot(point=complex_to_R3(np.exp(1j * angle) * radius), color=LIGHT_GREEN_COLOR)\n            dots.add(dot)\n            for j in range(2, int(i**0.5) + 1):\n                if i % j == 0:\n                    dot.set_color(LIGHT_YELLOW_COLOR)\n                    break\n            else:\n                dot.set_color(LIGHT_RED_COLOR)\n                primes.add(i)\n\n        number_line = NumberLine(\n            x_range=[-1, 50, 2],\n            length=10,\n            color=NAVY_COLOR,\n            include_numbers=True,\n            label_direction=DOWN,\n        )\n\n        self.add(title)\n        self.play(ShowCreation(number_line), run_time=2)\n        self.play(Succession(*[GrowFromCenter(dot) for dot in dots], run_time=5))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that shows the process of chemical bonding between an oxygen atom and a metal atom. The animation should start by showing the oxygen atom at the top of the screen and the metal atom appearing below it. Then, it should depict a bond forming between the oxygen and the metal atom, followed by a second bond forming from the bottom of the metal atom to the edge of the screen. Once the bonds are formed, the resulting molecule should move to the right and then back to its original position. Lastly, I want to introduce an electron into the scene, have it appear from the center, and then have all the elements and bonds fade away at the end. Can you do this in a simple, visually engaging way that would be suitable for a classroom setting?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        curve_label = MathTex(r\"f(x) = x^2\")\n        self.play(Write(curve_label))\n        self.wait(1)\n\n        # Drawing the curve\n        curve_graph = FunctionGraph(lambda x: x**2, x_range=[-3, 3])\n        self.play(Create(curve_graph))\n        self.wait(2)\n\n        # Indicating the area under the curve\n        area_label = Text(\"Calculate the area under the curve from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(area_label))\n        self.wait(2)\n\n        # Shading the area\n        area = area = self.get_area(curve_graph, (1, 2), color=[BLUE, GREEN], opacity=0.5)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Integral representation\n        integral = MathTex(r\"\\int_{1}^{2} x^2 \\,dx\")\n        self.play(Transform(area_label, integral))\n        self.wait(2)\n\n        # Calculation\n        calculated_area = MathTex(r\"=\\frac{1}{3}\\left[2^3 - 1^3\\right]\").to_edge(DOWN)\n        self.play(Write(calculated_area))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\frac{1}{3}(8 - 1) = \\frac{7}{3}\")\n        self.play(ReplacementTransform(calculated_area, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you please create an animation where a 5 by 5 grid of circles filled with a semi-transparent white color is displayed, and each circle has a black letter 'H' in the center, which represents hydrogen atoms? The circles should fade into view when the animation starts and remain visible for 2 seconds before the animation ends.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.stretch_to_fit_width\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.stretch_to_fit_width(5))\n            self.remove(square)"
    },
    {
        "query": "Could you create an educational animation using Manim that visually represents a Hydrogen molecule with its two atoms and the bond between them, and then have the molecule traverse a square path? The representation should be simple, using circles and letters to indicate the atoms, and a line for the bond between them. Additionally, I would like the movement of the molecule to be smooth and continuous as it follows the square path, finishing where it started.",
        "answer": "\\n import math\n\nfrom manim import *\n\n\nclass Main(Scene):\n    def construct(self):\n        # Background.\n        # background = ImageMobject(\"sea.jpg\")\n        background = Rectangle(height=config.frame_height, width=config.frame_width). \\\n            set_color([TEAL, BLUE, GREEN]). \\\n            set_opacity(0.7)\n        self.play(FadeIn(background), run_time=1)\n        self.bring_to_back(background)\n\n        # Default starting wait.\n        self.wait(0.5)\n\n        name = Text(\"Hello Kiron.\", color=BLUE)\n        self.play(Write(name), run_time=3)\n        self.play(Indicate(name))\n\n        # Default ending wait.\n        self.wait()"
    },
    {
        "query": "I would like to create an animated video demonstrating the motion of a lithium ion through a simplified 2D lattice structure representing a piece of metal oxide. The lattice should consist of a 3x3 grid where alternating cells represent metal and oxygen ions. The video should depict a lithium ion entering the scene, moving in a complex path through the grid, and then coming to a stop. The lithium ion's path should have distinct points where changes in direction occur, visually indicating the ion's interaction with the lattice as it moves. Could you produce such an educational video that illustrates this concept in an easy-to-follow manner for my chemistry students?",
        "answer": "\\n from manim import *_x000D_\nimport numpy as np_x000D_\n_x000D_\nclass AVLTree(VGroup):_x000D_\n    def __init__(_x000D_\n        self,_x000D_\n        scene,_x000D_\n        levels=3,_x000D_\n        node_radius=0.5,_x000D_\n        label_scale_factor=0.75,_x000D_\n        node_color=RED,_x000D_\n        edge_color=WHITE,_x000D_\n        animation_runtime=0.5,_x000D_\n    ):_x000D_\n        super().__init__()_x000D_\n        self.scene = scene_x000D_\n        self.levels = levels_x000D_\n        self.node_radius = node_radius_x000D_\n        self.label_scale_factor = label_scale_factor_x000D_\n        self.node_color = node_color_x000D_\n        self.edge_color = edge_color_x000D_\n        self.animation_runtime = animation_runtime_x000D_\n_x000D_\n        self.nodes = []_x000D_\n        self.edges = []_x000D_\n        self.tree_height = 1_x000D_\n_x000D_\n        self.create_tree(levels)_x000D_\n_x000D_\n    def create_tree(self, levels):_x000D_\n        level_width = 3.0 * (2 ** (levels - 1))_x000D_\n        nodes_current_level = 1_x000D_\n        for level in range(levels):_x000D_\n            horizontal_spacing = level_width / nodes_current_level_x000D_\n            for i in range(nodes_current_level):_x000D_\n                x = -level_width / 2 + i * horizontal_spacing_x000D_\n                y = -level_x000D_\n                node = self.create_node(value=\"\")_x000D_\n                node.move_to([x, y, 0])_x000D_\n                self.nodes.append(node)_x000D_\n                self.add(node)_x000D_\n            nodes_current_level *= 2_x000D_\n_x000D_\n    def create_node(self, value):_x000D_\n        node = Circle(radius=self.node_radius, color=self.node_color)_x000D_\n        label = Tex(str(value), color=WHITE).scale(self.label_scale_factor)_x000D_\n        label.move_to(node.get_center())_x000D_\n        node.add(label)_x000D_\n        return node_x000D_\n_x000D_\n    def create_edge(self, node1, node2):_x000D_\n        edge = Line(node1.get_center(), node2.get_center(), color=self.edge_color)_x000D_\n        self.edges.append(edge)_x000D_\n        self.add(edge)_x000D_\n_x000D_\n    def insert(self, value, index=0):_x000D_\n        node = self.nodes[index]_x000D_\n        label = node[0]_x000D_\n        label.become(Tex(str(value), color=WHITE).scale(self.label_scale_factor))_x000D_\n_x000D_\n        # Animate the label change to the new value_x000D_\n        self.scene.play(ReplacementTransform(label, label.copy()), run_time=self.animation_runtime)_x000D_\n_x000D_\n    def connect_parent_child(self, parent_index, child_index):_x000D_\n        parent_node = self.nodes[parent_index]_x000D_\n        child_node = self.nodes[child_index]_x000D_\n        # Create an edge from the parent to the child node_x000D_\n        self.create_edge(parent_node, child_node)_x000D_\n_x000D_\nclass AVLScene(Scene):_x000D_\n    def construct(self):_x000D_\n        avl_tree = AVLTree(self, levels=4)_x000D_\n        self.add(avl_tree)_x000D_\n_x000D_\n        # Let's insert some values and connect the parent and child nodes after each insertion_x000D_\n        avl_tree.insert(10, 0)_x000D_\n        avl_tree.insert(20, 1)_x000D_\n        avl_tree.insert(30, 2)_x000D_\n_x000D_\n        avl_tree.connect_parent_child(0, 1)_x000D_\n        avl_tree.connect_parent_child(0, 2)_x000D_\n_x000D_\n        # We wait a second to showcase the final tree_x000D_\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video that shows an electron moving along a complex, predefined path on the screen. The electron should start at the far left side, then make a sharp turn upwards, continue upward while gradually moving right, then move downwards and to the right in a symmetric way to how it went up, and finally end up at the far right side of the screen. During this motion, the electron should pause briefly after the first upward turn and again after it has moved straight down before continuing to the right. The whole movement from start to end should take around 2 seconds. Can you make this animation for me without going into too much technical detail?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^1 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{2+1}}{3}\\Big|_0^1\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the limits\n        explanation2 = Text(\"Evaluate at the limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Showing evaluation at the limits\n        evaluated_solution = MathTex(r\"= \\frac{1^{3}}{3} - \\frac{0^{3}}{3}\")\n        self.play(ReplacementTransform(solution1, evaluated_solution))\n        self.wait(1)\n\n        # Explanation for the final result\n        explanation3 = Text(\"Simplify to get the final result\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}\")\n        self.play(ReplacementTransform(evaluated_solution, final_solution))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that demonstrates electron movement within an electrolyte solution for my chemistry class. The animation should show a 5x5 grid representing the solution, with alternating cells containing either an electron or an oxygen atom. Electrons should be shown moving in a specific complex pattern across the grid to represent the flow of electricity. Each electron should follow a path that takes them through a sequence of cells in a strategic manner that might resemble the path they take in an actual electrolytic solution. Can you illustrate this in a simple yet informative way, while ensuring the movement is clear and the entire grid is centered on the screen?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2} x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration\n        explanation1 = Text(\"Calculate the definite integral:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{4}\\Bigg|_{0}^{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating from 0 to 2:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution evaluation\n        final_solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Simplify the final solution\n        final_answer = MathTex(r\"= 4\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)"
    },
    {
        "query": "I want to create an educational animation using Manim which visualizes different chemical elements and compounds. Could you illustrate the following sequence?\n\n1. Start with five individual chemical entities: denote an electron, an oxygen atom, a metallic atom, a positive ion, and a negative ion.\n2. Arrange these entities in a horizontal line with equal spacing.\n3. Sequentially fade each entity into visibility with a short delay between each one appearing.\n4. After they all appear, transform this line of elements into a 3 by 3 grid that represents a metal oxide compound.\n5. Then, change this grid into a layer of carbon atoms.\n6. Additionally, I want to showcase an electron taking a complex path through these elements. Have the electron move in a zigzag path, starting from the left off-screen, making two stops on its journey, and finally exiting to the right off-screen.\n7. This all should be paced well, with pauses in between major transformations to give viewers a moment to understand each step of the animation.\n\nCan this animation be done in such a way that holds attention and is informative for my chemistry students?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        integral_x = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), integral_x))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        integral_y = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(integral_x, integral_y))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}z^2]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(integral_y, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you create an educational animation using ManimCE that illustrates a chemical reaction where oxygen reacts with a lithium ion to form a metal oxide? I'd like the oxygen molecule to appear from the left, the lithium ion from the right, and when they react, I want them both to transform into the metal oxide in the center of the frame. Please show each reactant appearing, then wait for a second before they transform into the product, and hold the final product on screen for a moment so viewers can see the result of the reaction.",
        "answer": "\\n from manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create a grid of metal oxide cells\n        mo_grid = self.metal_oxid(3, 3)\n        self.add(mo_grid)\n\n        # Animate an electron moving along a complex path\n        electron_obj = self.electron()\n        self.add(electron_obj)\n        complex_path = [\n            LEFT * 2 + UP * 2,\n            RIGHT * 2 + UP * 2,\n            RIGHT * 2 + DOWN * 2,\n            LEFT * 2 + DOWN * 2,\n            ORIGIN\n        ]\n        electron_animations = self.move_along_complex_path(\n            electron_obj, [2, 4], complex_path, run_time=5\n        )\n        self.play(AnimationGroup(*electron_animations, lag_ratio=0.5))\n\n    def circle_with_text(\n        self, r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n    ) -> Mobject:\n        c = Circle(radius=r, color=color).set_opacity(1).set_fill(color=fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)\n\n    def electron(self) -> Mobject:\n        return self.circle_with_text(0.15, \"e$^-$\", YELLOW_D, 24, BLACK, 1, YELLOW_D)\n\n    def metal_oxid(self, rows: int, cols: int, scale=1.5) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                if (j + i) % 2 == 0:\n                    list.append(self.oxygen().move_to([i / scale, j / scale, 0]))\n                else:\n                    list.append(self.metal().move_to([i / scale, j / scale, 0]))\n        return VGroup(*list)\n\n    def oxygen(self) -> Mobject:\n        list = []\n        start = 0.3\n        end = 0.6\n        list.append(Line(start=LEFT * start, end=LEFT * end))\n        list.append(Line(start=RIGHT * start, end=RIGHT * end))\n        list.append(Line(start=UP * start, end=UP * end))\n        list.append(Line(start=DOWN * start, end=DOWN * end))\n        list = map(lambda x: x.set_opacity(0.7), list)\n        return VGroup(self.circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)\n\n    def metal(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        paths = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                paths.append(Line(points[i], points[i + 1]))\n\n        for path in paths:\n            animations.append(MoveAlongPath(obj, path, run_time=run_time/len(paths), rate_func=rate_func))\n\n        return animations"
    },
    {
        "query": "How can I create an animation of a simple atom model with a nucleus and electrons rotating around it using an animation software suitable for mathematical and scientific illustrations? The nucleus should be represented by two circles, one red and one blue, symbolizing a proton and a neutron, and there should be four electrons represented by smaller yellow circles positioned at the cardinal points around the nucleus. The electrons should then rotate around the nucleus to give the effect of an orbit.",
        "answer": "\\n class SimpleGraphScene(Scene):\n\n    def construct(self):\n        axes = Axes(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        # create a graph\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n\n        # display graph\n        self.add(axes, graph)"
    },
    {
        "query": "Can you create an animation that displays a 3x3 grid of red hydrogen atoms, where each atom is represented by a red circle with the letter 'H' in it, and then presents this grid on the screen?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes labels\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Original function f(x) = x^2\n        original_function = axes.plot(lambda x: x**2, color=GREEN)\n        original_function_label = axes.get_graph_label(original_function, label='x^2')\n\n        # Area under the curve f(x) = x^2 from x=1 to x=3\n        area = axes.get_area(original_function, x_range=(1, 3), color=[BLUE, PURPLE, RED], opacity=0.5)\n\n        self.play(Create(axes), Write(labels))\n        self.play(Create(original_function), Write(original_function_label))\n        self.wait(1)\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(2)\n\n        # Display the integral representation\n        integral = MathTex(r\"\\int_{1}^{3} x^2 \\,dx\")\n        integral.to_edge(UP)\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Calculate the area (analytical solution)\n        solution = MathTex(r\"=\\left.\\frac{x^3}{3}\\right|_1^3 = \\frac{27}{3} - \\frac{1}{3} = 8\")\n        solution.next_to(integral, DOWN)\n        self.play(Write(solution))\n        self.wait(2)\n\n        # Clear the scene and display the solution only\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animated chemistry-related video that shows a hydrogen molecule initially appearing on the screen and then moving along a zigzag path? In the video, I'd like each hydrogen atom to be represented by a colored circle with an 'H' in the center, and they should be connected by a bond represented by a grey line. The path should start by going up, then to the right, down, and finally to the left, taking a total of four seconds to complete. The atoms should be distinguishable by color: one in red and the other in blue.",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} f(r,\\theta)r\\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[\\int_{0}^{1} f(r, \\theta)r\\,dr\\right] d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Then integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{2\\pi} F(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for final result\n        explanation3 = Text(\"Finally, evaluate the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= F_{\\text{evaluated}}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animation using Manim that shows a simple model of a hydrogen atom, with a red proton and a blue electron, each labeled accordingly? The proton should be larger than the electron, and they should both be presented together as a group.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        explanation1 = Text(\"Apply the limits after integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        solution1 = MathTex(r\"= \\frac{2^{3+1}}{3+1} - \\frac{0^{3+1}}{3+1}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        explanation2 = Text(\"Evaluate the expression using limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        final_solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4} =\", \"\\\\frac{16}{4} - 0 =\", \"4\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        self.clear()\n        self.wait(1)\n\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create a chemistry-related educational animation using ManimCE that illustrates various concepts? I would like to see an animation that starts with an electron, then shows it transforming into different atoms and ions such as oxygen, a metal, a positive ion, and a negative ion. Could you also show the electron moving around? After that, please include a transition to a metal oxide crystal structure, followed by a lithium ion structure, and then to a carbon structure, with each structure fading in and out. Finally, return the focus to the electron, have it move back to the center, and grow to conclude the animation. Make sure to have pauses to let viewers grasp each stage.",
        "answer": "\\n self.play(Transform(text, Text(\"Fade In\").shift(UP*2.0)), run_time=0.5)\ncircle = Circle()\nself.play(FadeIn(circle))\nself.play(Transform(text, Text(\"Fade Out\").shift(UP*2.0)), run_time=0.5)\nself.play(FadeOut(circle))"
    },
    {
        "query": "Can you create an animated video showing a simple model of a water molecule using blue and white circles to represent the oxygen and hydrogen atoms respectively, with gray lines to indicate the bonds between them? I'd like the molecule to assemble on screen and then hold still for a moment before the video ends.",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Applying the fundamental theorem of calculus\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\").move_to(UP*2)\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= [\\frac{x^{3}}{3}]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Replacing with definite boundaries\n        boundaries_applied = MathTex(r\"= \\frac{3^3}{3} - \\frac{1^3}{3}\")\n        self.play(ReplacementTransform(solution1, boundaries_applied))\n        self.wait(1)\n\n        # Explanation for calculating the result\n        explanation2 = Text(\"Calculate the result\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_result = MathTex(r\"= 9 - \\frac{1}{3}\")\n        self.play(ReplacementTransform(boundaries_applied, final_result))\n        self.wait(2)\n\n        # Simplifying further\n        simplified_result = MathTex(r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(final_result, simplified_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final simplified result\n        self.play(Write(simplified_result))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation using ManimCE where an oxygen atom and a carbon atom appear on the screen at the top and bottom, respectively, and then show an electron moving in a circular path around the oxygen atom?",
        "answer": "\\n from manim import *\n\nclass LinearAlgebraScene(Scene):\n    def construct(self):\n        # Presenting a matrix\n        matrix = MathTex(r\"\\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}\")\n        self.play(Write(matrix))\n        self.wait(1)\n\n        # Showing the determinant\n        determinant_text = Text(\"Determinant of the matrix\", font_size=24).to_edge(UP)\n        self.play(Write(determinant_text))\n        self.wait(2)\n\n        # Writing the determinant formula\n        det_formula = MathTex(r\"\\text{det} = 1 \\cdot 4 - 2 \\cdot 3\")\n        self.play(ReplacementTransform(matrix.copy(), det_formula))\n        self.wait(1)\n\n        # Showing the determinant value\n        det_value = MathTex(r\"\\text{det} = -2\")\n        self.play(Transform(det_formula, det_value))\n        self.wait(2)\n\n        # Introducing eigenvalues\n        eigen_text = Text(\"Eigenvalues of the matrix\", font_size=24).to_edge(UP)\n        self.play(Transform(determinant_text, eigen_text))\n        self.wait(2)\n\n        # Showing the characteristic polynomial\n        char_poly = MathTex(r\"\\lambda^2 - (1+4)\\lambda + (1\\cdot4 - 2\\cdot3) = 0\")\n        self.play(Write(char_poly))\n        self.wait(1)\n\n        # Computing eigenvalues\n        eigenvalues = MathTex(r\"\\lambda = 2, \\lambda = 3\")\n        self.play(ReplacementTransform(char_poly, eigenvalues))\n        self.wait(2)\n\n        # Clearing the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion with eigenvalues highlighted\n        conclusion = Text(\"Eigenvalues are 2 and 3\", font_size=36, color=YELLOW)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animated video showing a simple water molecule with one oxygen atom and two hydrogen atoms. The oxygen atom should appear as a larger red circle with the letter 'O' in the center, and the hydrogen atoms should be smaller blue circles each with the letter 'H' in the center. All atoms should be connected with lines representing chemical bonds. Can the animation start by fading in the molecule, then scale it up to be twice its initial size over a couple of seconds, and end by fading out the entire molecule?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network.layers import ConvolutionalLayer, PoolingLayer, FullyConnectedLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        # Define the structure of the Convolutional Neural Network\n        cnn = NeuralNetwork([\n            ConvolutionalLayer(feature_maps=1, kernel_size=(3, 3), input_shape=(28, 28, 1)),\n            PoolingLayer(pool_size=(2, 2)),\n            ConvolutionalLayer(feature_maps=3, kernel_size=(3, 3)),\n            PoolingLayer(pool_size=(2, 2)),\n            FullyConnectedLayer(units=120),\n            FullyConnectedLayer(units=84),\n            FullyConnectedLayer(units=10, activation='softmax')\n        ], layer_spacing=0.2, neural_network_type='CNN')\n\n        cnn.scale(0.5)\n        cnn.move_to(ORIGIN)\n\n        # Animate the construction and forward pass of the CNN\n        self.play(AnimationGroup(\n            Create(cnn),\n            cnn.make_forward_pass_animation(),\n            lag_ratio=0.1,\n            run_time=4\n        ))\n\n        # Hold the final scene\n        self.wait(2)"
    },
    {
        "query": "I would like an animated video that simulates a basic chemical reaction where an electron reacts with an oxygen atom to form an oxygen ion and then combines with a metal atom to create a metal oxide. The video should start with a title \"Chemical Reaction Simulation\" at the top. Initially, the electron should be on the far left, the oxygen in the middle left, and the metal on the middle right. They should fade in sequentially. The electron then moves to the oxygen and they merge, indicating a reaction. Following this, the metal moves to the oxygen and they bond together, creating a simple metal oxide molecule. Finally, transition the single molecule into a 3x3 lattice structure of metal oxide before fading everything out, concluding the animation.",
        "answer": "\\n from manim import Scene, VGroup, RIGHT\nfrom manim_ml.neural_network import LinearLayer, ActivationLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        layers = VGroup(\n            LinearLayer(4, 6),\n            ActivationLayer('ReLU'),\n            LinearLayer(6, 4),\n            ActivationLayer('ReLU'),\n            LinearLayer(4, 1),\n            ActivationLayer('Sigmoid')\n        )\n\n        layers.arrange(RIGHT, buff=0.5)\n        self.add(layers)\n\n        forward_pass = layers.make_forward_pass_animation()\n        self.play(forward_pass)\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an educational animation that visually represents the basic structure of an atom. Can you show a simple nucleus made of two protons and two neutrons at the center, with one electron orbiting around it? Also, the nucleus should be stationary, and placed at the center of the screen, while the electron should be in constant motion along a visible orbit. Please use different colors to distinguish protons, neutrons, and the electron's path. The animation should start with the nucleus and orbit fading in, followed by the electron starting its orbit around the nucleus.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Fourier Series Demo\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n\n        # Fourier series equation\n        fourier_series = MathTex(\n            r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos\\left(\\frac{2\\pi nx}{P}\\right) + b_n \\sin\\left(\\frac{2\\pi nx}{P}\\right) \\right]\"\n        )\n        self.play(Write(fourier_series))\n        self.wait(2)\n\n        # Display the partial sum of the Fourier series\n        partial_sum = MathTex(\n            r\" S_N(x) = a_0 + \\sum_{n=1}^{N} \\left[ a_n \\cos\\left(\\frac{2\\pi nx}{P}\\right) + b_n \\sin\\left(\\frac{2\\pi nx}{P}\\right) \\right]\"\n        )\n        self.play(Transform(fourier_series, partial_sum))\n        self.wait(2)\n\n        # Explanation that we approximate using partial sums\n        explanation = Text(\"We approximate functions using partial sums of the series.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Display the approximation for N=3\n        three_term_approx = MathTex(\n            r\" S_3(x) = a_0 + a_1 \\cos\\left(\\frac{2\\pi x}{P}\\right) + b_1 \\sin\\left(\\frac{2\\pi x}{P}\\right) + a_2 \\cos\\left(\\frac{4\\pi x}{P}\\right) + b_2 \\sin\\left(\\frac{4\\pi x}{P}\\right) + a_3 \\cos\\left(\\frac{6\\pi x}{P}\\right) + b_3 \\sin\\left(\\frac{6\\pi x}{P}\\right)\"\n        ).scale(0.7)\n        self.play(ReplacementTransform(partial_sum, three_term_approx))\n        self.wait(2)\n\n        # Fade out everything\n        self.play(FadeOut(explanation), FadeOut(three_term_approx))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that shows a 5 by 6 grid representing hydrogen atoms, where each atom is depicted with a blue electron and a red proton, including labels for the electron and proton as \"e-\" and \"p+\" respectively?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and area\n        function = MathTex(r\"f(x) = x^2\")\n        area = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(function))\n        self.wait(1)\n        self.play(Write(area))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        expl_setup = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(expl_setup))\n        self.wait(2)\n\n        # Performing the integration\n        integration = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^3\")\n        self.play(Transform(area, integration))\n        self.wait(2)\n\n        # Explanation for definite integral\n        expl_definite = Text(\"Apply the Fundamental Theorem of Calculus\", font_size=24).to_edge(UP)\n        self.play(Transform(expl_setup, expl_definite))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= \\frac{1}{3}(27) - \\frac{1}{3}(1)\", \n                                r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration, final_answer))\n        self.wait(3)\n\n        # Conclusion\n        self.play(FadeOut(final_answer), FadeOut(expl_setup))\n        self.wait(1)\n        conclusion = Text(\"The area under f(x) from x=1 to x=3 is 26/3\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animation showing an electron particle appearing, and then moving upwards on the screen? The electron should look like a small yellow circle with the symbol 'e-' inside it to represent an electron.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Display the area problem\n        area_problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Transform(function, area_problem))\n        self.wait(2)\n\n        # Show area visualization\n        axes = Axes(\n            x_range=[0, 4],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(1, 3), color=[BLUE, GREEN], opacity=0.3)\n        self.play(Create(axes), Create(graph), FadeIn(area))\n        self.wait(3)\n\n        # Integration process\n        integration = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_1^3\")\n        self.play(ReplacementTransform(area_problem, integration))\n        self.wait(2)\n\n        # Calculating result\n        result = MathTex(r\"= \\frac{3^3}{3} - \\frac{1^3}{3}\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration, result))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text('The shaded area is \\\\( \\\\frac{26}{3} \\\\) square units.', font_size=24)\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), Transform(result, conclusion))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation demonstrating the movement of an electron around a conductor and the transition of metal oxide to a carbon grid, followed by a visualization of a lithium ion moving along a complex path using circles and sharp turns?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Wiggle\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"THIS\")\n            self.play(Wiggle(some_text))\n            self.remove(some_text)"
    },
    {
        "query": "I want an educational animation that visually demonstrates electron movement in a metal oxide grid. The grid should be alternating between metal atoms and oxygen atoms. The electron should then follow a complex path across this grid, making several turns while being clearly highlighted. After the electron completes its journey, all elements should fade out to end the animation. Can we show this process in a clear and visually appealing way?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule for definite integrals:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule for definite integrals\n        power_rule = MathTex(r\"\\int_a^b x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_a^b\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left. \\frac{x^{2+1}}{3} \\right|_1^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate at the boundaries:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution step 1: Substituting the upper limit of integration\n        final_solution_step1 = MathTex(r\"= \\Big( \\frac{3^3}{3} \\Big) -\")\n        self.play(ReplacementTransform(solution1.copy(), final_solution_step1))\n        self.wait(1)\n\n        # Final solution step 2: Substituting the lower limit of integration\n        final_solution_step2 = MathTex(r\"\\Big( \\frac{1^3}{3} \\Big)\")\n        final_solution_step2.next_to(final_solution_step1, RIGHT)\n        self.play(Write(final_solution_step2))\n        self.wait(1)\n\n        # Combine the final solution steps\n        final_solution_combined = MathTex(r\"= \\Big( \\frac{27}{3} \\Big) - \\Big( \\frac{1}{3} \\Big)\")\n        self.play(Transform(final_solution_step1, final_solution_combined))\n        self.remove(final_solution_step2)\n        self.wait(1)\n\n        # Simplify the final solution\n        simplified_solution = MathTex(r\"= 9 - \\frac{1}{3}\")\n        self.play(ReplacementTransform(final_solution_step1, simplified_solution))\n        self.wait(1)\n\n        # Final result\n        final_result = MathTex(r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(simplified_solution, final_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final result\n        self.play(Write(final_result))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation where we start with an oxygen molecule and two hydrogen molecules. The animation should visually represent the molecules with the oxygen atoms colored red and the hydrogen atoms colored blue. Initially, the molecules should fade into view: the oxygen molecule should be at the center while the hydrogen molecules appear on the left and the right sides of the oxygen molecule. After a short pause, I want the hydrogen molecules to move towards the oxygen molecule and bond with it to form two separate water molecules. The water molecules should also be colored appropriately with the same color coding. Once formed, the two water molecules should be displayed clearly for a moment. Can you design and explain how this chemical bonding animation process would work?",
        "answer": "\\n from manim import *_x000D_\nimport numpy as np_x000D_\nfrom manim_ml.neural_network import NeuralNetwork, FullyConnectedLayer_x000D_\n_x000D_\nconfig.pixel_height = 720_x000D_\nconfig.pixel_width = 1280_x000D_\nconfig.frame_height = 6.0_x000D_\nconfig.frame_width = 6.0_x000D_\n_x000D_\nclass SimpleNNVisualization(Scene):_x000D_\n    def construct(self):_x000D_\n        # Random input data generation_x000D_\n        input_data = np.random.rand(10, 3) * 0.1_x000D_\n_x000D_\n        # Define the layers of the neural network_x000D_\n        neural_net_layers = [_x000D_\n            FullyConnectedLayer(_x000D_\n                input_neurons=3,_x000D_\n                output_neurons=4,_x000D_\n                neuron_radius=0.15,_x000D_\n                layer_height=2.5_x000D_\n            ),_x000D_\n            FullyConnectedLayer(_x000D_\n                input_neurons=4,_x000D_\n                output_neurons=2,_x000D_\n                neuron_radius=0.15,_x000D_\n                layer_height=2.5_x000D_\n            ),_x000D_\n        ]_x000D_\n_x000D_\n        # Create the neural network object_x000D_\n        neural_network = NeuralNetwork(_x000D_\n            input_data=input_data,_x000D_\n            layers=neural_net_layers,_x000D_\n            spacing=0.3_x000D_\n        )_x000D_\n_x000D_\n        # Position the neural network on the screen_x000D_\n        neural_network.to_edge(LEFT, buff=0.75)_x000D_\n_x000D_\n        # Neural Network Animation_x000D_\n        animation = neural_network.get_edge_propagation_animation(run_time=2)_x000D_\n_x000D_\n        # Add neural network to the scene_x000D_\n        self.add(neural_network)_x000D_\n_x000D_\n        # Play the animation_x000D_\n        self.play(animation)_x000D_\n_x000D_\n        # Wait for a second after the animation has finished_x000D_\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animated video that demonstrates different concepts in chemistry, starting with the formation of a simple molecule. The video should show the individual atoms or particles coming together to form a molecule, followed by the transformation of this molecule into a metal oxide grid. Afterward, I'd like to see this grid change into a carbon grid structure. Both grid transformations should be smoothly animated. Finally, the animation should show an electron moving in a complex path around the molecule or grid, mimicking the motion of electrons in an atomic structure. The entire sequence should be visually engaging and help illustrate the dynamic nature of chemical structures. Can you create such an animation for me?",
        "answer": "\\n from manim import *\n\nclass HarmonicSeriesConvergence(Scene):\n    def construct(self):\n        # Introducing the Harmonic series\n        harmonic_series = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n}\")\n        self.play(Write(harmonic_series))\n        self.wait(1)\n\n        # Discuss convergence\n        convergence_text = Text(\"Does this series converge?\", font_size=24).to_edge(UP)\n        self.play(Write(convergence_text))\n        self.wait(2)\n\n        # Applying the integral test\n        integral_test = MathTex(r\"\\int_1^\\infty \\frac{1}{x} \\,dx\")\n        self.play(Transform(harmonic_series, integral_test))\n        self.wait(1)\n\n        # Display divergence explanation\n        divergence_explanation = Text(\"This improper integral diverges\", font_size=24).to_edge(UP)\n        self.play(Transform(convergence_text, divergence_explanation))\n        self.wait(1)\n\n        # Writing the steps for the integral test result\n        integral_steps = MathTex(r\"\\lim_{b \\to \\infty} \\ln{|x|}_1^b\")\n        self.play(ReplacementTransform(integral_test, integral_steps))\n        self.wait(1)\n\n        # Conclude with divergence of the series\n        divergent_result = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n}\", r\"\\text{ diverges}\")\n        self.play(ReplacementTransform(integral_steps, divergent_result))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Reaffirm the result\n        reaffirm_conclusion = Text(\"The harmonic series diverges.\", font_size=24)\n        self.play(Write(reaffirm_conclusion))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated visualization of a hydrogen atom and a hydrogen molecule (H2) using simple geometric shapes. The hydrogen atom should have one electron and one proton, while the hydrogen molecule should consist of two hydrogen atoms bonded together. Please animate the construction of the molecule step by step, first showing the individual proton and electron of one atom, then showing them combine, and finally adding the second hydrogen atom to form the molecule. I'd like the electrons and protons to be represented by circles with \"e-\" and \"p+\" labels, respectively. Can you color the electrons blue and the protons red, and make sure that the whole molecule centers itself on the screen after assembly?",
        "answer": "\\n from manim import *\n\nclass CircleAreaExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"A = \\pi r^2\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the area of a circle\n        explanation1 = Text(\"Area of a circle\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Introduce the variable for radius\n        radius_step = MathTex(r\"r = 2\")\n        self.play(FadeIn(radius_step, shift=DOWN))\n        self.wait(1)\n\n        # Explanation for substitution\n        explanation2 = Text(\"Substitute the value of r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Perform the substitution\n        substitution = MathTex(r\"A = \\pi (2)^2\")\n        self.play(ReplacementTransform(problem.copy(), substitution))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 4\\pi\")\n        self.play(ReplacementTransform(substitution, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"The area is 4\u03c0 units.\", font_size=36)))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation that visually represents a 5x5 grid where each cell contains either a carbon atom, an oxygen atom, a metal atom, or an electron, with the specific pattern that every alternate cell is a different type and follows certain rules\u2014for example, if both row and column indices are even, it will be a carbon atom, and if they are even and odd, it will be oxygen, but if the row index is divisible by 3 and the column index is odd, it should be a metal atom, otherwise, it's an electron. Then, can you animate a singular electron that enters the scene and follows a predefined path across the grid, bouncing from corner to corner until it reaches the center and stops, all while the entire grid fades into view initially and everything fades out at the end?",
        "answer": "\\n from manim import *\n\nclass SurfaceAreaExample(Scene):\n    def construct(self):\n        # Displaying the surface integral problem\n        problem = MathTex(r\"\\iint_S \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of parameterization of S\n        explanation1 = Text(\"Parameterize the surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterized surface\n        parameterized_surface = MathTex(r\"\\vec{r}(u,v) = u\\vec{i} + v\\vec{j} + f(u,v)\\vec{k}\")\n        self.play(ReplacementTransform(problem.copy(), parameterized_surface))\n        self.wait(1)\n\n        # Explanation for cross product\n        explanation2 = Text(\"Compute the cross product of partial derivatives\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Cross product step\n        cross_product = MathTex(r\"d\\vec{S} = \\left| \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right| du\\,dv\")\n        self.play(ReplacementTransform(parameterized_surface, cross_product))\n        self.wait(1)\n\n        # Explanation for dot product\n        explanation3 = Text(\"Take dot product with vector field\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Dot product step\n        dot_product = MathTex(r\"\\vec{F} \\cdot d\\vec{S} = \\vec{F} \\cdot \\left( \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right) du\\,dv\")\n        self.play(ReplacementTransform(cross_product, dot_product))\n        self.wait(1)\n\n        # Explanation for evaluating integral\n        explanation4 = Text(\"Evaluate the double integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final integrated solution\n        integrated_solution = MathTex(r\"\\iint_D \\vec{F} \\cdot \\left( \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right) du\\,dv\")\n        self.play(ReplacementTransform(dot_product, integrated_solution))\n        self.wait(1)\n\n        # Solution to the problem\n        final_solution = Text(\"The surface area is given by the evaluated integral\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "I would like an educational animation that visually represents a simple molecule with an electron moving around one of the atoms. The molecule should consist of an electron, an oxygen atom, a generic metal atom, and representations of a positive and a negative charge. The electron should start on the left side and move around the oxygen atom in a complex path, while the other parts of the molecule remain stationary. Please arrange the atoms and charges in a line, with the electron first, followed by the oxygen, metal, positive charge, and negative charge, each spaced evenly apart. After assembling them, show the electron orbiting the oxygen atom, to illustrate electron movement in molecular interactions.",
        "answer": "\\n from manim import *\n\nclass SortingVisualization(Scene):\n    def construct(self):\n        array = [4, 1, 3, 2, 5]\n        bars = VGroup(*[Rectangle(height=n, width=0.5, fill_opacity=1) for n in array])\n        bars.arrange(RIGHT, buff=0.1).to_edge(DOWN)\n\n        for i in range(len(array)):\n            for j in range(len(array) - i - 1):\n                bar1, bar2 = bars[j], bars[j + 1]\n                if array[j] > array[j + 1]:\n                    array[j], array[j + 1] = array[j + 1], array[j]\n                    self.play(\n                        bar1.animate.move_to(bar2.get_center()),\n                        bar2.animate.move_to(bar1.get_center()),\n                        run_time=0.5\n                    )\n                    bars[j], bars[j + 1] = bars[j + 1], bars[j]\n                self.wait(0.1)\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually represents the transfer of charge between an electron, a lithium ion, and a metal atom. Initially, all three particles should be shown in separate positions: the electron on the left, the lithium ion in the middle, and the metal atom on the right side of the screen. Then the animation should depict the electron moving towards the lithium ion and finally towards the metal atom in a sequence. After the electron's path, I want to show the lithium ion also moving towards the metal atom, indicating a charge transfer process. Following this, can the animation feature a grid that represents a metal oxide layer, consisting of multiple metal atoms, and fades into view in the central region of the screen? Finally, I'd like the animation to finish by fading out all elements on the screen. Can this entire process be visually demonstrated using an animation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"TransformMatchingShapes\").shift(UP*2.5)), run_time=0.5)\n            source_text = Text(\"tom marvolo riddle\")\n            dest_text = Text(\"lord voldemort\")\n            self.play(Write(source_text))\n            self.wait(0.5)\n            self.play(TransformMatchingShapes(source_text, dest_text, path_arc=PI/2))\n            self.wait(0.5)\n            self.remove(source_text,dest_text)"
    },
    {
        "query": "I need a visual representation for an educational video on chemistry, specifically showcasing a reaction at the molecular level. Can you create an animation with the following features?\n\n1. Show an oxygen molecule composed of two oxygen atoms, with a single unpaired electron nearby.\n2. Introduce a layer of carbon atoms from above.\n3. These three components should appear sequentially on the screen with a small delay between their appearances.\n4. After they have appeared, I want the unpaired electron to move along a curved path from one oxygen atom towards the carbon layer.\n5. Finally, end the animation by reorganizing the oxygen molecule, the unpaired electron, and the carbon layer into a product of a chemical reaction, showing them rearrange and align vertically.\n\nThe animation should be simple, without any complex backgrounds or additional elements, and it should convey the basic process of the reaction's mechanism.",
        "answer": "\\n from manim import *\n\nclass BasicArithmeticScene(Scene):\n    def construct(self):\n        # Define colors\n        background_color = WHITE\n        text_color = BLACK\n        operation_color = BLUE\n\n        # Set background color\n        self.camera.background_color = background_color\n\n        # Create equation parts\n        first_number = MathTex(\"3\", color=text_color).scale(2)\n        second_number = MathTex(\"2\", color=text_color).scale(2)\n        result_number = MathTex(\"6\", color=text_color).scale(2)\n        times_sign = MathTex(\"\\\\times\", color=operation_color).scale(2)\n\n        # Arrange equation on the screen\n        equation = VGroup(first_number, times_sign, second_number).arrange(RIGHT)\n        equals_sign = MathTex(\"=\", color=operation_color).scale(2)\n        equals_sign.next_to(equation, RIGHT)\n        result_number.next_to(equals_sign, RIGHT)\n\n        # Animate equation parts\n        self.play(Write(equation), run_time=0.5)\n        self.wait(0.5)\n        self.play(Write(equals_sign), run_time=0.5)\n        self.wait(0.5)\n        self.play(Write(result_number), run_time=0.5)\n\n        # Highlight the operation\n        highlight_rect = SurroundingRectangle(times_sign, color=operation_color)\n        self.play(Create(highlight_rect))\n        self.wait(0.5)\n\n        # Fade everything out\n        self.play(FadeOut(VGroup(equation, equals_sign, result_number, highlight_rect)), run_time=0.7)\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational chemistry animation that visually represents an electrochemical concept. The animation should start with a 3x3 grid of lithium ions to demonstrate the initial state of a battery's electrode. Then, it should transition to a single layer of carbon atoms to represent another electrode. Additionally, I want to include separate animations of an oxygen molecule and a metallic element, cobalt, symbolizing their interactions in the chemical process; have them appear one by one on opposite sides of the screen. \n\nFurthermore, animate the oxygen molecule moving in a triangular path to depict some sort of molecular motion or reaction pathway, showing the dynamic nature of the chemical processes within a battery. Please make sure the elements and ions are correctly labeled with their chemical symbols and charges, make it visually clear, and ensure that the animation runs smoothly and is visually engaging for students learning about chemistry.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Set up axes\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Displaying the integral problem\n        integral = MathTex(r\"\\int_{0}^{2} (x^2) \\,dx\")\n        integral.to_edge(UP)\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Graph function\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        # Display graph\n        self.play(Create(axes), Create(graph), FadeIn(graph_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = axes.get_area(graph, x_range=(0, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Calculate the area\n        solution = MathTex(r\"=\\frac{{(2)^3}}{3} - \\frac{{(0)^3}}{3}\")\n        solution.to_edge(DOWN)\n        self.play(ReplacementTransform(integral.copy(), solution))\n        self.wait(2)\n\n        # Simplify the solution\n        final_solution = MathTex(r\"=\\frac{8}{3}\")\n        final_solution.next_to(solution, DOWN)\n        self.play(Write(final_solution))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually represents how an electron moves through a grid of metal oxide cells. Can we have a 3x3 grid where alternating cells represent metal and oxygen atoms? For the electron, it should be represented as a small yellow circle with the label \"e-\" to symbolize an electron, and please animate it in such a way that it seems to be traveling around the grid in a complex path. The electron's path should include sharp turns at different grid points, giving the impression that it's navigating through this metallic environment. I also want the oxygen atoms to be slightly larger than the metal atoms and distinguished by a distinct color and the label \"O^2-\", and the metal atoms should have the label \"Co\". The animation should be clear and smooth with the path and stops of the electron easily visible. Can all this be done in a way that's visually appealing for a classroom setting?",
        "answer": "\\n from manim import *\nimport colour\n\n\nNUM_DOTS = 250\nFALL_TIME = 1\nRUNTIME = 2.5\nRED = \"#FF4040\"\nBLUE = \"#4040FF\"\n\n\nclass EventMobject(VGroup):\n    def __init__(self, probability, label, color=WHITE, y_coordinate=0):\n        super().__init__()\n        line = Line(\n            start=LEFT * probability * config[\"frame_width\"] * 0.5,\n            end=RIGHT * probability * config[\"frame_width\"] * 0.5,\n            stroke_width=12,\n            color=color,\n        )\n        label = Tex(label, color=color).next_to(line, direction=DOWN)\n\n        self.line = line\n        self.label = label\n        self.event_color = color\n\n        self.add(self.line, self.label)\n\n    def put_start_and_end_on(self, start, end):\n        self.line.put_start_and_end_on(start, end)\n        self.label.next_to(self.line, direction=DOWN)\n\n    def set_label(self, label):\n        self.label = Tex(label, color=self.event_color)\n        self.submobjects[1] = self.label\n\n    def set_color(self, color):\n        super().set_color(color)\n        self.event_color = color\n\n\nclass Label(VDict):\n    def __init__(self, label, color=BLUE):\n        super().__init__()\n        tex = Tex(label, color=color)\n        label_background = Rectangle(\n            height=tex.get_height() + MED_SMALL_BUFF,\n            width=tex.get_width() + MED_SMALL_BUFF,\n            stroke_opacity=0,\n            fill_color=BLACK,\n            fill_opacity=1,\n        ).move_to(tex.get_center())\n        self.add({\"background\": label_background, \"tex\": tex})\n\n\nclass DraftScene(Scene):\n    def construct(self):\n        event_a = EventMobject(0.7, \"$A$\", color=BLUE).shift(\n            UP * 0.1 * config[\"frame_height\"]\n        )\n        events = [event_a]\n\n        p_a = Label(\"P($A$)\").to_corner(UP + RIGHT)\n\n        self.add(event_a, p_a)\n        self.wait(0.5)\n\n        self.raindrop_scene(events, p_a)\n\n        p_not_a = Label(\"P($\\\\neg A$)\").to_corner(UP + RIGHT)\n\n        self.play(\n            event_a.set_color,\n            WHITE,\n            FadeOutAndShift(p_a),\n            FadeInFrom(p_not_a, UP),\n        )\n\n        event_a.event_color = WHITE\n        self.raindrop_scene(events, p_not_a, default_dot_color=BLUE)\n\n        event_a_target = event_a.generate_target()\n        event_a_target.put_start_and_end_on(\n            UP * 0.2 * config[\"frame_height\"]\n            + LEFT * (0.5 * config[\"frame_width\"] - 1),\n            UP * 0.2 * config[\"frame_height\"] + RIGHT * 2.5,\n        )\n        event_a_target.set_color(BLUE)\n\n        event_b = event_a_target.copy()\n        event_b.set_label(\"$B$\")\n        event_b.put_start_and_end_on(\n            UP * 0.0 * config[\"frame_height\"]\n            + RIGHT * (0.5 * config[\"frame_width\"] - 1),\n            UP * 0.0 * config[\"frame_height\"] + LEFT * 2.5,\n        )\n        events.append(event_b)\n        p_a_or_b = Label(\"P($A \\\\cup B$)\").to_corner(UP + RIGHT)\n\n        self.play(\n            MoveToTarget(event_a),\n            FadeIn(event_b),\n            FadeOutAndShift(p_not_a),\n            FadeInFrom(p_a_or_b, UP),\n        )\n        event_a.event_color = BLUE\n        self.raindrop_scene(events, p_a_or_b)\n\n        p_a_and_b = Label(\n            \"P($A \\\\cap B$)\", color=interpolate_color(BLUE, RED, 0.5)\n        ).to_corner(UP + RIGHT)\n        self.play(\n            event_b.set_color,\n            RED,\n            FadeOutAndShift(p_a_or_b),\n            FadeInFrom(p_a_and_b, UP),\n        )\n        event_b.event_color = RED\n\n        self.raindrop_scene(events, p_a_and_b)\n\n        p_a_given_b = Label(\n            \"P($A \\\\mid B$)\", color=interpolate_color(BLUE, RED, 0.5)\n        ).to_corner(UP + RIGHT)\n\n        event_b_target = event_b.generate_target()\n        event_b_target.put_start_and_end_on(\n            UP * event_b.line.get_center()[1] + RIGHT * 0.5 * config[\"frame_width\"],\n            UP * event_b.line.get_center()[1] + LEFT * 0.5 * config[\"frame_width\"],\n        )\n\n        # Scale both events by the same amount.\n        event_b_growth_ratio = (\n            event_b_target.line.get_length() / event_b.line.get_length()\n        )\n        event_a_offset = event_a.line.get_right()[0] - event_b.line.get_right()[0]\n\n        event_a_target = event_a.generate_target()\n        event_a_right = UP * event_a.line.get_center()[1] + RIGHT * (\n            event_b_target.line.get_right()[0] + event_a_offset * event_b_growth_ratio\n        )\n        event_a_target.put_start_and_end_on(\n            event_a_right + LEFT * event_b_target.line.get_length(),\n            event_a_right,\n        )\n        event_a_target.label.move_to(\n            UP * event_a.label.get_center()[1]\n            + RIGHT\n            * (event_a_target.get_right()[0] - config[\"frame_width\"] * 0.5)\n            * 0.5\n        )\n\n        self.play(\n            FadeOutAndShift(p_a_and_b),\n            FadeInFrom(p_a_given_b, UP),\n            MoveToTarget(event_b),\n            MoveToTarget(event_a),\n        )\n\n        self.raindrop_scene(events, p_a_given_b)\n\n        self.wait()\n\n    def raindrop_scene(self, events, label, default_dot_color=WHITE):\n        upper_left_corner = (\n            UP * 0.5 * config[\"frame_height\"] + LEFT * 0.5 * config[\"frame_width\"]\n        )\n\n        tracker = ValueTracker(0)\n        tracker.add_updater(lambda t, dt: t.increment_value(dt))\n        self.add(tracker)\n\n        # Reach the bottom of the screen in 1 second\n        falling_rate = config[\"frame_height\"] / FALL_TIME\n\n        def fall(dot, dt):\n            if tracker.get_value() < dot.falling_delay:\n                return\n            old_center = dot.get_center()\n            dot.shift(DOWN * falling_rate * dt)\n            new_center = dot.get_center()\n\n            for event in events:\n                if (\n                    event.get_left()[0] < old_center[0]\n                    and old_center[0] < event.get_right()[0]\n                    and new_center[1] < event.line.get_center()[1]\n                    and event.line.get_center()[1] < old_center[1]\n                ):\n                    dot_color = np.array(color.Color(dot.get_color()).get_rgb())\n                    event_color = np.array(color.Color(event.event_color).get_rgb())\n                    dot.color_array.append(event_color)\n                    new_color = interpolate(\n                        dot_color, event_color, 1 / len(dot.color_array)\n                    )\n                    dot.set_color(colour.Color(rgb=new_color))\n\n        for _ in range(NUM_DOTS):\n            dot = Dot(color=default_dot_color).move_to(\n                upper_left_corner + random.random() * RIGHT * config[\"frame_width\"]\n            )\n            dot.shift(UP * dot.radius)\n            dot.falling_delay = random.random() * RUNTIME\n            dot.color_array = []\n            dot.add_updater(fall)\n            self.add(dot)\n\n        self.add(*events)\n        self.add(label)\n        self.wait(RUNTIME + FALL_TIME)"
    },
    {
        "query": "Can you create an educational chemistry animation that shows different chemical entities? I would like to see an individual electron, an oxygen molecule, a generic metal atom, both a positive ion and a negative ion, and then grids made of metal oxide, lithium, and carbon. Arrange the single entities above each other, and each grid below them. Also, please place the oxygen molecule directly above the center of the scene, the metal atom to its right, the positive ion further right, and the negative ion to the left of the oxygen molecule. Then, for each grid, I want them aligned towards the bottom of the scene\u2014metal oxide in the center, lithium to the right, and carbon to the left. Each of these should be spaced evenly.",
        "answer": "\\n from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Explanation for converting to a closed form\n        explanation1 = Text(\"Convert the geometric series to a closed form\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Setting up the closed form expression\n        closed_form_setup = MathTex(r\"S = \\frac{a}{1 - r}, \\text{ for } |r| < 1\")\n        self.play(ReplacementTransform(problem.copy(), closed_form_setup))\n        self.wait(1)\n        \n        # Apply the closed form to a specific example\n        example_problem = MathTex(r\"S = \\sum_{n=0}^{\\infty} \\frac{1}{2^n}\")\n        self.play(Write(example_problem))\n        self.wait(1)\n        \n        # Explanation for substituting values into the formula\n        explanation2 = Text(\"Substitute values into the closed form\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculation of the specific example\n        example_calculation = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}}\")\n        self.play(ReplacementTransform(example_problem, example_calculation))\n        self.wait(1)\n        \n        # Showing the final solution\n        final_solution = MathTex(r\"S = 2\")\n        self.play(ReplacementTransform(example_calculation, final_solution))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"Sum of the series is 2\", font_size=36)))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation that illustrates an electron moving around a metal oxide lattice. The lattice should be a 3 by 3 grid. The electron starts in the top left corner, moves horizontally to the top right corner, then vertically to the bottom right corner, and finally horizontally again to the bottom left corner before returning to the top left corner. During its journey, the electron should momentarily stop at the top right and bottom left corners before continuing its path. Please animate this path smoothly, possibly over a time span of two seconds, and have slight pauses at the specified stop points. Can you show me how this would look like in an animated format?",
        "answer": "\\n from manim import *\n\n# VoiceOver imports\nfrom manim_voiceover import VoiceoverScene\nfrom manim_voiceover.services.gtts import GTTSService\nfrom manim_voiceover.services.azure import AzureService\n\n\nclass FourierSeries(VoiceoverScene):\n    def construct(self):\n        # Basic self settings.\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble(r\"\\usepackage{csquotes}\")\n        # self.add(NumberPlane())\n        self.always_update_mobjects = True\n        self.set_speech_service(AzureService(voice=\"en-GB-OliverNeural\", style=\"newscast-casual\"))\n        # self.set_speech_service(GTTSService())\n\n        ourBasicTrigonometricSeriesIs = Text(text=\"We know that the basic trigonometric series is: \", font=\"Arial\",\n                                             font_size=52, weight=SEMIBOLD, width=12, color=GREEN)\n        theBasicTrigonometricEquation = MathTex(r\"\\frac{A_0}{2} + \\sum_{n=1}^{\\infty} (A_n\\cos nx + B_n\\sin nx)\",\n                                                font_size=48)\n        g1 = Group(ourBasicTrigonometricSeriesIs, theBasicTrigonometricEquation).arrange(DOWN, buff=MED_LARGE_BUFF)\n\n        with self.voiceover(text=\"We know that the basic trigonometric series is...\") as tracker:\n            self.play(AddTextLetterByLetter(ourBasicTrigonometricSeriesIs), run_time=tracker.duration / 1.8)\n\n        with self.voiceover(text=\"the equation appearing on the screen.\") as tracker:\n            self.play(FadeIn(theBasicTrigonometricEquation), run_time=tracker.duration / 1.5)\n\n        self.play(g1.animate.scale(0.65).shift(2.9 * UP), run_time=0.8)\n\n        itWillCalled = Tex(\n            r'This equation will be called \\textbf{\\enquote{Fourier Series}} if the terms $A_0, A_n, B_n$ could be substituted into:',\n            tex_template=myTemplate, font_size=34)\n        A0 = MathTex(r\"A_0 = \\frac{1}{2\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cdot dx\", font_size=40)\n        An = MathTex(r\"A_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cdot \\cos nx\\cdot dx\", font_size=40)\n        Bn = MathTex(r\"B_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cdot \\sin nx\\cdot dx\", font_size=40)\n        g2 = Group(A0, An, Bn).arrange(DOWN, buff=MED_SMALL_BUFF).move_to(0.5 * DOWN)\n        whereFX = Tex(r\"Where \\textbf{$f(x)$} is any single-valued function defined in interval $(-\\pi, \\pi)$.\",\n                      font_size=35).next_to(g2, 1 * DOWN)\n\n        with self.voiceover(\n                text=\"This equation will be called \\\"Fourier Series\\\" if the terms, A nought, A N, B N could be substituted into\") as tracker:\n            self.play(Create(itWillCalled), run_time=tracker.duration / 1.2)\n\n        self.play(itWillCalled.animate.scale(0.7).next_to(g2, 1.3 * UP), run_time=0.3)\n        self.play(itWillCalled.animate.set_fill(RED), SpinInFromNothing(g2), point_color=RED, run_time=0.8)\n\n        with self.voiceover(text=\"these equations.\") as tracker:\n            self.play(Indicate(g2), run_time=tracker.duration)\n\n        with self.voiceover(\n                text=\"Where F of x is any single valued function defined in the exclusive interval from minus pai to pai.\") as tracker:\n            self.play(Write(whereFX), run_time=tracker.duration / 1.8)\n\n        self.play(whereFX.animate(run_time=1.2).shift(0.5 * DOWN).scale(1.15))\n\n        with self.voiceover(text=\"Thank you for watching.\") as tracker:\n            self.play(Circumscribe(whereFX), run_time=tracker.duration * 1.2)\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that illustrates the formation of a water molecule from oxygen and hydrogen atoms. Can you show two blue hydrogen atoms with positive signs coming together with one larger red oxygen atom marked with an 'O' to form a water molecule? Once they are combined, can the molecule rotate and shrink to a smaller size before keeping it steady on the screen? Also, please make sure each step is clearly visible and takes a few seconds to complete so it's easy to understand what's happening.",
        "answer": "\\n from manim import *\n\nfrom manim_ml.neural_network import NeuralNetwork\nfrom manim_ml.neural_network.layers.parent_layers import NeuralNetworkLayer, ConnectiveLayer, ThreeDLayer\nimport manim_ml\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 10.5\nconfig.frame_width = 10.5\n\nclass NeocognitronFilter(VGroup):\n    \"\"\"\n        Filter connecting the S and C Cells of a neocognitron layer.\n    \"\"\"\n\n    def __init__(\n        self,\n        input_cell, \n        output_cell, \n        receptive_field_radius, \n        outline_color=BLUE,\n        active_color=ORANGE, \n        **kwargs\n    ):\n        super().__init__(**kwargs)\n        self.outline_color = outline_color\n        self.active_color = active_color\n        self.input_cell = input_cell\n        self.output_cell = output_cell\n        # Draw the receptive field\n        # Make the points of a equilateral triangle in the plane of the \n        # cell about a random center\n        # center_point = input_cell.get_center()\n        shift_amount_x = np.random.uniform(\n            -(input_cell.get_height()/2 - receptive_field_radius - 0.01),\n            input_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        shift_amount_y = np.random.uniform(\n            -(input_cell.get_height()/2 - receptive_field_radius - 0.01),\n            input_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        # center_point += np.array([shift_amount_x, shift_amount_y, 0])\n        # # Make the triangle points\n        # side_length = np.sqrt(3) * receptive_field_radius\n        # normal_vector = np.cross(\n        #     input_cell.get_left() - input_cell.get_center(),\n        #     input_cell.get_top() - input_cell.get_center(),\n        # )\n        # Get vector in the plane of the cell\n        # vector_in_plane = input_cell.get_left() - input_cell.get_center()\n        # point_a = center_point + vector_in_plane * receptive_field_radius\n        # # rotate the vector 120 degrees about the vector normal to the cell\n        # vector_in_plane = rotate_vector(vector_in_plane, PI/3, normal_vector)\n        # point_b = center_point + vector_in_plane * receptive_field_radius\n        # # rotate the vector 120 degrees about the vector normal to the cell\n        # vector_in_plane = rotate_vector(vector_in_plane, PI/3, normal_vector)\n        # point_c = center_point + vector_in_plane * receptive_field_radius\n        # self.receptive_field = Circle.from_three_points(\n        #     point_a, \n        #     point_b,\n        #     point_c,\n        #     color=outline_color,\n        #     stroke_width=2.0,\n        # )\n        self.receptive_field = Circle(\n            radius=receptive_field_radius,\n            color=outline_color,\n            stroke_width=3.0,\n        )\n        self.add(self.receptive_field)\n        # Move receptive field to a random point within the cell\n        # minus the radius of the receptive field\n        self.receptive_field.move_to(\n            input_cell\n        )\n        # Shift a random amount in the x and y direction within \n        self.receptive_field.shift(\n            np.array([shift_amount_x, shift_amount_y, 0])\n        )\n        # Choose a random point on the c_cell\n        shift_amount_x = np.random.uniform(\n            -(output_cell.get_height()/2 - receptive_field_radius - 0.01),\n            output_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        shift_amount_y = np.random.uniform(\n            -(output_cell.get_height()/2 - receptive_field_radius - 0.01),\n            output_cell.get_height()/2 - receptive_field_radius - 0.01,\n        )\n        self.dot = Dot(\n            color=outline_color,\n            radius=0.04\n        )\n        self.dot.move_to(output_cell.get_center() + np.array([shift_amount_x, shift_amount_y, 0]))\n        self.add(self.dot)\n        # Make lines connecting receptive field to the dot\n        self.lines = VGroup()\n        self.lines.add(\n            Line(\n                self.receptive_field.get_center() + np.array([0, receptive_field_radius, 0]),\n                self.dot,\n                color=outline_color,\n                stroke_width=3.0,\n            )\n        )\n        self.lines.add(\n            Line(\n                self.receptive_field.get_center() - np.array([0, receptive_field_radius, 0]),\n                self.dot,\n                color=outline_color,\n                stroke_width=3.0,\n            )\n        )\n        self.add(self.lines)\n\n    def make_filter_pulse_animation(self, **kwargs):\n        succession = Succession(\n            ApplyMethod(\n                self.receptive_field.set_color, \n                self.active_color, \n                run_time=0.25\n            ),\n            ApplyMethod(\n                self.receptive_field.set_color, \n                self.outline_color, \n                run_time=0.25\n            ),\n            ShowPassingFlash(\n                self.lines.copy().set_color(self.active_color),\n                time_width=0.5,\n            ),\n            ApplyMethod(\n                self.dot.set_color, \n                self.active_color, \n                run_time=0.25\n            ),\n            ApplyMethod(\n                self.dot.set_color, \n                self.outline_color, \n                run_time=0.25\n            ),\n        )\n\n        return succession\n\nclass NeocognitronLayer(NeuralNetworkLayer, ThreeDLayer):\n    \n    def __init__(\n        self, \n        num_cells, \n        cell_height,\n        receptive_field_radius,\n        layer_name,\n        active_color=manim_ml.config.color_scheme.active_color,\n        cell_color=manim_ml.config.color_scheme.secondary_color,\n        outline_color=manim_ml.config.color_scheme.primary_color,\n        show_outline=True,\n        **kwargs\n    ):\n        super().__init__(**kwargs)\n        self.num_cells = num_cells\n        self.cell_height = cell_height\n        self.receptive_field_radius = receptive_field_radius\n        self.layer_name = layer_name\n        self.active_color = active_color\n        self.cell_color = cell_color\n        self.outline_color = outline_color\n        self.show_outline = show_outline\n\n        self.plane_label = Text(layer_name).scale(0.4)\n\n    def make_cell_plane(self, layer_name, cell_buffer=0.1, stroke_width=2.0):\n        \"\"\"Makes a plane of cells. \n        \"\"\"\n        cell_plane = VGroup()\n        for cell_index in range(self.num_cells):\n            # Draw the cell box\n            cell_box = Rectangle(\n                width=self.cell_height,\n                height=self.cell_height,\n                color=self.cell_color,\n                fill_color=self.cell_color,\n                fill_opacity=0.3,\n                stroke_width=stroke_width,\n            )\n            if cell_index > 0:\n                cell_box.next_to(cell_plane[-1], DOWN, buff=cell_buffer)\n            cell_plane.add(cell_box)\n        # Draw the outline\n        if self.show_outline:\n            self.plane_outline = SurroundingRectangle(\n                cell_plane,\n                color=self.cell_color,\n                buff=cell_buffer,\n                stroke_width=stroke_width,\n            )\n            cell_plane.add(\n                self.plane_outline\n            )\n        # Draw a label above the container box\n        self.plane_label.next_to(cell_plane, UP, buff=0.2)\n        cell_plane.add(self.plane_label)\n\n        return cell_plane\n\n    def construct_layer(self, input_layer, output_layer, **kwargs):\n        # Make the Cell layer\n        self.cell_plane = self.make_cell_plane(self.layer_name)\n        self.add(self.cell_plane)\n        \n    def make_forward_pass_animation(self, layer_args={}, **kwargs):\n        \"\"\"Forward pass for query\"\"\"\n        # # Pulse and un pulse the cell plane rectangle\n        flash_outline_animations = []\n        for cell in self.cell_plane:\n            flash_outline_animations.append(\n                Succession(\n                    ApplyMethod(\n                        cell.set_stroke_color,\n                        self.active_color,\n                        run_time=0.25\n                    ),\n                    ApplyMethod(\n                        cell.set_stroke_color,\n                        self.outline_color,\n                        run_time=0.25\n                    )\n                )\n            )\n        \n        return AnimationGroup(\n            *flash_outline_animations,\n            lag_ratio=0.0\n        )\n\nclass NeocognitronToNeocognitronLayer(ConnectiveLayer):\n    input_class = NeocognitronLayer\n    output_class = NeocognitronLayer\n\n    def __init__(self, input_layer, output_layer, **kwargs):\n        super().__init__(input_layer, output_layer, **kwargs)\n\n    def construct_layer(self, input_layer, output_layer, **kwargs):\n        self.filters = []\n        for cell_index in range(input_layer.num_cells):\n            input_cell = input_layer.cell_plane[cell_index]\n            # Randomly choose a cell from the output layer\n            output_cell = output_layer.cell_plane[\n                np.random.randint(0, output_layer.num_cells)\n            ]\n            # Make the filter\n            filter = NeocognitronFilter(\n                input_cell=input_cell,\n                output_cell=output_cell,\n                receptive_field_radius=input_layer.receptive_field_radius,\n                outline_color=self.input_layer.outline_color\n            )\n            # filter = NeocognitronFilter(\n            #     outline_color=input_layer.outline_color\n            # )\n            self.filters.append(filter)\n\n        self.add(VGroup(*self.filters))\n\n    def make_forward_pass_animation(self, layer_args={}, **kwargs):\n        \"\"\"Forward pass for query\"\"\"\n        filter_pulses = []\n        for filter in self.filters:\n            filter_pulses.append(\n                filter.make_filter_pulse_animation()\n            )\n        return AnimationGroup(\n            *filter_pulses\n        )\n\nmanim_ml.neural_network.layers.util.register_custom_connective_layer(\n    NeocognitronToNeocognitronLayer,\n)\n\nclass Neocognitron(NeuralNetwork):\n\n    def __init__(\n        self, \n        camera,\n        cells_per_layer=[4, 5, 4, 4, 3, 3, 5, 5],\n        cell_heights=[0.8, 0.8, 0.8*0.75, 0.8*0.75, 0.8*0.75**2, 0.8*0.75**2, 0.8*0.75**3, 0.02],\n        layer_names=[\"S1\", \"C1\", \"S2\", \"C2\", \"S3\", \"C3\", \"S4\", \"C4\"],\n        receptive_field_sizes=[0.2, 0.2, 0.2*0.75, 0.2*0.75, 0.2*0.75**2, 0.2*0.75**2, 0.2*0.75**3, 0.0],\n    ):\n        self.cells_per_layer = cells_per_layer\n        self.cell_heights = cell_heights\n        self.layer_names = layer_names\n        self.receptive_field_sizes = receptive_field_sizes\n        # Make the neo-cognitron input layer\n        input_layers = []\n        input_layers.append(\n            NeocognitronLayer(\n                1,\n                1.5,\n                0.2,\n                \"U0\",\n                show_outline=False,\n            )\n        )\n        # Make the neo-cognitron layers\n        for i in range(len(cells_per_layer)):\n            layer = NeocognitronLayer(\n                cells_per_layer[i],\n                cell_heights[i],\n                receptive_field_sizes[i],\n                layer_names[i]\n            )\n            input_layers.append(layer)\n        \n        # Make all of the layer labels fixed in frame\n        for layer in input_layers:\n            if isinstance(layer, NeocognitronLayer):\n                # camera.add_fixed_orientation_mobjects(layer.plane_label)\n                pass\n\n        all_layers = []\n        for layer_index in range(len(input_layers) - 1):\n            input_layer = input_layers[layer_index]\n            all_layers.append(input_layer)\n            output_layer = input_layers[layer_index + 1]\n            connective_layer = NeocognitronToNeocognitronLayer(\n                input_layer,\n                output_layer\n            )\n            all_layers.append(connective_layer)\n        all_layers.append(input_layers[-1])\n\n        def custom_layout_func(neural_network):\n            # Insert the connective layers\n            # Pass the layers to neural network super class\n            # Rotate pairs of layers\n            layer_index = 1\n            while layer_index < len(input_layers):\n                prev_layer = input_layers[layer_index - 1]\n                s_layer = input_layers[layer_index]\n                s_layer.next_to(prev_layer, RIGHT, buff=0.0)\n                s_layer.shift(RIGHT * 0.4)\n                c_layer = input_layers[layer_index + 1]\n                c_layer.next_to(s_layer, RIGHT, buff=0.0)\n                c_layer.shift(RIGHT * 0.2)\n                # Rotate the pair of layers\n                group = Group(s_layer, c_layer)\n                group.move_to(np.array([group.get_center()[0], 0, 0]))\n\n                # group.shift(layer_index * 3 * np.array([0, 0, 1.0]))\n                # group.rotate(40 * DEGREES, axis=UP, about_point=group.get_center())\n                # c_layer.rotate(40*DEGREES, axis=UP, about_point=group.get_center())\n                # s_layer.shift(\n                #     layer_index // 2 * np.array([0, 0, 0.3])\n                # )\n                # c_layer.shift(\n                #     layer_index // 2 * np.array([0, 0, 0.3])\n                # )\n                layer_index += 2\n            neural_network.move_to(ORIGIN)\n\n        super().__init__(\n            all_layers,\n            layer_spacing=0.5,\n            custom_layout_func=custom_layout_func\n        )\n\nclass Scene(ThreeDScene):\n\n    def construct(self):\n        neocognitron = Neocognitron(self.camera)\n        neocognitron.shift(DOWN*0.5)\n        self.add(neocognitron)\n        title = Text(\"Neocognitron\").scale(1)\n        self.add_fixed_in_frame_mobjects(title)\n        title.next_to(neocognitron, UP, buff=0.4)\n        self.add(title)\n        \"\"\"\n        self.play(\n            neocognitron.make_forward_pass_animation()\n        )\n        \"\"\"\n        print(self.camera.gamma)\n        print(self.camera.theta)\n        print(self.camera.phi)\n        neocognitron.rotate(90*DEGREES, axis=RIGHT)\n        neocognitron.shift(np.array([0, 0, -0.2]))\n        # title.rotate(90*DEGREES, axis=RIGHT)\n        # self.set_camera_orientation(phi=-15*DEGREES)\n        # vec = np.array([0.0, 0.2, 0.0])\n        # vec /= np.linalg.norm(vec)\n        # x, y, z = vec[0], vec[1], vec[2]\n        # theta = np.arccos(z)\n        # phi = np.arctan(y / x)\n        self.set_camera_orientation(phi=90 * DEGREES, theta=-70*DEGREES, gamma=0*DEGREES)\n        # self.set_camera_orientation(theta=theta, phi=phi)\n\n        forward_pass = neocognitron.make_forward_pass_animation()\n        self.play(forward_pass)"
    },
    {
        "query": "Can you create an educational animation using Manim that shows a simplified model of a hydrogen atom with a proton at the center and an electron orbiting around it in a circular path? The proton should be represented by a red circle with a \"P+\" symbol inside it to indicate a positively charged particle, and the electron should be a small white dot moving around the proton in a blue orbit. Both the orbit and particles should fade in at the start, and then the electron should start orbiting smoothly around the proton for one complete cycle in two seconds. Additionally, can you provide a way to animate the electron moving along a custom path around the orbit continuously if needed?",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Fourier Series Demo\").shift(UP*3)\n        self.play(Write(title))\n\n        # Original function\n        original_function_tex = MathTex(r\"f(t) = \\begin{cases} 1 & \\text{for } 0 \\leq t < \\pi, \\\\ -1 & \\text{for } -\\pi \\leq t < 0. \\end{cases}\")\n        self.play(Write(original_function_tex))\n        self.wait(2)\n\n        # Fourier series definition\n        fourier_series_definition = MathTex(r\"f(t) \\approx \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} [a_n \\cos(n t) + b_n \\sin(n t)]\")\n        fourier_series_definition.next_to(original_function_tex, DOWN)\n        self.play(Transform(original_function_tex, fourier_series_definition))\n        self.wait(2)\n\n        # Coefficients for Fourier series\n        coefficients = MathTex(r\"a_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(t) \\cos(n t) \\, dt\", \n                               r\"b_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(t) \\sin(n t) \\, dt\")\n        coefficients.next_to(fourier_series_definition, DOWN)\n        self.play(Write(coefficients))\n        self.wait(2)\n\n        # Visual representation of Fourier series\n        visual_rep = Text(\"Visual Representation of Fourier Series on a Graph\", font_size=24).to_edge(DOWN)\n        self.play(Write(visual_rep))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude\n        conclude_text = Text(\"The Fourier series approximates periodic functions.\", font_size=24).to_edge(UP)\n        self.play(Write(conclude_text))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that demonstrates the formation of an oxygen molecule by showing two oxygen atoms coming together, sharing an electron, creating a bond, and then having the entire molecule shift upwards, shrink in size, rotate, and finally disappear?",
        "answer": "\\n from manim import *\n\nclass CircleAreaScene(Scene):\n    def construct(self):\n        # Write the equation of the circle area\n        equation = MathTex(\"A = \\pi r^2\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explain the elements of the equation\n        explanation = Text(\"Area of a circle with radius r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Highlight the radius squared term\n        square_term = equation[2:5]\n        self.play(Indicate(square_term))\n        self.wait(1)\n\n        # Show a circle with its radius\n        circle = Circle(color=BLUE)\n        radius = Line(ORIGIN, RIGHT, color=GREEN).shift(DOWN)\n        radius_label = MathTex(\"r\").next_to(radius, DOWN)\n        self.play(Create(circle), GrowFromPoint(radius, ORIGIN), Write(radius_label))\n        self.wait(2)\n\n        # Calculate the area for r=1\n        area_calculation = MathTex(r\"A = \\pi \\cdot 1^2 = \\pi\")\n        self.play(Transform(equation, area_calculation))\n        self.wait(1)\n\n        # Show that for r=1, the area of the circle is \u03c0\n        circle_area_highlight = Circle(color=YELLOW).scale(np.sqrt(np.pi))\n        self.play(Transform(circle, circle_area_highlight), FadeOut(radius), FadeOut(radius_label))\n        self.wait(1)\n\n        # Clear the scene and show the final area value\n        self.clear()\n        self.wait(1)\n        self.play(Write(area_calculation))\n        self.wait(1)"
    },
    {
        "query": "Can you create an educational animation using ManimCE that shows a 5 by 5 grid representing a simplified atomic structure, alternating between two elements like chlorine and sodium, with each atom represented by a colored circle and the element's symbol in the center? The chlorine atoms should have a green circle with 'Cl' in white text, and the sodium atoms should have an orange circle with 'Na' in white text. The animation should start by building up this grid of atoms and pause for a couple of seconds once complete so it's clear to viewers.",
        "answer": "\\n from manim import *\n\nclass LinearWaveExampleScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(60 * DEGREES, -45 * DEGREES)\n        wave = LinearWave()\n        self.add(wave)\n        wave.start_wave()\n        self.wait()\n        wave.stop_wave()"
    },
    {
        "query": "I would like to have an animation that displays a 4x4 grid of hydrogen molecules, each made up of two hydrogen atoms connected by a bond, which then all fade in from above, rotate together by 90 degrees, and then fade out downwards. Could you create something like that for me?",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration step\n        explanation = Text(\"Integrate by reversing the power rule of differentiation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)"
    },
    {
        "query": "Can you create a simple educational animation using ManimCE that displays four different colored atoms labeled as hydrogen, carbon, nitrogen, and oxygen? They should initially appear one by one, from different directions, and then arrange themselves in a 2x2 grid. After forming the grid, I'd like the group of atoms to rotate 90 degrees on the screen and then hold the image for a couple of seconds before ending the animation.",
        "answer": "\\n class ShapeOverlay(Scene):\n    def construct(self):\n        red_triangle = Triangle(color=RED, fill_opacity=0.7)\n        yellow_hexagon = RegularPolygon(n=6, color=YELLOW, fill_opacity=0.5)\n        yellow_hexagon.next_to(red_triangle, UP)\n        self.play(FadeIn(red_triangle), GrowFromCenter(yellow_hexagon))\n        self.wait(1)\n        self.play(FadeOut(red_triangle), ShrinkToPoint(yellow_hexagon, UP))"
    },
    {
        "query": "Can you create an animation that shows a simplified model of a hydrogen atom with an orbiting electron and then demonstrates the electron migrating along a path while the atom follows it, eventually fading both the electron and the atom out of view?",
        "answer": "\\n from manim import *\nfrom random import uniform\n\nclass ReceptiveField(VGroup):\n    def __init__(self, center_cell, cells, radius=0.5, **kwargs):\n        super().__init__(**kwargs)\n        self.center_cell = center_cell\n        self.cells = cells\n        self.radius = radius\n        self.circle = Circle(\n            radius=self.radius,\n            color=WHITE\n        )\n        self.circle.move_to(self.center_cell.get_center())\n        self.add(self.circle)\n        self.lines = VGroup()\n        for cell in self.cells:\n            line = Line(\n                start=self.center_cell.get_center(),\n                end=cell.get_center(),\n                stroke_width=1.5,\n                color=WHITE\n            )\n            self.lines.add(line)\n            self.add(line)\n\n    def highlight(self, color=YELLOW):\n        self.circle.set_color(color)\n        for line in self.lines:\n            line.set_color(color)\n\n    def reset_color(self):\n        self.highlight(WHITE)\n\nclass VisualCortexLayer(VGroup):\n    CONFIG = {\n        \"neuron_radius\": 0.2,\n        \"neuron_spacing\": 0.6,\n        \"neuron_color\": BLUE,\n        \"layer_name\": \"Layer\",\n    }\n\n    def __init__(self, n_neurons, **kwargs):\n        super().__init__(**kwargs)\n        self.n_neurons = n_neurons\n        self.neurons = VGroup()\n\n        for i in range(n_neurons):\n            neuron = Circle(\n                radius=self.neuron_radius,\n                color=self.neuron_color,\n                fill_opacity=0.5\n            )\n            neuron.move_to(i * self.neuron_spacing * RIGHT)\n            self.neurons.add(neuron)\n\n        self.add(self.neurons)\n        self.layer_label = Text(self.layer_name, font_size=24)\n        self.layer_label.next_to(self.neurons, UP, buff=0.1)\n        self.add(self.layer_label)\n\n    def get_neurons(self):\n        return self.neurons\n\nclass ConnectionPattern(VGroup):\n    CONFIG = {\n        \"pattern_color\": RED,\n    }\n\n    def __init__(self, layer1, layer2, **kwargs):\n        super().__init__(**kwargs)\n        self.layer1 = layer1\n        self.layer2 = layer2\n        self.receptive_fields = VGroup()\n\n        for neuron in layer1.get_neurons():\n            connected_neurons = self.select_connected_neurons(layer2)\n            receptive_field = ReceptiveField(\n                center_cell=neuron,\n                cells=connected_neurons,\n                radius=uniform(0.3, 0.5)\n            )\n            self.receptive_fields.add(receptive_field)\n        self.add(self.receptive_fields)\n\n    def select_connected_neurons(self, layer, n_connections=3):\n        return random.sample(layer.get_neurons(), n_connections)\n\nclass VisualCortexNetwork(VGroup):\n    CONFIG = {\n        \"n_layers\": 4,\n    }\n\n    def __init__(self, neurons_per_layer, **kwargs):\n        super().__init__(**kwargs)\n        self.layers = []\n        self.connections = VGroup()\n        prev_layer = None\n\n        for i, n_neurons in enumerate(neurons_per_layer):\n            layer = VisualCortexLayer(\n                n_neurons,\n                layer_name=f\"Layer {i+1}\"\n            )\n            self.layers.append(layer)\n            if prev_layer is not None:\n                connection = ConnectionPattern(prev_layer, layer)\n                self.connections.add(connection)\n            layer.shift(i * DOWN)\n            prev_layer = layer\n        \n        self.add(*self.layers, self.connections)\n\nclass VisualSystemScene(Scene):\n    def construct(self):\n        layers = [5, 4, 6, 3]\n        visual_cortex = VisualCortexNetwork(layers)\n        self.add(visual_cortex)\n\n        # Show the receptive fields connections pulsing through layers\n        for conn in visual_cortex.connections:\n            self.play(LaggedStart(*[\n                ApplyMethod(rf.highlight, YELLOW)\n                for rf in conn.receptive_fields\n            ], lag_ratio=0.2, run_time=1))\n            self.play(LaggedStart(*[\n                ApplyMethod(rf.reset_color)\n                for rf in conn.receptive_fields\n            ], lag_ratio=0.2, run_time=1))\n\n        # Shift the whole network downwards\n        self.play(ApplyMethod(visual_cortex.shift, DOWN))\n\n        # Add some labels\n        input_label = Text(\"Input Layer\", font_size=24)\n        input_label.next_to(visual_cortex.layers[0], LEFT)\n        output_label = Text(\"Output Layer\", font_size=24)\n        output_label.next_to(visual_cortex.layers[-1], LEFT)\n        self.play(Write(input_label), Write(output_label))"
    },
    {
        "query": "I would like to create an educational animation showing a simple chemical reaction where reactant molecules transform into product molecules. The animation should start by showing the reactant molecules at the top of the screen and the products at the bottom, with an arrow pointing downwards from the reactants to the products indicating the direction of the reaction. The reactant molecules should consist of individual electron, metal, and oxygen graphics, while the products should be a compound made of metal and oxygen along with an electron. During the animation, I want the reactants to change to green and the products to turn orange to symbolize the reaction taking place. After pausing for a moment to let the viewers observe the change, the products and arrow should disappear, and the original reactant molecules should move to the center of the screen. Can you create this animation so it can be used as an educational tool to demonstrate a simple chemical reaction?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r^2 \\, dr \\, d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral (r)\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} [\\frac{1}{3}r^3]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral (theta)\n        explanation2 = Text(\"Now integrate with respect to \\\\(\\\\theta\\\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3}\\theta]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Displaying the final answer\n        final_answer = MathTex(r\"= \\frac{2\\pi}{3}\")\n        self.play(Transform(final_solution, final_answer))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational chemistry animation using Manim that shows a simplified chemical structure with both oxygen and metal elements arranged in a grid pattern? Also, include an electron moving in a complex path around this grid, some lithium ions placed to the side and below the grid, and have everything fade out at the end. The animation should start with the title 'Chemical Structure Example' at the top of the screen.",
        "answer": "\\n from manim import *\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        nn = VGroup()\n        layers = [Rectangle(height=0.5, width=2) for _ in range(4)]\n        layers_labels = [Tex(f\"Layer {_ + 1}\") for _ in range(4)]\n        \n        # Position layers and add labels\n        for i, (layer, label) in enumerate(zip(layers, layers_labels)):\n            layer.next_to(3 * UP if i == 0 else layers[i - 1], DOWN, buff=1)\n            label.move_to(layer.get_center())\n            nn.add(layer, label)\n        \n        # Draw connections\n        for layer1, layer2 in zip(layers, layers[1:]):\n            nn.add(Arrow(layer1.get_bottom(), layer2.get_top(), buff=0.1))\n        \n        # Position the neural network in the center\n        nn.move_to(ORIGIN)\n        \n        # Animate construction of the neural network\n        self.play(AnimationGroup(*(FadeIn(layer) for layer in layers), lag_ratio=0.5))\n        self.play(AnimationGroup(*(Write(label) for label in layers_labels), lag_ratio=0.5))\n        self.play(AnimationGroup(*(GrowArrow(arrow) for arrow in nn.submobjects if isinstance(arrow, Arrow)), lag_ratio=0.5))"
    },
    {
        "query": "Can you create an educational animation using Manim that shows an oxygen molecule with electrons moving along a complex path around it, including the appearance and disappearance of the molecule and the electron?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{2} \\int_{0}^{3} xyz \\,dz\\,dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{2} \\frac{1}{2}x y z^2 \\Big|_{0}^{3} \\,dx\\,dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n        \n        # Explanation for second integral\n        explanation2 = Text(\"Next, integrate the result with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Second integral step\n        second_integral = MathTex(r\"= \\int_{0}^{1} \\frac{9}{2} y x^2 \\Big|_{0}^{2} \\,dy\")\n        self.play(ReplacementTransform(inner_integral, second_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= 9 \\int_{0}^{1} y^2 \\,dy\", r\"= 9 \\cdot \\frac{1}{3} y^3 \\Big|_{0}^{1}\", r\"= 3\")\n        self.play(ReplacementTransform(second_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution[-1]))\n        self.wait(1)"
    },
    {
        "query": "\"Can you create an educational animation using manim that visually represents fundamental particles such as a red proton with a positive sign, a blue neutron with a zero sign, and a yellow electron with a negative sign? Each particle should be labeled clearly, and electrons should be smaller than protons and neutrons. First, the proton should fade in, then the neutron should appear to its right while the electron appears above it but smaller. After that, I want the electron to orbit around the proton in an elliptical path to showcase electron movement around a nucleus. Each of the particles must fade out at the end. Additionally, I want the animation to be simple and clear enough for a basic physics class presentation.\"",
        "answer": "\\n from manim import *\n\nclass ChemicalReactionScene(Scene):\n    def construct(self):\n        # Create a reactant molecule\n        reactant = VGroup(electron(), metal(), oxygen())\n        reactant.arrange(RIGHT, buff=0.3)\n        reactant.to_edge(UP)\n        \n        # Create a product molecule\n        product = VGroup(metal_oxid(2, 2), electron())\n        product.arrange(RIGHT, buff=0.3)\n        product.to_edge(DOWN)\n        \n        # Create arrows for the reaction\n        arrow = Arrow(reactant.get_bottom(), product.get_top(), buff=0.1)\n        \n        # Add reactant, arrow, and product to the scene\n        self.add(reactant, arrow, product)\n        \n        # Animate reactant and product changing color to show reaction\n        self.play(reactant.animate.set_color(GREEN), product.animate.set_color(ORANGE))\n        \n        # Wait to observe the scene\n        self.wait(2)\n        \n        # Animate the reformation of the original reactant\n        self.play(Uncreate(product), Uncreate(arrow), reactant.animate.move_to(ORIGIN))\n        \n        # Wait to observe the final scene\n        self.wait()"
    },
    {
        "query": "Can you create an educational animation using Manim that first shows a magnet with its north pole colored red and south pole colored blue, then displays its magnetic field lines flowing from the north pole to the south pole in a semi-circular pattern? After that, can you animate a separate scene where multiple electrons flow in a straight line across the screen, with each electron labeled with an \"e-\" to represent an electron? The flow of electrons should be smooth and evenly spaced out, and I would like the animation to hold for a moment after the magnet and electrons appear, as well as after the electrons start flowing.",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration method\n        explanation1 = Text(\"Use u-substitution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Substitution step\n        subst_step = MathTex(r\"\\frac{1}{2} \\int e^u \\,du\", r\", \\text{ where } u = 2x\")\n        self.play(ReplacementTransform(problem.copy(), subst_step))\n        self.wait(1)\n        \n        # Explanation for the integration result\n        explanation2 = Text(\"Integrate with respect to u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(subst_step, final_solution))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.play(FadeOut(explanation1), FadeOut(final_solution))\n        self.wait(1)\n\n        # Show final result on a clean scene\n        final_result = MathTex(r\"\\int e^{2x} \\,dx = \\frac{1}{2}e^{2x} + C\")\n        self.play(Write(final_result))\n        self.wait(2)"
    },
    {
        "query": "Can you create an educational animation that shows the formation of a water molecule by combining one oxygen atom with two hydrogen atoms, illustrating the bonding process, rotating the molecule to give a 3D perspective, and finally having all parts of the molecule disappear from the view? The oxygen atom should be larger and blue, the hydrogen atoms should be smaller and white, and there should be a visual representation of the bonds forming between them. I'd like to see each atom and bond appear one by one, hold on screen long enough to be clearly seen, and then have the molecule rotate around for a few seconds before everything fades away.",
        "answer": "\\n from manim import *\n\nclass SineCurveUnitCircle(Scene):\n    def construct(self):\n        # Create a unit circle and sine curve\n        circle = Circle(radius=1)\n        sine_curve = ParametricFunction(\n            lambda t : np.array([t, np.sin(t), 0]),\n            t_range = np.array([-PI, PI]),\n            color = BLUE\n        )\n\n        # Display the circle and sine curve\n        self.play(Create(circle))\n        self.play(Create(sine_curve))\n        self.wait(1)\n\n        # Create a dot that will move around the circle\n        dot = Dot(radius=0.08)\n        self.play(FadeIn(dot))\n\n        # This updater will move the dot along the unit circle\n        def update_dot(mob, dt):\n            rate = dt * 0.5  # speed of the dot\n            mob.move_to(circle.point_at_angle(rate + mob.get_center()[0]))\n\n        dot.add_updater(update_dot)\n\n        # Create a vertical line that will be used to trace the sine curve\n        vertical_line = always_redraw(\n            lambda: DashedLine(\n                start=sine_curve.get_start(),\n                end=[dot.get_center()[0], dot.get_center()[1], 0],\n                stroke_width=2,\n                dashed_ratio=0.6\n            ).set_color(RED)\n        )\n\n        # Display the vertical line and let it trace the sine curve with the dot\n        self.add(vertical_line)\n        self.wait(PI / 0.5)  # Wait until the dot makes half a revolution\n\n        # Remove the tracer line and the dot updater\n        dot.clear_updaters()\n        vertical_line.clear_updaters()\n\n        # Draw label for the sine curve\n        sine_label = Tex(\"Sine Curve\").next_to(sine_curve, DOWN)\n        self.play(Write(sine_label))\n\n        # Wait and clear the scene\n        self.wait(2)\n        self.clear()\n\n        # Show a static image of the sine curve\n        self.play(Create(sine_curve), FadeIn(sine_label))\n        self.wait(2)"
    },
    {
        "query": "Could you create an educational animation that illustrates the basic structure of a hydrogen atom, showing a simplified model with an electron cloud and its nucleus, and have the entire model grow in size to emphasize the components?",
        "answer": "\\n from manim import *\ndef move_along_complex_path(obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n    animations = []\n    paths = []\n    for i in range(len(points) - 1):\n        if i not in stop_indices:\n            paths.append(Line(points[i], points[i + 1]))\n\n    for i in range(len(paths)):\n        animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))\n\n    return animations"
    },
    {
        "query": "I would like to create an educational animation showing a chemical reaction where an electron transforms into an oxygen molecule, and then further changes into a metal oxide compound with the formula M2O3. The electron should first appear, then after a short pause morph into the oxygen molecule, followed by another pause before it changes into the metal oxide. There should be a brief moment to view the metal oxide before it all fades away from the screen. Can you design this simple chemistry-based transformation animation for me?",
        "answer": "\\n from manim import *\n\nclass SineWaveExample(Scene):\n    def construct(self):\n        equation = MathTex(r\"\\sin(x) = y\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        text = Text(\"The graph of a sine function\", font_size=24).to_edge(UP)\n        self.play(Write(text))\n        self.wait(2)\n\n        # Create a sine curve\n        graph = self.get_graph(lambda x: np.sin(x), color=BLUE)\n        self.play(Create(graph))\n        self.wait(2)\n\n        new_text = Text(\"Sine waves have a periodic nature\", font_size=24).to_edge(UP)\n        self.play(Transform(text, new_text))\n        self.wait(2)\n\n        amplitude_text = Text(\"Amplitude: 1, Period: \\(2\\pi\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(text, amplitude_text))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(equation))\n        self.wait(1)\n\n    def get_graph(self, function, color):\n        return FunctionGraph(function, color=color, x_range=[-PI, PI])"
    },
    {
        "query": "I would like to create an educational animation that visually represents an electron moving through an electric field. To illustrate this, I'd like an animation where a grid is created that alternates between positive and negative charges, making a checkerboard pattern. The grid should have 4 rows and 5 columns. Once the grid is displayed, an electron should appear on the screen, and then proceed to make a few movements. The electron's movement should be a combination of shifts to the right and upward, as if it is zigzagging through the field due to the alternating charges. It'd be great if the electron could move in this pattern at least three times. Can you help me create an animation like this?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Labels for axes\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # The graph\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        # Area under graph\n        area = axes.get_area(graph, x_range=[0, 2], color=GREEN, opacity=0.5)\n\n        # Display graph and area\n        self.play(Create(axes), Write(labels))\n        self.wait(1)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Display the problem\n        problem = MathTex(r\"\\text{Area} = \\int_0^2 x^2 \\,dx\")\n        problem.next_to(area, DOWN)\n        self.play(Write(problem))\n        self.wait(2)\n\n        # Final solution\n        solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2 = \\frac{8}{3}\")\n        solution.next_to(problem, DOWN)\n        self.play(ReplacementTransform(problem, solution))\n        self.wait(2)\n\n        # Cleanup\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational chemistry animation using ManimCE that shows the following sequence:\n1. Start by fading in individual particles: an electron, an oxygen atom, a metal atom, a positive ion, and a negative ion.\n2. After a brief pause, these particles should combine, or transform, into a grid pattern that represents a metal oxide on a 3x3 grid.\n3. Wait for a moment, then transform this metal oxide grid into a lithium grid structure made of a 2x2 grid pattern.\n4. Wait again, and then change this lithium grid to a carbon grid structure, which is made up of a single element in a 3x3 grid pattern.\n5. Finally, I want the initial electron to move along a complex path made of 9 points that form a loop with stops at the 3rd and 6th points in the pattern. The electron should complete this path loop within 2 seconds.\nThe animation should include waiting periods between each major step so the viewers can understand the changes happening on the screen. Can you help create this animation?",
        "answer": "\\n from manim import *\n\nclass DifferentiationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\frac{d}{dx}(x^2 + 2x + 1)\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the power rule\n        explanation1 = Text(\"Use the power rule for differentiation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Differentiation step\n        diff_step = MathTex(r\"2x + 2\")\n        self.play(ReplacementTransform(problem.copy(), diff_step))\n        self.wait(1)\n\n        # Explanation that the derivative is constant\n        explanation2 = Text(\"The derivative is a linear function\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final derivative\n        final_derivative = MathTex(r\"y' = 2x + 2\")\n        self.play(ReplacementTransform(diff_step, final_derivative))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_derivative))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that shows the construction and dissociation of a water molecule using simple geometric shapes to represent atoms. The animation should start by displaying an oxygen atom and two hydrogen atoms, then visually connect them to form the water molecule (H2O). The atoms should be labeled with their respective element symbols, and it would be great if the water molecule itself could be labeled with its chemical formula. Lastly, I want the animation to demonstrate the process of the water molecule breaking apart, with the atoms moving away from each other. Can you create an animation that visually represents this concept?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 8.0\nconfig.frame_width = 14.0\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define the layers of the neural network\n        layers = [\n            FeedForwardLayer(20, neuron_radius=0.15, stroke_width=3.0),\n            FeedForwardLayer(10, neuron_radius=0.15, stroke_width=3.0),\n            FeedForwardLayer(5, neuron_radius=0.15, stroke_width=3.0),\n        ]\n\n        # Create the neural network\n        neural_network = NeuralNetwork(layers, layer_spacing=0.3)\n\n        # Position the neural network in the center\n        neural_network.move_to(ORIGIN)\n\n        # Create animation for each layer to fade in sequentially\n        layer_animations = [\n            FadeIn(layer, shift=UP, rate_func=linear)\n            for layer in neural_network.layers\n        ]\n\n        # Play the layer animations\n        self.play(AnimationGroup(*layer_animations, lag_ratio=1))\n\n        # Create forward pass animation for the neural network\n        forward_pass = neural_network.make_forward_pass_animation(rate_func=linear)\n\n        # Play the forward pass animation\n        self.play(forward_pass)\n\n        # Hold the final image for a couple seconds before exiting\n        self.wait(2)"
    },
    {
        "query": "Could you create an animation sequence using Manim that illustrates the formation of a molecule from an oxygen molecule and a lithium ion? I would like to see an oxygen molecule at the top of the screen and a lithium ion appearing below it. The lithium ion should then move up to join the oxygen molecule, and the resulting lithium-oxygen compound should grow slightly in size and move to the center of the screen. Please also make sure that the animation includes a final pause so the viewer can see the completed molecule.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FadeToColor\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(RED)\n            self.play(FadeToColor(square,color=YELLOW))\n            self.remove(square)"
    },
    {
        "query": "Can you create an animated video that shows a carbon monoxide (CO) molecule and a water (H2O) molecule positioned on opposite sides of the screen, then have them move towards each other, react, and transform into a single carbonic acid (H2CO3) molecule at the center of the screen? The CO molecule should have a gray \"C\" for carbon and a blue \"O\" for oxygen, while the H2O molecule has a blue \"O\" for oxygen and two white \"H\"s for hydrogen. After they react and form carbonic acid, it should just be shown with its chemical formula.",
        "answer": "\\n from manim import Scene, VGroup, BLUE, RED\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\nfrom manim_ml.neural_network.animations.training import Train\n\nclass NeuralNetworkTrainScene(Scene):\n    def construct(self):\n        # Create a neural network\n        layers = [FeedForwardLayer(n) for n in [3, 5, 4, 2]]\n        neural_network = NeuralNetwork(layers)\n        neural_network.set_colors(input_color=BLUE, output_color=RED)\n        neural_network.move_to(ORIGIN)\n\n        # Group layers for easy transformation\n        vg_layers = VGroup(*[layer for layer in neural_network.layers])\n\n        # Add network to scene\n        self.add(vg_layers)\n\n        # Create training animation\n        train_anim = Train(neural_network)\n\n        self.play(train_anim)\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational chemistry animation that shows different particles such as an electron, an oxygen atom, a metal atom, and both positive and negative ions. These should appear one after the other in a single row with some space between them. Then, I want the electron to follow a complex path moving around the other particles as if it's showing how electrons might move in a reaction or an orbit. Once the electron completes its movement, all the particles should fade away from the screen. Can you make something like this in a simple and visual way, perhaps using animation?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"AddTextLetterByLetter\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Here is a text\")\n            self.play(AddTextLetterByLetter(some_text))\n            self.play(Transform(text,Text(\"RemoveTextLetterByLetter\").shift(UP*2.5)), run_time=0.5)\n            self.play(RemoveTextLetterByLetter(some_text))"
    },
    {
        "query": "I would like to create an educational animation that shows a grid of red atoms labeled with \"H\" to represent hydrogen, all arranged neatly on the screen. Then, I want each hydrogen atom to transform into helium by changing the label from \"H\" to \"He\". Each atom should be a small circle with the label in the center, and they should change to helium at a quick pace one after the other. Can you make that for me using simple visual effects?",
        "answer": "\\n from manim import *\n\nclass TaylorSeriesExample(Scene):\n    def construct(self):\n        # Display the function to be expanded\n        function = MathTex(r\"f(x) = e^x\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Display the Taylor expansion\n        taylor_expansion = MathTex(r\"f(x) \\approx 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots\")\n        self.play(Write(taylor_expansion))\n        self.wait(2)\n\n        # Explanation of approximation\n        explanation1 = Text(\n            \"This is the Taylor series expansion of \", font_size=24\n        ).next_to(function, DOWN)\n        explanation2 = Text(\n            \"around x=0\", font_size=24\n        )\n        explanation = VGroup(explanation1, explanation2).arrange(RIGHT)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Highlight the polynomial terms\n        polynomial = MathTex(r\"1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!}\")\n        self.play(ReplacementTransform(taylor_expansion.copy(), polynomial))\n        self.wait(1)\n\n        # Explanation that the series is infinite\n        infinite_series_exp = Text(\"Using more terms increases accuracy\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation, infinite_series_exp))\n        self.wait(2)\n\n        # Show the actual function graph\n        axes = Axes(\n            x_range=[-6, 6],\n            y_range=[-1, 8],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: np.exp(x), color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='e^x')\n\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Plot the polynomial approximation\n        polynomial_graph = axes.plot(\n            lambda x: 1 + x + x**2 / math.factorial(2) + x**3 / math.factorial(3),\n            color=RED\n        )\n        polynomial_label = axes.get_graph_label(polynomial_graph, label='Polynomial approximation', x_val=-3, direction=UP)\n\n        self.play(Write(polynomial_label))\n        self.play(Create(polynomial_graph))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"This is the Taylor series approximation of e^x\", font_size=24)))\n        self.wait(1)"
    },
    {
        "query": "Can you create a simple animated visualization of data being processed through a neural network with two layers, showing three neurons in the input layer, four neurons in the first hidden layer, and two neurons in the output layer? I'd like the animation to illustrate data passing through the network, and could we position the network on the left side of the screen with a smooth flowing animation of the data within a two-second time frame? Also, after the animation ends, can there be a brief pause before it finishes?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"SpinInFromNothing\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(SpinInFromNothing(triangle))\n            self.remove(triangle)"
    },
    {
        "query": "Can you create an animated video that shows a simple feedforward neural network with three layers, where the first layer has 4 neurons, the second layer has 6 neurons with a ReLU activation function, and the third layer has 3 neurons with a Softmax activation function, and then demonstrate a data point passing through this network?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function\n        function_label = MathTex(r\"f(x) = x^2\", font_size=24).to_edge(UP)\n        self.play(Write(function_label))\n        self.wait(1)\n\n        # Show the integral\n        integral = MathTex(r\"\\int_1^3 x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait(2)\n\n        # Integration process\n        integration = MathTex(r\"= \\left[ \\frac{1}{3}x^3 \\right]_1^3\")\n        self.play(Transform(integral, integration))\n        self.wait(2)\n\n        # Calculation of definite integral value\n        final_value = MathTex(r\"= \\frac{1}{3}(3^3 - 1^3)\", r\"= \\frac{1}{3}(27 - 1)\", r\"= \\frac{1}{3}(26)\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration, final_value))\n        self.wait(3)\n\n        # Display final result\n        self.clear()\n        self.play(Write(final_value))\n        self.wait(2)"
    },
    {
        "query": "Could you create an animation that visualizes how a simple neural network processes an image of a handwritten digit, using Manim? The animation should begin by loading an image of a digit, then display the architecture of the neural network, including convolutional and pooling layers, and finally, show the forward pass of the image through the network with each layer's transformation. The network should have at least one convolutional layer with a max-pooling layer following it, and end with a fully connected layer that outputs ten categories, representing the digits 0 through 9.",
        "answer": "\\n from manim import *\n\nclass CubicFunctionDerivative(Scene):\n    def construct(self):\n        # Displaying the function to be derived\n        original_function = MathTex(r\"f(x) = x^3 + 3x^2 + 3x + 1\")\n        self.play(Write(original_function))\n        self.wait()\n\n        # Explanation for the derivative computation\n        explanation_text = Text(\"Calculating the derivative of the function:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation_text))\n        self.wait(2)\n\n        # Differentiation step by step using power rule\n        derivative_step1 = MathTex(r\"f'(x) = 3x^2 + 6x + 3\")\n        self.play(ReplacementTransform(original_function.copy(), derivative_step1))\n        self.wait(2)\n\n        # Explanation for simplifying the derivative\n        simplify_text = Text(\"The derivative is already simplified\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation_text, simplify_text))\n        self.wait(2)\n\n        # Display final derivative\n        final_derivative = MathTex(r\"f'(x) = 3(x^2 + 2x + 1)\")\n        self.play(ReplacementTransform(derivative_step1, final_derivative))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait()\n\n        # Presenting the final derivative\n        self.play(Write(final_derivative))\n        self.wait(2)"
    },
    {
        "query": "I would like to see an animation that visually demonstrates the training process of a simple neural network. The network should have three layers with 4 neurons in the first layer, 7 in the second, and again 4 in the last one. The neurons should have a stroke width of 2 for clarity, and the second layer should be semi-transparent with an opacity of 0.5 to distinguish it from the others. The neurons of the first layer will also be the starting points for some data points, say 5 random positions that we can treat as training data. Can you show this neural network getting trained with the provided data points smoothly transitioning in the scene, centered nicely for easy viewing?",
        "answer": "\\n from manim import *\n\nclass ExponentialGraphScene(Scene):\n    def construct(self):\n        # Writing the title of the graph\n        title = Text(\"Exponential Function Graph\").shift(UP*3)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Create axes\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-1, 8],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Create the function and its graph\n        exponential_function = lambda x: np.exp(x)\n        graph = axes.plot(exponential_function, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='e^x')\n\n        # Display the axes and the graph\n        self.play(Create(axes), Write(graph_label))\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Introduction to a new function\n        explanation1 = Text(\"Consider function 2^x\", font_size=24).to_edge(UP)\n        self.play(Transform(title, explanation1))\n        self.wait(2)\n\n        # New function and its graph\n        new_function = lambda x: 2**x\n        new_graph = axes.plot(new_function, color=RED)\n        new_label = axes.get_graph_label(new_graph, label='2^x', x_val=1, direction=UP*2)\n\n        # Display the new_function graph\n        self.play(ReplacementTransform(graph, new_graph), ReplacementTransform(graph_label, new_label))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion by showing the comparison\n        self.play(Create(axes), Write(new_label), Create(new_graph))\n        self.play(Create(graph), Write(graph_label))\n        self.wait(2)"
    },
    {
        "query": "I'd like to create an animation that visually represents a neural network with three layers: the first layer having 20 neurons, the second layer 10 neurons, and the third layer 5 neurons. Each neuron should be relatively small with a clear outline. The neurons should appear one layer at a time, each layer coming from above and then settling into position. After all layers are displayed, I want to see an animation that represents the forward pass of data through this network, going from the first layer to the last. The animation should be clear and hold on the final frame for a short moment before ending. Can you design something like this?",
        "answer": "\\n from manim import *\n\nclass SimpleHarmonicMotionScene(Scene):\n    def construct(self):\n        # Display the differential equation for simple harmonic motion\n        equation = MathTex(r\"m\\frac{d^2 x}{dt^2} = -kx\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explain what each term represents\n        terms_explanation = Text(\n            \"Represents mass, spring constant, and position (m, k, x)\",\n            font_size=24\n        ).to_edge(UP)\n        self.play(Write(terms_explanation))\n        self.wait(2)\n\n        # Show the form of the solution\n        solution_form = MathTex(r\"x(t) = A \\cos(\\omega t - \\phi)\")\n        self.play(ReplacementTransform(equation, solution_form))\n        self.wait(1)\n\n        # Explain the solution terms\n        solution_explanation = Text(\n            \"Where A is amplitude, omega is angular frequency, and phi is phase shift\",\n            font_size=24\n        ).to_edge(UP)\n        self.play(Transform(terms_explanation, solution_explanation))\n        self.wait(2)\n\n        # Oscillation\n        oscillator = Circle(radius=1.0, color=BLUE)\n        oscillator.move_to(4*LEFT)\n        self.play(Create(oscillator))\n        \n        # Create an arrow representing the force\n        arrow = Arrow(\n            oscillator.get_edge_center(RIGHT),\n            oscillator.get_edge_center(RIGHT) + 2*RIGHT,\n            buff=0\n        )\n        self.play(GrowArrow(arrow))\n        self.wait(1)\n\n        # Oscillate the circle to the right\n        self.play(oscillator.animate.move_to(4*RIGHT), run_time=2, rate_func=there_and_back)\n        self.wait(1)\n\n        # Clear the scene and show the solution again\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_form))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animated representation of a neural network using 5 sigmoid neurons in one layer connected to a single output neuron, where each neuron and the connections between them light up sequentially to illustrate the process of activation in a neural network?",
        "answer": "\\n class SquareToCircle(Scene):\n    def construct(self):\n        green_square = Square(color=GREEN, fill_opacity=0.5)\n        self.play(DrawBorderThenFill(green_square))\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        self.play(ReplacementTransform(green_square, blue_circle))\n        self.play(Indicate(blue_circle))\n        self.play(FadeOut(blue_circle))"
    },
    {
        "query": "Could you create an animated diagram that visually represents the layers of a convolutional neural network, including the input image, convolutional layer, max pooling, ReLU activation, fully connected layer, and output, with arrows between each layer to indicate the flow of data processing, all centered on the screen with smooth animations for each element's appearance?",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting u = 2x\n        explanation1 = Text(\"Let u = 2x, thus du = 2dx\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Changing the integral\n        substitute_step = MathTex(r\"\\int \\frac{1}{2}e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), substitute_step))\n        self.wait(1)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate using the antiderivative of e^u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(substitute_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that visualizes how a dropout technique works in a neural network using animated fading effects to represent the dropout of neurons, where the network has three layers with 4, 6, and 4 neurons respectively, and ensure the neurons are close together with a small radius?",
        "answer": "\\n from pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=1.5),\n            Convolutional2DLayer(1, 5, 5, 1, 1),\n            Convolutional2DLayer(4, 5, 5, 1, 1),\n            Convolutional2DLayer(2, 5, 5),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.50)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 5, 1, filter_spacing=0.32),\n                Convolutional2DLayer(4, 5, 1, filter_spacing=0.32),\n                Convolutional2DLayer(2, 5, 5, filter_spacing=0.32),\n            ],\n            layer_spacing=0.4,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        # Group it all\n        group = Group(nn, code)\n        group.move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)"
    },
    {
        "query": "Can you create an educational animation using Python that visually represents a simple neural network with 4 layers, where the first layer has 4 neurons, the second and third layers have 8 neurons each, and the last layer has 4 neurons again? Each neuron should be represented by a blue circle, and they should be connected with gray lines to indicate the connections between each neuron in one layer to all neurons in the next layer. Additionally, I'd like to see an effect that visually simulates a forward pass through this network by highlighting the first neuron of each layer in green sequentially. The animation should be smoothly transitioned and it would be great if the simulation can be clearly viewed on a standard HD screen.",
        "answer": "\\n from manim import *\n\n\nclass WaterMoleculeScene(Scene):\n    def construct(self):\n        # Create a water molecule with one oxygen and two hydrogen atoms\n        molecule = VGroup()\n        \n        # Oxygen atom\n        oxygen_atom = self.create_atom(\"O\", WHITE, RED_B)\n        molecule.add(oxygen_atom)\n\n        # Hydrogen atoms\n        hydrogen_atom1 = self.create_atom(\"H\", WHITE, BLUE)\n        hydrogen_atom2 = self.create_atom(\"H\", WHITE, BLUE)\n\n        hydrogen_atom1.next_to(oxygen_atom, UP + LEFT, buff=0.7)\n        hydrogen_atom2.next_to(oxygen_atom, UP + RIGHT, buff=0.7)\n\n        molecule.add(hydrogen_atom1, hydrogen_atom2)\n\n        # Bonds\n        bond1 = Line(oxygen_atom.get_center(), hydrogen_atom1.get_center(), buff=0.2)\n        bond2 = Line(oxygen_atom.get_center(), hydrogen_atom2.get_center(), buff=0.2)\n\n        molecule.add(bond1, bond2)\n\n        # Make the molecule move in a path\n        molecule.move_to(ORIGIN)\n\n        # Animation\n        self.play(FadeIn(molecule))\n        self.play(Rotate(molecule, angle=2*PI), run_time=4)\n        self.wait()\n\n    def create_atom(\n        self, label: str,\n        label_color: str,\n        circle_color: str,\n        radius: float = 0.3\n    ) -> VGroup:\n        atom_circle = Circle(radius=radius, color=circle_color)\n        atom_circle.set_fill(circle_color, opacity=1)\n\n        atom_label = Text(label, color=label_color)\n        atom = VGroup(atom_circle, atom_label)\n        atom_label.move_to(atom_circle.get_center())\n\n        return atom"
    },
    {
        "query": "Can you create an educational animation that visually demonstrates how a simple fully connected neural network processes data? The neural network should have an input layer of 784 neurons, two hidden layers with 128 and 64 neurons respectively, and an output layer with 10 neurons. Each hidden layer should be followed by a ReLU activation function, and the output layer should have a softmax function. Also include an animation that shows the activation sequence passing through the network layers from input to output.",
        "answer": "\\n         self.play(Transform(text,Text(\"SpinInFromNothing\").shift(UP*2.5)), run_time=0.5)\n        triangle = Triangle()\n        self.play(SpinInFromNothing(triangle))\n        self.remove(triangle)"
    },
    {
        "query": "Can you create an animated visualization of a Recurrent Neural Network (RNN) using three layers with 6, 8, and 4 neurons respectively, where the middle layer is recurrent and has colored neurons, accompanied by a label that says \"Recurrent Neural Network\" at the top, and display arrows indicating the input and output flows for the recurrent layer? Additionally, can you animate a signal passing through the network?",
        "answer": "\\n from manim import *\n\n\ndef create_simple_motor() -> Mobject:\n    c_inner = Circle(1.4, GREY_D).set_fill(GREY_B, 1).set_z_index(3)\n    c_middle = Circle(1.6, GREY_D).set_fill(WHITE, 1).set_z_index(2)\n    c_outer = Circle(2, GREY_D).set_fill(GREY_B, 1).set_z_index(1)\n\n    stand = (\n        Polygon(\n            [-2, -2.2, 0],\n            [2, -2.2, 0],\n            [2, -2, 0],\n            [1.75, -2, 0],\n            [np.sqrt(2), -np.sqrt(2), 0],\n            [-np.sqrt(2), -np.sqrt(2), 0],\n            [-1.75, -2, 0],\n            [-2, -2, 0],\n            color=GREY_D,\n        )\n        .set_fill(GRAY_C, 1)\n        .set_z_index(0)\n    )\n\n    return VGroup(c_inner, c_middle, c_outer, stand)\n\n\nclass SimpleMotor(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n\n        rotor = Text(\"Rotor\", color=BLACK).set_x(-5.5).set_y(2)\n        rotor_line = VGroup(\n            Line([-6.4, 1.65, 0], [-3.5, 1.65, 0], color=BLACK),\n            Line([-3.5, 1.65, 0], [-0.5, 0.5, 0], color=BLACK).set_z_index(10),\n        )\n\n        stator = Text(\"Stator\", color=BLACK).set_x(5.5).set_y(-1.1)\n        stator_line = VGroup(\n            Line([6.4, -1.45, 0], [3.7, -1.45, 0], color=BLACK),\n            Line([3.7, -1.45, 0], [1.3 * 1.8, -1.3 * 1.8, 0], color=BLACK).set_z_index(10),\n        )\n\n        self.add(create_simple_motor(), rotor, rotor_line, stator, stator_line)"
    },
    {
        "query": "Can you create an animation of a simple neural network with three layers that have different numbers of neurons, where the neurons are blue circles connected by lines to show the connections between them? Let's have the first layer have 4 neurons, the second have 5, and the third have 3. Also, can the camera rotate around the network so we can view it from different angles?",
        "answer": "\\n from manim import *\n\nclass WaveAnimationExample(Scene):\n    def construct(self):\n        initial_text = Text(\"Wave Propagation\")\n        self.play(Write(initial_text))\n        self.wait(1)\n        self.play(ApplyWave(initial_text))\n        self.wait(1)\n        transformed_text = Text(\"Wave Effect\").shift(DOWN*2)\n        self.play(Transform(initial_text, transformed_text))\n        self.wait(1)\n        self.play(ApplyWave(transformed_text, direction=UP))\n        self.wait(1)\n        self.remove(transformed_text)"
    },
    {
        "query": "I would like to create an educational animation that visually demonstrates how a Convolutional Neural Network (CNN) processes an input image step by step. Can you show the image going through various layers like convolutional layers with filters, followed by fully connected feed-forward layers, and finally outputting the classification into a few categories? Additionally, I'd like the animation to be high-definition and the scene to start with fading in the CNN, then performing a forward pass through the network, and ending with a short pause to see the final result. Also, if possible, include some customizable aspects such as the number of filters in the convolutional layer and the dimensions of the subsequent feed-forward layers.",
        "answer": "\\n from manim import *\n\nclass SimpleMoleculeScene(Scene):\n    def construct(self):\n        electron_m = electron()\n        oxygen_m = oxygen()\n        metal_m = metal()\n        positive_m = positive()\n        negative_m = negative()\n        \n        # Position Mobjects\n        electron_m.shift(LEFT * 2)\n        oxygen_m.next_to(electron_m, RIGHT, buff=1.5)\n        metal_m.next_to(oxygen_m, RIGHT, buff=1.5)\n        positive_m.next_to(metal_m, RIGHT, buff=1.5)\n        negative_m.next_to(positive_m, RIGHT, buff=1.5)\n\n        molecule_group = VGroup(electron_m, oxygen_m, metal_m, positive_m, negative_m)\n\n        # Animate Mobjects\n        self.play(Write(molecule_group))\n        self.wait(1)\n\n        # Move electron around the oxygen atom\n        self.play(*move_along_complex_path(electron_m, [], [UP * 1.5 + LEFT * 2,\n                                                            UP * 1.5 + RIGHT * 0.5,\n                                                            DOWN * 1.5 + RIGHT * 0.5,\n                                                            DOWN * 1.5 + LEFT * 2], run_time=4))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation video that visualizes a simple Recurrent Neural Network (RNN) operating on a sequence of numbers. Can you show the numbers moving through the network, highlight how the LSTM cell processes these numbers, and finally update the sequence at the end of the process? Additionally, I want the animation to illustrate the connections focused on a particular neuron to see its influence within the network.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the triple integral problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{-1}^{1} \\int_{0}^{2} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Introduction text for first integral\n        explanation1 = Text(\"Integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Solving the innermost integral with respect to z\n        integral_z = MathTex(r\"= \\int_{0}^{1} \\int_{-1}^{1} [frac{1}{2}x y z^2]_{0}^{2} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), integral_z))\n        self.wait(1)\n\n        # Introduction text for second integral\n        explanation2 = Text(\"Now, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solving the middle integral with respect to y\n        integral_y = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2} x (y^2 z^2)]_{-1}^{1} \\,dx\")\n        self.play(ReplacementTransform(integral_z, integral_y))\n        self.wait(1)\n\n        # Introduction text for third integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Solving the outermost integral with respect to x and showing the final solution\n        final_solution = MathTex(r\"= [\\frac{1}{3} (y^2 x^3 z^2)]_{0}^{1}\", r\"= \\frac{1}{3} (1)^2 (1)^3 (2)^2\", r\"= \\frac{4}{3}\")\n        self.play(ReplacementTransform(integral_y, final_solution))\n        self.wait(1)\n\n        # Clear the scene and present the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation using ManimCE that visualizes a simple convolutional neural network with alternating convolutional layers and pooling layers? The network should start with a convolutional layer that has 6 feature maps and a 3x3 kernel, then a pooling layer, followed by another convolutional layer with 16 feature maps and a 3x3 kernel, and ending with a final pooling layer. The animation should show the construction of this neural network.",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y'' + \\omega^2 y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for formal solution\n        explanation1 = Text(\"Consider a trial solution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Trial solution step\n        trial_solution = MathTex(r\"y = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(Transform(problem, trial_solution))\n        self.wait(1)\n\n        # Explanation for initial conditions\n        explanation2 = Text(\"Apply initial conditions\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Applying initial conditions\n        initial_conditions = MathTex(r\"A = y(0), \\quad \\omega B = y'(0)\")\n        self.play(Write(initial_conditions))\n        self.wait(1)\n\n        # General solution with conditions\n        general_solution = MathTex(r\"y = y(0)\\cos(\\omega t) + \\frac{y'(0)}{\\omega}\\sin(\\omega t)\")\n        self.play(Transform(trial_solution, general_solution))\n        self.play(Transform(initial_conditions, MathTex(r\"\\text{for } y(0), y'(0) \\text{ given}\")))\n        self.wait(1)\n\n        # Conclusion\n        self.clear()\n        explanation3 = Text(\"Resulting harmonic oscillator solution\", font_size=24).to_edge(UP)\n        self.play(Write(explanation3))\n        self.play(Write(general_solution))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visualizes a simple neural network using a Python library. The neural network should have an input layer with 4 neurons, followed by a fully connected layer with 10 neurons, an activation layer using the ReLU function, another fully connected layer with 2 neurons, and finally an activation layer using the Sigmoid function. The animation should show the construction of the neural network and then demonstrate forward propagation, with clear visualization of activations in the neurons. Can you provide code for an animation that does this in a straightforward and visually appealing way?",
        "answer": "\\n from manim import Scene, VGroup, Circle, SQUARE, ORIGIN, Create, FadeOut\n\nclass NeuralNetworkAnimation(Scene):\n    def construct(self):\n        # Create a group of circles to represent neurons\n        neurons = VGroup(*[Circle(radius=0.1, color=SQUARE) for _ in range(5)])\n        neurons.arrange_in_grid(rows=1, buff=0.5)\n        neurons.move_to(ORIGIN)\n\n        # Animation: creation of each neuron\n        self.play(*(Create(neuron) for neuron in neurons))\n\n        # Animation: Fade out all neurons\n        self.play(*(FadeOut(neuron) for neuron in neurons))"
    },
    {
        "query": "\"Can you create an educational animation showing the structure of a simple recurrent neural network (RNN) followed by a feedforward layer with an animated forward pass process, using a visual representation that highlights the connections and activation functions between neurons?\"",
        "answer": "\\n from manim import *\n\nclass SceneWithMovingCharge(Scene):\n    def construct(self):\n        # Create an electron Mobject\n        electron_obj = electron()\n        # Set initial position of the electron\n        electron_obj.move_to(LEFT * 4)\n\n        # Define complex path points for the electron\n        path_points = [\n            LEFT * 4, LEFT * 3 + UP * 2, LEFT * 2 + UP * 4,\n            LEFT + UP * 2, ORIGIN, RIGHT + DOWN * 2,\n            RIGHT * 2 + DOWN * 4, RIGHT * 3 + DOWN * 2, RIGHT * 4\n        ]\n\n        # Call move_along_complex_path to get animations for the electron\n        electron_animations = move_along_complex_path(\n            electron_obj, stop_indices=[2, 5], points=path_points, run_time=2\n        )\n\n        # Add electron to the scene and play the animations\n        self.add(electron_obj)\n        self.play(*electron_animations)"
    },
    {
        "query": "\"Can you create an animated visualization that shows a simple feed-forward neural network with three layers, where the input layer has 4 nodes, the hidden layer has 6 nodes using ReLU activation, then another layer with 4 nodes also using ReLU, and finally an output layer with a single node using a Sigmoid activation function? Arrange the layers from left to right with some space in between, and animate a forward pass through the network.\"",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C, \", r\"(n \\neq -1)\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\left. \\frac{x^{3+1}}{3+1} \\right|_0^3\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating limits\n        explanation2 = Text(\"Evaluate at the boundaries\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate the definite integral\n        evaluated_solution = MathTex(r\"= \\frac{3^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(solution1, evaluated_solution))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{81}{4}\")\n        self.play(ReplacementTransform(evaluated_solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Create an animation showing a simplified model of a neural network called a Neocognitron with three layers. Have the first layer contain three neurons, the second layer four, and the third layer two. Each neuron should be represented by a blue sphere and aligned vertically within its layer. The layers should be spaced out horizontally. Draw black lines to connect each neuron from one layer to the next, representing the connections in the network. Finally, present the whole network from an angle to give a three-dimensional perspective.",
        "answer": "\\n from manim import *\n\nclass TrigFunctionIntegration(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integral of sin(x)\n        explanation1 = Text(\"Integral of sine function:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Displaying the integral rule for sine\n        integral_rule = MathTex(r\"\\int \\sin(x) \\,dx = -\\cos(x) + C\")\n        self.play(Write(integral_rule))\n        self.wait(2)\n\n        # Writing down the solution steps\n        solution = MathTex(r\"= -\\cos(x) + C\")\n        self.play(ReplacementTransform(problem.copy(), solution))\n        self.wait(1)\n\n        # Explanation for adding the constant\n        explanation2 = Text(\"Don't forget the integration constant C\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Clear the scene\n        self.play(FadeOut(explanation1), FadeOut(solution))\n        self.wait(1)\n\n        # Final presentation of the solution\n        final_solution = MathTex(r\"-\\cos(x) + C\")\n        self.play(Write(final_solution))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an educational animation that visually represents a neural network with four layers: an input layer with 4 nodes, two hidden layers each with 6 nodes, and an output layer with 2 nodes. Each layer should be labeled appropriately. The animation should also show connections forming between these layers to indicate the flow of information or the neural connections. Can this neural network animation also include an animated sequence where the network and the connections appear one after the other?",
        "answer": "\\n from manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Calculate area under the parabola\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Anti-derivative step\n        antid_step = MathTex(r\"\\int x^2 \\,dx = \\frac{1}{3}x^3\")\n        self.play(ReplacementTransform(problem.copy(), antid_step))\n        self.wait(1)\n\n        # Explanation for computing the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Applying the limits\n        limits_step = MathTex(r\"\\Bigg|_0^2 \\frac{1}{3}x^3\")\n        self.play(ReplacementTransform(antid_step, limits_step))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\left. \\frac{1}{3}(2)^3 \\right|_0^2 = \\frac{8}{3}\")\n        self.play(ReplacementTransform(limits_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "How do I create an animation that shows the training of a simple feedforward neural network using Manim, with specific layers and different colors for the input and output layers?",
        "answer": "\\n class MovingLabel(Scene):\n    def construct(self):\n        blue_dot = Dot(color=BLUE)\n        dot_label = Text(\"Hello dot!\").next_to(blue_dot, UP)\n        dot_label.add_updater(\n            lambda mobject: mobject.next_to(blue_dot, UP)\n        )\n        self.add(blue_dot, dot_label)\n        self.play(blue_dot.animate.shift(RIGHT))\n        self.play(blue_dot.animate.scale(10))\n        self.play(blue_dot.animate.move_to([-2, -2, 0]))"
    },
    {
        "query": "Can you create an animated visualization of a simple convolutional neural network (CNN) using an animation library, which includes components like convolutional layers with customizable feature maps and kernel sizes, pooling layers with adjustable pool sizes, and fully connected layers with a specified number of units and activation functions? The animation should show the structure and forward pass of the network, and be easily understandable even for those without a deep knowledge of deep learning or neural networks.",
        "answer": "\\n class MovingFrameBoxExample(Scene):\n    def construct(self):\n        text_group = VGroup(\n            Text(\"This is a sample\"), Text(\"of moving\"), Text(\"FrameBoxes\")\n        ).arrange(DOWN, buff=0.5)\n\n        frame_box1 = SurroundingRectangle(text_group[0], color=BLUE)\n        frame_box2 = SurroundingRectangle(text_group[1], color=GREEN)\n        frame_box3 = SurroundingRectangle(text_group[2], color=RED)\n\n        self.add(text_group, frame_box1)\n        self.wait(0.5)\n        self.play(ReplacementTransform(frame_box1, frame_box2))\n        self.wait(0.5)\n        self.play(ReplacementTransform(frame_box2, frame_box3))\n        self.wait(0.5)\n\n        frame_movement = frame_box3.copy()\n        path = VMobject()\n        path.set_points_as_corners([frame_box3.get_center(), frame_box3.get_center() + 2*UP])\n        self.play(MoveAlongPath(frame_movement, path), run_time=2)\n\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animated visualization of a simple neural network with four layers, where each layer is represented by a rectangle. Could you create a video where these layers are stacked vertically with some space between them, and label each one as \"Layer 1,\" \"Layer 2,\" etc.? Additionally, I want animated arrows that connect the bottom of one layer to the top of the next to represent the connections in the network. After the whole network is shown, can you animate a small blue bar moving through each layer to signify the activation process within the neural network? I'm looking for the animation to be clean, with everything centered, and have the activations in each layer appear in sequence rather than all at once.",
        "answer": "\\n from manim import *\n\n\n# All manim class must inherit Scence, cause all the things will be a scence.\nclass squareToCircle(Scene):\n    def construct(self):\n        s = Square().rotate(PI/4)\n        c = Circle()\n\n        # Playing animation.\n        self.play(Create(s))\n        self.play(Transform(s, c), run_time=5)\n        self.play(FadeOut(s))"
    },
    {
        "query": "Can you create an animated visualization of a simplified model of the visual cortex, consisting of different layers of neurons connected to each other? Each neuron should be represented as a circle, and connections between neurons across layers should be depicted with lines. I would like to see the connections behaving dynamically, possibly flashing or changing color, to simulate neural activity. Additionally, the network should include an input layer and an output layer, with labels identifying them. And finally, the entire network should shift downward at some point during the animation.",
        "answer": "\\n from manim import *\n\nclass HarmonicOscillatorODE(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y'' + \\omega^2 y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Form the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation step\n        char_eq = MathTex(r\"r^2 + \\omega^2 = 0\")\n        self.play(ReplacementTransform(problem.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solve for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solving the characteristic equation\n        roots = MathTex(r\"r = \\pm i\\omega\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = C_1 \\cos(\\omega x) + C_2 \\sin(\\omega x)\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the harmonic oscillator\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of the demonstration\", font_size=24)))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an educational animation that visually represents a simple neural network model. The animation should include four layers, each represented by a rectangle and labeled as \"Layer 1\", \"Layer 2\", \"Layer 3\", and \"Layer 4\". These layers should be stacked vertically with some space between them. Additionally, I would like to see arrows drawn between the layers to illustrate the connections from one layer to the next. The construction of the network should appear gradually on screen \u2013 have the rectangles fade in one by one, then the layer labels should be written out, followed by the growth of the connecting arrows. Can this be centered on the screen and presented in a clean and professional way suitable for a classroom or presentation context?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network import FullyConnectedLayer, NeuralNetwork\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Define neural network architecture\n        nn = NeuralNetwork(\n            {\n                \"input\": FullyConnectedLayer(784, 16),\n                \"hidden1\": FullyConnectedLayer(16, 32, activation_function=ReLU()),\n                \"hidden2\": FullyConnectedLayer(32, 16, activation_function=ReLU()),\n                \"output\": FullyConnectedLayer(16, 10, activation_function=Softmax())\n            },\n            layer_spacing=1\n        )\n\n        # Add skip connections\n        nn.add_connection(\"input\", \"hidden2\")\n        nn.add_connection(\"hidden1\", \"output\")\n\n        # Positioning the neural network on the screen\n        nn.move_to(ORIGIN)\n\n        # Animate the construction of the neural network\n        self.play(Create(nn), run_time=2)\n\n        # Animate the forward pass of the neural network\n        forward_pass = nn.make_forward_pass_animation(\n            input_vector=np.random.rand(784),\n            show_propagation=True\n        )\n        self.play(forward_pass, run_time=4)\n\n        # Highlight the output layer\n        output_layer = nn.get_layer(\"output\")\n        self.play(output_layer.animate.set_fill(YELLOW, opacity=0.5), run_time=1)\n\n        self.wait(2)"
    },
    {
        "query": "I want to create an animation that visually demonstrates the structure and functionality of a convolutional neural network with ManimCE. Can you show me step by step how the network is built using animated layers, including convolutional layers with different numbers of feature maps and sizes, a flattening layer, and several fully connected layers? After constructing the network, I would like to see an animation of data passing through it, representing the forward propagation process.",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef SpeechBubble(**kwargs):\n    gp = VGroup(\n        RoundedRectangle(width=4.5, height=2.5),\n        Polygram([\n            [-4.5/3, -2.5 + 0.55, 0], \n            [-4.5/2.8, -2.5 + 1.25, 0], \n            [-4.5/2.8 + 1, -2.5 + 1.25, 0]\n        ])\n    )\n\n    return Union(*gp, **kwargs)\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass SmallerPrime(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        animal_1 = ImageMobject(\"./assets/Asset 2 - Flipped.png\")\n        animal_1.scale(0.4)\n        animal_1.shift(9 * LEFT)\n        animal_2 = ImageMobject(\"./assets/Asset 3.png\")\n        animal_2.scale(0.4)\n        animal_2.shift(9 * RIGHT)\n        animal_3 = ImageMobject(\"./assets/Asset 1.png\")\n        animal_3.scale(0.4)\n        animal_3.shift(9 * RIGHT)\n        speech_1 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_PURPLE_COLOR)\n        speech_1.shift(3 * UP + 7 * LEFT)\n        speech_2 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=LIGHT_RED_COLOR)\n        speech_2.shift(3 * UP + 7 * RIGHT).flip(UP)\n        speech_3 = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=BROWN_COLOR)\n        speech_3.shift(3 * UP + 7 * RIGHT).flip(UP)\n        text_1 = VGroup(\n            Text(\"E qual \u00e9 o menor\", color=WHITE),\n            Text(\"n\u00famero primo?\", color=WHITE)\n        )\n        text_1.scale(0.6)\n        text_1.arrange(DOWN, buff=0.1)\n        text_1.shift(3 * UP + 7 * LEFT)\n        text_2 = VGroup(\n            Text(\"O menor primo\", color=WHITE),\n            Text(\"\u00e9 o dois!\", color=WHITE),\n        )\n        text_2.scale(0.6)\n        text_2.arrange(DOWN, buff=0.1)\n        text_2.shift(3.03 * UP + 7 * RIGHT)\n        text_3 = VGroup(\n            Text(\"O n\u00famero um n\u00e3o\", color=WHITE),\n            Text(\"\u00e9 primo, pois tem\", color=WHITE),\n            Text(\"um s\u00f3 divisor.\", color=WHITE)\n        )\n        text_3.scale(0.6)\n        text_3.arrange(DOWN, buff=0.1)\n        text_3.shift(3.03 * UP + 7 * RIGHT)\n        text_3[1].shift(0.03 * DOWN)\n\n        self.play(\n            animal_1.animate.shift(7 * RIGHT), \n            speech_1.animate.shift(8 * RIGHT),\n            text_1.animate.shift(8 * RIGHT),\n            run_time=0.7\n        )\n        self.wait(1.7)\n        self.play(\n            animal_1.animate.shift(9 * LEFT), \n            speech_1.animate.shift(9 * LEFT),\n            text_1.animate.shift(9 * LEFT),\n            animal_2.animate.shift(7 * LEFT), \n            speech_2.animate.shift(8 * LEFT), \n            text_2.animate.shift(8 * LEFT), \n            run_time=0.7\n        )\n        self.wait(1.9)\n        self.play(\n            animal_2.animate.shift(9 * LEFT), \n            speech_2.animate.shift(9 * LEFT),\n            text_2.animate.shift(9 * LEFT),\n            animal_3.animate.shift(7 * LEFT), \n            speech_3.animate.shift(8 * LEFT), \n            text_3.animate.shift(8 * LEFT), \n            run_time=0.7\n        )\n        self.wait(2.4)\n        self.play(\n            animal_3.animate.shift(9 * LEFT), \n            speech_3.animate.shift(9 * LEFT),\n            text_3.animate.shift(9 * LEFT),\n            run_time=0.7\n        )\n        self.remove(*self.mobjects)"
    },
    {
        "query": "I'd like to create an educational animation that demonstrates the basic structure of a neural network. Can you visualize a flow of data through the different layers of the network? Start with an input image and then show an animated sequence where the data progresses through a convolutional layer, an activation function layer, and finally to the output layer. For a touch of realism, use an actual image file as the input and make sure that each layer and its function are clearly labeled on the screen. Also, could you emphasize the flow of data with a moving element, like a small circle or dot, that travels from one layer to the next? I'm looking for a clear, visually appealing way to explain the concept to beginners.",
        "answer": "\\n from manim import *\n\nclass AnimatedBoundaryScene(Scene):\n    def construct(self):\n        # Create a square and position it\n        square = Square()\n        square.to_edge(UP)\n\n        # Apply an animated boundary to the square\n        animated_boundary = AnimatedBoundary(square, cycle_rate=2, colors=[YELLOW, PURPLE, TEAL])\n        self.add(square, animated_boundary)\n\n        # Play animations\n        self.play(FadeIn(square))\n        self.wait(1)\n\n        # Transform the square into a triangle\n        triangle = Triangle()\n        triangle.to_edge(UP)\n        self.play(Transform(square, triangle))\n        self.wait(1)\n\n        # Remove the square and animated boundary\n        self.play(FadeOut(square), FadeOut(animated_boundary))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that shows a simple feedforward neural network with three layers, where the first layer has 4 neurons, the second layer has 8 neurons, and the output layer has 2 neurons, with ReLU activation functions in the first two layers and a Sigmoid activation function in the output layer, and can you also animate the forward pass of information through the neural network?",
        "answer": "\\n from manim import *\n\nclass ChemicalBonding(Scene):\n    def construct(self):\n        # Create Oxygen and Metal objects\n        oxygen_atom = oxygen()\n        metal_atom = metal()\n        # Position Oxygen and Metal\n        oxygen_atom.to_edge(UP)\n        metal_atom.next_to(oxygen_atom, DOWN)\n\n        # Create Bonds\n        bond_up = Line(oxygen_atom.get_bottom(), metal_atom.get_top())\n        bond_down = Line(metal_atom.get_bottom(), metal_atom.get_bottom() + DOWN * 0.5)\n\n        # Group objects\n        molecule = VGroup(oxygen_atom, metal_atom, bond_up)\n\n        # Display molecule\n        self.play(Create(molecule))\n        self.wait(1)\n\n        # Display bond_down\n        self.play(Create(bond_down))\n        self.wait(1)\n\n        # Move molecule around\n        self.play(molecule.animate.shift(RIGHT * 2), run_time=2)\n        self.play(molecule.animate.shift(LEFT * 2), run_time=2)\n\n        # Grow from Center\n        electron_particle = electron()\n        self.play(GrowFromCenter(electron_particle))\n        self.wait(1)\n\n        # Fade out all objects\n        self.play(FadeOut(molecule), FadeOut(bond_down), FadeOut(electron_particle))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that depicts a simple model of a neural network consisting of three layers, each represented by a colored rectangle, with arrows showing connections between them, and also include a label below the last layer to indicate that it's using the ReLU activation function?",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\ndef ChocolateSquare():\n    return VGroup(\n                Square(1, color=\"#a26953\", fill_opacity=1, stroke_color=\"#814c3c\"),\n                Line((UP + RIGHT) / 2, (DOWN + LEFT) / 2, color=\"#814c3c\"),\n                Line((UP + LEFT) / 2, (DOWN + RIGHT) / 2, color=\"#814c3c\"),\n                Square(0.5, color=\"#814c3c\", fill_opacity=1),\n            )\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass ChocolateFractions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"1 de um total de 12 peda\u00e7os\", color=LIGHT_RED_COLOR)\n        title.scale(1.3)\n        frac = MathTex(r\"\\frac{1}{12}\", color=LIGHT_RED_COLOR)\n        frac.scale(1.8)\n        chocolate_row = VGroup(\n            ChocolateSquare(),\n            ChocolateSquare(),\n            ChocolateSquare(),\n        )\n        chocolate_row.arrange(RIGHT, buff=0)\n        chocolate_bar = VGroup(\n            chocolate_row.copy(),\n            chocolate_row.copy(),\n            chocolate_row.copy(),\n            chocolate_row.copy(),\n        )\n        chocolate_bar.arrange(DOWN, buff=0)\n        Group(title, chocolate_bar, frac).arrange(DOWN, buff=0.5)\n        chocolate_bar.shift(9 * RIGHT)\n\n        self.play(chocolate_bar.animate.shift(9 * LEFT))\n        self.play(\n            LaggedStart(\n                Write(title.shift(0.3 * UP)), \n                chocolate_bar[0][0].animate.shift((LEFT + UP) / 2),\n                lag_ratio=0.2,\n                run_time=1.8\n            )\n        )\n        self.play(Write(frac), run_time=0.7)\n        self.play(\n            chocolate_bar[2][2].animate.shift(RIGHT * 1.5),\n            chocolate_bar[0][0].animate.shift((RIGHT + DOWN) / 2),\n            run_time=0.8\n        )\n        self.wait(0.5)\n        self.play(chocolate_bar[2][2].animate.shift(LEFT * 1.5), run_time=0.5)\n        self.play(Group(*self.mobjects).animate.scale(0), run_time=0.7)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "How can I create an animated video that visually demonstrates a neural network with 4 layers having 4, 7, 4, and 2 neurons respectively, and shows the process of the information being passed forward through the network?",
        "answer": "\\n from manim import *\n\nclass EquivalentFractions(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        \n        fractions = VGroup(\n            MathTex(r\"\\frac{1}{2}\", color=BLACK).scale(2),\n            MathTex(r\"\\frac{2}{4}\", color=BLACK).scale(2),\n            MathTex(r\"\\frac{4}{8}\", color=BLACK).scale(2)\n        ).arrange(RIGHT, buff=1)\n        \n        arrows = VGroup(\n            Arrow(fractions[0].get_right(), fractions[1].get_left(), buff=0.1, color=BLUE),\n            Arrow(fractions[1].get_right(), fractions[2].get_left(), buff=0.1, color=BLUE)\n        )\n        \n        times_two = Tex(r\"\\times 2\", color=BLUE).next_to(arrows[0], UP)\n        times_four = Tex(r\"\\times 4\", color=BLUE).next_to(arrows[1], UP)\n        \n        self.play(Write(fractions[0]), run_time=0.5)\n        self.play(\n            GrowArrow(arrows[0]),\n            Write(times_two),\n            run_time=0.7\n        )\n        self.play(Write(fractions[1]), run_time=0.5)\n        self.play(\n            GrowArrow(arrows[1]),\n            Write(times_four),\n            run_time=0.7\n        )\n        self.play(Write(fractions[2]), run_time=0.5)\n        self.wait(2)\n        self.play(FadeOut(Group(*self.mobjects)), run_time=1)"
    },
    {
        "query": "Can you create an animated visualization of a Convolutional Neural Network (CNN) using a randomly generated RGB image as input and show the forward pass through the different layers, including convolutional layers and fully connected layers, with 28x28 input dimension and 3 channels? The CNN should start with a layer that converts the image to grayscale, followed by two convolutional layers with 16 and 32 feature maps respectively, as well as a downsized feature map on the second one. Then add two fully connected layers, one with 128 neurons and one with 10 neurons representing the output layer. The animation should be of high resolution and clearly show the spacing and buffer between layers. It should run smoothly, demonstrating the process over a period of time.",
        "answer": "\\n from manim import Scene, VGroup\nfrom manim_ml.neural_network import NeuralNetwork, FullyConnectedLayer, ReLULayer, SoftmaxLayer\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Create a simple fully connected neural network\n        nn = NeuralNetwork([\n            FullyConnectedLayer(784, 128),\n            ReLULayer(),\n            FullyConnectedLayer(128, 64),\n            ReLULayer(),\n            FullyConnectedLayer(64, 10),\n            SoftmaxLayer()\n        ],\n        layer_spacing=0.35,\n        )\n\n        # Organize the layers vertically in the center\n        nn.arrange(VGroup(*nn.layers), direction=DOWN, center=True)\n        self.add(nn)\n\n        # Play activation animations sequentially through the network\n        activations = nn.make_forward_pass_animation(run_time=2)\n        self.play(activations)\n        self.wait()"
    },
    {
        "query": "I'm interested in creating an educational animation to explain how a convolutional neural network (CNN) processes data. Could you illustrate a simple CNN architecture with several convolutional layers followed by fully connected layers, showing how data flows through the network during a forward pass? The first layer should accept a single input channel and progressively increase the channels through the convolutional layers. Also, I'd like to see the transitions between layers animated to help visualize the processing steps.",
        "answer": "\\n from manim import *\nimport random\n\nclass LawOfLargeNumbers(Scene):\n    def construct(self):\n        heads = 0\n        total = 0\n        heads_ratio = always_redraw(lambda: DecimalNumber(heads / total if total > 0 else 0).to_edge(UP))\n\n        for _ in range(100):\n            total += 1\n            if random.random() < 0.5:\n                heads += 1\n            self.play(\n                ChangeDecimalToValue(heads_ratio, heads / total if total > 0 else 0),\n                run_time=0.1\n            )\n        self.wait(1)"
    },
    {
        "query": "\"I would like to create an animation that visualizes the process of an image being fed through a neural network. The image should be a digit from the MNIST dataset, and the network should include pooling and multiple feed-forward layers. I want to see each step of the image passing through the network, starting with the original image, then being pooled and reduced in size, and finally being processed through the feed-forward layers that output the classification. The animation should be detailed, highlighting the forward pass of the neural network, and it should end with a short pause. Can you make this animation for me?\"",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef Division(numerator, denominator):\n    result = numerator // denominator\n    integerPart = int(result * denominator)\n    remainder = numerator - integerPart\n    \n    gp = VGroup(\n        VGroup(\n            MathTex(str(numerator), color=LIGHT_PURPLE_COLOR),\n            VGroup(\n                Line((0, 0, 0), (0, 0.6, 0), color=LIGHT_PURPLE_COLOR),\n                Line((0, 0, 0), (0.6, 0, 0), color=LIGHT_PURPLE_COLOR),\n                MathTex(str(denominator), color=LIGHT_PURPLE_COLOR).shift(0.3 * UP + 0.32 * RIGHT)\n            ) \n        ).arrange(RIGHT),\n        VGroup(\n            MathTex(\"-\", color=SAND_COLOR),\n            MathTex(r\"\\frac{\" + str(integerPart) + \"}{\" + str(remainder) + \"}\", color=SAND_COLOR),\n            MathTex(str(result), color=SAND_COLOR)\n        ).arrange(RIGHT)\n    )\n\n    gp[1].shift(0.5 * LEFT + 0.9 * DOWN)\n    gp[1][0].shift(0.3 * UP)\n    gp[1][1][0][1].scale(2).shift(0.03 * UP)\n    gp[1][2].shift(0.3 * UP + 0.22 * RIGHT)\n\n    return gp\n\nclass SixDivision(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(6, 1)\n        by_one.scale(1.4)\n        by_two = Division(6, 2)\n        by_two.scale(1.4)\n        by_three = Division(6, 3)\n        by_three.scale(1.4)\n        by_four = Division(6, 4)\n        by_four.scale(1.4)\n        by_five = Division(6, 5)\n        by_five.scale(1.4)\n        by_six = Division(6, 6)\n        by_six.scale(1.4)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two\n            ).arrange(RIGHT, buff=1),\n            VGroup(\n                by_three,\n                by_four\n            ).arrange(RIGHT, buff=1),\n            VGroup(\n                by_five,\n                by_six\n            ).arrange(RIGHT, buff=1)\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_two, color=LIGHT_RED_COLOR)\n        square3 = SurroundingRectangle(by_three, color=LIGHT_RED_COLOR)\n        square4 = SurroundingRectangle(by_six, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            FadeIn(by_six),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            Create(square3),\n            Create(square4),\n            lag_ratio=0.3,\n            run_time=2.5\n        ))\n        self.wait(2.5)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(square3), \n            FadeOut(square4), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)"
    },
    {
        "query": "Can you create an animation that visualizes a small neural network with input, hidden, and output layers, where the input has 784 nodes, the first hidden layer has 16 nodes, the second hidden layer has 32 nodes, then another hidden layer with 16 nodes that connect to an output layer with 10 nodes? I would like to see ReLU activation functions in the hidden layers and a Softmax activation function in the output layer. Also, can you add some skip connections directly from the input to the second hidden layer and from the first hidden layer to the output? During the animation, it would be great to watch a random forward pass through the network and see the output nodes get highlighted at the end.",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series equation\n        fourier_series_eq = MathTex(r\"f(x) = a_0 + \\sum_{n=1}^{\\infty} \\left( a_n \\cos(nx) + b_n \\sin(nx) \\right)\")\n        self.play(Write(fourier_series_eq))\n        self.wait(2)\n\n        # Adding the explanation for Fourier series\n        explanation1 = Text(\"Fourier series decomposes periodic functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Further explanation\n        explanation2 = Text(\"into the frequencies composing the original function.\", font_size=24).next_to(explanation1, DOWN)\n        self.play(Write(explanation2))\n        self.wait(2)\n\n        # Example of a function\n        function_example = MathTex(r\"f(x) = \\cos(x) + \\frac{1}{2}\\cos(2x)\")\n        self.play(ReplacementTransform(fourier_series_eq, function_example))\n        self.wait(1)\n        \n        # Updating the explanation for this example\n        explanation3 = Text(\"This is a simple example with only two terms\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(1)\n        self.remove(explanation2)\n        self.wait(1)\n\n        # Clear the scene\n        self.play(FadeOut(function_example), FadeOut(explanation1))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation that visually demonstrates the concept of dropout in a simple feedforward neural network with four layers containing 4, 6, 6, and 3 neurons each, and apply a dropout rate of 20% to each layer except the input one? The network should be centered and the dropout effect should be animated for each applicable layer. After the dropout effect finishes, hold the final frame for a couple of seconds.",
        "answer": "\\n from manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using exponential rule\n        explanation1 = Text(\"Use the exponential rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(1)\n\n        # Conclusion with the final solution\n        self.play(FadeOut(explanation1))\n        final_solution = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(Transform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and show only the final solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create a simple animation where the word \"Animations\" appears at the top of the screen?",
        "answer": "\\n from manim import *\n\nclass MovingElectronScene(Scene):\n    def construct(self):\n        # Create an electron object using the previously defined function\n        electron_object = electron()\n        \n        # Define starting and ending points\n        start_point = LEFT * 4\n        end_point = RIGHT * 4\n        \n        # Create a path for the electron to follow\n        path = VMobject()\n        path.set_points_as_corners([start_point, UP*2, end_point])\n        \n        # Move electron along the path\n        self.play(MoveAlongPath(electron_object, path, rate_func=there_and_back, run_time=5))\n        \n        # Keep the electron on screen at the end of the path\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation using a python-based animation library where a star appears onscreen, and the word \"Create\" is shown above it, then the star disappears, and the word changes to \"Uncreate\"?",
        "answer": "\\n from manim import Scene, Circle, FadeIn_x000D_\n_x000D_\nclass CreateCircleScene(Scene):_x000D_\n    def construct(self):_x000D_\n        circle = Circle() # Create a circle_x000D_\n        circle.set_fill(PINK, opacity=0.5) # Set the color and transparency_x000D_\n        self.play(FadeIn(circle)) # Fade the circle in_x000D_\n        self.wait(2) # Wait for 2 seconds"
    },
    {
        "query": "I would like to create an animation where a circle appears and is surrounded by a colorful moving boundary consisting of red, green, and blue colors. Additionally, I want the name \"AnimatedBoundary\" to appear above the circle quickly before the animation starts. After displaying the animated boundary around the circle for a short while, both the circle and the boundary should disappear. Can the boundary loop its animation three times every second?",
        "answer": "\\n from manim import *\n\nclass AtomDistribution(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        atom_grid = self.create_atom_grid(5, 5)\n        # Animate the creation of the atom grid\n        self.play(Create(atom_grid))\n        # Show the scene\n        self.wait(2)\n\n    def atom_element(self, symbol: str, color: Color, text_color: Color) -> Mobject:\n        # Create a circle with element symbol text inside\n        atom_circle = Circle(radius=0.5, color=color).set_opacity(1).set_fill(color)\n        atom_text = Tex(symbol, color=text_color).scale(1.5)\n        atom = VGroup(atom_circle, atom_text)\n        return atom\n\n    def create_atom_grid(self, rows: int, cols: int) -> Mobject:\n        # Initialize empty list to hold atoms\n        atom_list = []\n        # Loop to populate the list with atoms\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom_list.append(self.atom_element(\"Cl\", GREEN, WHITE).shift([j - cols/2, rows/2 - i, 0]))\n                else:\n                    atom_list.append(self.atom_element(\"Na\", ORANGE, WHITE).shift([j - cols/2, rows/2 - i, 0]))\n        # Create a group with all atoms\n        atom_group = VGroup(*atom_list)\n        return atom_group"
    },
    {
        "query": "I would like to create an animation where a red dot travels in a simple path on the screen. First, the dot should move up, then left, and finally diagonally down and to the right, creating a neat trace of its journey. Also, at the beginning of the animation, I want the screen to display the words \"TracedPath\" at the top, and all movements should be completed quickly, perhaps in half-second intervals. Once the path is complete, the dot and its trace should disappear. Can you create such an animation for me?",
        "answer": "\\n from manim import *\n\nclass ExampleIntegrationByParts(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using integration by parts\n        explanation1 = Text(\"Use integration by parts\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration by parts formula\n        ibp_formula = MathTex(r\"\\int u dv = uv - \\int v du\")\n        self.play(Write(ibp_formula))\n        self.wait(2)\n\n        # Choosing u and dv\n        choosing_udv = MathTex(r\"u = x\", r\",\\ dv = e^x \\,dx\")\n        self.play(Write(choosing_udv))\n        self.wait(2)\n\n        # Computing du and v\n        computing_duv = MathTex(r\"du = dx\", r\",\\ v = e^x\")\n        self.play(Write(computing_duv))\n        self.wait(2)\n\n        # Apply formula\n        applied_formula = MathTex(r\"x e^x - \\int e^x \\,dx\")\n        self.play(ReplacementTransform(ibp_formula, applied_formula))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= x e^x - e^x + C\")\n        self.play(ReplacementTransform(applied_formula, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where a sentence appears on screen one letter at a time. First, the sentence \"Here is a text\" should be displayed gradually, with each character popping into view sequentially. After the whole sentence is visible, I want to replace the text with a new sentence, \"AddTextLetterByLetter,\" which will also appear letter by letter. Once that's done, I'd like to change that sentence to \"RemoveTextLetterByLetter,\" but this time I want the removal of the sentence to be animated with each letter disappearing one after another, effectively reversing the process of the text appearing. Can you provide a visual representation of this sequence?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the integral\n        integral = MathTex(r\"\\int_0^3 x^2 \\, dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Setting up the visualization of the area under the curve\n        axes = Axes(\n            x_range=[0, 4], y_range=[0, 10],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        area = axes.get_area(graph, x_range=(0,3), color=GREY, opacity=0.5)\n\n        # Show the axes and graph with shaded area\n        self.play(Create(axes), Create(graph), FadeIn(area))\n        self.wait(1)\n\n        # Calculation step\n        calculation = MathTex(r\"= \\frac{1}{3} x^3 \\Big|_0^3\")\n        self.play(ReplacementTransform(integral.copy(), calculation))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3} (3)^3 - 0\")\n        self.play(Transform(calculation, final_solution))\n        self.wait(1)\n\n        # Conclusion, show the area equals final integral value\n        conclusion_text = Text(\"Area under the curve is equal to the integral value\", font_size=24).to_edge(UP)\n        final_value = MathTex(r\"= 9\").next_to(conclusion_text, DOWN)\n        self.play(Write(conclusion_text), ReplacementTransform(final_solution.copy(), final_value))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_value))\n        self.wait(1)"
    },
    {
        "query": "I want to create a simple animation using a Python-based library where text appears on the screen, changes to something else, and then disappears. I would like the initial text to begin by transforming into the word \"Write,\" move up, and stay there briefly. Then, I would like additional text that reads \"Here is more text\" to be written out on the screen below the first word. After a short moment, I want the first text to transform again, this time into the word \"Unwrite,\" move to the same upper position, and then have the additional text be unwritten or erased from the screen. Finally, I want both texts to be removed completely. Can this animation be made in a way that it looks smooth and professional, with the transformations and writing actions having a specific quick duration?",
        "answer": "\\n from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        self.add(hydrogen_atom())\n\ndef hydrogen_atom() -> Mobject:\n    electron_layer = Circle(radius=1, color=BLUE).set_opacity(0.5)\n    nucleus = Dot(radius=0.1, color=RED_A).shift(ORIGIN)\n\n    electron = Dot(radius=0.05, color=WHITE)\n    electron.set_z_index(1)\n\n    orbit = electron_layer.copy().set_fill(opacity=0)\n    electron.move_to(orbit.point_from_proportion(0))\n\n    circle_group = VGroup(orbit, electron, nucleus)\n\n    def update_electron(mob, dt):\n        rate = dt * 0.1  # revolutions per second\n        mob.move_to(orbit.point_from_proportion((mob.get_center()[0]+rate) % 1))\n\n    electron.add_updater(update_electron)\n\n    return VGroup(circle_group)\n\ndef hydrogen_migration(scene: Scene, electron_path: Arc, run_time: float):\n    hydrogen = hydrogen_atom()\n    scene.play(ShowCreation(hydrogen))\n    scene.wait(1)\n\n    electron = hydrogen[0][1]\n    hydrogen.remove(electron)  # We'll animate the electron separately\n\n    def update_pos(mob, alpha):\n        mob.move_to(electron_path.point_from_proportion(alpha))\n\n    scene.play(\n        UpdateFromAlphaFunc(electron, update_pos),\n        MoveAlongPath(hydrogen, electron_path),\n        run_time=run_time,\n        rate_func=linear\n    )\n    scene.play(FadeOut(hydrogen), FadeOut(electron))"
    },
    {
        "query": "I would like to create a simple animation where a text message morphs into a colorful blue-bordered square with a yellow fill, which then appears on the screen accompanied by an effect that draws the border first and then fills it in with color. Once the square is completely drawn and filled, it should disappear immediately. The entire sequence should happen quite quickly, ideally in half a second. Can you help me accomplish this with an animation?",
        "answer": "\\n from manim import *\n\nclass ParabolaTangentExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y = x^2, \\, P(2, 4), \\, \\text{find the tangent at P}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Draw the graph\n        graph = FunctionGraph(lambda x : x**2, color=BLUE)\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Mark the point and tangent\n        point = Dot(ax.i2gp(2, graph), color=YELLOW)\n        label = MathTex(r\"P(2, 4)\").next_to(point, RIGHT)\n        tangent = Line(start=point.get_center() + LEFT*3, end=point.get_center() + RIGHT*3, color=GREEN)\n        self.add(point, label)\n        self.play(GrowFromCenter(tangent))\n        self.wait(2)\n\n        # Explanation for the derivative\n        explanation1 = Text(\"Use the derivative for the slope of the tangent\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Derivative step\n        derivative_step = MathTex(r\"\\frac{d}{dx}(x^2) = 2x\")\n        self.play(Write(derivative_step))\n        self.wait(1)\n\n        # Slope at point P\n        slope_at_P = MathTex(r\"2x|_{x=2} = 4\")\n        self.play(Transform(derivative_step, slope_at_P))\n        self.wait(1)\n\n        # Equation of the tangent\n        tangent_eq = MathTex(r\"y - 4 = 4(x - 2)\")\n        self.play(Write(tangent_eq))\n        self.wait(1)\n\n        # Final tangent equation\n        final_tangent_eq = MathTex(r\"y = 4x - 4\")\n        self.play(ReplacementTransform(tangent_eq, final_tangent_eq))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.play(Write(final_tangent_eq))\n        self.wait(1)"
    },
    {
        "query": "How can I create an animation with Manim where the screen initially shows the text \"ShowIncreasingSubsets\" at the top, followed by a sequence of three circles appearing one after another: one circle in the center a bit up, the second circle on the bottom left, and the third on the bottom right, and then have all the circles disappear?",
        "answer": "\\n from manim import *\n\nclass EulersFormula(Scene):\n    def construct(self):\n        # Introducing Euler's formula\n        title = Text(\"Euler's Formula\").scale(1.5)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Move title up\n        self.play(ApplyMethod(title.to_edge, UP))\n        self.wait(1)\n\n        # Euler's formula\n        formula = MathTex(r\"e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)\")\n        self.play(FadeIn(formula))\n        self.wait(1)\n\n        # Visualize the complex plane\n        plane = NumberPlane(\n            x_range=(-4, 4, 1), \n            y_range=(-3, 3, 1)\n        )\n        self.play(Write(plane))\n        self.wait(1)\n\n        # Angle theta on the complex plane\n        angle = ValueTracker(0)\n        radius = 2\n        line = always_redraw(lambda: Line(start=plane.c2p(0, 0), end=plane.c2p(radius * np.cos(angle.get_value()), radius * np.sin(angle.get_value())), color=BLUE))\n        dot = always_redraw(lambda: Dot(plane.c2p(radius * np.cos(angle.get_value()), radius * np.sin(angle.get_value())), color=RED))\n\n        # Add angle line and dot on the plane\n        self.play(Write(line), FadeIn(dot))\n        self.wait(1)\n\n        # Animate the angle change\n        self.play(angle.animate.set_value(2 * PI), run_time=4, rate_func=linear)\n        self.wait(1)\n\n        # Final explanation of Euler's formula\n        explanation = Text(\n            \"As theta varies, e^(i*theta) traces out the unit circle in the complex plane.\", \n            font_size=24\n        ).to_edge(DOWN)\n\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # End scene with Euler's formula\n        self.play(Write(formula))\n        self.wait(1)"
    },
    {
        "query": "\"I would like to create an animation where a piece of text reading 'ShowSubmobjectsOneByOne' appears and moves to the top of the screen. Following this, can you depict three circles appearing one after another, with the first circle at the center top, the second to the bottom left, and the third to the bottom right? After all circles are displayed, they should then disappear from the screen. I'm aiming for the text transformation to be quick, perhaps just half a second, with the rest of the animation having a standard duration.\"",
        "answer": "\\n from manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Displaying the Fourier series\n        fourier_series = MathTex(r\"f(x) \\sim a_0 + \\sum_{n=1}^{\\infty} (a_n\\cos(nx) + b_n\\sin(nx))\")\n        self.play(Write(fourier_series))\n        self.wait(1)\n\n        # Explanation for Fourier coefficients\n        explanation1 = Text(\"Determine the Fourier coefficients\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Fourier coefficients equations\n        coeff_a0 = MathTex(r\"a_0 = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x) \\, dx\")\n        coeff_an = MathTex(r\"a_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cos(nx) \\, dx\")\n        coeff_bn = MathTex(r\"b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\sin(nx) \\, dx\")\n        coeffs_group = VGroup(coeff_a0, coeff_an, coeff_bn).arrange(DOWN)\n        self.play(ReplacementTransform(fourier_series.copy(), coeffs_group))\n        self.wait(1)\n\n        # Explanation for partial sum\n        explanation2 = Text(\"Partial sum approximation of the series\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Partial sum of Fourier series\n        partial_sum = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^{N} (a_n\\cos(nx) + b_n\\sin(nx))\")\n        self.play(ReplacementTransform(coeffs_group, partial_sum))\n        self.wait(1)\n\n        # Explanation for convergence\n        explanation3 = Text(\"Convergence of the Fourier series\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Visualizing the convergence of the Fourier series\n        convergence = Text(\"Visualizing the convergence for N terms...\", font_size=24)\n        self.clear()\n        self.play(Write(convergence))\n        self.wait(1)\n\n        # Final waiting time before conclusion\n        self.wait(1)"
    },
    {
        "query": "Can you create a simple animation where a text saying \"FadeIn\" appears at the top, then a square fades in below it, after that the text changes to \"FadeOut\", and finally both the square and the changed text fade out from the screen?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Setting up the axes\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 6, 1],\n            x_length=5,\n            y_length=3,\n            axis_config={\"color\": BLUE},\n        )\n\n        # Defining the function to plot and its curve\n        func = lambda x: 0.2 * x ** 2\n        curve = axes.plot(\n            func, \n            x_range=[0, 4], \n            color=RED\n        )\n\n        # Area under the curve\n        area = axes.get_area(curve, x_range=(0, 4), color=GREEN, opacity=0.5)\n\n        # Plot and area labels\n        curve_label = axes.get_graph_label(curve, label='y=0.2x^2')\n        area_label = Text(\"Area under curve\", color=WHITE).scale(0.6).next_to(area, DOWN)\n\n        # Animate the display\n        self.play(Create(axes), Write(curve_label))\n        self.play(Create(curve))\n        self.play(FadeIn(area), FadeIn(area_label))\n        self.wait(2)\n\n        # Clear and show final message\n        self.clear()\n        final_message = Text(\"The area under y=0.2x^2 from x=0 to x=4\", font_size=24)\n        self.play(Write(final_message))\n        self.wait(2)"
    },
    {
        "query": "How can I create a simple animation using a Python library where a text saying \"GrowArrow\" appears and moves upward, followed by an arrow that grows from a point below, which then disappears after it has fully appeared?",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass TenPrimes(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        text = Tex(\"Dez primeiros primos\", color=LIGHT_RED_COLOR)\n        text.scale(1.5)\n        primes = VGroup(*[Tex(str(prime), color=LIGHT_BLUE_COLOR) for prime in range(2, 30) if is_prime(prime)])\n        primes.scale(1.5)\n        first_five = VGroup(*primes[0:5])\n        first_five.arrange(RIGHT, buff=0.8)\n        next_five = VGroup(*primes[5:])\n        next_five.arrange(RIGHT, buff=0.5)\n        Group(\n            text,\n            first_five, \n            next_five\n        ).arrange(DOWN, buff=0.8)\n\n        self.play(Write(text), run_time=0.7)\n\n        for prime in primes:\n            self.play(DrawBorderThenFill(prime), run_time=0.3, rate_func=linear)\n\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.scale(0), run_time=0.7)"
    },
    {
        "query": "I'd like to create an animation where a piece of text reading \"GrowFromCenter\" appears at the top of the screen and instantly transforms into an outlined triangle that expands from its center and then vanishes. Can this animation be completed in just half a second?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_color_by_gradient\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1)\n            self.add(square)\n            self.play(square.animate.set_color_by_gradient(RED,BLUE,YELLOW))\n            self.remove(square)"
    },
    {
        "query": "I would like to create an animated sequence where a text appears and changes to describe the animation that follows. The animation should show a square growing from one of its edges in four different directions: down, right, up, and left. Each time a square grows from an edge, the text should change to indicate the direction from which the square is growing. The text should be displayed above the square and should change quickly with a transition effect before each new square animation begins. After showing all four squares growing in the respective directions, all squares should disappear from the screen. Can you create this animation in a simple and visually appealing way?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function\n        function = MathTex(r\"f(x) = 3 - x^2\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Indicate the area of interest\n        area_description = Text(\"Area under the curve from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(area_description))\n        self.wait(2)\n\n        # Setup the definite integral\n        definite_integral = MathTex(r\"\\int_1^2 (3 - x^2) \\,dx\")\n        self.play(Transform(function, definite_integral))\n        self.wait(1)\n\n        # Steps to find the area\n        step1 = MathTex(r\"= \\left[ 3x - \\frac{x^3}{3} \\right]_1^2\")\n        self.play(ReplacementTransform(definite_integral.copy(), step1))\n        self.wait(1)\n\n        step2_description = Text(\"Calculate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(area_description, step2_description))\n        self.wait(2)\n\n        # Show the final result\n        final_area = MathTex(r\"= (6 - \\frac{8}{3}) - (3 - \\frac{1}{3})\", r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(step1, final_area))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The area is 7/3 square units\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_area))\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation where the phrase \"GrowFromPoint\" appears at the top of the screen, followed by a star that grows from a specific point on the screen which then both disappear?",
        "answer": "\\n from manim import Scene, VGroup\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\nfrom manim_ml.neural_network.animations import Train\n\nclass TrainNeuralNetworkScene(Scene):\n    def construct(self):\n        # Define a neural network\n        nn = NeuralNetwork([\n            FeedForwardLayer(4),\n            FeedForwardLayer(7),\n            FeedForwardLayer(2),\n        ],\n        layer_spacing=0.5,\n        )\n\n        # Center the neural network\n        nn.move_to(ORIGIN)\n\n        # Add the neural network to the scene\n        self.add(nn)\n\n        # Training animation for the neural network\n        training_animation = Train(nn)\n\n        # Play the training animation\n        self.play(training_animation)\n\n        # Hold the final frame\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animation where a text reading \"SpinInFromNothing\" appears with a spinning effect and is placed at the top of the screen. After the text appears, I want a triangle to spin into existence in the center of the screen and then disappear. The animation should be quick, with the text transformation happening in just half a second. Can you write me a script for this using ManimCE?",
        "answer": "\\n from manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Describing the motion\n        motion_eq = MathTex(r\"\\frac{d^2 x}{dt^2} + \\omega^2 x = 0\")\n        self.play(Write(motion_eq))\n        self.wait(1)\n\n        # Explaining the terms\n        explanation1 = Text(\"This represents a simple harmonic oscillator.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Frequency of the oscillator\n        explanation2 = Text(r\"The term $\\omega$ is the angular frequency.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the solution to the motion equation\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(motion_eq, solution))\n        self.wait(1)\n\n        # Describing the amplitude and phase\n        explanation3 = Text(\"Here, A is amplitude and \u03c6 is the phase.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear scene and show conclusion\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)"
    },
    {
        "query": "\"I want to create an animation where the phrase 'Mathematical Animations' appears on screen, then has a wave effect applied to it from the center outwards, and then has the wave effect applied again but this time from the left to the right. After the effects, the text should disappear. Can this be done somewhat quickly, let's say in half a second for the initial appearance?\"",
        "answer": "\\n from manim import *\n\nclass ElementSymbol(Scene):\n    def construct(self):\n        symbol = Tex(\"He\", color=WHITE, font_size=144)\n        electron_orbit = Ellipse(width=3.6, height=2.2, color=YELLOW_C).shift(DOWN*0.5)\n        electron_1 = Dot(color=RED, radius=0.1).shift(LEFT*1.8)\n        electron_2 = Dot(color=RED, radius=0.1).shift(RIGHT*1.8)\n\n        element_group = VGroup(symbol, electron_orbit, electron_1, electron_2)\n\n        self.play(FadeIn(element_group))\n        self.play(\n            Rotate(electron_1, angle=2*PI, about_point=symbol.get_center()),\n            Rotate(electron_2, angle=2*PI, about_point=symbol.get_center()),\n            rate_func=linear,\n            run_time=4\n        )\n        self.play(FadeOut(element_group))"
    },
    {
        "query": "I would like to create an animation where a text saying \"Look Here\" appears on the screen, then gets encircled by a shape to highlight it. First, I want the text to be highlighted by a rectangle that automatically adjusts to the size of the text, and then I want the rectangle to transform into a circle highlighting the same text. After the text has been highlighted by both shapes, it should disappear from the screen. Can this be done in a simple animation, perhaps with an additional transformation where another text saying \"Circumscribe\" moves upwards on the screen before the main animation starts?",
        "answer": "\\n from manim import *\nfrom PIL import Image\nimport numpy as np\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        # Load an image to use as input\n        image_path = \"path/to/your/image.png\"\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n\n        # Create layers for the neural network\n        layers = VGroup(\n            ImageMobject(image).scale(0.5),\n            RoundedRectangle(corner_radius=0.2).scale(0.2),\n            RoundedRectangle(corner_radius=0.2).scale(0.5).set_fill(ORANGE, opacity=0.5),\n            RoundedRectangle(corner_radius=0.2).scale(0.3).set_fill(GREEN, opacity=0.8),\n        )\n\n        # Position the layers of the neural network\n        layers.arrange(DOWN, buff=0.5)\n\n        # Label the layers\n        labels = VGroup(\n            Text(\"Input Image\", font_size=24),\n            Text(\"Conv Layer\", font_size=24),\n            Text(\"ReLU Activation\", font_size=24),\n            Text(\"Output Layer\", font_size=24),\n        )\n\n        # Align labels with layers\n        for label, layer in zip(labels, layers):\n            label.next_to(layer, UP)\n\n        # Create a group with layers and labels\n        neural_network_group = VGroup(layers, labels).move_to(ORIGIN)\n\n        # Animate the creation of the neural network\n        self.play(\n            *[FadeIn(layer) for layer in layers],\n            *[Write(label) for label in labels],\n            run_time=2\n        )\n\n        self.wait(1)\n\n        # Illustrate data flowing through the network\n        flow_data = Circle(radius=0.1, color=YELLOW).move_to(layers[0].get_bottom())\n        self.play(flow_data.move_to, layers[1].get_top())\n        self.wait(0.5)\n        self.play(flow_data.move_to, layers[2].get_top())\n        self.wait(0.5)\n        self.play(flow_data.move_to, layers[3].get_top())\n\n        self.wait(2)"
    },
    {
        "query": "How can I create a simple animation using Manim where the word \"Flash\" appears and moves upwards, followed by the word \"Ta Da\" in yellow color flashing on the screen before disappearing?",
        "answer": "\\n         self.play(Transform(text,Text(\"GrowArrow\").shift(UP*2.5)), run_time=0.5)\n        arrow = Arrow()\n        self.play(GrowArrow(arrow))\n        self.remove(arrow)"
    },
    {
        "query": "\"I'd like an animation where a word appears at the top, then another word appears in the center, the scene focuses on the new word, and finally, the centered word disappears.\"",
        "answer": "\\n from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y' - y = 0\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Form the characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation step\n        char_eq = MathTex(r\"r - 1 = 0\")\n        self.play(ReplacementTransform(problem.copy(), char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solve for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solving the characteristic equation\n        roots = MathTex(r\"r = 1\")\n        self.play(ReplacementTransform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = C e^{x}\")\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(general_solution))\n        self.wait(1)"
    },
    {
        "query": "I want to create an animation where a piece of text reading \"Indicate\" appears and moves to the top of the screen quickly. Then, another text saying \"This is important\" appears, and I want this text to be highlighted or indicated in some way to emphasize its importance. After the emphasis, the second text should disappear from the screen.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the problem of finding the area under a curve\n        problem_text = MathTex(r\"A = \\int_{a}^{b} f(x) \\,dx\")\n        self.play(Write(problem_text))\n        self.wait(1)\n\n        # Show the graph of f(x)\n        axes = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: 0.1 * x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='f(x)')\n        \n        self.play(Create(axes), Write(graph_label))\n        self.wait(1)\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Shade the area under the curve\n        area = axes.get_area(graph, x_range=[2, 8], color=[RED, ORANGE], opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(1)\n        \n        # Explanation of integral as area under the curve\n        explanation_text = Text(\"Integral represents the area under f(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation_text))\n        self.wait(2)\n\n        # Value of the definite integral\n        integral_value = MathTex(r\"A = \\int_{2}^{8} 0.1x^2 \\,dx = \\frac{4^3}{3} - \\frac{2^3}{3}\")\n        self.play(ReplacementTransform(problem_text, integral_value))\n        self.wait(1)\n\n        # Show numerical value of the area\n        numerical_value = MathTex(r\"A \\approx 21.333\")\n        self.play(FadeOut(explanation_text), ReplacementTransform(integral_value, numerical_value))\n        self.wait(1)\n\n        # Clear the scene and show the final area value\n        self.clear()\n        self.play(Write(numerical_value))\n        self.wait(1)"
    },
    {
        "query": "Can you help create an animation where the word \"Wiggle\" moves up slightly and wiggles using that cool math animation software?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowFromCenter\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(GrowFromCenter(triangle))\n            self.remove(triangle)"
    },
    {
        "query": "I would like to create an animation where a piece of text reading \"ShowPassingFlash\" appears and shifts upwards, followed by a square that has a flashing effect passing over it, and then the square disappears. How can I do that using an animation library?",
        "answer": "\\n from manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        proton = self.create_proton()\n        electron = self.create_electron()\n        hydrogen_atom = VGroup(proton, electron).arrange(RIGHT, buff=1)\n        self.add(hydrogen_atom)\n        self.play(hydrogen_atom.animate.shift(UP))\n\n    def create_proton(self) -> Mobject:\n        return circle_with_text(0.2, \"p$^+$\", RED_E, 24, WHITE, 2, RED_E)\n\n    def create_electron(self) -> Mobject:\n        return circle_with_text(0.15, \"e$^-$\", BLUE_E, 24, WHITE, 1, BLUE_E)\n\n    def circle_with_text(\n        self,\n        radius: float,\n        text: str,\n        border_color: str,\n        font_size: int,\n        font_color: str,\n        stroke_width: int,\n        fill_color: str\n    ) -> Mobject:\n        circle = Circle(radius, color=border_color).set_opacity(1).set_fill(fill_color)\n        label = Tex(text, font_size=font_size, color=font_color).set_stroke(width=stroke_width)\n        return VGroup(circle, label)"
    },
    {
        "query": "I would like to create a short animation where a text appears with a transition effect and moves upwards slightly, followed by a square that has a flashing animation with its stroke width thinning out, and after the flash, the square should disappear. Can this be done using an animation library?",
        "answer": "\\n class SimpleCustomAnimation(Scene):\n    def construct(self):\n        def spiral_out(mobject, t):\n            radius = 4 * t\n            angle = 2*t * 2*PI\n            mobject.move_to(radius*(np.cos(angle)*RIGHT + np.sin(angle)*UP))\n            mobject.set_color(Color(hue=t, saturation=1, luminance=0.5))\n            mobject.set_opacity(1-t)\n        \n        d = Dot(color=YELLOW)\n        self.add(d)\n        self.play(UpdateFromAlphaFunc(d, spiral_out, run_time=3))"
    },
    {
        "query": "I would like to create an animation where a text saying \"MoveAlongPath\" appears and shifts upwards, followed by a line being drawn from the bottom left to the top right of the screen. Then, I want a dot to appear at the beginning of the line and move smoothly to the end of the line, and once the dot reaches the end, both the line and the dot disappear. Can you make the dot's movement and the line's creation quick, each happening in half a second?",
        "answer": "\\n from manim import *\n\nclass ChemicalAnimation(Scene):\n    def construct(self):\n        electron_particle = electron()\n        oxygen_atom = oxygen()\n        metal_atom = metal()\n        positive_ion = positive()\n        negative_ion = negative()\n        metal_oxide_structure = metal_oxid(4, 4)\n        lithium_ion_structure = lithium_grid(3, 3)\n        carbon_structure = carbon_grid(2)\n\n        self.play(Create(electron_particle))\n        self.play(electron_particle.animate.move_to(RIGHT * 2 + UP * 1))\n        self.wait()\n\n        self.play(Transform(electron_particle, oxygen_atom))\n        self.wait()\n\n        self.play(Transform(electron_particle, metal_atom))\n        self.play(electron_particle.animate.move_to(LEFT * 2 + UP * 1))\n        self.wait()\n\n        self.play(Transform(electron_particle, positive_ion))\n        self.play(ReplacementTransform(electron_particle, negative_ion))\n        self.wait(1)\n\n        self.play(FadeIn(metal_oxide_structure))\n        self.wait(2)\n\n        self.play(FadeOut(metal_oxide_structure), FadeIn(lithium_ion_structure))\n        self.wait(2)\n\n        self.play(ReplacementTransform(lithium_ion_structure, carbon_structure))\n        self.wait(2)\n\n        self.play(FadeOut(carbon_structure))\n        self.wait(1)\n\n        self.play(electron_particle.animate.move_to(ORIGIN))\n        self.play(GrowFromCenter(electron_particle))\n        self.wait(1)"
    },
    {
        "query": "I would like to see an animation where a text saying \"Rotate\" appears and moves upwards, followed by a five-pointed star shape appearing in the center and rotating for a while before it disappears. Can you create this for me?",
        "answer": "\\n         self.play(Transform(text,Text(\"Create\").shift(UP*2.5)), run_time=0.5)\n        start = Star()\n        self.play(Create(start))\n        self.play(Transform(text,Text(\"Uncreate\").shift(UP*2.5)), run_time=0.5)\n        self.play(Uncreate(start))"
    },
    {
        "query": "Please create a simple animation using a math visualization tool where text that says \"Rotating\" appears and moves upwards, followed by a square that rotates in place, and after a brief pause, both the text and the rotating square disappear.",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}x^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation where the word \"Broadcast\" appears and moves upward, followed by a triangle shape emanating some sort of broadcast signal and then the triangle disappearing?",
        "answer": "\\n from manim import *\n\nclass InfiniteGeometricSeries(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for the sum of an infinite geometric series\n        explanation1 = Text(\"Use formula for sum of infinite geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Showing the sum formula\n        sum_formula = MathTex(r\"S = \\frac{a}{1 - r}\", r\",\\ |r| < 1\")\n        self.play(ReplacementTransform(series, sum_formula))\n        self.wait(1)\n\n        # Explanation for a specific example\n        explanation2 = Text(\"Example with a=1, r=1/2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Specific example calculation\n        example_calculation = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}} = 2\")\n        self.play(ReplacementTransform(sum_formula, example_calculation))\n        self.wait(1)\n\n        # Clear screen and conclude with the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(example_calculation))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where text reading \"ChangeSpeed\" appears at the top of the screen rapidly within half a second. Then, I want a dot to start from the left side of the screen, move to the right, and change speed during its movement \u2013 starting at normal speed, slowing down in the middle, and then speeding up again to the normal speed at the end of the path before it disappears. The movement should be smooth with no sudden changes in velocity. Can you do that?",
        "answer": "\\n from manim import *\n\nclass TrigFunctionIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^{\\pi} \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for integrating over the interval\n        explanation1 = Text(\"Integrate sine over the interval from 0 to pi\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^{\\pi}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show conclusion\n        conclusion = Text(\"The integral of sine from 0 to pi is 2\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where a text object reading \"Transform\" moves upwards and then transforms into a star shape from a square. The text and shape should not stay on the screen after the animation is over. Can this animation be made to play quickly, let's say in half a second for the text transformation?",
        "answer": "\\n from manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{x} e^{y^2} dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to y first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\left[ \\frac{e^{y^2}}{2y} \\right]_{0}^{x} dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for impossibility of inner integral\n        explanation2 = Text(\"This integral cannot be expressed in elementary functions\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Numerical solution prompt\n        numerical_solution_prompt = Text(\"We shall evaluate it numerically\", font_size=24).to_edge(DOWN)\n        self.play(Write(numerical_solution_prompt))\n        self.wait(2)\n\n        # Numerical integral presentation\n        numerical_integral = MathTex(r\"\\approx \\text{numerical value}\")\n        self.play(ReplacementTransform(inner_integral, numerical_integral))\n        self.wait(1)"
    },
    {
        "query": "Could you create an animation where a text saying \"ClockwiseTransform\" appears and moves upwards, followed by a transformation of a square into a star, with everything happening in a rapid motion, and then both the square and the star disappear from the screen?",
        "answer": "\\n from manim import *\n\nclass CircumscribeExample(Scene):\n    def construct(self):\n        square = Square()\n        self.add(square)\n\n        text_inside = Text(\"Inside\").move_to(square.get_center())\n        self.add(text_inside)\n\n        self.play(Circumscribe(square, color=BLUE))\n        self.wait(0.5)\n\n        text_outside = Text(\"Outside\").shift(DOWN*2)\n        self.add(text_outside)\n\n        self.play(Circumscribe(text_outside, FadeOut, shape=Rectangle, fade_out=True, color=RED))\n        self.wait(0.5)"
    },
    {
        "query": "I would like to create an animation where a text saying \"CounterclockwiseTransform\" appears and moves upward, followed by the transformation of a square into a star shape, but the transformation should happen in a counterclockwise rotation rather than the default clockwise motion. After the transformation, both the text and the shapes should disappear from the view. Can you make this with smooth and quick transitions?",
        "answer": "\\n from manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Display the problem of definite integral\n        problem = MathTex(r\"\\int_0^1 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration process\n        explanation1 = Text(\"Evaluate using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the power rule of integration\n        integral_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1}\")\n        self.play(Write(integral_rule))\n        self.wait(2)\n\n        # Calculating the integral\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{3+1} \\Bigg|_0^1\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for the definite integral evaluation\n        explanation2 = Text(\"Evaluate at the bounds:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution with bounds evaluated\n        final_solution = MathTex(r\"= \\frac{1}{4} - 0\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= \\frac{1}{4}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the simplified final solution\n        self.play(Write(simplified_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where the phrase \"CyclicReplace\" appears at the top of the screen, and below it, there are a series of geometric shapes\u2014a square, a star, a circle, and a triangle\u2014arranged side by side. After they appear, I want them to undergo a transformation where each shape shifts into the place of the next one in the sequence cyclically. Once this transformation is complete, all the shapes should disappear from the screen. Can we make this animation in a simple and visually appealing way?",
        "answer": "\\n from manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_TEAL_COLOR = \"#5adbad\"\nLIGHT_PINK_COLOR = \"#f5a3c7\"\nLIGHT_BROWN_COLOR = \"#cdab7e\"\nDARK_TEAL_COLOR = \"#3c787e\"\nDARK_PINK_COLOR = \"#8c4351\"\nDARK_BROWN_COLOR = \"#5a4634\"\n\nclass SimplePieChart(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        data = [35, 25, 40]\n        colors = [LIGHT_TEAL_COLOR, LIGHT_PINK_COLOR, LIGHT_BROWN_COLOR]\n        legend_labels = [\"Teal Product\", \"Pink Product\", \"Brown Product\"]\n        pie_chart = PieChart(\n            data,\n            radius=2,\n            colors=colors,\n            start_angle=PI/2,\n            stroke_width=0,\n            slice_colors=colors\n        )\n\n        # Create legends\n        legends = VGroup()\n        for i, label in enumerate(legend_labels):\n            legend = Legend(\n                color=colors[i],\n                label=label,\n                label_constructor=Text,\n                label_scale=0.6,\n                size=0.2\n            )\n            legends.add(legend)\n        legends.arrange(DOWN, aligned_edge=LEFT, buff=0.5)\n        legends.move_to(RIGHT * 4)\n\n        # Adding percentage texts inside the pie chart\n        for slice_, value in zip(pie_chart.slice, data):\n            percentage = (value / sum(data)) * 100\n            slice_.add(Text(f\"{percentage:.1f}%\", font_size=36, color=BACKGROUND_COLOR).move_to(slice_.get_center()))\n\n        # Initial animations\n        self.play(FadeIn(pie_chart), FadeIn(legends))\n        self.wait(1)\n\n        # Highlight each section\n        for i in range(len(data)):\n            slice_ = pie_chart.slice[i]\n            legends[i].set_color(DARK_TEAL_COLOR if i == 0 else DARK_PINK_COLOR if i == 1 else DARK_BROWN_COLOR)\n            self.play(slice_.animate.scale(1.1))\n            self.wait(0.5)\n            self.play(slice_.animate.scale(1/1.1))\n            self.wait(0.5)\n            legends[i].set_color(colors[i])\n\n        self.wait(2)\n\n        # Remove pie chart and legends\n        self.play(FadeOut(pie_chart), FadeOut(legends))\n        self.wait(0.4)"
    },
    {
        "query": "I'd like to create an animation where a piece of text transforms into the phrase \"FadeToColor\" and then moves upwards. Following that, I want a red square to appear and then seamlessly change its color to yellow before disappearing from the screen. Can you show me how to do this with an animation tool?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-1, 5],\n            y_range=[-1, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes and labels\n        labels = axes.get_axis_labels(x_label='x', y_label='f(x)')\n\n        # The graph\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        area = axes.get_area(graph, x_range=(0,2), color=GREY, opacity=0.5)\n\n        # Displaying everything\n        self.play(Create(axes), Write(labels))\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Show the area under the graph\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Show the integral representation\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        integral.to_edge(UP)\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Solve the integral on screen\n        solution = MathTex(r\"= \\left[\\frac{x^3}{3}\\right]_0^2\", r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        solution.next_to(integral, DOWN)\n        self.play(Write(solution))\n        self.wait(2)\n\n        # Fade everything out\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(labels), FadeOut(graph_label), FadeOut(area), FadeOut(integral), FadeOut(solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where a text saying \"FadeTransform\" moves upwards on the screen and then transitions into a blue square. Next, I want to see the blue square smoothly transform into a yellow star. After the transformation, both the square and the star should disappear. The initial movement of the text should be quick, lasting only half a second. Can you help me with that?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Rotating\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(Rotating(square))\n            self.wait(0.5)\n            self.remove(square)"
    },
    {
        "query": "I'd like to create an animation where a piece of text saying \"MoveToTarget\" moves upward, and then a circle shifts from the left side of the screen to the right side and then disappears. The text movement should happen faster than the circle's movement. How can this be done in a simple way using animations?",
        "answer": "\\n from manim import Scene, Create\nfrom manim_ml.neural_network import ConvolutionalLayer, PoolingLayer, NeuralNetworkMobject\n\nclass ConvolutionalNetworkScene(Scene):\n    def construct(self):\n        layers = [\n            ConvolutionalLayer(num_feature_maps=6, kernel_shape=(3, 3)),\n            PoolingLayer(),\n            ConvolutionalLayer(num_feature_maps=16, kernel_shape=(3, 3)),\n            PoolingLayer(),\n        ]\n        conv_net = NeuralNetworkMobject(layers=layers)\n        self.play(Create(conv_net))\n        self.wait()"
    },
    {
        "query": "I would like to create an educational animation that starts with a piece of text that says \"ReplacementTransform\" which moves upwards on the screen, and then I want to see a circle on the left side of the screen transform into a square on the right side of the screen. Can the circle-to-square transformation be quick, and after the transformation is complete, can both shapes disappear from the view?",
        "answer": "\\n from manim import *\n\nclass CalculusTheoremScene(Scene):\n    def construct(self):\n        # Displaying the theorem\n        theorem = MathTex(r\"\\frac{d}{dx}\\left(\\int_a^x f(t)dt\\right) = f(x)\")\n        self.play(Write(theorem))\n        self.wait(1)\n\n        # Explanation for the Fundamental Theorem of Calculus\n        explanation1 = Text(\"Fundamental Theorem of Calculus, Part 1\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Showing differentiation step\n        differentiate_step = MathTex(r\"f(x) = \\frac{d}{dx}F(x)\")\n        self.play(ReplacementTransform(theorem, differentiate_step))\n        self.wait(1)\n\n        # Explanation for continuous function\n        explanation2 = Text(\"f(x) must be continuous on [a, b]\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final note\n        final_note = MathTex(r\"\\text{where } F(x) \\text{ is an antiderivative of } f(x)\")\n        self.play(Write(final_note.next_to(differentiate_step, DOWN)))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude by rewriting the theorem for emphasis\n        self.play(Write(theorem))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation using simple geometric shapes that starts with a text message moving upwards, then a circle appearing on the screen, which transforms into a red square that moves downwards and to the right, then the square shifts right, rotates slightly, and finally reverts back to a circle in its original position? Also, can you make sure that there's a brief pause after the circle appears and again after it rotates, with the entire sequence of events happening quickly?",
        "answer": "\\n from manim import *\nimport pkg_resources\n\nversion_num = \"0.1.1\"\n\n\nclass Ball(LabeledDot):\n    CONFIG = {\"radius\": 0.4, \"fill_opacity\": 1, \"color\": BLUE}\n\n    def __init__(self, lable=r\"\\alpha\", **kwargs):\n        LabeledDot.__init__(self, lable, **kwargs)\n        self.velocity = np.array((2, 1.5, 0))\n\n    def get_top(self):\n        return self.get_center()[1] + self.radius\n\n    def get_bottom(self):\n        return self.get_center()[1] - self.radius\n\n    def get_right_edge(self):\n        return self.get_center()[0] + self.radius\n\n    def get_left_edge(self):\n        return self.get_center()[0] - self.radius\n\n\nclass Box(Rectangle):\n    def __init__(self, **kwargs):\n        Rectangle.__init__(self, height=6, width=8, color=GREEN_C, **kwargs)  # Edges\n        self.top = 0.5 * self.height\n        self.bottom = -0.5 * self.height\n        self.right_edge = 0.5 * self.width\n        self.left_edge = -0.5 * self.width\n\n\nclass TwitterScene(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        version = Tex(f\"v{version_num}\").to_corner(UR).set_color(BLACK)\n        self.add(version)\n\n        box = Box()\n        ball = Ball(lable=Text(\"v0.1.1\").scale(0.3))\n        self.add(box)\n        self.play(Write(ball))\n\n        def update_ball(ball, dt):\n            ball.acceleration = np.array((0, -5, 0))\n            ball.velocity = ball.velocity + ball.acceleration * dt\n            ball.shift(ball.velocity * dt)  # Bounce off ground and roof\n            if ball.get_bottom() <= box.bottom or ball.get_top() >= box.top:\n                ball.velocity[1] = -ball.velocity[1]\n            # Bounce off walls\n            if (\n                ball.get_left_edge() <= box.left_edge\n                or ball.get_right_edge() >= box.right_edge\n            ):\n                ball.velocity[0] = -ball.velocity[0]\n\n        ball.add_updater(update_ball)\n        self.add(ball)\n\n        ball2 = Ball(lable=r\"\\Psi\")\n        self.play(Write(ball2))\n        ball2.add_updater(update_ball)\n\n        ball3 = Ball(lable=r\"\\alpha\")\n        self.play(Write(ball3))\n        ball3.add_updater(update_ball)\n\n        ball4 = Ball(lable=r\"\\lambda\")\n        self.play(Write(ball4))\n        ball4.add_updater(update_ball)\n\n        self.wait(3)\n        cu1 = Cutout(\n            box,\n            ball,\n            ball2,\n            ball3,\n            ball4,\n            fill_opacity=0.2,\n            color=GREY,\n            stroke_color=RED,\n        )\n        self.add(cu1)\n        cu1_small = cu1.copy().scale(0.3).to_edge(RIGHT).shift(2 * UP)\n        self.play(Transform(cu1, cu1_small))\n\n        cu2 = Cutout(\n            box,\n            ball,\n            ball2,\n            ball3,\n            ball4,\n            fill_opacity=0.2,\n            color=GREY,\n            stroke_color=RED,\n        )\n        self.add(cu2)\n        cu2_small = cu2.copy().scale(0.3).to_edge(RIGHT)\n        self.play(Transform(cu2, cu2_small))\n\n        self.wait()\n        #\n        banner = ManimBanner(dark_theme=False).scale(0.3).to_corner(DR)\n        self.play(*[FadeOut(x) for x in self.mobjects], FadeIn(banner), run_time=2.5)\n        self.play(banner.expand())\n        self.wait()"
    },
    {
        "query": "Could you show me a simple animation where a piece of text saying \"ScaleInPlace\" appears and moves upward, then a square doubles in size, but without changing its position, and finally the square disappears?",
        "answer": "\\n from manim import *\n\nclass ChemicalBond(Scene):\n    def construct(self):\n        # Create a hydrogen atom\n        hydrogen = self.create_atom(\"H\", WHITE, 0.2, font_size=24)\n        # Create a chlorine atom\n        chlorine = self.create_atom(\"Cl\", GREEN, 0.25, font_size=24)\n        # Arrange the atoms in space\n        hydrogen.next_to(chlorine, LEFT, buff=1.5)\n        # Create a bond between atoms\n        bond = Line(hydrogen.get_right(), chlorine.get_left(), color=GREY)\n\n        # Group the atoms and the bond\n        molecule = VGroup(hydrogen, chlorine, bond)\n\n        # Show the molecule components with some animations\n        self.play(FadeIn(hydrogen), FadeIn(chlorine), GrowFromCenter(bond))\n        self.wait(1)\n\n        # Move the entire molecule to the center of the scene\n        self.play(molecule.animate.move_to(ORIGIN))\n        self.wait(1)\n\n    def create_atom(self, element_symbol, color, radius, font_size=20):\n        atom = Circle(radius=radius, color=color)\n        atom.set_stroke(color=color, width=2)\n        atom.set_fill(color, opacity=0.5)\n\n        symbol = Tex(element_symbol, color=color, font_size=font_size)\n        \n        return VGroup(atom, symbol)"
    },
    {
        "query": "I would like to see an animation where text transforms into the phrase \"ShrinkToCenter\" and moves upward on the screen, followed by a square shape that appears and then shrinks to its center and disappears. The entire sequence should be quite fast, particularly the text transformation, which should only take half a second. Can you create this animation for me?",
        "answer": "\\n from manim import *\n\nclass TaylorSeriesExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"f(x) = e^x\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for Taylor series expansion\n        explanation1 = Text(\"Let's expand using Taylor series around x=0\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Taylor series expansion\n        taylor_expansion = MathTex(r\"e^x = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots\")\n        self.play(Write(taylor_expansion))\n        self.wait(2)\n\n        # Display a finite number of terms\n        finite_terms = MathTex(r\"e^x \\approx 1 + x + \\frac{x^2}{2} + \\frac{x^3}{6}\")\n        self.play(ReplacementTransform(taylor_expansion.copy(), finite_terms))\n        self.wait(1)\n\n        # Explanation for truncating the series\n        explanation2 = Text(\"This is a 3rd-degree polynomial approximation\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clear the scene and show only the approximation\n        self.clear()\n        self.wait(1)\n        self.play(Write(finite_terms))\n        self.wait(1)\n        self.play(FadeOut(finite_terms))\n        self.wait(1)\n\n        # Show the radius of convergence\n        radius_explanation = Text(\"The radius of convergence for the Taylor series of e^x is \\(\\infty\\).\", font_size=24)\n        self.play(Write(radius_explanation))\n        self.wait(1)\n        self.play(FadeOut(radius_explanation))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation where a piece of text saying \"tom marvolo riddle\" transitions into \"lord voldemort\" with a sweeping motion, and before this transformation, another text reading \"TransformMatchingShapes\" moves upwards on the screen? Additionally, the initial text \"tom marvolo riddle\" should appear through a writing animation, and after the transformation, both texts disappear from the screen.",
        "answer": "\\n from manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nLIGHT_YELLOW_COLOR = \"#f9e24c\"\nAQUA_BLUE_COLOR = \"#16b0b5\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nORANGE_COLOR = \"#fc5922\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nDARK_PURPLE_COLOR = \"#5157b9\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\ndef MathOperation(path, expression_text):\n    image = ImageMobject(path)\n    expression = Tex(expression_text, color=BLACK)\n    expression.scale(1.8)\n    group = Group(image, expression)\n    group.arrange(RIGHT, buff=0.25)\n\n    return group\n\ndef LetterOperation(expression, expression_result):\n    inner_group = Group(\n        Tex(expression, color=TEXT_COLOR).scale(1.8),\n        Tex(expression_result, color=TEXT_COLOR).scale(1.8),\n    ).arrange(DOWN, buff=0.8)\n    box = DashedVMobject(\n        SurroundingRectangle(inner_group, color=AQUA_BLUE_COLOR, buff=0.5),\n        num_dashes=25,\n        dashed_ratio=0.7\n    )\n    outer_group = Group(\n        box,\n        inner_group\n    )\n\n    return outer_group\n\nclass AlgebraWithLetters(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        operation_1 = LetterOperation(\"x + 3 = 5\", \"x = 2\")\n        operation_2 = LetterOperation(\"9 - d = 2\", \"d = 7\")\n        operation_3 = LetterOperation(\"2 . a = 6\", \"a = 3\")\n        Group(\n            operation_1, \n            operation_2, \n            operation_3\n        ).arrange(DOWN, buff=1)\n        \n        self.play(SpinInFromNothing(operation_1), run_time=0.7)\n        self.wait(3)\n        self.play(SpinInFromNothing(operation_2), run_time=0.7)\n        self.wait(3)\n        self.play(SpinInFromNothing(operation_3), run_time=0.7)\n        self.wait(4)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.5)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "I would like to create an animated video that starts with a mathematical equation a^2 + b^2 = c^2 that transforms into the equation a^2 - c^2 = -b^2. I want the animation to be quick, with the transformation clearly showing each term in the equation moving to its new position, ideally in an arc motion, and the entire sequence to take place in just a few seconds. The final equations should briefly appear on the screen and then disappear. Can you do that?",
        "answer": "\\n from manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"Integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and the final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"The triple integral value is 1/8\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)"
    },
    {
        "query": "I would like to create an animation where a text label moves up on the screen and then a circle appears. The circle should move up, then down, then left, and finally right. Each movement should be quick, taking only half a second, and after the movements, I'd like the circle to disappear. Can you describe how this animation would look using the ManimCE animation library?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 4],\n            y_range=[0, 8],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Define the function and get its graph\n        f = lambda x: x**2\n        graph = axes.plot(f, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        \n        # Mark the area under the curve\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.5)\n        \n        # Display everything\n        self.play(Create(axes), Write(graph_label))\n        self.wait(1)\n        self.play(Create(graph))\n        self.wait(1)\n        self.play(FadeIn(area, scale=0.5))\n        self.wait(2)"
    },
    {
        "query": "Can you create a simple animation where text changes to read \"animate.set_fill\" and moves up, followed by a red square that appears and then disappears?",
        "answer": "\\n from manim import *\n\nclass EulerFormulaExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"e^{ix} = \\cos(x) + i\\sin(x)\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for Euler's formula\n        explanation = Text(\"Euler's formula relates complex exponentials to trigonometric functions\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Transform the formula to its real and imaginary parts\n        real_part = MathTex(r\"\\cos(x) = \\Re\\{e^{ix}\\}\")\n        imaginary_part = MathTex(r\"\\sin(x) = \\Im\\{e^{ix}\\}\")\n        self.play(Transform(problem, real_part))\n        self.wait(1)\n        self.play(Transform(problem, imaginary_part))\n        self.wait(1)\n\n        # Applying Euler's formula in polar form\n        euler_polar = MathTex(r\"e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)\")\n        self.play(ReplacementTransform(problem, euler_polar))\n        self.wait(1)\n\n        # Show polar representation\n        point = Dot(radius=0.1).move_to(RIGHT)\n        circle = Circle(radius=1).move_to(ORIGIN)\n        line = DashedLine(ORIGIN, point)\n        angle = Angle(ORIGIN, point, radius=0.5, other_angle=False)\n\n        polar_form = VGroup(circle, line, angle, point)\n        polar_form_label = MathTex(r\"\\theta\").move_to(0.3*UP + 0.2*RIGHT)\n        \n        self.play(FadeIn(polar_form), FadeIn(polar_form_label))\n        self.wait(2)\n\n        # Clear the scene and conclude with the original problem\n        self.clear()\n        self.wait(1)\n        self.play(Write(problem))\n        self.wait(1)"
    },
    {
        "query": "How can I create a simple animation where a triangle rotates a full 180 degrees and then disappears from the scene, and also include a piece of text that moves upwards and transforms into a different text saying \"animate.rotate\"?",
        "answer": "\\n from manim import *\n\nclass SecondExample(Scene):\n    def construct(self):\n        red_triangle = Triangle(color=RED, fill_opacity=0.7)\n        yellow_hexagon = RegularPolygon(6, color=YELLOW, fill_opacity=0.6)\n        yellow_hexagon.next_to(red_triangle, LEFT, buff=0.5)\n        self.play(GrowFromCenter(red_triangle))\n        self.play(FadeIn(yellow_hexagon))\n        self.wait(1)"
    },
    {
        "query": "\"Can you create a simple animation where a text morphs and moves upward, followed by a square that increases in size by 1.5 times and then disappears?\"",
        "answer": "\\n from manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nDARK_GREEN_COLOR = \"#2a623d\"\n\nclass PieChartExample(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n        \n        data = [30, 15, 55]\n        pie_chart = PieChart(\n            values=data,\n            colors=[LIGHT_BLUE_COLOR, LIGHT_PURPLE_COLOR, DARK_GREEN_COLOR],\n            labels=[\"Sky\", \"Lavender\", \"Forest\"],\n            start_angle=90,\n            radius=2,\n            slice_colors_opacity=0.7\n        )\n\n        legends = [\n            LegendEntry(text=\"Sky\", color=LIGHT_BLUE_COLOR),\n            LegendEntry(text=\"Lavender\", color=LIGHT_PURPLE_COLOR),\n            LegendEntry(text=\"Forest\", color=DARK_GREEN_COLOR)\n        ]\n        legend = Legend(legends, dot_scale=1)\n        legend.shift(3 * DOWN)\n\n        title = Text(\"Favorite Colors Survey Results\", color=TEXT_COLOR)\n        title.to_edge(UP)\n\n        self.add(pie_chart, legend, title)"
    },
    {
        "query": "How can I create an animation where text is transformed to display \"animate.rotate_about_origin\" and moves upwards, followed by a star rotating about the origin and then disappearing from the screen?",
        "answer": "\\n BACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\nSAND_COLOR = \"#b3a77d\"\nBROWN_COLOR = \"#b85842\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\ndef SpeechBubble(**kwargs):\n    gp = VGroup(\n        RoundedRectangle(width=4.5, height=2.5),\n        Polygram([\n            [-4.5/3, -2.5 + 0.55, 0], \n            [-4.5/2.8, -2.5 + 1.25, 0], \n            [-4.5/2.8 + 1, -2.5 + 1.25, 0]\n        ])\n    )\n\n    return Union(*gp, **kwargs)\n\nclass QuestionTwo(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        animal = ImageMobject(\"./assets/Asset 1.png\")\n        animal.scale(0.4)\n        animal.shift(9 * LEFT)\n        speech = SpeechBubble(color=TEXT_COLOR, fill_opacity=0.8, fill_color=BROWN_COLOR)\n        speech.shift(3 * UP + 8 * LEFT)\n        text = VGroup(\n            Text(\"O n\u00famero seis\", color=WHITE),\n            Text(\"\u00e9 primo?\", color=WHITE)\n        )\n        text.scale(0.6)\n        text.arrange(DOWN, buff=0.1)\n        text.shift(3 * UP + 8 * LEFT)\n\n        self.play(\n            animal.animate.shift(7 * RIGHT), \n            speech.animate.shift(9 * RIGHT), \n            text.animate.shift(9 * RIGHT), \n            run_time=0.7\n        )\n        self.wait(2)\n        self.play(Group(*self.mobjects).animate.shift(9 * LEFT), run_time=0.7)\n        self.remove(*self.mobjects)"
    },
    {
        "query": "I would like to create an educational video where I'd like to show an animation of a piece of text that says \"animate.rotate\" elevating and settling at the top of the frame quickly, followed by a triangle appearing and then rotating a full 180 degrees before disappearing from the view. Can you help me design this simple animation sequence?",
        "answer": "\\n         self.play(Transform(text,Text(\"AddTextLetterByLetter\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Here is a text\")\n        self.play(AddTextLetterByLetter(some_text))\n        self.play(Transform(text,Text(\"RemoveTextLetterByLetter\").shift(UP*2.5)), run_time=0.5)\n        self.play(RemoveTextLetterByLetter(some_text))"
    },
    {
        "query": "I'd like to create an animation where a piece of text saying \"animate.flip\" moves and settles at the top of the screen, and then a triangle appears, flips over, and then disappears. Can this be done quickly, maybe in half a second?",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.move_to\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            self.play(circle.animate.move_to(RIGHT+UP))\n            self.remove(circle)"
    },
    {
        "query": "How can I create an animation using simple shapes where a circle stretches vertically and then disappears, with additional text animation that shifts upwards and changes to say \"animate.stretch\"?",
        "answer": "\\n from manim import *\n\nclass DerivativeConcept(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3], y_range=[-1, 5])\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        tangent_line = axes.plot(lambda x: 2*x - 1, color=GREEN)\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n\n        explanation = Tex(\"The derivative of $x^2$ is $2x$. Here is the tangent when $x=1$.\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n\n        dot = Dot(color=RED).move_to(axes.c2p(1, 1**2))\n        tangent = TangentLine(graph, alpha=0.5, length=4, line_color=GREEN)\n        self.play(Create(dot), Create(tangent))\n        self.wait(2)"
    },
    {
        "query": "How can I create a simple animation using an open-source tool where a piece of text and a square both appear to wag or shake and then the square disappears?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function to integrate\n        function_text = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_text))\n        self.wait(1)\n        \n        # Showing the area under the curve to be calculated\n        area_problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Transform(function_text, area_problem))\n        self.wait(2)\n        \n        # Drawing the curve and shaded area\n        axes = Axes(x_range=[0, 3], y_range=[0, 5], axis_config={\"include_tip\": True})\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        shaded_area = axes.get_area(graph, x_range=(0, 2), color=BLUE, opacity=0.5)\n        \n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n        self.play(FadeIn(shaded_area))\n        self.wait(1)\n        \n        # Integration calculation\n        integration_result = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(ReplacementTransform(area_problem, integration_result))\n        self.wait(2)\n        \n        # Final solution\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(integration_result.copy(), final_solution))\n        self.wait(1)\n        \n        # Clear the scene and conclude\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(shaded_area))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation using a simple animation tool where a piece of text reading \"animate.pose_at_angle\" moves upwards on the screen and immediately after a square comes into view and seems to strike a pose at an angle. Then, the square should disappear from the screen. I want the whole animation to be brief, with the text transformation taking just half a second. Can you guide me through the steps to accomplish this?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Define the function and the area under the curve\n        func = lambda x: x**2\n        area = self.get_area_under_curve(func, x_min=0, x_max=2)\n\n        # Display the function's graph\n        graph = self.get_graph(func, color=WHITE)\n        graph_label = self.get_graph_label(graph, label='x^2')\n\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Fill the area under the graph\n        self.play(Write(area))\n        self.wait(1)\n\n        # Calculation of the integral value\n        integral_value = MathTex(r\"\\int_0^2 x^2 \\,dx = \", r\"\\frac{2^3}{3}\", \"- \\frac{0^3}{3} = \", r\"\\frac{8}{3}\").next_to(area, DOWN)\n        self.play(Write(integral_value))\n        self.wait(2)\n\n        # Show the final result\n        result = MathTex(r\"The area under x^2 from 0 to 2 is \", r\"\\frac{8}{3}\").next_to(integral_value, DOWN)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(*[FadeOut(mob)for mob in self.mobjects])\n        self.wait(1)\n\n    def get_area_under_curve(self, func, x_min, x_max):\n        return self.get_riemann_rectangles(func, x_min=x_min, x_max=x_max, dx=0.1, input_sample_type='center', stroke_width=0.3)\n\n    def get_graph(self, function, **kwargs):\n        return FunctionGraph(function, **kwargs)"
    },
    {
        "query": "I want to create an animation where a piece of text first transforms into the phrase \"animate.center\", moves up a little bit, and then a square appears on the left side of the screen. After that, I would like the square to move to the center of the screen and then disappear. I'm looking for the animation to be quick, taking only half a second for the text transformation and the usual animation time for the square's centering. Can you help me write the script for this animation sequence using ManimCE?",
        "answer": "\\n from manim import *\n\nclass LissajousCurve(Scene):\n    def construct(self):\n        path = ParametricFunction(\n            lambda t: np.array([\n                2 * np.sin(3 * t + PI/2),\n                2 * np.sin(2 * t),\n                0\n            ]),\n            t_range=[0, TAU],\n            color=RED\n        )\n\n        dot = Dot(color=RED).move_to(path.get_start())\n        self.add(dot, path)\n        self.play(MoveAlongPath(dot, path), run_time=5, rate_func=linear)\n        self.wait(1)"
    },
    {
        "query": "How can I create an animation using a math animation engine where a piece of text transforms into another with the words \"animate.align_on_border\" and then shifts upwards, followed by a square shape animating to align itself with the top border and then disappearing from the scene?",
        "answer": "\\n from manim import *\n\nclass CalculateEulerNumber(Scene):\n    def construct(self):\n        # Describe the problem\n        problem_text = MathTex(r\"e = \\lim_{{n \\to \\infty}} \\left(1 + \\frac{1}{n}\\right)^n\")\n        self.play(Write(problem_text))\n        self.wait(1)\n\n        # Introduce the approximation concept\n        approximation_explanation = Text(\n            \"Approximate with a large value of n\", font_size=24\n        ).to_edge(UP)\n        self.play(Write(approximation_explanation))\n        self.wait(2)\n\n        # Show the approximation with a tangible n\n        approximation = MathTex(r\"\\approx \\left(1 + \\frac{1}{100}\\right)^{100}\")\n        self.play(ReplacementTransform(problem_text.copy(), approximation))\n        self.wait(1)\n\n        # Calculate the numerical approximation\n        numerical_result_text = Text(\"Numerical result\", font_size=24).to_edge(UP)\n        self.play(Transform(approximation_explanation, numerical_result_text))\n        self.wait(2)\n\n        # Show numerical result\n        numerical_result = MathTex(fr\"\\approx {round((1 + 1/100)**100, 8)}\")\n        self.play(ReplacementTransform(approximation, numerical_result))\n        self.wait(1)\n\n        # Clear the scene and show the calculated value of e\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(f\"Calculated value of e: {round((1 + 1/100)**100, 8)}\", font_size=24)))\n        self.wait(1)"
    },
    {
        "query": "I would like to create an animation where text morphs into the phrase \"animate.to_corner\" and moves up, and then a square slides to a corner of the screen. After the square reaches the corner, I want it to disappear. Can you provide me with a step-by-step guide to do this using a simple animation tool?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function\n        function_tex = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Display the area problem\n        area_problem = MathTex(r\"\\text{Area under } f(x) \\text{ from } x = 1 \\text{ to } x = 2\")\n        area_problem.next_to(function_tex, DOWN)\n        self.play(Write(area_problem))\n        self.wait(2)\n\n        # Graph the function\n        axes = Axes(\n            x_range=[0, 3, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n        graph = axes.plot(lambda x: x ** 2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n        \n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(2)\n\n        # Fill the area under the curve\n        area = axes.get_area(graph, x_range=(1, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Calculate the definite integral\n        integral = MathTex(r\"\\int_1^2 x^2 \\,dx\")\n        integral_result = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^2\")\n        integral_solution = MathTex(r\"= \\left.\\frac{1}{3}x^3\\right|_1^2\")\n        integral_value = MathTex(r\"= \\frac{1}{3}(2^3) - \\frac{1}{3}(1^3)\")\n        final_answer = MathTex(r\"= \\frac{7}{3}\")\n\n        integral.to_edge(UP)\n        integral_result.next_to(integral, DOWN)\n        integral_solution.next_to(integral_result, DOWN)\n        integral_value.next_to(integral_solution, DOWN)\n        final_answer.next_to(integral_value, DOWN)\n\n        self.play(Write(integral))\n        self.wait(2)\n\n        self.play(Write(integral_result))\n        self.wait(2)\n\n        self.play(Write(integral_solution))\n        self.wait(2)\n\n        self.play(Write(integral_value))\n        self.wait(2)\n\n        self.play(Write(final_answer))\n        self.wait(2)"
    },
    {
        "query": "How can I create a simple animation where a piece of text saying \"animate.to_edge\" moves upwards and then immediately afterwards a square moves to the edge of the screen, then disappears, using ManimCE?",
        "answer": "\\n from manim import Scene, Create\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, RNNLayer\n\nclass RNNVisualization(Scene):\n    def construct(self):\n        rnn = NeuralNetwork([\n            RNNLayer(5, 3, activation_function=\"tanh\"),\n            FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n        ],\n        layer_spacing=0.4,\n        neural_network_spacing=0.5\n        )\n        self.add(rnn)\n        rnn_update = rnn.make_forward_pass_animation()\n        self.play(Create(rnn_update))"
    },
    {
        "query": "I would like to create an animation where a text element moves to a new location at the top of the screen very quickly. After that, I want to see a dot appear at a specific point towards the top right of the screen and a square towards the left side. The square should then move and position itself next to the dot. Finally, both the dot and the square should disappear from the screen.",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the integral problem\n        problem = MathTex(r\"\\int_1^3\", r\"x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integral setup\n        explanation1 = Text(\"Find the area under x squared from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Illustrate integration process\n        integration_step = MathTex(r\"= \\left[ \\frac{1}{3} x^3 \\right]_1^3\")\n        self.play(ReplacementTransform(problem[1].copy(), integration_step, run_time=2))\n        self.wait(1)\n\n        # Changing the explanation\n        explanation2 = Text(\"Apply the power rule for integration\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Present the final solution\n        final_solution = MathTex(r\"= \\frac{1}{3} (3^3) - \\frac{1}{3} (1^3)\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        # Cleaning the scene and putting the final answer\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)"
    },
    {
        "query": "Could you show me an animation where a piece of text transforms into a message that reads \"animate.scale_to_fit_width\" and moves to the top of the screen, followed by a square that grows to fit a specific width on the screen, and then both the text and the square disappear?",
        "answer": "\\n from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        # Write an initial text\n        text_begin = Text(\"Let's learn about quadratic functions!\", font_size=36)\n        self.play(Write(text_begin))\n        self.wait(2)\n\n        # Creating the quadratic formula\n        quadratic_formula = MathTex(r\"f(x) = ax^2 + bx + c\")\n        self.play(Transform(text_begin, quadratic_formula))\n        self.wait(2)\n\n        # Showing an example quadratic function\n        example_quadratic = MathTex(r\"f(x) = 2x^2 - 3x + 1\")\n        self.play(ReplacementTransform(quadratic_formula, example_quadratic))\n        self.wait(2)\n\n        # Showing the graph of the function\n        axes = Axes(x_range=[-3, 3], y_range=[-5, 5])\n        quadratic_graph = axes.plot(lambda x: 2*x**2 - 3*x + 1, color=BLUE)\n        graph_label = axes.get_graph_label(quadratic_graph, label='f(x)')\n\n        self.play(Write(axes), Write(quadratic_graph), Write(graph_label))\n        self.wait(2)\n\n        # Pointing out the vertex of the parabola\n        vertex_dot = Dot(axes.i2gp(-3/4, quadratic_graph), color=YELLOW)\n        vertex_annotation = Text(\"Vertex\").next_to(vertex_dot, UP)\n        self.play(FadeIn(vertex_dot), Write(vertex_annotation))\n        self.wait(2)\n\n        # Clear the scene and display the vertex formula\n        self.clear()\n        vertex_formula = MathTex(r\"Vertex\\, (h, k) = \\left( -\\frac{b}{2a}, f\\left(-\\frac{b}{2a}\\right) \\right)\")\n        self.play(Write(vertex_formula))\n        self.wait(2)"
    },
    {
        "query": "I want to create an instructional animation that shows a square changing its width on the screen. First, there should be a text label \"animate.stretch_to_fit_width\" that appears at the top. Then a square should be shown that stretches out horizontally to become five times its original width. After the square has stretched, it should disappear from the scene. Can the animation also be quick, perhaps half a second for each action?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Defining the function and its graph\n        f = lambda x: x**2\n        function_graph = axes.plot(f, color=GREEN)\n        label = axes.get_graph_label(function_graph, label='x^2')\n\n        # Setting up the area to find the definite integral\n        area = axes.get_area(function_graph, x_range=(0,2), color=GREY, opacity=0.5)\n        \n        # Title for the graph\n        title = Title(\"Area under the curve y = x^2 from 0 to 2\")\n\n        # Animation sequence\n        # Add axes and the function graph\n        self.play(Create(axes), Write(function_graph), Write(label))\n        self.wait(1)\n        \n        # Add title\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Shade the area under the curve to represent the integral\n        self.play(Write(area))\n        self.wait(2)\n        \n        # Add area calculation\n        area_calculation = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(area_calculation.to_corner(UL)))\n        self.wait(1)\n\n        # Show final value after calculating the integral\n        integral_value = MathTex(r\"=\\left[\\frac{x^3}{3}\\right]_0^2\", r\"=\\frac{2^3}{3} - \\frac{0^3}{3}\", r\"=\\frac{8}{3}\")\n        self.play(Write(integral_value.next_to(area_calculation, DOWN)))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integral_value.to_edge(UP)))\n        self.wait(1)"
    },
    {
        "query": "I want to create an animation where a line of text is transformed to display the message \"animate.scale_to_fit_height\" and shifts upward on the screen. Then right after that, a square should appear and grow in size to fit a certain height, then disappear. The text transformation should happen quickly, within half a second.",
        "answer": "\\n from manim import *\n\nclass CircularWaveExampleScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        wave = CircularWave(\n            point=ORIGIN,  # Origin of the waves\n            color=BLUE,\n            wave_radius=0.5,\n            num_waves=5\n        )\n        self.add(wave)\n        wave.start_wave()\n        self.wait(2)\n        wave.stop_wave()\n        self.wait(1)"
    },
    {
        "query": "How can I create an animation where a text saying \"animate.stretch_to_fit_height\" moves upwards and then a square stretches to three times its original height and remove the square afterward using an animation tool for mathematical videos?",
        "answer": "\\n         self.play(Transform(text,Text(\"ApplyWave\").shift(UP*2.5)), run_time=0.5)\n        some_text = Text(\"Mathematical Animations\")\n        self.play(ApplyWave(some_text))\n        self.play(ApplyWave(some_text, direction=RIGHT))\n        self.remove(some_text)"
    },
    {
        "query": "I would like to create an animation where a piece of text transforms into a different text that then moves to the top of the screen, followed by a square appearing that shifts its position to the left side of the screen, and finally, I want the square to disappear. Can you provide me with a step-by-step guide on achieving this with a simple animation tool?",
        "answer": "\\n from manim import *\n\nclass TrigonometricIntegration(Scene):\n    def construct(self):\n        # Display the integral to be solved\n        integral = MathTex(r\"\\int \\sin(x) \\cos(x) \\, dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Mentioning the substitution method\n        substitution = Text(\"Using the substitution method\", font_size=24)\n        substitution.to_edge(UP)\n        self.play(Write(substitution))\n        self.wait(2)\n\n        # Choosing substitution\n        substitution_eq = MathTex(r\"u = \\sin(x), \\quad du = \\cos(x) dx\")\n        self.play(Write(substitution_eq))\n        self.wait(2)\n\n        # Rewriting the integral with u\n        rewritten_integral = MathTex(r\"= \\int u \\, du\")\n        self.play(ReplacementTransform(integral.copy(), rewritten_integral))\n        self.wait(1)\n\n        # Integration result\n        solved_integral = MathTex(r\"= \\frac{{u^2}}{2} + C\")\n        self.play(Write(solved_integral))\n        self.wait(2)\n\n        # Back-substitution\n        back_substitution = MathTex(r\"= \\frac{{\\sin^2(x)}}{2} + C\")\n        self.play(ReplacementTransform(solved_integral, back_substitution))\n        self.wait(1)\n\n        # Clear the scene and display only the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(back_substitution))\n        self.wait(1)"
    },
    {
        "query": "I want to create an animation where a text smoothly transitions to read \"animate.set_x\" and moves up on the screen, followed by a square moving to the left side of the screen and then disappearing altogether. Can you write a script for that animation using ManimCE?",
        "answer": "\\n from manim import *\n\nclass BasicDerivative(Scene):\n    def construct(self):\n        # Displaying the function\n        function = MathTex(r\"f(x) = x^3 + 3x^2 + 2x\")\n        self.play(Write(function))\n        self.wait(1)\n\n        # Explanation for the derivative rule\n        explanation1 = Text(\"Applying the power rule of differentiation:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\frac{d}{dx} x^n = n x^{n-1}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the differentiation step\n        derivative1 = MathTex(r\"= 3 x^{3-1} + 2 \\cdot 3 x^{2-1} + 2\")\n        self.play(ReplacementTransform(function.copy(), derivative1))\n        self.wait(1)\n\n        # Explanation for simplifying the expression\n        explanation2 = Text(\"Simplify the expression\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final derivative\n        final_derivative = MathTex(r\"= 3x^2 + 6x + 2\")\n        self.play(ReplacementTransform(derivative1, final_derivative))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final derivative\n        self.play(Write(final_derivative))\n        self.wait(1)"
    },
    {
        "query": "I want to create an animation where a line of text transforms into another line that reads \"animate.set_y\" and moves upwards, followed by a square appearing and then moving downwards before disappearing from the screen. Can you provide a simple script for this using an animation library that's suitable for mathematical or educational videos?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        # Display the function\n        function_tex = MathTex(r\"f(x) = e^{-x^2}\")\n        self.play(Write(function_tex))\n        self.wait(1)\n\n        # Explanation for the definite integral over an interval\n        explanation1 = Text(\"Area under the curve from x = -1 to x = 1\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Setting up the definite integral\n        definite_integral = MathTex(r\"\\int_{-1}^1 e^{-x^2} \\,dx\")\n        self.play(ReplacementTransform(function_tex.copy(), definite_integral))\n        self.wait(1)\n\n        # Explanation of the numerical method since the integral is non-elementary\n        explanation2 = Text(\"Use numerical methods to estimate the area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Numerical solution placeholder (Value would typically be procured by numerical algorithm)\n        numerical_solution = MathTex(r\"\\approx 1.493\")\n        self.play(ReplacementTransform(definite_integral, numerical_solution))\n        self.wait(1)\n\n        # Clear the scene and show the final estimated area\n        self.clear()\n        self.wait(1)\n        self.play(Write(numerical_solution))\n        self.wait(1)"
    },
    {
        "query": "How can I create an animation where text transitions to a new message with an upward shift, followed by a circle with a star inside it expanding so that the star moves away from the center, and then both shapes disappear from the screen?",
        "answer": "\\n class ScalingAndRotating(Scene):\n    def construct(self):\n        s = Square()\n        self.add(s)\n        self.play(Scale(s, 2), Rotate(s, PI / 2), run_time=3)"
    },
    {
        "query": "I would like to create an animated video where a piece of text moves upwards and at the same time I want to see a circle move diagonally upwards to the right and then have the circle disappear from the screen. Can you help me make this animation?",
        "answer": "\\n from manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the first order ODE\n        ode = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explanation for moving y term\n        move_y_explanation = Text(\"Rearrange terms\", font_size=24).to_edge(UP)\n        self.play(Write(move_y_explanation))\n        self.wait(2)\n\n        # Rearranged ODE step\n        rearranged_ode = MathTex(r\"y' = 3y\")\n        self.play(ReplacementTransform(ode, rearranged_ode))\n        self.wait(1)\n\n        # Explanation for integrating factor\n        integrating_factor_explanation = Text(\"Use an integrating factor\", font_size=24).to_edge(UP)\n        self.play(Transform(move_y_explanation, integrating_factor_explanation))\n        self.wait(2)\n\n        # Integrating factor and transformed ODE\n        integrating_factor = MathTex(r\"\\mu(x) = e^{3x}\")\n        transformed_ode = MathTex(r\"\\frac{d}{dx}( ye^{3x} ) = 0\")\n        self.play(\n            ReplacementTransform(rearranged_ode, transformed_ode),\n            Write(integrating_factor)\n        )\n        self.wait(1)\n\n        # Explanation for general solution\n        general_solution_explanation = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(move_y_explanation, general_solution_explanation))\n        self.wait(2)\n\n        # Writing the general solution\n        general_solution = MathTex(r\"y = C e^{-3x}\")\n        self.play(Transform(transformed_ode, general_solution))\n        self.wait(1)\n        \n        # Conclusion statement\n        conclusion = Text(\"The function y(x) solves the ODE\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final general solution only\n        self.play(Write(general_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation where a text appears and moves upwards, followed by transforming a circle into a star on screen while both shapes are initially positioned on opposite sides of the screen, and eventually both shapes disappear?",
        "answer": "\\n from manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        title = Text(\"Wave Equation in One Dimension\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        wave_eq.next_to(title, DOWN)\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Describing the wave equation\n        description = Text(\"Describes the propagation of waves, like sound and light.\", font_size=24)\n        description.to_edge(UP)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Displaying the general solution to the wave equation\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        general_solution.next_to(wave_eq, DOWN)\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(2)\n\n        # Explanation for the general solution\n        explanation = Text(\"The general solution consists of two functions representing waves travelling in opposite directions.\", font_size=24)\n        explanation.to_edge(UP)\n        self.play(Transform(description, explanation))\n        self.wait(3)\n\n        # Specific Example of a sine wave solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        specific_solution.next_to(general_solution, DOWN)\n        self.play(Write(specific_solution))\n        self.wait(2)\n\n        # Explanation for specific sine wave solution\n        explanation2 = Text(\"An example of a specific solution: a sine wave with amplitude A, wavenumber k, and angular frequency \u03c9.\", font_size=24)\n        explanation2.to_edge(UP)\n        self.play(Transform(description, explanation2))\n        self.wait(3)\n\n        # Clear the scene and conclude with the sine wave solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_solution))\n        self.wait(2)"
    },
    {
        "query": "Can you create an animation where a text label saying \"animate.surround\" moves upwards, followed by a circle moving from the left side of the screen to surround a star on the right side of the screen, and then both the circle and star disappear?",
        "answer": "\\n from manim import *\n\nclass SolarSystem(ThreeDScene):\n    def construct(self):\n        sun = Sphere(radius=1, color=YELLOW)\n        earth = Sphere(radius=0.3, color=BLUE).move_to(RIGHT * 5)\n        moon = Sphere(radius=0.1, color=GREY_B).move_to(earth.get_center() + RIGHT)\n\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.play(FadeIn(sun), FadeIn(earth), FadeIn(moon))\n        self.wait(1)\n\n        earth_orbit = Circle(radius=5, color=WHITE)\n        moon_orbit = Circle(radius=1, color=LIGHT_GREY).move_to(earth.get_center())\n        self.play(ShowCreation(earth_orbit), ShowCreation(moon_orbit))\n        self.wait(1)\n\n        self.play(Rotating(earth, about_point=sun.get_center(), rate_func=linear, run_time=8, rate=PI/5),\n                  Rotating(moon, about_point=earth.get_center(), rate_func=linear, run_time=2, rate=PI))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(8)\n        self.stop_ambient_camera_rotation()\n        self.wait(2)"
    },
    {
        "query": "How can I create an animation where a text element that says \"animate.add_background_rectangle\" moves upwards and becomes followed by a square that appears with a background rectangle, and then the square disappears?",
        "answer": "\\n from manim import *\n\nclass FourierTransformVisualization(Scene):\n    def construct(self):\n        function = Tex(\"f(x) = sin(x)\")\n        self.play(Write(function))\n        self.wait(1)\n\n        transform = Tex(\"Fourier Transform of $f(x)$\")\n        self.play(Transform(function, transform))\n        self.wait(1)\n\n        explanation = Tex(\"This transforms the function into frequency space.\")\n        self.play(Write(explanation))\n        self.wait(1)"
    },
    {
        "query": "How would I create a simple animation using a Python library where a square appears on the screen, changes its color to blue, and then disappears? I'd like the animation to start by displaying the text \"animate.set_color\" and moving it up on the screen. The transformation of the text should be quick, maybe taking half a second.",
        "answer": "\\n class Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ClockwiseTransform\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            star = Star()\n            self.play(ClockwiseTransform(square,star))\n            self.remove(square,star)"
    },
    {
        "query": "How can I create an animation using Manim where a colored text saying \"animate.set_color_by_gradient\" appears and shifts upwards, followed by a square that changes its color through a gradient from red to blue to yellow, and then disappears?",
        "answer": "\\n from manim import *\n\nclass HarmonicSeriesConvergence(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for divergence of the harmonic series\n        explanation1 = Text(\"The harmonic series diverges\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Divergence proof setup\n        divergence_proof = MathTex(r\"= 1 + \\frac{1}{2} + \\frac{1}{3} + \\frac{1}{4} + \\dots\")\n        self.play(ReplacementTransform(problem, divergence_proof))\n        self.wait(2)\n\n        # Grouping terms for comparison\n        comparison_step = MathTex(r\"> 1 + \\frac{1}{2} + \\left(\\frac{1}{4} + \\frac{1}{4}\\right) + \\left(\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8}\\right) + \\dots\")\n        self.play(ReplacementTransform(divergence_proof, comparison_step))\n        self.wait(2)\n\n        # Explanation for comparison with series that sums to infinity\n        explanation2 = Text(\"Each group in parentheses sums to at least 1/2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Simplifying the comparison\n        simplified_comparison = MathTex(r\"> 1 + \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} + \\dots\")\n        self.play(ReplacementTransform(comparison_step, simplified_comparison))\n        self.wait(2)\n\n        # Conclusion that the series diverges\n        conclusion = Text(\"Hence, the harmonic series diverges\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(explanation1))\n        self.wait(1)"
    },
    {
        "query": "How can I create an animation where a piece of text transforms and moves up, followed by a red square that changes its color to green and then disappears?",
        "answer": "\\n from manim import *\n\nclass CubicFunctionGraph(Scene):\n    def construct(self):\n        # Display the cubic function\n        cubic_eq = MathTex(r\"f(x) = x^3 - 3x^2 + x\")\n        self.play(Write(cubic_eq))\n        self.wait(1)\n\n        # Draw the graph of the cubic function\n        graph = self.get_graph(lambda x: x**3 - 3*x**2 + x, color=BLUE)\n        self.play(Create(graph))\n        self.wait(1)\n\n        # Label the graph\n        graph_label = Tex(\"Graph of $f(x)$\").next_to(graph, UP)\n        self.play(Write(graph_label))\n        self.wait(1)\n\n        # Discuss critical points\n        explanation = Text(\"Critical points where $f'(x)=0$\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Derivative of cubic function\n        derivative = MathTex(r\"f'(x) = 3x^2 - 6x + 1\")\n        self.play(Transform(cubic_eq, derivative))\n        self.wait(1)\n\n        # Mark critical points on graph\n        critical_points = VGroup(\n            Dot().move_to(self.coords_to_point(1, -2)),\n            Dot().move_to(self.coords_to_point(2, 2))\n        )\n        self.play(Create(critical_points))\n        self.wait(1)\n\n        # Function for cubic equation's derivative\n        def cubic_derivative(x):\n            return 3*x**2 - 6*x + 1\n\n        # Graph the derivative\n        derivative_graph = self.get_graph(cubic_derivative, x_min=-1, x_max=3, color=RED)\n        self.play(Create(derivative_graph))\n        self.wait(1)\n\n        # Conclusion\n        self.clear()\n        conclusion = Text(\"Visualizing a Cubic Function and its Derivative\", font_size=30)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n    # Utility function to get a graph from a function\n    def get_graph(self, function, **kwargs):\n        return FunctionGraph(function, **kwargs)"
    },
    {
        "query": "I'd like to create an animation where text appears and then moves upwards while fading out quickly, followed by a solid red square that fades away into nothingness. Can you write a script to produce this effect?",
        "answer": "\\n from manim import *\n\nclass CircleToSquare(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        circle.set_fill(PINK, opacity=0.5)\n\n        # Create a square\n        square = Square()\n        square.set_fill(YELLOW, opacity=0.5)\n\n        # Display the circle\n        self.play(Create(circle))\n        self.wait(1)\n\n        # Transform the circle into the square\n        self.play(Transform(circle, square))\n        self.wait(1)\n\n        # Annotate the transformation\n        transform_text = Text(\"A circle transforms into a square\", font_size=24).to_edge(DOWN)\n        self.play(Write(transform_text))\n        self.wait(2)\n\n        # Fade out the square and the text\n        self.play(FadeOut(square), FadeOut(transform_text))\n        self.wait(1)"
    },
    {
        "query": "I'd like an animation where a text phrase moves up the screen, followed by a red circle appearing on the left and a square appearing on the right. Then, I'd like the square's color to transform and match the color of the circle. Afterward, both the circle and square should disappear from the screen. Can you create this animation for me?",
        "answer": "\\n from manim import *\n\nclass GeometricSeriesExample(Scene):\n    def construct(self):\n        # Display the sum of geometric series\n        sum_of_series = MathTex(r\"S = a + ar + ar^2 + ar^3 + \\cdots\")\n        self.play(Write(sum_of_series))\n        self.wait(1)\n\n        # Explanation for the formula of a finite geometric series\n        explanation1 = Text(\"Formula of a finite geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Finite geometric series formula\n        finite_formula = MathTex(r\"S_n = \\frac{a(1-r^n)}{1-r}\")\n        self.play(ReplacementTransform(sum_of_series.copy(), finite_formula))\n        self.wait(1)\n\n        # Explanation for the sum of an infinite geometric series\n        explanation2 = Text(\"For |r| < 1, the sum of an infinite series\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Infinite geometric series formula\n        infinite_formula = MathTex(r\"S_\\infty = \\frac{a}{1-r}\")\n        self.play(ReplacementTransform(finite_formula, infinite_formula))\n        self.wait(1)\n\n        # Evaluate an example of an infinite geometric series\n        example_evaluation = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}}\")\n        self.play(ReplacementTransform(infinite_formula, example_evaluation))\n        self.wait(1)\n\n        # Solution to the example\n        solution_to_example = MathTex(r\"S = 2\")\n        self.play(ReplacementTransform(example_evaluation, solution_to_example))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_to_example))\n        self.wait(1)"
    },
    {
        "query": "Can you create an animation where a text appears and shifts upwards, followed by a square changing its size to match the dimension of a larger circle and then both the square and the circle disappear?",
        "answer": "\\n class FirstExample(Scene):\n    def construct(self):\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        green_square = Square(color=GREEN, fill_opacity=0.8)\n        green_square.next_to(blue_circle, RIGHT)\n        self.add(blue_circle, green_square)"
    },
    {
        "query": "I'd like to create an animation where a text element transitions into another text that says \"animate.match_width\" and moves upwards, followed by a square changing its width to match the width of a larger circle, with both the square and the circle then disappearing. Can this be done in a simple and visually appealing way, possibly with a quick transition for the text and a smooth transformation for the square?",
        "answer": "\\n from manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_0^4 (4 - x^2) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the area under the curve\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the graph\n        graph = FunctionGraph(lambda x: 4 - x**2, x_range=[0, 4])\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Shade the area under the curve\n        area = graph.get_area(x_range=(0, 4), color=BLUE, opacity=0.3)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Integration to find the area\n        integration_step = MathTex(r\"= [4x - \\frac{x^3}{3}]_0^4\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        # Explanation for the definite integral\n        explanation2 = Text(\"Evaluate the definite integral for the area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= (4 \\cdot 4) - \\frac{4^3}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\frac{32}{3}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer.move_to(ORIGIN)))\n        self.wait(1)"
    },
    {
        "query": "\"Can you create an animation where a square changes its height to match the height of a circle, and both shapes are initially displayed on the screen? Also, before the transformation starts, I would like a text animation that moves the words 'animate.match_height' to a position above the shapes. The shapes should then disappear from the screen after the transformation. And could you make the whole animation happen quite quickly, let's say in half a second?\"",
        "answer": "\\n from manim import *\n\nclass ExampleScene(Scene):\n    def construct(self):\n        grid = self.create_grid(4, 4, 0.5)\n        self.add(grid)\n        self.wait(1)\n        \n        path = self.create_complex_path()\n        electron_particle = electron()\n        self.play(*move_along_complex_path(electron_particle, [2, 4], path, 0.5))\n        self.wait(1)\n        \n        self.play(FadeOut(grid), FadeOut(electron_particle))\n        \n    def create_grid(self, rows: int, cols: int, cell_size: float) -> VGroup:\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                cell = Square(side_length=cell_size)\n                cell.move_to(np.array([j * cell_size, i * cell_size, 0]))\n                grid.add(cell)\n        grid.move_to(ORIGIN)\n        return grid\n    \n    def create_complex_path(self):\n        points = [UP * 2, UP + RIGHT, ORIGIN, DOWN + LEFT * 2, DOWN * 2 + RIGHT * 2]\n        return points"
    },
    {
        "query": "I would like to create an animation where a text changes to say \"animate.match_x\" and moves upward, followed by a scene where a dot and a star appear on the screen. Then the star should move horizontally to align its x-position with the dot. After that, both the star and the dot should be removed from the scene. Can this be done in a way that the text transformation happens quickly, say in half a second?",
        "answer": "\\n from manim import *\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.layers.flatten import FlattenLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nimport numpy as np\nfrom PIL import Image\n\nROOT_DIR = Path(__file__).parents[2]\n\n# Manim rendering options\nconfig.pixel_height = 1080\nconfig.pixel_width = 1920\nconfig.frame_height = 6.0\nconfig.frame_width = 8.0\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        # Load an image and convert to numpy array\n        image_path = ROOT_DIR / \"assets/mnist/digit.png\"\n        image = Image.open(image_path)\n        numpy_image = np.array(image)\n        \n        # Define the neural network structure\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image, height=2.5),\n            Convolutional2DLayer(\n                num_feature_maps=32,\n                feature_map_size=6,\n                filter_size=5,\n                padding=2,\n                padding_dashed=True\n            ),\n            MaxPooling2DLayer(pool_size=2),\n            Convolutional2DLayer(\n                num_feature_maps=64,\n                feature_map_size=6,\n                filter_size=5,\n                padding=2,\n                padding_dashed=True\n            ),\n            MaxPooling2DLayer(pool_size=2),\n            FlattenLayer(),\n            FeedForwardLayer(120),\n            FeedForwardLayer(84),\n            FeedForwardLayer(10),\n        ], layer_spacing=0.3)\n\n        # Add the neural network model to the scene\n        self.add(nn)\n        \n        # Create and play the forward pass animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(forward_pass, run_time=15)\n        self.wait(2)"
    },
    {
        "query": "How can I create an animation using ManimCE where text transforms into the message \"animate.match_y\" and moves upward, followed by a dot and a star appearing on the screen, with the star moving vertically to align with the dot on the y-axis before both the star and the dot disappear?",
        "answer": "\\n from manim import * \nimport numpy as np\n\nclass AllMObjects(ThreeDScene):\n    def construct(self):\n        t = Text(\"Manim Objects\")\n        t.shift(UP*2.5)\n\n        mobject_list = [\n            # Geometry\n            Annulus(),\n            AnnularSector(),\n            Arc(),\n            Circle(),\n            Dot(),\n            Ellipse(),\n            Arrow(),\n            Vector(),\n            Square(),\n            Star(),\n            Triangle(),\n            ArrowCircleTip(),\n            \n            # Frame\n            FullScreenRectangle(),\n            ScreenRectangle(),\n\n            # Graph\n            Graph(vertices=(1,2,3,4,5), edges=[(1,2), (1,3), (4,2), (3,5), (1,5)]),\n\n            # Graphing\n            Axes(),\n            ComplexPlane(),\n            CoordinateSystem(),\n            NumberPlane(),\n            FunctionGraph(lambda x: (-1.0*x)**2),\n            NumberLine(),\n            BarChart(values=[1,2,3,4,5]),\n\n            # Logo\n            ManimBanner(),\n\n            # Matrix\n            DecimalMatrix([[1.0,2.0],[3.0,4.0]]),\n            IntegerMatrix([[1,2],[3,4]]),\n            Matrix([[1,2],[3,4]]),\n            MobjectMatrix([[Circle(),Square()],[Star(),Triangle()]]),\n\n            # Table\n            DecimalTable([[1,2,3,4], [5,6,7,8]], row_labels=[Text(\"Row 1\"), Text(\"Row 2\")]),\n            MathTable([[\"+\", 0, 5, 10],[0, 0, 5, 10],[2, 2, 7, 12],[4, 4, 9, 14]],include_outer_lines=True),\n            MobjectTable( [ [Circle(), Square()] , [Triangle(), Star()] ] ),\n\n            # Text\n            Code(file_name=\"dummy.py\", language=\"Python\"),\n            DecimalNumber(5.5),\n            Integer(5),\n            BulletedList(\"Apple\", \"Pear\", \"Grape\"),\n            MathTex(r\"\\frac{a}{b} = x^{2}\"),\n            SingleStringMathTex(r\"\\frac{a}{b} = x^{2}\"),\n            Tex(\"Hello World\"),\n            Title(\"Here Is a Ttitle\"),\n            MarkupText('<span foreground=\"red\" size=\"x-large\">Red text</span> is <i>fire</i>!\"'),\n            Paragraph('There once was a man', 'that lived in a van', 'with only one right hand'),\n            Text(\"Here is Text\"),\n\n            # Types\n            Point(color=RED),\n            PointCloudDot(),\n        ]\n\n        mobject_list_3d = [\n            ThreeDAxes(),\n            Dodecahedron(),\n            Icosahedron(),\n            Octahedron(),\n            Tetrahedron(edge_length=2),\n            Arrow3D(),\n            Cone(),\n            Cube(),\n            Cylinder(),\n            Dot3D(),\n            Line3D(start=np.array([-3,-3,-3]), end=np.array([3,3,3])),\n            Prism(),\n            Sphere(),\n            Torus(),\n        ]\n\n        # Show all 2D MObjects\n        self.add(t)\n        self.wait(0.2)\n        for mobj in mobject_list:\n            try:\n                self.play(Transform(t,Text(mobj.name).shift(UP*2.5)), FadeIn(mobj), run_time=0.5)\n                self.wait(0.5)\n                self.remove(mobj)\n            except:\n                continue\n        \n        # Show all 3D MObjects\n        self.play(Transform(t,Text(\"Looking at 3D Mobjects...\").shift(UP*2.5)), run_time=0.5)\n        self.wait(1)\n\n        self.begin_3dillusion_camera_rotation(rate=4)\n        self.wait(2)\n\n        for mobj in mobject_list_3d:\n            try:\n                self.play(Transform(t,Text(mobj.name).shift(UP*2.5)), FadeIn(mobj), run_time=0.5)\n                self.wait(1)\n                self.remove(mobj)\n            except:\n                continue\n        self.play(FadeOut(t))\n        self.wait()"
    },
    {
        "query": "I would like to create an animation where the text \"animate.arrange\" is transformed and shifted upwards at the beginning, run over a short period. Then, I want three numbers \"3\", \"1\", \"2\" to appear on the screen from left to right respectively, but not in numerical order. After a brief pause, these numbers should rearrange themselves with equal spacing between them, in ascending order. Once this rearrangement is complete, all elements should disappear from the screen. Can you create this animation sequence?",
        "answer": "\\n from manim import *\n\nclass HappyNewYearScene(Scene):\n    def construct(self):\n        background = Rectangle(width=FRAME_WIDTH, height=FRAME_HEIGHT)\n        background.set_fill(BLACK, 1)\n        self.add(background)\n\n        message = Text(\"Happy New Year 2023!\", font_size=72)\n        message.set_color_by_gradient([BLUE, GREEN])\n        self.play(Write(message))\n        self.wait(1)\n\n        fireworks = VGroup()\n\n        for i in range(5):\n            color = random.choice([RED, YELLOW, GREEN, BLUE, PURPLE])\n            firework = self.create_firework(3 * RIGHT * np.random.uniform(-3, 3)\n                + 3 * UP * np.random.uniform(0, 2), color)\n            fireworks.add(firework)\n\n        self.play(LaggedStart(*fireworks, lag_ratio=0.7))\n        self.wait(2)\n\n    def create_firework(self, position, color):\n        sparks = VGroup()\n        for _ in range(20):\n            angle = TAU * np.random.random()\n            velocity = np.random.uniform(0.5, 3)\n            spark = ParametricFunction(\n                lambda t: position + np.array([np.cos(angle), np.sin(angle), 0]) * t * velocity,\n                t_min=0,\n                t_max=0.5,\n                fill_opacity=0,\n            ).set_color(color).set_stroke(width=0.2)\n            sparks.add(spark)\n\n        return Write(sparks, run_time=1, rate_func=linear)"
    },
    {
        "query": "I would like to create an animation with the following sequence:\n1. Start with a phrase \"animate.arrange_in_grid\" appearing and moving to the top of the screen.\n2. Then, have six squares appear in a horizontal row with some space between them.\n3. After a short pause, I want the squares to rearrange themselves into a grid of two rows with less space between the squares.\n4. Finally, I want the squares to disappear from the screen. \n\nCould you provide me with an animation that incorporates these elements?",
        "answer": "\\n import numpy as np\nfrom PIL import Image\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, Convolutional2DLayer, ImageLayer\n\nimage = Image.open(\"digit.jpeg\") # You will need to download an image of a digit. \nnumpy_image = np.asarray(image)\n\nnn = NeuralNetwork([\n        ImageLayer(numpy_image, height=1.5),\n        Convolutional2DLayer(1, 7, 3, filter_spacing=0.32), # Note the default stride is 1. \n        Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n        Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n        FeedForwardLayer(3),\n        FeedForwardLayer(3),\n    ],\n    layer_spacing=0.25,\n)\n# Center the neural network\nnn.move_to(ORIGIN)\nself.add(nn)\n# Make a forward pass animation\nforward_pass = nn.make_forward_pass_animation()"
    },
    {
        "query": "Create a new scene named 'MyScene'.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pass"
    },
    {
        "query": "Add a circle with radius 2 and center at the origin to the scene.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2, color=BLUE) self.add(circle)"
    },
    {
        "query": "Create a text object saying 'Hello, World!' and add it to the scene.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): text = Text('Hello, World!') self.add(text)"
    },
    {
        "query": "Animate the circle to move 2 units to the right in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2, color=BLUE) self.add(circle) self.play(circle.animate.shift(RIGHT * 2), run_time=2)"
    },
    {
        "query": "Create a square with side length 3 and add it to the scene.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=3, color=RED) self.add(square)"
    },
    {
        "query": "Scale the square by a factor of 2 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=3, color=RED) self.add(square) self.play(square.animate.scale(2), run_time=1.5)"
    },
    {
        "query": "Create a triangle with vertices at (-1, 0), (1, 0), and (0, 2) and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1, 0), (1, 0), (0, 2), color=YELLOW) self.add(triangle)"
    },
    {
        "query": "Rotate the triangle by 90 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1, 0), (1, 0), (0, 2), color=YELLOW) self.add(triangle) self.play(triangle.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (0, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2, color=BLUE) rectangle.move_to((0, 0)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'A' at the coordinates (-2, 1) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2, color=BLUE) label = Text('A').move_to((-2, 1)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a square with side length 2 and a circle with radius 1 to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2, color=RED) circle = Circle(radius=1, color=GREEN) vgroup = VGroup(square, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2, color=RED) circle = Circle(radius=1, color=GREEN) vgroup = VGroup(square, circle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create an axis with x-axis ranging from -5 to 5 and y-axis ranging from -3 to 3.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): axes = Axes(x_range=(-5, 5), y_range=(-3, 3)) self.add(axes)"
    },
    {
        "query": "Plot a graph of the function y = sin(x) on the axis.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): axes = Axes(x_range=(-5, 5), y_range=(-1, 1)) graph = axes.get_graph(lambda x: np.sin(x), color=PURPLE) self.add(axes, graph)"
    },
    {
        "query": "Add an arrow pointing downwards at the coordinates (-2, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): arrow = Arrow(start=(-2, 1), end=(-2, 0), color=YELLOW) self.add(arrow)"
    },
    {
        "query": "Create an ellipse with major axis 2 and minor axis 1.5.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): ellipse = Ellipse(width=2, height=1.5, color=ORANGE) self.add(ellipse)"
    },
    {
        "query": "Rotate the ellipse clockwise by 90 degrees over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): ellipse = Ellipse(width=2, height=1.5, color=ORANGE) self.add(ellipse) self.play(ellipse.animate.rotate(90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a regular pentagon with side length 2.5 and color it cyan.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2.5, color=CYAN) self.add(pentagon)"
    },
    {
        "query": "Move the pentagon to the right by 3 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2.5, color=CYAN) self.add(pentagon) self.play(pentagon.animate.shift(RIGHT * 3), run_time=2)"
    },
    {
        "query": "Create a regular hexagon with side length 2.5 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2.5, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Rotate the hexagon by 120 degrees counterclockwise over 3 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2.5, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.rotate(-120 * DEGREES), run_time=3)"
    },
    {
        "query": "Create a text object saying 'Hello, Manim!' and position it at (0, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): text = Text('Hello, Manim!') text.move_to((0, 2)) self.add(text)"
    },
    {
        "query": "Add an arc with radius 3 and angle of 90 degrees centered at (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): arc = Arc(radius=3, start_angle=0, angle=90 * DEGREES, color=PINK) arc.move_to((-1, -1)) self.add(arc)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a point at coordinates (1, 1) and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((1, 1), color=RED) self.add(point)"
    },
    {
        "query": "Create a bezier curve with control points (-1, 0), (0, 2), and (2, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): points = [(-1, 0), (0, 2), (2, 1)] curve = VMobject() curve.set_points_smoothly(points) self.add(curve)"
    },
    {
        "query": "Create a regular octagon with side length 2 and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=PURPLE) self.add(octagon)"
    },
    {
        "query": "Scale the octagon by a factor of 1.5 in 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=PURPLE) self.add(octagon) self.play(octagon.animate.scale(1.5), run_time=1)"
    },
    {
        "query": "Create a line segment connecting points (-1, -1) and (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (2, 2)) self.add(line)"
    },
    {
        "query": "Create a triangle with vertices at (-1, 0), (1, 0), and (0, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1, 0), (1, 0), (0, 2)) self.add(triangle)"
    },
    {
        "query": "Rotate the triangle by 90 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1, 0), (1, 0), (0, 2)) self.add(triangle) self.play(triangle.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (0, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((0, 0)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'A' at the coordinates (-2, 1) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) label = Text('A').move_to((-2, 1)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a square with side length 2 and a circle with radius 1 to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2) circle = Circle(radius=1) vgroup = VGroup(square, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2) circle = Circle(radius=1) vgroup = VGroup(square, circle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular pentagon with side length 2.5 and color it cyan.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2.5, color=CYAN) self.add(pentagon)"
    },
    {
        "query": "Move the pentagon to the right by 3 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2.5, color=CYAN) self.add(pentagon) self.play(pentagon.animate.shift(RIGHT * 3), run_time=2)"
    },
    {
        "query": "Create a regular hexagon with side length 2.5 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2.5, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Rotate the hexagon by 120 degrees counterclockwise over 3 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2.5, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.rotate(-120 * DEGREES), run_time=3)"
    },
    {
        "query": "Create a text object saying 'Hello, Manim!' and position it at (0, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): text = Text('Hello, Manim!') text.move_to((0, 2)) self.add(text)"
    },
    {
        "query": "Add an arc with radius 3 and angle of 90 degrees centered at (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): arc = Arc(radius=3, start_angle=0, angle=90 * DEGREES) arc.move_to((-1, -1)) self.add(arc)"
    },
    {
        "query": "Create a triangle with vertices at (-1, 0), (1, 0), and (0, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1, 0), (1, 0), (0, 2)) self.add(triangle)"
    },
    {
        "query": "Rotate the triangle by 90 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1, 0), (1, 0), (0, 2)) self.add(triangle) self.play(triangle.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular decagon with side length 2 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=PINK) self.add(decagon)"
    },
    {
        "query": "Scale the decagon by a factor of 2 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=PINK) self.add(decagon) self.play(decagon.animate.scale(2), run_time=1.5)"
    },
    {
        "query": "Create a line segment connecting points (-2, 1) and (2, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 1), (2, -1)) self.add(line)"
    },
    {
        "query": "Create a VGroup and add a triangle and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1, 0), (1, 0), (0, 2)) circle = Circle(radius=1) vgroup = VGroup(triangle, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 30 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1, 0), (1, 0), (0, 2)) circle = Circle(radius=1) vgroup = VGroup(triangle, circle) self.add(vgroup) self.play(vgroup.animate.rotate(30 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular nonagon with side length 2 and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=TEAL) self.add(nonagon)"
    },
    {
        "query": "Move the nonagon to the right by 3 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=TEAL) self.add(nonagon) self.play(nonagon.animate.shift(RIGHT * 3), run_time=2)"
    },
    {
        "query": "Create an arc with radius 2, angle of 180 degrees, and centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): arc = Arc(radius=2, start_angle=0, angle=180 * DEGREES) arc.move_to((1, 1)) self.add(arc)"
    },
    {
        "query": "Create a trapezoid with base lengths 2 and 4, and height 3.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): trapezoid = Polygon((-2, -1.5), (2, -1.5), (1, 1.5), (-1, 1.5)) self.add(trapezoid)"
    },
    {
        "query": "Create a point at coordinates (2, 2) and color it blue.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((2, 2), color=BLUE) self.add(point)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=ORANGE) self.add(hexagon)"
    },
    {
        "query": "Rotate the hexagon by 60 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=ORANGE) self.add(hexagon) self.play(hexagon.animate.rotate(-60 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a rectangle with width 3 and height 2, centered at (0, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=2) rectangle.move_to((0, 0)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'B' at the coordinates (2, -1) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=2) label = Text('B').move_to((2, -1)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a line segment and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 1), (2, -1)) circle = Circle(radius=1) vgroup = VGroup(line, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 1), (2, -1)) circle = Circle(radius=1) vgroup = VGroup(line, circle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular dodecagon with side length 2 and color it brown.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): dodecagon = RegularPolygon(n=12, radius=2, color=BROWN) self.add(dodecagon)"
    },
    {
        "query": "Scale the dodecagon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): dodecagon = RegularPolygon(n=12, radius=2, color=BROWN) self.add(dodecagon) self.play(dodecagon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a line segment connecting points (-1, 1) and (1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, 1), (1, -1)) self.add(line)"
    },
    {
        "query": "Create a VGroup and add a rectangle and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=2) circle = Circle(radius=1) vgroup = VGroup(rectangle, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 60 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=2) circle = Circle(radius=1) vgroup = VGroup(rectangle, circle) self.add(vgroup) self.play(vgroup.animate.rotate(60 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a regular heptagon with side length 2.5 and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2.5, color=PURPLE) self.add(heptagon)"
    },
    {
        "query": "Move the heptagon to the right by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2.5, color=PURPLE) self.add(heptagon) self.play(heptagon.animate.shift(RIGHT * 2), run_time=1)"
    },
    {
        "query": "Create an arc with radius 3, angle of 180 degrees, and centered at (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): arc = Arc(radius=3, start_angle=0, angle=180 * DEGREES) arc.move_to((-1, -1)) self.add(arc)"
    },
    {
        "query": "Create a trapezoid with base lengths 3 and 5, and height 4.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): trapezoid = Polygon((-2.5, -2), (2.5, -2), (3, 2), (-3, 2)) self.add(trapezoid)"
    },
    {
        "query": "Create a point at coordinates (0, 0) and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((0, 0), color=GREEN) self.add(point)"
    },
    {
        "query": "Create a regular octagon with side length 3 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=3, color=RED) self.add(octagon)"
    },
    {
        "query": "Rotate the octagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=3, color=RED) self.add(octagon) self.play(octagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (-1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((-1, 1)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'C' at the coordinates (0, -1) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) label = Text('C').move_to((0, -1)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a square and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2) circle = Circle(radius=1) vgroup = VGroup(square, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 30 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2) circle = Circle(radius=1) vgroup = VGroup(square, circle) vgroup.rotate(-30 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular tetragon with side length 2 and color it gray.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): tetragon = RegularPolygon(n=4, radius=2, color=GRAY) self.add(tetragon)"
    },
    {
        "query": "Move the tetragon to the right by 3 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): tetragon = RegularPolygon(n=4, radius=2, color=GRAY) self.add(tetragon) self.play(tetragon.animate.shift(RIGHT * 3), run_time=1)"
    },
    {
        "query": "Create a parallelogram with base lengths 4 and 2, and height 3.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): parallelogram = Polygon((-2, -1.5), (2, -1.5), (4, 1.5), (0, 1.5)) self.add(parallelogram)"
    },
    {
        "query": "Create a point at coordinates (1, -1) and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((1, -1), color=YELLOW) self.add(point)"
    },
    {
        "query": "Create a regular pentagon with side length 2.5 and color it cyan.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2.5, color=CYAN) self.add(pentagon)"
    },
    {
        "query": "Rotate the pentagon by 120 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2.5, color=CYAN) self.add(pentagon) self.play(pentagon.animate.rotate(-120 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a rectangle with width 5 and height 3, centered at (1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=5, height=3) rectangle.move_to((1, -1)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'D' at the coordinates (2, 1) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=5, height=3) label = Text('D').move_to((2, 1)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a triangle and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Triangle() circle = Circle(radius=1) vgroup = VGroup(triangle, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Triangle() circle = Circle(radius=1) vgroup = VGroup(triangle, circle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular nonagon with side length 3.5 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=3.5, color=PINK) self.add(nonagon)"
    },
    {
        "query": "Move the nonagon to the right by 4 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=3.5, color=PINK) self.add(nonagon) self.play(nonagon.animate.shift(RIGHT * 4), run_time=1.5)"
    },
    {
        "query": "Create a sector with radius 2, angle of 120 degrees, and centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): sector = Sector(radius=2, start_angle=0, angle=120 * DEGREES) sector.move_to((1, 1)) self.add(sector)"
    },
    {
        "query": "Create a trapezium with base lengths 2 and 4, and height 3.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): trapezium = Polygon((-2, -1.5), (2, -1.5), (4, 1.5), (-4, 1.5)) self.add(trapezium)"
    },
    {
        "query": "Create a point at coordinates (-1, 2) and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((-1, 2), color=ORANGE) self.add(point)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=TEAL) self.add(hexagon)"
    },
    {
        "query": "Rotate the hexagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=TEAL) self.add(hexagon) self.play(hexagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 3 and height 5, centered at (-2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=5) rectangle.move_to((-2, 2)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'E' at the coordinates (-1, -1) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=5) label = Text('E').move_to((-1, -1)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a line segment and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1)) circle = Circle(radius=1) vgroup = VGroup(line, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 90 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1)) circle = Circle(radius=1) vgroup = VGroup(line, circle) vgroup.rotate(-90 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular heptagon with side length 2.5 and color it lavender.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2.5, color=LAVENDER) self.add(heptagon)"
    },
    {
        "query": "Move the heptagon to the right by 3.5 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2.5, color=LAVENDER) self.add(heptagon) self.play(heptagon.animate.shift(RIGHT * 3.5), run_time=2)"
    },
    {
        "query": "Create a sector with radius 2.5, angle of 60 degrees, and centered at (-1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): sector = Sector(radius=2.5, start_angle=0, angle=60 * DEGREES) sector.move_to((-1, 1)) self.add(sector)"
    },
    {
        "query": "Create a trapezoid with base lengths 2 and 5, and height 4.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): trapezoid = Polygon((-2.5, -2), (2.5, -2), (3.5, 2), (-3.5, 2)) self.add(trapezoid)"
    },
    {
        "query": "Create a point at coordinates (2, -2) and color it magenta.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((2, -2), color=MAGENTA) self.add(point)"
    },
    {
        "query": "Create a regular octagon with side length 3 and color it brown.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=3, color=BROWN) self.add(octagon)"
    },
    {
        "query": "Rotate the octagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=3, color=BROWN) self.add(octagon) self.play(octagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (-1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((-1, 1)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'F' at the coordinates (0, -1) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) label = Text('F').move_to((0, -1)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a square and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square() circle = Circle(radius=1) vgroup = VGroup(square, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 30 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square() circle = Circle(radius=1) vgroup = VGroup(square, circle) vgroup.rotate(-30 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular nonagon with side length 2 and color it olive.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=OLIVE) self.add(nonagon)"
    },
    {
        "query": "Move the nonagon to the right by 2.5 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=OLIVE) self.add(nonagon) self.play(nonagon.animate.shift(RIGHT * 2.5), run_time=1.5)"
    },
    {
        "query": "Create a sector with radius 3, angle of 90 degrees, and centered at (0, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): sector = Sector(radius=3, start_angle=0, angle=90 * DEGREES) sector.move_to((0, 0)) self.add(sector)"
    },
    {
        "query": "Create a trapezium with base lengths 2 and 6, and height 4.5.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): trapezium = Polygon((-3, -2.25), (3, -2.25), (4, 2.25), (-4, 2.25)) self.add(trapezium)"
    },
    {
        "query": "Create a point at coordinates (-2, -2) and color it gray.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((-2, -2), color=GRAY) self.add(point)"
    },
    {
        "query": "Create a regular hexagon with side length 3 and color it maroon.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=3, color=MAROON) self.add(hexagon)"
    },
    {
        "query": "Rotate the hexagon by 45 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=3, color=MAROON) self.add(hexagon) self.play(hexagon.animate.rotate(-45 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 5 and height 2, centered at (1, -2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=5, height=2) rectangle.move_to((1, -2)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'G' at the coordinates (2, 0) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=5, height=2) label = Text('G').move_to((2, 0)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a line segment and a square to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1)) square = Square(side_length=2) vgroup = VGroup(line, square) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 60 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1)) square = Square(side_length=2) vgroup = VGroup(line, square) vgroup.rotate(-60 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular heptagon with side length 2.5 and color it navy.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2.5, color=NAVY) self.add(heptagon)"
    },
    {
        "query": "Move the heptagon to the right by 3 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2.5, color=NAVY) self.add(heptagon) self.play(heptagon.animate.shift(RIGHT * 3), run_time=1)"
    },
    {
        "query": "Create a sector with radius 2.5, angle of 120 degrees, and centered at (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): sector = Sector(radius=2.5, start_angle=0, angle=120 * DEGREES) sector.move_to((-1, -1)) self.add(sector)"
    },
    {
        "query": "Create a trapezoid with base lengths 3 and 7, and height 5.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): trapezoid = Polygon((-4, -2.5), (4, -2.5), (5, 2.5), (-5, 2.5)) self.add(trapezoid)"
    },
    {
        "query": "Create a point at coordinates (3, -3) and color it indigo.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((3, -3), color=INDIGO) self.add(point)"
    },
    {
        "query": "Create a regular octagon with side length 4 and color it aqua.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=4, color=AQUA) self.add(octagon)"
    },
    {
        "query": "Rotate the octagon by 120 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=4, color=AQUA) self.add(octagon) self.play(octagon.animate.rotate(-120 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 6 and height 3, centered at (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=6, height=3) rectangle.move_to((2, 2)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'H' at the coordinates (3, 3) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=6, height=3) label = Text('H').move_to((3, 3)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a line segment and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1)) circle = Circle(radius=1) vgroup = VGroup(line, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1)) circle = Circle(radius=1) vgroup = VGroup(line, circle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular nonagon with side length 3 and color it olive.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=3, color=OLIVE) self.add(nonagon)"
    },
    {
        "query": "Move the nonagon to the right by 4 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=3, color=OLIVE) self.add(nonagon) self.play(nonagon.animate.shift(RIGHT * 4), run_time=2)"
    },
    {
        "query": "Create a sector with radius 3, angle of 90 degrees, and centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): sector = Sector(radius=3, start_angle=0, angle=90 * DEGREES) sector.move_to((1, 1)) self.add(sector)"
    },
    {
        "query": "Create a trapezoid with base lengths 2 and 6, and height 4.5.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): trapezoid = Polygon((-3, -2.25), (3, -2.25), (4, 2.25), (-4, 2.25)) self.add(trapezoid)"
    },
    {
        "query": "Create a point at coordinates (-2, -2) and color it gray.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((-2, -2), color=GRAY) self.add(point)"
    },
    {
        "query": "Create a regular hexagon with side length 3 and color it maroon.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=3, color=MAROON) self.add(hexagon)"
    },
    {
        "query": "Rotate the hexagon by 45 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=3, color=MAROON) self.add(hexagon) self.play(hexagon.animate.rotate(-45 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 5 and height 2, centered at (1, -2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=5, height=2) rectangle.move_to((1, -2)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'I' at the coordinates (2, 0) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=5, height=2) label = Text('I').move_to((2, 0)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a square and a circle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square() circle = Circle(radius=1) vgroup = VGroup(square, circle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 30 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square() circle = Circle(radius=1) vgroup = VGroup(square, circle) vgroup.rotate(-30 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a circle with radius 2 and center at the origin.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2) self.add(circle)"
    },
    {
        "query": "Move the circle to the right by 3 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2) self.add(circle) self.play(circle.animate.shift(RIGHT * 3), run_time=1)"
    },
    {
        "query": "Create a square with side length 4 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=4, color=RED) self.add(square)"
    },
    {
        "query": "Scale the square by a factor of 2 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=4, color=RED) self.add(square) self.play(square.animate.scale(2), run_time=1.5)"
    },
    {
        "query": "Create a triangle with side lengths 3, 4, and 5.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1.5, -2), (1.5, -2), (0, 2), color=YELLOW) self.add(triangle)"
    },
    {
        "query": "Rotate the triangle by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = Polygon((-1.5, -2), (1.5, -2), (0, 2), color=YELLOW) self.add(triangle) self.play(triangle.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-2, -1) to (2, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -1), (2, 1), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment upward by 2 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -1), (2, 1), color=GREEN) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1.5)"
    },
    {
        "query": "Create a regular pentagon with side length 3.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=3, color=BLUE) self.add(pentagon)"
    },
    {
        "query": "Move the pentagon to the left by 4 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=3, color=BLUE) self.add(pentagon) self.play(pentagon.animate.shift(LEFT * 4), run_time=2)"
    },
    {
        "query": "Create an ellipse with major axis 4 and minor axis 2.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): ellipse = Ellipse(width=4, height=2, color=ORANGE) self.add(ellipse)"
    },
    {
        "query": "Scale the ellipse by a factor of 1.5 in 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): ellipse = Ellipse(width=4, height=2, color=ORANGE) self.add(ellipse) self.play(ellipse.animate.scale(1.5), run_time=1)"
    },
    {
        "query": "Create a point at coordinates (1, 1) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((1, 1), color=PURPLE) self.add(point)"
    },
    {
        "query": "Create a regular heptagon with side length 2 and color it cyan.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=CYAN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=CYAN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a rectangle with width 3 and height 6, centered at (-1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=6) rectangle.move_to((-1, 1)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'M' at the coordinates (0, 2) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=6) label = Text('M').move_to((0, 2)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a line segment and a square to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1)) square = Square() vgroup = VGroup(line, square) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1)) square = Square() vgroup = VGroup(line, square) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular octagon with side length 2 and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon)"
    },
    {
        "query": "Move the octagon upward by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon) self.play(octagon.animate.shift(UP * 3), run_time=1.5)"
    },
    {
        "query": "Create a regular nonagon with side length 3 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=3, color=PINK) self.add(nonagon)"
    },
    {
        "query": "Rotate the nonagon by 90 degrees clockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=3, color=PINK) self.add(nonagon) self.play(nonagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line from (0, 0) to (3, 4).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((0, 0), (3, 4), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line downward by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((0, 0), (3, 4), color=GREEN) self.add(line) self.play(line.animate.shift(DOWN * 2), run_time=1)"
    },
    {
        "query": "Create an equilateral triangle with side length 3 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = RegularPolygon(n=3, radius=3, color=YELLOW) self.add(triangle)"
    },
    {
        "query": "Scale the triangle by a factor of 1.5 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = RegularPolygon(n=3, radius=3, color=YELLOW) self.add(triangle) self.play(triangle.animate.scale(1.5), run_time=1.5)"
    },
    {
        "query": "Create a point at coordinates (-1, -1) and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((-1, -1), color=ORANGE) self.add(point)"
    },
    {
        "query": "Create a regular decagon with side length 2 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=GREEN) self.add(decagon)"
    },
    {
        "query": "Rotate the decagon by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=GREEN) self.add(decagon) self.play(decagon.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a rectangle with width 2 and height 4, centered at (2, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=2, height=4) rectangle.move_to((2, -1)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'N' at the coordinates (2, 3) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=2, height=4) label = Text('N').move_to((2, 3)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 90 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-90 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it violet.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=VIOLET) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the right by 3 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=VIOLET) self.add(hexagon) self.play(hexagon.animate.shift(RIGHT * 3), run_time=2)"
    },
    {
        "query": "Create a regular enneagon with side length 3 and color it brown.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): enneagon = RegularPolygon(n=9, radius=3, color=BROWN) self.add(enneagon)"
    },
    {
        "query": "Rotate the enneagon by 60 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): enneagon = RegularPolygon(n=9, radius=3, color=BROWN) self.add(enneagon) self.play(enneagon.animate.rotate(-60 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-3, -2) to (3, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, -2), (3, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment upward by 4 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, -2), (3, 2), color=GREEN) self.add(line) self.play(line.animate.shift(UP * 4), run_time=2)"
    },
    {
        "query": "Create an equilateral triangle with side length 2 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = RegularPolygon(n=3, radius=2, color=PINK) self.add(triangle)"
    },
    {
        "query": "Scale the triangle by a factor of 2 in 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = RegularPolygon(n=3, radius=2, color=PINK) self.add(triangle) self.play(triangle.animate.scale(2), run_time=1)"
    },
    {
        "query": "Create a point at coordinates (2, 2) and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((2, 2), color=TEAL) self.add(point)"
    },
    {
        "query": "Create a regular dodecagon with side length 2 and color it gray.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): dodecagon = RegularPolygon(n=12, radius=2, color=GRAY) self.add(dodecagon)"
    },
    {
        "query": "Rotate the dodecagon by 30 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): dodecagon = RegularPolygon(n=12, radius=2, color=GRAY) self.add(dodecagon) self.play(dodecagon.animate.rotate(-30 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a rectangle with width 3 and height 5, centered at (-2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=5) rectangle.move_to((-2, 2)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'O' at the coordinates (-1, -2) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=5) label = Text('O').move_to((-1, -2)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a circle, a square, and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() square = Square() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, square, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 120 degrees clockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() square = Square() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, square, triangle) vgroup.rotate(-120 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular pentadecagon with side length 2 and color it cyan.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentadecagon = RegularPolygon(n=15, radius=2, color=CYAN) self.add(pentadecagon)"
    },
    {
        "query": "Move the pentadecagon to the left by 4 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentadecagon = RegularPolygon(n=15, radius=2, color=CYAN) self.add(pentadecagon) self.play(pentadecagon.animate.shift(LEFT * 4), run_time=2)"
    },
    {
        "query": "Create a regular polygon with 20 sides, side length 2, and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=20, radius=2, color=ORANGE) self.add(polygon)"
    },
    {
        "query": "Rotate the polygon by 75 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=20, radius=2, color=ORANGE) self.add(polygon) self.play(polygon.animate.rotate(-75 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment to the right by 3 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.shift(RIGHT * 3), run_time=1)"
    },
    {
        "query": "Create an equilateral triangle with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = RegularPolygon(n=3, radius=2, color=YELLOW) self.add(triangle)"
    },
    {
        "query": "Scale the triangle by a factor of 2 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = RegularPolygon(n=3, radius=2, color=YELLOW) self.add(triangle) self.play(triangle.animate.scale(2), run_time=2)"
    },
    {
        "query": "Create a square with side length 2 and color it blue.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2, color=BLUE) self.add(square)"
    },
    {
        "query": "Move the square to the right by 3 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2, color=BLUE) self.add(square) self.play(square.animate.shift(RIGHT * 3), run_time=2)"
    },
    {
        "query": "Create a circle with radius 1.5 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=1.5, color=RED) self.add(circle)"
    },
    {
        "query": "Scale the circle by a factor of 2 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=1.5, color=RED) self.add(circle) self.play(circle.animate.scale(2), run_time=1.5)"
    },
    {
        "query": "Create a text object saying 'Hello, Manim!' and add it to the scene.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): text = Text('Hello, Manim!') self.add(text)"
    },
    {
        "query": "Fade in the text object over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): text = Text('Hello, Manim!') self.add(text) self.play(FadeIn(text), run_time=1)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2) and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a rectangle with width 3 and height 4 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=4, color=ORANGE) self.add(rectangle)"
    },
    {
        "query": "Move the rectangle downward by 2 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=4, color=ORANGE) self.add(rectangle) self.play(rectangle.animate.shift(DOWN * 2), run_time=1.5)"
    },
    {
        "query": "Create a polygon with vertices at (-2, 0), (0, 2), and (2, 0) and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = Polygon((-2, 0), (0, 2), (2, 0), color=YELLOW) self.add(polygon)"
    },
    {
        "query": "Scale the polygon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = Polygon((-2, 0), (0, 2), (2, 0), color=YELLOW) self.add(polygon) self.play(polygon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=PINK) self.add(hexagon)"
    },
    {
        "query": "Rotate the hexagon by 60 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=PINK) self.add(hexagon) self.play(hexagon.animate.rotate(60 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create an ellipse with x-radius 3 and y-radius 2 and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): ellipse = Ellipse(width=6, height=4, color=PURPLE) self.add(ellipse)"
    },
    {
        "query": "Fade out the ellipse over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): ellipse = Ellipse(width=6, height=4, color=PURPLE) self.add(ellipse) self.play(FadeOut(ellipse), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 2 and color it cyan.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=CYAN) self.add(heptagon)"
    },
    {
        "query": "Move the heptagon to the left by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=CYAN) self.add(heptagon) self.play(heptagon.animate.shift(LEFT * 3), run_time=1.5)"
    },
    {
        "query": "Create a point at coordinates (2, 2) and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): point = Dot((2, 2), color=TEAL) self.add(point)"
    },
    {
        "query": "Create a regular dodecagon with side length 2 and color it gray.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): dodecagon = RegularPolygon(n=12, radius=2, color=GRAY) self.add(dodecagon)"
    },
    {
        "query": "Rotate the dodecagon by 30 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): dodecagon = RegularPolygon(n=12, radius=2, color=GRAY) self.add(dodecagon) self.play(dodecagon.animate.rotate(-30 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a regular pentagon with side length 2 and color it brown.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=BROWN) self.add(pentagon)"
    },
    {
        "query": "Move the pentagon upward by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=BROWN) self.add(pentagon) self.play(pentagon.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Create a regular octagon with side length 2 and color it olive.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=OLIVE) self.add(octagon)"
    },
    {
        "query": "Scale the octagon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=OLIVE) self.add(octagon) self.play(octagon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a regular tetradecagon with side length 2 and color it lime.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): tetradecagon = RegularPolygon(n=14, radius=2, color=LIME) self.add(tetradecagon)"
    },
    {
        "query": "Move the tetradecagon to the right by 4 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): tetradecagon = RegularPolygon(n=14, radius=2, color=LIME) self.add(tetradecagon) self.play(tetradecagon.animate.shift(RIGHT * 4), run_time=2)"
    },
    {
        "query": "Create a regular polygon with 20 sides, side length 2, and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=20, radius=2, color=ORANGE) self.add(polygon)"
    },
    {
        "query": "Rotate the polygon by 75 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=20, radius=2, color=ORANGE) self.add(polygon) self.play(polygon.animate.rotate(-75 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment to the right by 3 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.shift(RIGHT * 3), run_time=1)"
    },
    {
        "query": "Create a regular polygon with 6 sides, side length 2, and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=6, radius=2, color=PURPLE) self.add(polygon)"
    },
    {
        "query": "Rotate the polygon by 90 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=6, radius=2, color=PURPLE) self.add(polygon) self.play(polygon.animate.rotate(90 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (0, 0) to (4, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((0, 0), (4, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment upward by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((0, 0), (4, 0), color=GREEN) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Create a regular polygon with 8 sides, side length 2, and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(polygon)"
    },
    {
        "query": "Scale the polygon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(polygon) self.play(polygon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a line segment from (1, 1) to (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a regular polygon with 10 sides, side length 2, and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=10, radius=2, color=YELLOW) self.add(polygon)"
    },
    {
        "query": "Move the polygon to the left by 3 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=10, radius=2, color=YELLOW) self.add(polygon) self.play(polygon.animate.shift(LEFT * 3), run_time=1)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment downward by 2 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line) self.play(line.animate.shift(DOWN * 2), run_time=1.5)"
    },
    {
        "query": "Create a regular polygon with 12 sides, side length 2, and color it blue.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=12, radius=2, color=BLUE) self.add(polygon)"
    },
    {
        "query": "Scale the polygon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=12, radius=2, color=BLUE) self.add(polygon) self.play(polygon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular polygon with 6 sides, side length 2, and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=6, radius=2, color=RED) self.add(polygon)"
    },
    {
        "query": "Move the polygon to the right by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=6, radius=2, color=RED) self.add(polygon) self.play(polygon.animate.shift(RIGHT * 3), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular polygon with 8 sides, side length 2, and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=8, radius=2, color=PINK) self.add(polygon)"
    },
    {
        "query": "Scale the polygon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): polygon = RegularPolygon(n=8, radius=2, color=PINK) self.add(polygon) self.play(polygon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a square with side length 2 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2, color=RED) self.add(square)"
    },
    {
        "query": "Move the square upward by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=2, color=RED) self.add(square) self.play(square.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Create a rectangle with width 3 and height 4.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=4, color=BLUE) self.add(rectangle)"
    },
    {
        "query": "Rotate the rectangle by 90 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=3, height=4, color=BLUE) self.add(rectangle) self.play(rectangle.animate.rotate(90 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create an ellipse with x-radius 2 and y-radius 3.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): ellipse = Ellipse(width=4, height=6, color=GREEN) self.add(ellipse)"
    },
    {
        "query": "Scale the ellipse by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): ellipse = Ellipse(width=4, height=6, color=GREEN) self.add(ellipse) self.play(ellipse.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a circle with radius 2 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2, color=ORANGE) self.add(circle)"
    },
    {
        "query": "Move the circle to the left by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2, color=ORANGE) self.add(circle) self.play(circle.animate.shift(LEFT * 3), run_time=1.5)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Rotate the hexagon by 120 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.rotate(-120 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a line segment from (0, 0) to (4, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((0, 0), (4, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment upward by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((0, 0), (4, 0), color=GREEN) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Create a regular pentagon with side length 2 and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=PURPLE) self.add(pentagon)"
    },
    {
        "query": "Scale the pentagon by a factor of 2 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=PURPLE) self.add(pentagon) self.play(pentagon.animate.scale(2), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment downward by 2 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line) self.play(line.animate.shift(DOWN * 2), run_time=1.5)"
    },
    {
        "query": "Create a regular octagon with side length 2 and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon)"
    },
    {
        "query": "Rotate the octagon by 90 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon) self.play(octagon.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a line segment from (1, 1) to (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a regular heptagon with side length 2 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=PINK) self.add(heptagon)"
    },
    {
        "query": "Scale the heptagon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=PINK) self.add(heptagon) self.play(heptagon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=RED) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the right by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=RED) self.add(hexagon) self.play(hexagon.animate.shift(RIGHT * 3), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular nonagon with side length 2 and color it blue.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=BLUE) self.add(nonagon)"
    },
    {
        "query": "Scale the nonagon by a factor of 2 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=BLUE) self.add(nonagon) self.play(nonagon.animate.scale(2), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-1, -1) to (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 90 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1), color=GREEN) self.add(line) self.play(line.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular decagon with side length 2 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=ORANGE) self.add(decagon)"
    },
    {
        "query": "Move the decagon downward by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=ORANGE) self.add(decagon) self.play(decagon.animate.shift(DOWN * 3), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (0, 0) to (3, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((0, 0), (3, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 60 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((0, 0), (3, 0), color=GREEN) self.add(line) self.play(line.animate.rotate(-60 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular dodecagon with side length 2 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): dodecagon = RegularPolygon(n=12, radius=2, color=PINK) self.add(dodecagon)"
    },
    {
        "query": "Scale the dodecagon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): dodecagon = RegularPolygon(n=12, radius=2, color=PINK) self.add(dodecagon) self.play(dodecagon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a line segment from (-2, 0) to (2, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 0), (2, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment upward by 1 unit over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 0), (2, 0), color=GREEN) self.add(line) self.play(line.animate.shift(UP * 1), run_time=1)"
    },
    {
        "query": "Create a regular pentagon with side length 2 and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=PURPLE) self.add(pentagon)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=PURPLE) self.add(pentagon) self.play(pentagon.animate.rotate(90 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment downward by 2 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line) self.play(line.animate.shift(DOWN * 2), run_time=1.5)"
    },
    {
        "query": "Create a regular octagon with side length 2 and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon)"
    },
    {
        "query": "Rotate the octagon by 90 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon) self.play(octagon.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a line segment from (1, 1) to (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a regular heptagon with side length 2 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=PINK) self.add(heptagon)"
    },
    {
        "query": "Scale the heptagon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=PINK) self.add(heptagon) self.play(heptagon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=RED) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the right by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=RED) self.add(hexagon) self.play(hexagon.animate.shift(RIGHT * 3), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular nonagon with side length 2 and color it blue.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=BLUE) self.add(nonagon)"
    },
    {
        "query": "Scale the nonagon by a factor of 2 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=BLUE) self.add(nonagon) self.play(nonagon.animate.scale(2), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-1, -1) to (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 90 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1), color=GREEN) self.add(line) self.play(line.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular decagon with side length 2 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=ORANGE) self.add(decagon)"
    },
    {
        "query": "Move the decagon downward by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=ORANGE) self.add(decagon) self.play(decagon.animate.shift(DOWN * 3), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-2, 0) to (2, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 0), (2, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment upward by 1 unit over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 0), (2, 0), color=GREEN) self.add(line) self.play(line.animate.shift(UP * 1), run_time=1)"
    },
    {
        "query": "Create a regular pentagon with side length 2 and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=PURPLE) self.add(pentagon)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=PURPLE) self.add(pentagon) self.play(pentagon.animate.rotate(90 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment downward by 2 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line) self.play(line.animate.shift(DOWN * 2), run_time=1.5)"
    },
    {
        "query": "Create a regular octagon with side length 2 and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon)"
    },
    {
        "query": "Rotate the octagon by 90 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon) self.play(octagon.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a line segment from (1, 1) to (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a regular heptagon with side length 2 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=PINK) self.add(heptagon)"
    },
    {
        "query": "Scale the heptagon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=PINK) self.add(heptagon) self.play(heptagon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=RED) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the right by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=RED) self.add(hexagon) self.play(hexagon.animate.shift(RIGHT * 3), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular nonagon with side length 2 and color it blue.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=BLUE) self.add(nonagon)"
    },
    {
        "query": "Scale the nonagon by a factor of 2 in 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): nonagon = RegularPolygon(n=9, radius=2, color=BLUE) self.add(nonagon) self.play(nonagon.animate.scale(2), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-1, -1) to (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 90 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-1, -1), (1, 1), color=GREEN) self.add(line) self.play(line.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a regular decagon with side length 2 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=ORANGE) self.add(decagon)"
    },
    {
        "query": "Move the decagon downward by 3 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): decagon = RegularPolygon(n=10, radius=2, color=ORANGE) self.add(decagon) self.play(decagon.animate.shift(DOWN * 3), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-2, 0) to (2, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 0), (2, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment upward by 1 unit over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, 0), (2, 0), color=GREEN) self.add(line) self.play(line.animate.shift(UP * 1), run_time=1)"
    },
    {
        "query": "Create a regular pentagon with side length 2 and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=PURPLE) self.add(pentagon)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=PURPLE) self.add(pentagon) self.play(pentagon.animate.rotate(90 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment downward by 2 units over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=GREEN) self.add(line) self.play(line.animate.shift(DOWN * 2), run_time=1.5)"
    },
    {
        "query": "Create a regular octagon with side length 2 and color it teal.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon)"
    },
    {
        "query": "Rotate the octagon by 90 degrees clockwise over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): octagon = RegularPolygon(n=8, radius=2, color=TEAL) self.add(octagon) self.play(octagon.animate.rotate(90 * DEGREES), run_time=1)"
    },
    {
        "query": "Create a line segment from (1, 1) to (-1, -1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line)"
    },
    {
        "query": "Rotate the line segment by 45 degrees counterclockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((1, 1), (-1, -1), color=GREEN) self.add(line) self.play(line.animate.rotate(-45 * DEGREES), run_time=1.5)"
    },
    {
        "query": "Create a regular heptagon with side length 2 and color it pink.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=PINK) self.add(heptagon)"
    },
    {
        "query": "Scale the heptagon by a factor of 1.5 in 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=2, color=PINK) self.add(heptagon) self.play(heptagon.animate.scale(1.5), run_time=2)"
    },
    {
        "query": "Create a circle with radius 2 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2, color=RED) self.add(circle)"
    },
    {
        "query": "Move the circle to the right by 3 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2, color=RED) self.add(circle) self.play(circle.animate.shift(RIGHT * 3), run_time=2)"
    },
    {
        "query": "Create a square with side length 4 and color it blue.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=4, color=BLUE) self.add(square)"
    },
    {
        "query": "Scale the square by a factor of 0.5 in 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=4, color=BLUE) self.add(square) self.play(square.animate.scale(0.5), run_time=1)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment to the right by 3 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.shift(RIGHT * 3), run_time=1)"
    },
    {
        "query": "Create a regular pentagon with side length 3 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=3, color=ORANGE) self.add(pentagon)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=3, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Move the square to the right by 4 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=5, color=CYAN) self.add(square) self.play(square.animate.shift(RIGHT * 4), run_time=2)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Add a text label 'A' at the coordinates (2, -1) of the rectangle.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) label = Text('A').move_to((2, -1)) self.add(rectangle, label)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Scale the triangle by a factor of 0.5 in 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = RegularPolygon(n=3, radius=3, color=PINK) self.add(triangle) self.play(triangle.animate.scale(0.5), run_time=1)"
    },
    {
        "query": "Create a circle with radius 2 and color it red.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2, color=RED) self.add(circle)"
    },
    {
        "query": "Move the circle to the right by 3 units over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle(radius=2, color=RED) self.add(circle) self.play(circle.animate.shift(RIGHT * 3), run_time=2)"
    },
    {
        "query": "Create a square with side length 4 and color it blue.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=4, color=BLUE) self.add(square)"
    },
    {
        "query": "Scale the square by a factor of 0.5 in 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=4, color=BLUE) self.add(square) self.play(square.animate.scale(0.5), run_time=1)"
    },
    {
        "query": "Create a line segment from (-2, -2) to (2, 2).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line)"
    },
    {
        "query": "Move the line segment to the right by 3 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-2, -2), (2, 2), color=GREEN) self.add(line) self.play(line.animate.shift(RIGHT * 3), run_time=1)"
    },
    {
        "query": "Create a regular pentagon with side length 3 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=3, color=ORANGE) self.add(pentagon)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=3, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Scale the triangle by a factor of 0.5 in 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): triangle = RegularPolygon(n=3, radius=3, color=PINK) self.add(triangle) self.play(triangle.animate.scale(0.5), run_time=1)"
    },
    {
        "query": "Rotate the pentagon by 90 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon) self.play(pentagon.animate.rotate(-90 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a rectangle with width 4 and height 2, centered at (1, 1).",
        "answer": "from manim import * class MyScene(Scene): def construct(self): rectangle = Rectangle(width=4, height=2) rectangle.move_to((1, 1)) self.add(rectangle)"
    },
    {
        "query": "Create a VGroup and add a circle and a triangle to it.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) self.add(vgroup)"
    },
    {
        "query": "Rotate the VGroup by 45 degrees clockwise over 1.5 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): circle = Circle() triangle = Polygon((-1, -1), (1, -1), (0, 1)) vgroup = VGroup(circle, triangle) vgroup.rotate(-45 * DEGREES) self.add(vgroup)"
    },
    {
        "query": "Create a regular hexagon with side length 2 and color it yellow.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon)"
    },
    {
        "query": "Move the hexagon to the left by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): hexagon = RegularPolygon(n=6, radius=2, color=YELLOW) self.add(hexagon) self.play(hexagon.animate.shift(LEFT * 2), run_time=1)"
    },
    {
        "query": "Create a regular heptagon with side length 3 and color it green.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon)"
    },
    {
        "query": "Rotate the heptagon by 60 degrees counterclockwise over 2 seconds.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): heptagon = RegularPolygon(n=7, radius=3, color=GREEN) self.add(heptagon) self.play(heptagon.animate.rotate(-60 * DEGREES), run_time=2)"
    },
    {
        "query": "Create a line segment from (-3, 0) to (3, 0) and color it purple.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line)"
    },
    {
        "query": "Move the line segment upwards by 2 units over 1 second.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): line = Line((-3, 0), (3, 0), color=PURPLE) self.add(line) self.play(line.animate.shift(UP * 2), run_time=1)"
    },
    {
        "query": "Create a square with side length 5 and color it cyan.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): square = Square(side_length=5, color=CYAN) self.add(square)"
    },
    {
        "query": "Create a regular pentagon with side length 2 and color it orange.",
        "answer": "from manim import * class MyScene(Scene): def construct(self): pentagon = RegularPolygon(n=5, radius=2, color=ORANGE) self.add(pentagon)"
    }
]